//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Add_Hidden_Items
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Add_List_Items
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Add_Ratings
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Add_to_Collection
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Add_to_History
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Add_to_Personal_Recommendations___BETA
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Add_to_Watchlist
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Aliases
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class All_DVD
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class All_Movies
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class All_New_Shows
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class All_Season_Premieres
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class All_Shows
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Anticipated
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Approve_or_Deny_Follower_Requests
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Authorize
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Box_Office
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Certifications
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Checkin
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Collaborations
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Collected
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Collection
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Collection_Progress
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Comment
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Comments
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Device_Code
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Follow
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Follower_Requests
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Followers
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Following
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Following_Requests
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Friends
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Get_Collection
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Get_History
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Get_Personal_Recommendations___BETA
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Get_Ratings
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Get_Token
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Get_Watched
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Get_Watchlist
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Hidden_Items
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Hide_Movie
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Hide_Show
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class History
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ID_Lookup
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Item
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Last_Activities
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Last_Episode
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Like
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Likes
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class List
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class List_Comments
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class List_Items
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class List_Like
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class List_Likes
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Lists
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Movies
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class My_DVD
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class My_Movies
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class My_New_Shows
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class My_Season_Premieres
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class My_Shows
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Next_Episode
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Pause
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class People
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Personal_Recommendations___BETA
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Playback
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Played
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Popular
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Profile
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Ratings
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Recent
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Recommended
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Refresh_Token
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Related
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Releases
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Remove_Hidden_Items
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Remove_List_Items
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Remove_Playback
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Remove_Ratings
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Remove_from_Collection
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Remove_from_History
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Remove_from_Personal_Recommendations___BETA
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Remove_from_Watchlist
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Reorder_List_Items
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Reorder_Lists
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Reorder_Personal_Recommendations___BETA
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Reorder_Watchlist
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Replies
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Reset_Watched_Progress
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Revoke_Token
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Saved_Filters
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Season
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Settings
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Shows
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Start
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Stats
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Stop
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Studios
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Summary
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Text_Query
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Translations
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Trending
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Updated_IDs
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Updates
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Watched
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Watched_Progress
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Watching
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Watchlist
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Add_hidden_itemsBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public Add_hidden_itemsBodyMovies[] Add_hidden_itemsBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public Add_hidden_itemsBodySeasons[] Add_hidden_itemsBodySeasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public Add_hidden_itemsBodyShows[] Add_hidden_itemsBodyShows { get; set; }
	}
	
	public class Add_hidden_itemsBodyMovies
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Add_hidden_itemsBodyMoviesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class Add_hidden_itemsBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class Add_hidden_itemsBodySeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Add_hidden_itemsBodySeasonsIds Ids { get; set; }
	}
	
	public class Add_hidden_itemsBodySeasonsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class Add_hidden_itemsBodyShows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Add_hidden_itemsBodyShowsIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public Add_hidden_itemsBodyShowsSeasons[] Add_hidden_itemsBodyShowsSeasons { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="year")]
		public double Year { get; set; }
	}
	
	public class Add_hidden_itemsBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class Add_hidden_itemsBodyShowsSeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="number")]
		public System.Nullable<System.Double> Number { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Remove_items_from_collectionBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public Remove_items_from_collectionBodyEpisodes[] Remove_items_from_collectionBodyEpisodes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public Remove_items_from_collectionBodyMovies[] Remove_items_from_collectionBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public Remove_items_from_collectionBodySeasons[] Remove_items_from_collectionBodySeasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public Remove_items_from_collectionBodyShows[] Remove_items_from_collectionBodyShows { get; set; }
	}
	
	public class Remove_items_from_collectionBodyEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Remove_items_from_collectionBodyEpisodesIds Ids { get; set; }
	}
	
	public class Remove_items_from_collectionBodyEpisodesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class Remove_items_from_collectionBodyMovies
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Remove_items_from_collectionBodyMoviesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class Remove_items_from_collectionBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class Remove_items_from_collectionBodySeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Remove_items_from_collectionBodySeasonsIds Ids { get; set; }
	}
	
	public class Remove_items_from_collectionBodySeasonsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class Remove_items_from_collectionBodyShows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Remove_items_from_collectionBodyShowsIds Ids { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public Remove_items_from_collectionBodyShowsSeasons[] Remove_items_from_collectionBodyShowsSeasons { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="year")]
		public double Year { get; set; }
	}
	
	public class Remove_items_from_collectionBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class Remove_items_from_collectionBodyShowsSeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public Remove_items_from_collectionBodyShowsSeasonsEpisodes[] Remove_items_from_collectionBodyShowsSeasonsEpisodes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	public class Remove_items_from_collectionBodyShowsSeasonsEpisodes
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Reorder_watchlist_itemsBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="rank")]
		public double[] Rank { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get DVD releases
		/// #### &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all movies with a DVD release date during the time period specified.
		/// CalendarsAllDvd_start_date_daysGet calendars/all/dvd/{start_date}/{days}
		/// </summary>
		/// <param name="start_date">Start the calendar on this date.</param>
		/// <param name="days">Number of days to display.</param>
		/// <returns>OK</returns>
		public async Task CalendarsAllDvd_start_date_daysGetAsync(string start_date, int days, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "calendars/all/dvd/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date))+"/"+days;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get movies
		/// #### &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all movies with a release date during the time period specified.
		/// CalendarsAllMovies_start_date_daysGet calendars/all/movies/{start_date}/{days}
		/// </summary>
		/// <param name="start_date">Start the calendar on this date.</param>
		/// <param name="days">Number of days to display.</param>
		/// <returns>OK</returns>
		public async Task CalendarsAllMovies_start_date_daysGetAsync(string start_date, int days, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "calendars/all/movies/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date))+"/"+days;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get new shows
		/// #### &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all new show premieres (season 1, episode 1) airing during the time period specified.
		/// CalendarsAllShowsNew_start_date_daysGet calendars/all/shows/new/{start_date}/{days}
		/// </summary>
		/// <param name="start_date">Start the calendar on this date.</param>
		/// <param name="days">Number of days to display.</param>
		/// <returns>OK</returns>
		public async Task CalendarsAllShowsNew_start_date_daysGetAsync(string start_date, int days, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "calendars/all/shows/new/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date))+"/"+days;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get season premieres
		/// #### &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all show premieres (any season, episode 1) airing during the time period specified.
		/// CalendarsAllShowsPremieres_start_date_daysGet calendars/all/shows/premieres/{start_date}/{days}
		/// </summary>
		/// <param name="start_date">Start the calendar on this date.</param>
		/// <param name="days">Number of days to display.</param>
		/// <returns>OK</returns>
		public async Task CalendarsAllShowsPremieres_start_date_daysGetAsync(string start_date, int days, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "calendars/all/shows/premieres/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date))+"/"+days;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get shows
		/// #### &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all shows airing during the time period specified.
		/// CalendarsAllShows_start_date_daysGet calendars/all/shows/{start_date}/{days}
		/// </summary>
		/// <param name="start_date">Start the calendar on this date.</param>
		/// <param name="days">Number of days to display.</param>
		/// <returns>OK</returns>
		public async Task CalendarsAllShows_start_date_daysGetAsync(string start_date, int days, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "calendars/all/shows/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date))+"/"+days;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get DVD releases
		/// #### &#128274; OAuth Required &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all movies with a DVD release date during the time period specified.
		/// CalendarsMyDvd_start_date_daysGet calendars/my/dvd/{start_date}/{days}
		/// </summary>
		/// <param name="start_date">Start the calendar on this date.</param>
		/// <param name="days">Number of days to display.</param>
		/// <returns>OK</returns>
		public async Task CalendarsMyDvd_start_date_daysGetAsync(string start_date, int days, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "calendars/my/dvd/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date))+"/"+days;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get movies
		/// #### &#128274; OAuth Required &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all movies with a release date during the time period specified.
		/// CalendarsMyMovies_start_date_daysGet calendars/my/movies/{start_date}/{days}
		/// </summary>
		/// <param name="start_date">Start the calendar on this date.</param>
		/// <param name="days">Number of days to display.</param>
		/// <returns>OK</returns>
		public async Task CalendarsMyMovies_start_date_daysGetAsync(string start_date, int days, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "calendars/my/movies/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date))+"/"+days;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get new shows
		/// #### &#128274; OAuth Required &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all new show premieres (season 1, episode 1) airing during the time period specified.
		/// CalendarsMyShowsNew_start_date_daysGet calendars/my/shows/new/{start_date}/{days}
		/// </summary>
		/// <param name="start_date">Start the calendar on this date.</param>
		/// <param name="days">Number of days to display.</param>
		/// <returns>OK</returns>
		public async Task CalendarsMyShowsNew_start_date_daysGetAsync(string start_date, int days, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "calendars/my/shows/new/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date))+"/"+days;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get season premieres
		/// #### &#128274; OAuth Required &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all show premieres (any season, episode 1) airing during the time period specified.
		/// CalendarsMyShowsPremieres_start_date_daysGet calendars/my/shows/premieres/{start_date}/{days}
		/// </summary>
		/// <param name="start_date">Start the calendar on this date.</param>
		/// <param name="days">Number of days to display.</param>
		/// <returns>OK</returns>
		public async Task CalendarsMyShowsPremieres_start_date_daysGetAsync(string start_date, int days, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "calendars/my/shows/premieres/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date))+"/"+days;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get shows
		/// #### &#128274; OAuth Required &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all shows airing during the time period specified.
		/// CalendarsMyShows_start_date_daysGet calendars/my/shows/{start_date}/{days}
		/// </summary>
		/// <param name="start_date">Start the calendar on this date.</param>
		/// <param name="days">Number of days to display.</param>
		/// <returns>OK</returns>
		public async Task CalendarsMyShows_start_date_daysGetAsync(string start_date, int days, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "calendars/my/shows/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date))+"/"+days;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get certifications
		/// Get a list of all certifications, including names, slugs, and descriptions.
		/// Certifications_typeGet certifications/{type}
		/// </summary>
		/// <returns>OK</returns>
		public async Task Certifications_typeGetAsync(Certifications_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certifications/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete any active checkins
		/// #### &#128274; OAuth Required
		/// 
		/// Removes any active checkins, no need to provide a specific item.
		/// CheckinDelete checkin
		/// </summary>
		public async Task CheckinDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "checkin";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check into an item
		/// #### &#128274; OAuth Required
		/// 
		/// Check into a movie or episode. This should be tied to a user action to manually indicate they are watching something. The item will display as *watching* on the site, then automatically switch to *watched* status once the duration has elapsed. A unique history `id` (64-bit integer) will be returned and can be used to reference this checkin directly.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | item <span style="color:red;">*</a> | object | `movie` or `episode` object. (see examples &#8594;) |
		/// | `sharing`  | object | Control sharing to any connected social networks. (see below &#8595;) |
		/// | `message`  | string | Message used for sharing. If not sent, it will use the watching string in the user settings. |
		/// | `venue_id` | string | Foursquare venue ID. |
		/// | `venue_name` | string | Foursquare venue name. |
		/// | `app_version` | string | Version number of the app. |
		/// | `app_date` | string | Build date of the app. |
		/// 
		/// #### Sharing
		/// 
		/// The `sharing` object is optional and will apply the user's settings if not sent. If `sharing` is sent, each key will override the user's setting for that social network. Send `true` to post or `false` to not post on the indicated social network. You can see which social networks a user has connected with the [**/users/settings**](/reference/users/settings) method.
		/// 
		/// | Key | Type |
		/// |---|---|
		/// | `twitter` | boolean |
		/// | `mastodon` | boolean |
		/// | `tumblr` | boolean |
		/// 
		/// **Note:** If a checkin is already in progress, a `409` HTTP status code will returned. The response will contain an `expires_at` timestamp which is when the user can check in again.
		/// CheckinPost checkin
		/// </summary>
		public async Task CheckinPostAsync(CheckinPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "checkin";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Post a comment
		/// #### &#128274; OAuth Required &#128513; Emojis
		/// 
		/// Add a new comment to a movie, show, season, episode, or list. Make sure to allow and encourage *spoilers* to be indicated in your app and follow the rules listed above.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Default | Value |
		/// |---|---|---|---|
		/// | item <span style="color:red;">*</a> | object | | `movie`, `show`, `season`, `episode`, or `list` object. (see examples &#8594;) |
		/// | `comment` <span style="color:red;">*</a> | string |  | Text for the comment. |
		/// | `spoiler` | boolean | `false` | Is this a spoiler? |
		/// | `sharing`  | object | | Control sharing to any connected social networks. (see below &#8595;) |
		/// 
		/// #### Sharing
		/// 
		/// The `sharing` object is optional and will apply the user's settings if not sent. If `sharing` is sent, each key will override the user's setting for that social network. Send `true` to post or `false` to not post on the indicated social network. You can see which social networks a user has connected with the [**/users/settings**](/reference/users/settings) method.
		/// 
		/// | Key | Type |
		/// |---|---|
		/// | `twitter` | boolean |
		/// | `tumblr` | boolean |
		/// | `medium` | boolean |
		/// CommentsPost comments
		/// </summary>
		public async Task CommentsPostAsync(CommentsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get recently created comments
		/// #### &#128196; Pagination &#10024; Extended Info &#128513; Emojis
		/// 
		/// Returns the most recently written comments across all of Trakt. You can optionally filter by the `comment_type` and media `type` to limit what gets returned. If you want to `include_replies` that will return replies in place alongside top level comments.
		/// CommentsRecent_comment_type_typeGetByInclude_replies comments/recent/{comment_type}/{type}
		/// </summary>
		/// <param name="include_replies">include comment replies</param>
		/// <returns>OK</returns>
		public async Task CommentsRecent_comment_type_typeGetByInclude_repliesAsync(CommentsRecent_comment_type_typeGetByInclude_repliesComment_type comment_type, CommentsRecent_comment_type_typeGetByInclude_repliesType type, string include_replies, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/recent/"+comment_type+"/"+type+"?include_replies=" + (include_replies==null? "" : System.Uri.EscapeDataString(include_replies));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get trending comments
		/// #### &#128196; Pagination &#10024; Extended Info &#128513; Emojis
		/// 
		/// Returns all comments with the most likes and replies over the last 7 days. You can optionally filter by the `comment_type` and media `type` to limit what gets returned. If you want to `include_replies` that will return replies in place alongside top level comments.
		/// CommentsTrending_comment_type_typeGetByInclude_replies comments/trending/{comment_type}/{type}
		/// </summary>
		/// <param name="include_replies">include comment replies</param>
		/// <returns>OK</returns>
		public async Task CommentsTrending_comment_type_typeGetByInclude_repliesAsync(CommentsRecent_comment_type_typeGetByInclude_repliesComment_type comment_type, CommentsRecent_comment_type_typeGetByInclude_repliesType type, string include_replies, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/trending/"+comment_type+"/"+type+"?include_replies=" + (include_replies==null? "" : System.Uri.EscapeDataString(include_replies));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get recently updated comments
		/// #### &#128196; Pagination &#10024; Extended Info &#128513; Emojis
		/// 
		/// Returns the most recently updated comments across all of Trakt. You can optionally filter by the `comment_type` and media `type` to limit what gets returned. If you want to `include_replies` that will return replies in place alongside top level comments.
		/// CommentsUpdates_comment_type_typeGetByInclude_replies comments/updates/{comment_type}/{type}
		/// </summary>
		/// <param name="include_replies">include comment replies</param>
		/// <returns>OK</returns>
		public async Task CommentsUpdates_comment_type_typeGetByInclude_repliesAsync(CommentsRecent_comment_type_typeGetByInclude_repliesComment_type comment_type, CommentsRecent_comment_type_typeGetByInclude_repliesType type, string include_replies, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/updates/"+comment_type+"/"+type+"?include_replies=" + (include_replies==null? "" : System.Uri.EscapeDataString(include_replies));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a comment or reply
		/// #### &#128274; OAuth Required
		/// 
		/// Delete a single comment. The OAuth user must match the author of the comment in order to delete it. If not, a `401` HTTP status code is returned. The comment must also be less than 2 weeks old or have 0 replies. If not, a `409` HTTP status is returned.
		/// Comments_idDelete comments/{id}
		/// </summary>
		/// <param name="id">Automatically added</param>
		public async Task Comments_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a comment or reply
		/// ####  &#128513; Emojis
		/// 
		/// Returns a single comment and indicates how many replies it has. Use [**/comments/:id/replies**](/reference/comments/replies/) to get the actual replies.
		/// Comments_idGet comments/{id}
		/// </summary>
		/// <param name="id">A specific comment ID.</param>
		/// <returns>OK</returns>
		public async Task Comments_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a comment or reply
		/// #### &#128274; OAuth Required &#128513; Emojis
		/// 
		/// Update a single comment. The OAuth user must match the author of the comment in order to update it. If not, a `401` HTTP status is returned.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Default | Value |
		/// |---|---|---|---|
		/// | `comment` | string |  | Text for the comment. |
		/// | `spoiler` | boolean | `false` | Is this a spoiler? |
		/// Comments_idPut comments/{id}
		/// </summary>
		/// <param name="id">Automatically added</param>
		/// <returns>OK</returns>
		public async Task Comments_idPutAsync(string id, Comments_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get the attached media item
		/// #### &#10024; Extended Info
		/// 
		/// Returns the media item this comment is attached to. The media type can be `movie`, `show`, `season`, `episode`, or `list` and it also returns the standard media object for that media type.
		/// Comments_idItemGet comments/{id}/item
		/// </summary>
		/// <param name="id">A specific comment ID.</param>
		/// <returns>OK</returns>
		public async Task Comments_idItemGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/"+id+"/item";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove like on a comment
		/// #### &#128274; OAuth Required
		/// 
		/// Remove a like on a comment.
		/// Comments_idLikeDelete comments/{id}/like
		/// </summary>
		/// <param name="id">Automatically added</param>
		public async Task Comments_idLikeDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/like";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Like a comment
		/// #### &#128274; OAuth Required
		/// 
		/// Votes help determine popular comments. Only one like is allowed per comment per user.
		/// Comments_idLikePost comments/{id}/like
		/// </summary>
		/// <param name="id">A specific comment ID.</param>
		public async Task Comments_idLikePostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/like";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all users who liked a comment
		/// #### &#128196; Pagination
		/// 
		/// Returns all users who liked a comment. If you only need the `replies` count, the main `comment` object already has that, so no need to use this method.
		/// Comments_idLikesGet comments/{id}/likes
		/// </summary>
		/// <param name="id">A specific comment ID.</param>
		/// <returns>OK</returns>
		public async Task Comments_idLikesGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/"+id+"/likes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get replies for a comment
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all replies for a comment. It is possible these replies could have replies themselves, so in that case you would just call [**/comments/:id/replies**](/reference/comments/replies/) again with the new comment `id`.
		/// Comments_idRepliesGet comments/{id}/replies
		/// </summary>
		/// <param name="id">A specific comment ID.</param>
		/// <returns>OK</returns>
		public async Task Comments_idRepliesGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/replies";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Post a reply for a comment
		/// #### &#128274; OAuth Required &#128513; Emojis
		/// 
		/// Add a new reply to an existing comment. Make sure to allow and encourage *spoilers* to be indicated in your app and follow the rules listed above.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Default | Value |
		/// |---|---|---|---|
		/// | `comment` <span style="color:red;">*</a> | string |  | Text for the reply. |
		/// | `spoiler` | boolean | `false` | Is this a spoiler? |
		/// Comments_idRepliesPost comments/{id}/replies
		/// </summary>
		/// <param name="id">Automatically added</param>
		public async Task Comments_idRepliesPostAsync(string id, Comments_idRepliesPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "comments/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/replies";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get countries
		/// Get a list of all countries, including names and codes.
		/// Countries_typeGet countries/{type}
		/// </summary>
		/// <returns>OK</returns>
		public async Task Countries_typeGetAsync(Certifications_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "countries/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get genres
		/// Get a list of all genres, including names and slugs.
		/// Genres_typeGet genres/{type}
		/// </summary>
		/// <returns>OK</returns>
		public async Task Genres_typeGetAsync(Certifications_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "genres/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get languages
		/// Get a list of all langauges, including names and codes.
		/// Languages_typeGet languages/{type}
		/// </summary>
		/// <returns>OK</returns>
		public async Task Languages_typeGetAsync(Certifications_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "languages/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get popular lists
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns the most popular lists. Popularity is calculated using total number of likes and comments.
		/// ListsPopularGet lists/popular
		/// </summary>
		/// <returns>OK</returns>
		public async Task ListsPopularGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lists/popular";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get trending lists
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all lists with the most likes and comments over the last 7 days.
		/// ListsTrendingGet lists/trending
		/// </summary>
		/// <returns>OK</returns>
		public async Task ListsTrendingGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lists/trending";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get list
		/// #### &#128513; Emojis
		/// 
		/// Returns a single list. Use the [**/lists/:id/items**](#reference/lists/list-items) method to get the actual items this list contains.
		/// 
		/// **Note:** You must use an integer `id`, and only public lists will return data.
		/// Lists_idGet lists/{id}
		/// </summary>
		/// <param name="id">Trakt ID</param>
		/// <returns>OK</returns>
		public async Task Lists_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lists/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all list comments
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all top level comments for a list. By default, the `newest` comments are returned first. Other sorting options include `oldest`, most `likes`, and most `replies`.
		/// Lists_idComments_sortGet lists/{id}/comments/{sort}
		/// </summary>
		/// <param name="id">Trakt ID</param>
		/// <param name="sort">how to sort</param>
		/// <returns>OK</returns>
		public async Task Lists_idComments_sortGetAsync(int id, Lists_idComments_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lists/"+id+"/comments/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get items on a list
		/// #### &#128196; Pagination Optional &#10024; Extended Info &#128513; Emojis
		/// 
		/// Get all items on a personal list. Items can be a `movie`, `show`, `season`, `episode`, or `person`. You can optionally specify the `type` parameter with a single value or comma delimited string for multiple item types.
		/// 
		/// #### Notes
		/// 
		/// Each list item contains a `notes` field with text entered by the user.
		/// 
		/// #### Sorting Headers
		/// 
		/// All list items are sorted by ascending `rank`. We also send `X-Sort-By` and `X-Sort-How` headers which can be used to custom sort the list _**in your app**_ based on the user's preference. Values for `X-Sort-By` include `rank`, `added`, `title`, `released`, `runtime`, `popularity`, `percentage`, `votes`, `my_rating`, `random`, `watched`, and `collected`. Values for `X-Sort-How` include `asc` and `desc`.
		/// Lists_idItems_typeGet lists/{id}/items/{type}
		/// </summary>
		/// <param name="id">Trakt ID</param>
		/// <param name="type">Filter for a specific item type</param>
		/// <returns>OK</returns>
		public async Task Lists_idItems_typeGetAsync(string id, Lists_idItems_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lists/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/items/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all users who liked a list
		/// #### &#128196; Pagination
		/// 
		/// Returns all users who liked a list.
		/// Lists_idLikesGet lists/{id}/likes
		/// </summary>
		/// <param name="id">Trakt ID</param>
		/// <returns>OK</returns>
		public async Task Lists_idLikesGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lists/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/likes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the most anticipated movies
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most anticipated movies based on the number of lists a movie appears on.
		/// MoviesAnticipatedGet movies/anticipated
		/// </summary>
		/// <returns>OK</returns>
		public async Task MoviesAnticipatedGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/anticipated";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the weekend box office
		/// #### &#10024; Extended Info
		/// 
		/// Returns the top 10 grossing movies in the U.S. box office last weekend. Updated every Monday morning.
		/// MoviesBoxofficeGet movies/boxoffice
		/// </summary>
		/// <returns>OK</returns>
		public async Task MoviesBoxofficeGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/boxoffice";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the most Collected movies
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most collected (unique users) movies in the specified time `period`, defaulting to `weekly`. All stats are relative to the specific time `period`.
		/// MoviesCollected_periodGet movies/collected/{period}
		/// </summary>
		/// <param name="period">Time period.</param>
		/// <returns>OK</returns>
		public async Task MoviesCollected_periodGetAsync(MoviesCollected_periodGetPeriod period, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/collected/"+period;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the most played movies
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most played (a single user can watch multiple times) movies in the specified time `period`, defaulting to `weekly`. All stats are relative to the specific time `period`.
		/// MoviesPlayed_periodGet movies/played/{period}
		/// </summary>
		/// <param name="period">Time period.</param>
		/// <returns>OK</returns>
		public async Task MoviesPlayed_periodGetAsync(MoviesCollected_periodGetPeriod period, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/played/"+period;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get popular movies
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most popular movies. Popularity is calculated using the rating percentage and the number of ratings.
		/// MoviesPopularGet movies/popular
		/// </summary>
		/// <returns>OK</returns>
		public async Task MoviesPopularGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/popular";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the most recommended movies
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most recommended movies in the specified time `period`, defaulting to `weekly`. All stats are relative to the specific time `period`.
		/// MoviesRecommended_periodGet movies/recommended/{period}
		/// </summary>
		/// <param name="period">Time period.</param>
		/// <returns>OK</returns>
		public async Task MoviesRecommended_periodGetAsync(MoviesCollected_periodGetPeriod period, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/recommended/"+period;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get trending movies
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all movies being watched right now. Movies with the most users are returned first.
		/// MoviesTrendingGet movies/trending
		/// </summary>
		/// <returns>OK</returns>
		public async Task MoviesTrendingGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/trending";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get recently updated movie Trakt IDs
		/// #### &#128196; Pagination
		/// 
		/// Returns all movie Trakt IDs updated since the specified UTC date and time. We recommended storing the `X-Start-Date` header you can be efficient using this method moving forward. By default, `10` results are returned. You can send a `limit` to get up to `100` results per page.
		/// 
		/// **Important!** The `start_date` is only accurate to the hour, for caching purposes. Please drop the minutes and seconds from your timestamp to help optimize our cached data. For example, use `2021-07-17T12:00:00Z` and not `2021-07-17T12:23:34Z`.
		/// 
		/// **Note:** The `start_date` can only be a maximum of 30 days in the past.
		/// MoviesUpdatesId_start_dateGet movies/updates/id/{start_date}
		/// </summary>
		/// <param name="start_date">Updated since this date and time.</param>
		/// <returns>OK</returns>
		public async Task MoviesUpdatesId_start_dateGetAsync(string start_date, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/updates/id/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get recently updated movies
		/// #### &#128196; Pagination &#10024; Extended Info
		/// 
		/// Returns all movies updated since the specified UTC date and time. We recommended storing the `X-Start-Date` header you can be efficient using this method moving forward. By default, `10` results are returned. You can send a `limit` to get up to `100` results per page.
		/// 
		/// **Important!** The `start_date` is only accurate to the hour, for caching purposes. Please drop the minutes and seconds from your timestamp to help optimize our cached data. For example, use `2021-07-17T12:00:00Z` and not `2021-07-17T12:23:34Z`.
		/// 
		/// **Note:** The `start_date` can only be a maximum of 30 days in the past.
		/// MoviesUpdates_start_dateGet movies/updates/{start_date}
		/// </summary>
		/// <param name="start_date">Updated since this date and time.</param>
		/// <returns>OK</returns>
		public async Task MoviesUpdates_start_dateGetAsync(string start_date, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/updates/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the most watched movies
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most watched (unique users) movies in the specified time `period`, defaulting to `weekly`. All stats are relative to the specific time `period`.
		/// MoviesWatched_periodGet movies/watched/{period}
		/// </summary>
		/// <param name="period">Time period.</param>
		/// <returns>OK</returns>
		public async Task MoviesWatched_periodGetAsync(MoviesCollected_periodGetPeriod period, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/watched/"+period;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a movie
		/// #### &#10024; Extended Info
		/// 
		/// Returns a single movie's details.
		/// 
		/// **Note:** When getting `full` extended info, the `status` field can have a value of `released`, `in production`, `post production`, `planned`, `rumored`, or `canceled`.
		/// Movies_idGet movies/{id}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>```
		/// /movies/tron-legacy-2010?extended=full
		///```</returns>
		public async Task Movies_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all movie aliases
		/// Returns all title aliases for a movie.  Includes country where name is different.
		/// Movies_idAliasesGet movies/{id}/aliases
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Movies_idAliasesGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/aliases";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all movie comments
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all top level comments for a movie. By default, the `newest` comments are returned first. Other sorting options include `oldest`, most `likes`, most `replies`, `highest` rated, `lowest` rated, and most `plays`.
		/// Movies_idComments_sortGet movies/{id}/comments/{sort}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="sort">how to sort</param>
		/// <returns>OK</returns>
		public async Task Movies_idComments_sortGetAsync(string id, Movies_idComments_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/comments/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get lists containing this movie
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all lists that contain this movie. By default, `personal` lists are returned sorted by the most `popular`.
		/// Movies_idLists_type_sortGet movies/{id}/lists/{type}/{sort}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="type">Filter for a specific list type</param>
		/// <param name="sort">How to sort</param>
		/// <returns>OK</returns>
		public async Task Movies_idLists_type_sortGetAsync(string id, Movies_idLists_type_sortGetType type, Movies_idLists_type_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+type+"/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all people for a movie
		/// #### &#10024; Extended Info
		/// 
		/// Returns all `cast` and `crew` for a movie. Each `cast` member will have a `characters` array and a standard `person` object.
		/// 
		/// The `crew` object will be broken up by department into `production`, `art`, `crew`, `costume & make-up`, `directing`, `writing`, `sound`, `camera`, `visual effects`, `lighting`, and `editing` (if there are people for those crew positions). Each of those members will have a `jobs` array and a standard `person` object.
		/// Movies_idPeopleGet movies/{id}/people
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Movies_idPeopleGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/people";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get movie ratings
		/// Returns rating (between 0 and 10) and distribution for a movie.
		/// Movies_idRatingsGet movies/{id}/ratings
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Movies_idRatingsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/ratings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get related movies
		/// #### &#128196; Pagination &#10024; Extended Info
		/// 
		/// Returns related and similar movies.
		/// Movies_idRelatedGet movies/{id}/related
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Movies_idRelatedGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/related";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all movie releases
		/// Returns all releases for a movie including country, certification, release date, release type, and note. The release type can be set to `unknown`, `premiere`, `limited`, `theatrical`, `digital`, `physical`, or `tv`. The `note` might have optional info such as the film festival name for a `premiere` release or Blu-ray specs for a `physical` release. We pull this info from [TMDB](https://developers.themoviedb.org/3/movies/get-movie-release-dates).
		/// Movies_idReleases_countryGet movies/{id}/releases/{country}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="country">2 character country code</param>
		/// <returns>OK</returns>
		public async Task Movies_idReleases_countryGetAsync(string id, string country, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/releases/"+ (country==null? "" : System.Uri.EscapeDataString(country));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get movie stats
		/// Returns lots of movie stats.
		/// Movies_idStatsGet movies/{id}/stats
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Movies_idStatsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/stats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get movie studios
		/// Returns all studios for a movie.
		/// Movies_idStudiosGet movies/{id}/studios
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Movies_idStudiosGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/studios";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all movie translations
		/// Returns all translations for a movie, including language and translated values for title, tagline and overview.
		/// Movies_idTranslations_languageGet movies/{id}/translations/{language}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="language">2 character language code</param>
		/// <returns>OK</returns>
		public async Task Movies_idTranslations_languageGetAsync(string id, string language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/translations/"+ (language==null? "" : System.Uri.EscapeDataString(language));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get users watching right now
		/// #### &#10024; Extended Info
		/// 
		/// Returns all users watching this movie right now.
		/// Movies_idWatchingGet movies/{id}/watching
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Movies_idWatchingGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "movies/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/watching";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get networks
		/// Get a list of all TV networks, including the name.
		/// NetworksGet networks
		/// </summary>
		/// <returns>OK</returns>
		public async Task NetworksGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Authorize Application
		/// Construct then redirect to this URL. The Trakt website will request permissions for your app, which the user needs to approve. If the user isn't signed into Trakt, it will ask them to do so. Send `signup=true` if you prefer the account sign up page to be the default.
		/// 
		/// **Note:** You should use the normal **https://trakt.tv** hostname when creating this URL and not the API URL.
		/// OauthAuthorizeGetByResponse_typeAndClient_idAndRedirect_uriAndState oauth/authorize
		/// </summary>
		/// <param name="response_type">Must be set to code.</param>
		/// <param name="client_id">Get this from your app settings.</param>
		/// <param name="redirect_uri">URI specified in your app settings.</param>
		/// <param name="state">State variable for CSRF purposes.</param>
		/// <returns>OK</returns>
		public async Task OauthAuthorizeGetByResponse_typeAndClient_idAndRedirect_uriAndStateAsync(string response_type, string client_id, string redirect_uri, string state, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oauth/authorize?response_type=" + (response_type==null? "" : System.Uri.EscapeDataString(response_type))+"&client_id=" + (client_id==null? "" : System.Uri.EscapeDataString(client_id))+"&redirect_uri=" + (redirect_uri==null? "" : System.Uri.EscapeDataString(redirect_uri))+"&state=" + (state==null? "" : System.Uri.EscapeDataString(state));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Generate new device codes
		/// Generate new codes to start the device authentication process. The `device_code` and `interval` will be used later to poll for the `access_token`. The `user_code` and `verification_url` should be presented to the user as mentioned in the flow steps above.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `client_id` <span style="color:red;">*</a> | string | Get this from your app settings. |
		/// OauthDeviceCodePost oauth/device/code
		/// </summary>
		/// <returns>OK</returns>
		public async Task OauthDeviceCodePostAsync(OauthDeviceCodePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oauth/device/code";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Poll for the access_token
		/// Use the `device_code` and poll at the `interval` (in seconds) to check if the user has authorized you app. Use `expires_in` to stop polling after that many seconds, and gracefully instruct the user to restart the process. **It is important to poll at the correct interval and also stop polling when expired.**
		/// 
		/// When you receive a `200` success response, save the `access_token` so your app can authenticate the user in methods that require it. The `access_token` is valid for 3 months. Save and use the `refresh_token` to get a new `access_token` without asking the user to re-authenticate. Check below for all the error codes that you should handle.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `code` <span style="color:red;">*</a> | string | `device_code` from the initial method. |
		/// | `client_id` <span style="color:red;">*</a> | string | Get this from your app settings. |
		/// | `client_secret` <span style="color:red;">*</a> | string | Get this from your app settings. |
		/// 
		/// ####  Status Codes
		/// 
		/// This method will send various HTTP status codes that you should handle accordingly.
		/// 
		/// | Code | Description |
		/// |---|---|
		/// | `200` | Success - *save the `access_token`*
		/// | `400` | Pending - *waiting for the user to authorize your app*
		/// | `404` | Not Found - *invalid `device_code`*
		/// | `409` | Already Used - *user already approved this code*
		/// | `410` | Expired - *the tokens have expired, restart the process*
		/// | `418` | Denied - *user explicitly denied this code*
		/// | `429` | Slow Down - *your app is polling too quickly*
		/// OauthDeviceTokenPost oauth/device/token
		/// </summary>
		/// <returns>OK</returns>
		public async Task OauthDeviceTokenPostAsync(OauthDeviceTokenPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oauth/device/token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Revoke an access_token
		/// An `access_token` can be revoked when a user signs out of their Trakt account in your app. This is not required, but might improve the user experience so the user doesn't have an unused app connection hanging around.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `token` <span style="color:red;">*</a> | string | A valid OAuth `access_token`. |
		/// | `client_id` <span style="color:red;">*</a> | string | Get this from your app settings. |
		/// | `client_secret` <span style="color:red;">*</a> | string | Get this from your app settings. |
		/// OauthRevokePost oauth/revoke
		/// </summary>
		/// <returns>OK</returns>
		public async Task OauthRevokePostAsync(OauthRevokePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oauth/revoke";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Exchange refresh_token for access_token
		/// Use the `refresh_token` to get a new `access_token` without asking the user to re-authenticate. The `access_token` is valid for 3 months before it needs to be refreshed again.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `refresh_token` <span style="color:red;">*</a> | string | Saved from the initial token method. |
		/// | `client_id` <span style="color:red;">*</a> | string | Get this from your app settings. |
		/// | `client_secret` <span style="color:red;">*</a> | string | Get this from your app settings. |
		/// | `redirect_uri` <span style="color:red;">*</a> | string | URI specified in your app settings. |
		/// | `grant_type` <span style="color:red;">* </a> | string | `refresh_token` |
		/// OauthTokenPost oauth/token
		/// </summary>
		/// <returns>If the `refresh_token` is valid, you'll get the `access_token` back.</returns>
		public async Task OauthTokenPostAsync(OauthTokenPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oauth/token";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get recently updated people Trakt IDs
		/// #### &#128196; Pagination
		/// 
		/// Returns all people Trakt IDs updated since the specified UTC date and time. We recommended storing the `X-Start-Date` header you can be efficient using this method moving forward. By default, `10` results are returned. You can send a `limit` to get up to `100` results per page.
		/// 
		/// **Important!** The `start_date` is only accurate to the hour, for caching purposes. Please drop the minutes and seconds from your timestamp to help optimize our cached data. For example, use `2021-07-17T12:00:00Z` and not `2021-07-17T12:23:34Z`.
		/// 
		/// **Note:** The `start_date` can only be a maximum of 30 days in the past.
		/// PeopleUpdatesId_start_dateGet people/updates/id/{start_date}
		/// </summary>
		/// <param name="start_date">Updated since this date and time.</param>
		/// <returns>OK</returns>
		public async Task PeopleUpdatesId_start_dateGetAsync(string start_date, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "people/updates/id/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get recently updated people
		/// #### &#128196; Pagination &#10024; Extended Info
		/// 
		/// Returns all people updated since the specified UTC date and time. We recommended storing the `X-Start-Date` header you can be efficient using this method moving forward. By default, `10` results are returned. You can send a `limit` to get up to `100` results per page.
		/// 
		/// **Important!** The `start_date` is only accurate to the hour, for caching purposes. Please drop the minutes and seconds from your timestamp to help optimize our cached data. For example, use `2021-07-17T12:00:00Z` and not `2021-07-17T12:23:34Z`.
		/// 
		/// **Note:** The `start_date` can only be a maximum of 30 days in the past.
		/// PeopleUpdates_start_dateGet people/updates/{start_date}
		/// </summary>
		/// <param name="start_date">Updated since this date and time.</param>
		/// <returns>OK</returns>
		public async Task PeopleUpdates_start_dateGetAsync(string start_date, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "people/updates/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a single person
		/// #### &#10024; Extended Info
		/// 
		/// Returns a single person's details.
		/// 
		/// #### Gender
		/// 
		/// If available, the `gender` property will be set to `male`, `female`, or `non_binary`.
		/// 
		/// #### Known For Department
		/// 
		/// If available, the `known_for_department` property will be set to `production`, `art`, `crew`, `costume & make-up`, `directing`, `writing`, `sound`, `camera`, `visual effects`, `lighting`, or `editing`. Many people have credits across departments, `known_for` allows you to select their default credits more accurately.
		/// People_idGet people/{id}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>```
		/// /people/bryan-cranston?extended=full
		///```</returns>
		public async Task People_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "people/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get lists containing this person
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all lists that contain this person. By default, `personal` lists are returned sorted by the most `popular`.
		/// People_idLists_type_sortGet people/{id}/lists/{type}/{sort}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="type">Filter for a specific list type</param>
		/// <param name="sort">How to sort</param>
		/// <returns>OK</returns>
		public async Task People_idLists_type_sortGetAsync(string id, People_idLists_type_sortGetType type, Movies_idLists_type_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "people/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+type+"/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get movie credits
		/// #### &#10024; Extended Info
		/// 
		/// Returns all movies where this person is in the `cast` or `crew`. Each `cast` object will have a `characters` array and a standard `movie` object.
		/// 
		/// The `crew` object will be broken up by department into `production`, `art`, `crew`, `costume & make-up`, `directing`, `writing`, `sound`, `camera`, `visual effects`, `lighting`, and `editing` (if there are people for those crew positions). Each of those members will have a `jobs` array and a standard `movie` object.
		/// People_idMoviesGet people/{id}/movies
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task People_idMoviesGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "people/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/movies";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get show credits
		/// #### &#10024; Extended Info
		/// 
		/// Returns all shows where this person is in the `cast` or `crew`, including the `episode_count` for which they appear. Each `cast` object will have a `characters` array and a standard `show` object. If `series_regular` is `true`, this person is a series regular and not simply a guest star.
		/// 
		/// The `crew` object will be broken up by department into `production`, `art`, `crew`, `costume & make-up`, `directing`, `writing`, `sound`, `camera`, `visual effects`, `lighting`, `editing`, and `created  by` (if there are people for those crew positions). Each of those members will have a `jobs` array and a standard `show` object.
		/// People_idShowsGet people/{id}/shows
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task People_idShowsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "people/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/shows";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get movie recommendations
		/// #### &#128274; OAuth Required &#10024; Extended Info
		/// 
		/// Movie recommendations for a user. By default, `10` results are returned. You can send a `limit` to get up to `100` results per page. Set `ignore_collected=true` to filter out movies the user has already collected or `ignore_watchlisted=true` to filter out movies the user has already watchlisted.
		/// 
		/// The `recommended_by` array contains all users who recommended the item along with any notes they added.
		/// RecommendationsMoviesGetByIgnore_collectedAndIgnore_watchlisted recommendations/movies
		/// </summary>
		/// <param name="ignore_collected">filter out collected movies</param>
		/// <param name="ignore_watchlisted">filter out watchlisted movies</param>
		/// <returns>OK</returns>
		public async Task RecommendationsMoviesGetByIgnore_collectedAndIgnore_watchlistedAsync(RecommendationsMoviesGetByIgnore_collectedAndIgnore_watchlistedIgnore_collected ignore_collected, RecommendationsMoviesGetByIgnore_collectedAndIgnore_watchlistedIgnore_watchlisted ignore_watchlisted, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "recommendations/movies?ignore_collected=" + ignore_collected+"&ignore_watchlisted=" + ignore_watchlisted;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Hide a movie recommendation
		/// #### &#128274; OAuth Required
		/// 
		/// Hide a movie from getting recommended anymore.
		/// RecommendationsMovies_idDelete recommendations/movies/{id}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		public async Task RecommendationsMovies_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "recommendations/movies/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get show recommendations
		/// #### &#128274; OAuth Required &#10024; Extended Info
		/// 
		/// TV show recommendations for a user. By default, `10` results are returned. You can send a `limit` to get up to `100` results per page. Set `ignore_collected=true` to filter out shows the user has already collected or `ignore_watchlisted=true` to filter out shows the user has already watchlisted.
		/// 
		/// The `recommended_by` array contains all users who recommended the item along with any notes they added.
		/// RecommendationsShowsGetByIgnore_collectedAndIgnore_watchlisted recommendations/shows
		/// </summary>
		/// <param name="ignore_collected">filter out collected shows</param>
		/// <param name="ignore_watchlisted">filter out watchlisted movies</param>
		/// <returns>OK</returns>
		public async Task RecommendationsShowsGetByIgnore_collectedAndIgnore_watchlistedAsync(RecommendationsShowsGetByIgnore_collectedAndIgnore_watchlistedIgnore_collected ignore_collected, RecommendationsShowsGetByIgnore_collectedAndIgnore_watchlistedIgnore_watchlisted ignore_watchlisted, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "recommendations/shows?ignore_collected=" + ignore_collected+"&ignore_watchlisted=" + ignore_watchlisted;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Hide a show recommendation
		/// #### &#128274; OAuth Required
		/// 
		/// Hide a show from getting recommended anymore.
		/// RecommendationsShows_idDelete recommendations/shows/{id}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		public async Task RecommendationsShows_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "recommendations/shows/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Pause watching in a media center
		/// #### &#128274; OAuth Required
		/// 
		/// Use this method when the video is paused. The playback progress will be saved and [**/sync/playback**](/reference/sync/playback/) can be used to resume the video from this exact position. Unpause a video by calling the [**/scrobble/start**](/reference/scrobble/start/) method again.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | item <span style="color:red;">*</a> | object | `movie` or `episode` object. (see examples &#8594;) |
		/// | `progress` <span style="color:red;">*</a> | float | Progress percentage between 0 and 100. |
		/// | `app_version` | string | Version number of the app. |
		/// | `app_date` | string | Build date of the app. |
		/// ScrobblePausePost scrobble/pause
		/// </summary>
		public async Task ScrobblePausePostAsync(ScrobblePausePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scrobble/pause";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Start watching in a media center
		/// #### &#128274; OAuth Required
		/// 
		/// Use this method when the video initially starts playing or is unpaused. This will remove any playback progress if it exists.
		/// 
		/// **Note:** A watching status will auto expire after the remaining runtime has elapsed. There is no need to call this method again while continuing to watch the same item.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | item <span style="color:red;">*</a> | object | `movie` or `episode` object. (see examples &#8594;) |
		/// | `progress` <span style="color:red;">*</a> | float | Progress percentage between 0 and 100. |
		/// | `app_version` | string | Version number of the app. |
		/// | `app_date` | string | Build date of the app. |
		/// ScrobbleStartPost scrobble/start
		/// </summary>
		public async Task ScrobbleStartPostAsync(ScrobbleStartPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scrobble/start";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stop or finish watching in a media center
		/// #### &#128274; OAuth Required
		/// 
		/// Use this method when the video is stopped or finishes playing on its own. If the progress is above 80%, the video will be scrobbled and the `action` will be set to **scrobble**. A unique history `id` (64-bit integer) will be returned and can be used to reference this `scrobble` directly.
		/// 
		/// If the progress is less than 80%, it will be treated as a *pause* and the `action` will be set to **pause**. The playback progress will be saved and [**/sync/playback**](/reference/sync/playback/) can be used to resume the video from this exact position.
		/// 
		/// **Note:** If you prefer to use a threshold higher than 80%, you should use [**/scrobble/pause**](/reference/scrobble/pause/) yourself so it doesn't create duplicate scrobbles.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | item <span style="color:red;">*</a> | object | `movie` or `episode` object. (see examples &#8594;) |
		/// | `progress` <span style="color:red;">*</a> | flloat | Progress percentage between 0 and 100. |
		/// | `app_version` | string | Version number of the app. |
		/// | `app_date` | string | Build date of the app. |
		/// 
		/// **Note:** If the same item was just scrobbled, a `409` HTTP status code will returned to avoid scrobbling a duplicate. The response will contain a `watched_at` timestamp when the item was last scrobbled and a `expires_at` timestamp when the item can be scrobbled again.
		/// ScrobbleStopPost scrobble/stop
		/// </summary>
		public async Task ScrobbleStopPostAsync(ScrobbleStopPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "scrobble/stop";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get ID lookup results
		/// #### &#128196; Pagination &#10024; Extended Info
		/// 
		/// Lookup items by their Trakt, IMDB, TMDB, or TVDB ID. If you use the search url without a `type` it might return multiple items if the `id_type` is not globally unique. Specify the `type` of results by sending a single value or a comma delimited string for multiple types.
		/// 
		/// | Type | URL |
		/// |---|---|
		/// | `trakt` | `/search/trakt/:id` |
		/// |  | `/search/trakt/:id?type=movie` |
		/// |  | `/search/trakt/:id?type=show` |
		/// |  | `/search/trakt/:id?type=episode` |
		/// |  | `/search/trakt/:id?type=person` |
		/// | `imdb` | `/search/imdb/:id` |
		/// | `tmdb` | `/search/tmdb/:id` |
		/// |  | `/search/tmdb/:id?type=movie` |
		/// |  | `/search/tmdb/:id?type=show` |
		/// |  | `/search/tmdb/:id?type=episode` |
		/// |  | `/search/tmdb/:id?type=person` |
		/// | `tvdb` | `/search/tvdb/:id` |
		/// |  | `/search/tvdb/:id?type=show` |
		/// |  | `/search/tvdb/:id?type=episode` |
		/// Search_id_type_idGetByType search/{id_type}/{id}
		/// </summary>
		/// <param name="id_type">Type of ID to lookup.</param>
		/// <param name="id">ID that matches with the type.</param>
		/// <param name="type">Search type.</param>
		/// <returns>```
		/// /search/trakt/12601?type=movie
		/// /search/imdb/tt1104001
		///```</returns>
		public async Task Search_id_type_idGetByTypeAsync(Search_id_type_idGetByTypeId_type id_type, string id, Search_id_type_idGetByTypeType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/"+id_type+"/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"&type=" + type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get text query results
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Search all text fields that a media object contains (i.e. title, overview, etc). Results are ordered by the most relevant score. Specify the `type` of results by sending a single value or a comma delimited string for multiple types.
		/// 
		/// #### Special Characters
		/// 
		/// Our search engine (Solr) gives the following characters special meaning when they appear in a query:
		/// 
		/// `+ - && || ! ( ) { } [ ] ^ " ~ * ? : /`
		/// 
		/// To interpret any of these characters literally (and not as a special character), precede the character with a backslash `\` character.
		/// 
		/// #### Search Fields
		/// 
		/// By default, all text fields are used to search for the `query`. You can optionally specify the `fields` parameter with a single value or comma delimited string for multiple fields. Each `type` has specific `fields` that can be specified. This can be useful if you want to support more strict searches (i.e. title only).
		/// 
		/// | Type | Field |
		/// |---|---|
		/// | `movie` | `title` |
		/// |  | `tagline` |
		/// |  | `overview` |
		/// |  | `people` |
		/// |  | `translations` |
		/// |  | `aliases` |
		/// | `show` | `title` |
		/// |  | `overview` |
		/// |  | `people` |
		/// |  | `translations` |
		/// |  | `aliases` |
		/// | `episode` | `title` |
		/// |  | `overview` |
		/// | `person` | `name` |
		/// |  | `biography` |
		/// | `list` | `name` |
		/// |  | `description` |
		/// Search_typeGetByQuery search/{type}
		/// </summary>
		/// <param name="type">Search type.</param>
		/// <param name="query">Search all text based fields.</param>
		/// <returns>```
		/// /search/movie,show,episode,person,list?query=tron
		///```</returns>
		public async Task Search_typeGetByQueryAsync(Search_id_type_idGetByTypeType type, string query, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/"+type+"?query=" + (query==null? "" : System.Uri.EscapeDataString(query));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the most anticipated shows
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most anticipated shows based on the number of lists a show appears on.
		/// ShowsAnticipatedGet shows/anticipated
		/// </summary>
		/// <returns>OK</returns>
		public async Task ShowsAnticipatedGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/anticipated";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the most collected shows
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most collected (unique users) shows in the specified time `period`, defaulting to `weekly`. All stats are relative to the specific time `period`.
		/// ShowsCollected_periodGet shows/collected/{period}
		/// </summary>
		/// <param name="period">Time period.</param>
		/// <returns>OK</returns>
		public async Task ShowsCollected_periodGetAsync(MoviesCollected_periodGetPeriod period, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/collected/"+period;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the most played shows
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most played (a single user can watch multiple episodes multiple times) shows in the specified time `period`, defaulting to `weekly`. All stats are relative to the specific time `period`.
		/// ShowsPlayed_periodGet shows/played/{period}
		/// </summary>
		/// <param name="period">Time period.</param>
		/// <returns>OK</returns>
		public async Task ShowsPlayed_periodGetAsync(MoviesCollected_periodGetPeriod period, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/played/"+period;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get popular shows
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most popular shows. Popularity is calculated using the rating percentage and the number of ratings.
		/// ShowsPopularGet shows/popular
		/// </summary>
		/// <returns>OK</returns>
		public async Task ShowsPopularGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/popular";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the most recommended shows
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most recommended shows in the specified time `period`, defaulting to `weekly`. All stats are relative to the specific time `period`.
		/// ShowsRecommended_periodGet shows/recommended/{period}
		/// </summary>
		/// <param name="period">Time period.</param>
		/// <returns>OK</returns>
		public async Task ShowsRecommended_periodGetAsync(MoviesCollected_periodGetPeriod period, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/recommended/"+period;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get trending shows
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns all shows being watched right now. Shows with the most users are returned first.
		/// ShowsTrendingGet shows/trending
		/// </summary>
		/// <returns>OK</returns>
		public async Task ShowsTrendingGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/trending";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get recently updated show Trakt IDs
		/// #### &#128196; Pagination
		/// 
		/// Returns all show Trakt IDs updated since the specified UTC date and time. We recommended storing the `X-Start-Date` header you can be efficient using this method moving forward. By default, `10` results are returned. You can send a `limit` to get up to `100` results per page.
		/// 
		/// **Important!** The `start_date` is only accurate to the hour, for caching purposes. Please drop the minutes and seconds from your timestamp to help optimize our cached data. For example, use `2021-07-17T12:00:00Z` and not `2021-07-17T12:23:34Z`.
		/// 
		/// **Note:** The `start_date` can only be a maximum of 30 days in the past.
		/// ShowsUpdatesId_start_dateGet shows/updates/id/{start_date}
		/// </summary>
		/// <param name="start_date">Updated since this date and time.</param>
		/// <returns>OK</returns>
		public async Task ShowsUpdatesId_start_dateGetAsync(string start_date, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/updates/id/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get recently updated shows
		/// #### &#128196; Pagination &#10024; Extended Info
		/// 
		/// Returns all shows updated since the specified UTC date and time. We recommended storing the `X-Start-Date` header you can be efficient using this method moving forward. By default, `10` results are returned. You can send a `limit` to get up to `100` results per page.
		/// 
		/// **Important!** The `start_date` is only accurate to the hour, for caching purposes. Please drop the minutes and seconds from your timestamp to help optimize our cached data. For example, use `2021-07-17T12:00:00Z` and not `2021-07-17T12:23:34Z`.
		/// 
		/// **Note:** The `start_date` can only be a maximum of 30 days in the past.
		/// ShowsUpdates_start_dateGet shows/updates/{start_date}
		/// </summary>
		/// <param name="start_date">Updated since this date and time.</param>
		/// <returns>OK</returns>
		public async Task ShowsUpdates_start_dateGetAsync(string start_date, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/updates/"+ (start_date==null? "" : System.Uri.EscapeDataString(start_date));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the most watched shows
		/// #### &#128196; Pagination &#10024; Extended Info &#127898; Filters
		/// 
		/// Returns the most watched (unique users) shows in the specified time `period`, defaulting to `weekly`. All stats are relative to the specific time `period`.
		/// ShowsWatched_periodGet shows/watched/{period}
		/// </summary>
		/// <param name="period">Time period.</param>
		/// <returns>OK</returns>
		public async Task ShowsWatched_periodGetAsync(MoviesCollected_periodGetPeriod period, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/watched/"+period;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a single show
		/// #### &#10024; Extended Info
		/// 
		/// Returns a single shows's details. If you request extended info, the `airs` object is relative to the show's country. You can use the `day`, `time`, and `timezone` to construct your own date then convert it to whatever timezone your user is in.
		/// 
		/// **Note:** When getting `full` extended info, the `status` field can have a value of `returning series` (airing right now),  `continuing` (airing right now), `in production` (airing soon), `planned` (in development), `upcoming` (in development),  `pilot`, `canceled`, or `ended`.
		/// Shows_idGet shows/{id}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>```
		/// /shows/game-of-thrones?extended=full
		///```</returns>
		public async Task Shows_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all show aliases
		/// Returns all title aliases for a show.  Includes country where name is different.
		/// Shows_idAliasesGet shows/{id}/aliases
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Shows_idAliasesGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/aliases";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all show certifications
		/// Returns all content certifications for a show, including the country.
		/// Shows_idCertificationsGet shows/{id}/certifications
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Shows_idCertificationsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/certifications";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all show comments
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all top level comments for a show. By default, the `newest` comments are returned first. Other sorting options include `oldest`, most `likes`, most `replies`, `highest` rated, `lowest` rated, most `plays`, and highest `watched` percentage.
		/// Shows_idComments_sortGet shows/{id}/comments/{sort}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="sort">how to sort</param>
		/// <returns>OK</returns>
		public async Task Shows_idComments_sortGetAsync(string id, Shows_idComments_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/comments/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get last episode
		/// #### &#10024; Extended Info
		/// 
		/// Returns the most recently aired episode. If no episode is found, a `204` HTTP status code will be returned.
		/// Shows_idLast_episodeGet shows/{id}/last_episode
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Shows_idLast_episodeGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/last_episode";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get lists containing this show
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all lists that contain this show. By default, `personal` lists are returned sorted by the most `popular`.
		/// Shows_idLists_type_sortGet shows/{id}/lists/{type}/{sort}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="type">Filter for a specific list type</param>
		/// <param name="sort">How to sort</param>
		/// <returns>OK</returns>
		public async Task Shows_idLists_type_sortGetAsync(string id, Movies_idLists_type_sortGetType type, Movies_idLists_type_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+type+"/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get next episode
		/// #### &#10024; Extended Info
		/// 
		/// Returns the next scheduled to air episode. If no episode is found, a `204` HTTP status code will be returned.
		/// Shows_idNext_episodeGet shows/{id}/next_episode
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Shows_idNext_episodeGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/next_episode";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all people for a show
		/// #### &#10024; Extended Info
		/// 
		/// Returns all `cast` and `crew` for a show, including the `episode_count` for which they appears. Each `cast` member will have a `characters` array and a standard `person` object.
		/// 
		/// The `crew` object will be broken up by department into `production`, `art`, `crew`, `costume & make-up`, `directing`, `writing`, `sound`, `camera`, `visual effects`, `lighting`, `editing`, and `created  by` (if there are people for those crew positions). Each of those members will have a `jobs` array and a standard `person` object.
		/// 
		/// #### Guest Stars
		/// 
		/// If you add `?extended=guest_stars` to the URL, it will return all guest stars that appeared in at least 1 episode of the show.
		/// 
		/// **Note:** This returns a lot of data, so please only use this extended parameter if you actually need it!
		/// Shows_idPeopleGet shows/{id}/people
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>```
		/// /shows/game-of-thrones/people?extended=guest_stars
		///```</returns>
		public async Task Shows_idPeopleGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/people";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get show collection progress
		/// #### &#128274; OAuth Required
		/// 
		/// Returns collection progress for a show including details on all aired seasons and episodes. The `next_episode` will be the next episode the user should collect, if there are no upcoming episodes it will be set to `null`.
		/// 
		/// By default, any hidden seasons will be removed from the response and stats. To include these and adjust the completion stats, set the `hidden` flag to `true`.
		/// 
		/// By default, specials will be excluded from the response. Set the `specials` flag to `true` to include season 0 and adjust the stats accordingly. If you'd like to include specials, but not adjust the stats, set `count_specials` to `false`.
		/// 
		/// By default, the `last_episode` and `next_episode` are calculated using the last `aired` episode the user has collected, even if they've collected older episodes more recently. To use their last collected episode for these calculations, set the `last_activity` flag to `collected`.
		/// 
		/// **Note:** Only aired episodes are used to calculate progress. Episodes in the future or without an air date are ignored.
		/// Shows_idProgressCollectionGetByHiddenAndSpecialsAndCount_specials shows/{id}/progress/collection
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="hidden">include any hidden seasons</param>
		/// <param name="specials">include specials as season 0</param>
		/// <param name="count_specials">count specials in the overall stats (only applies if specials are included)</param>
		/// <returns>OK</returns>
		public async Task Shows_idProgressCollectionGetByHiddenAndSpecialsAndCount_specialsAsync(string id, string hidden, string specials, string count_specials, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/progress/collection&hidden=" + (hidden==null? "" : System.Uri.EscapeDataString(hidden))+"&specials=" + (specials==null? "" : System.Uri.EscapeDataString(specials))+"&count_specials=" + (count_specials==null? "" : System.Uri.EscapeDataString(count_specials));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get show watched progress
		/// #### &#128274; OAuth Required
		/// 
		/// Returns watched progress for a show including details on all aired seasons and episodes. The `next_episode` will be the next episode the user should watch, if there are no upcoming episodes it will be set to `null`. If not `null`, the `reset_at` date is when the user started re-watching the show. Your app can adjust the progress by ignoring episodes with a `last_watched_at` prior to the `reset_at`.
		/// 
		/// By default, any hidden seasons will be removed from the response and stats. To include these and adjust the completion stats, set the `hidden` flag to `true`.
		/// 
		/// By default, specials will be excluded from the response. Set the `specials` flag to `true` to include season 0 and adjust the stats accordingly. If you'd like to include specials, but not adjust the stats, set `count_specials` to `false`.
		/// 
		/// By default, the `last_episode` and `next_episode` are calculated using the last `aired` episode the user has watched, even if they've watched older episodes more recently. To use their last watched episode for these calculations, set the `last_activity` flag to `watched`.
		/// 
		/// **Note:** Only aired episodes are used to calculate progress. Episodes in the future or without an air date are ignored.
		/// Shows_idProgressWatchedGetByHiddenAndSpecialsAndCount_specials shows/{id}/progress/watched
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="hidden">include any hidden seasons</param>
		/// <param name="specials">include specials as season 0</param>
		/// <param name="count_specials">count specials in the overall stats (only applies if specials are included)</param>
		/// <returns>OK</returns>
		public async Task Shows_idProgressWatchedGetByHiddenAndSpecialsAndCount_specialsAsync(string id, string hidden, string specials, string count_specials, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/progress/watched&hidden=" + (hidden==null? "" : System.Uri.EscapeDataString(hidden))+"&specials=" + (specials==null? "" : System.Uri.EscapeDataString(specials))+"&count_specials=" + (count_specials==null? "" : System.Uri.EscapeDataString(count_specials));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Undo reset show progress
		/// #### &#128274; OAuth Required 🔥 VIP Only
		/// 
		/// Undo the reset and have watched progress use all watched history for the show.
		/// Shows_idProgressWatchedResetDelete shows/{id}/progress/watched/reset
		/// </summary>
		/// <param name="id">Automatically added</param>
		public async Task Shows_idProgressWatchedResetDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/progress/watched/reset";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset show progress
		/// #### &#128274; OAuth Required 🔥 VIP Only
		/// 
		/// Reset a show's progress when the user started re-watching the show. You can optionally specify the `reset_at` date to have it calculate progress from that specific date onwards.
		/// Shows_idProgressWatchedResetPost shows/{id}/progress/watched/reset
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Shows_idProgressWatchedResetPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/progress/watched/reset";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get show ratings
		/// Returns rating (between 0 and 10) and distribution for a show.
		/// Shows_idRatingsGet shows/{id}/ratings
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Shows_idRatingsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/ratings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get related shows
		/// #### &#128196; Pagination &#10024; Extended Info
		/// 
		/// Returns related and similar shows.
		/// Shows_idRelatedGet shows/{id}/related
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Shows_idRelatedGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/related";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all seasons for a show
		/// #### &#10024; Extended Info
		/// 
		/// Returns all seasons for a show including the number of episodes in each season.
		/// 
		/// #### Episodes
		/// 
		/// If you add `?extended=episodes` to the URL, it will return all episodes for all seasons.
		/// 
		/// **Note:** This returns a lot of data, so please only use this extended parameter if you actually need it!
		/// Shows_idSeasonsGet shows/{id}/seasons
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>```
		/// /shows/game-of-thrones/seasons?extended=episodes
		///```</returns>
		public async Task Shows_idSeasonsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get single season for a show
		/// #### &#10024; Extended Info
		/// 
		/// Returns all episodes for a specific season of a show.
		/// 
		/// #### Translations
		/// 
		/// If you'd like to included translated episode titles and overviews in the response, include the `translations` parameter in the URL. Include all languages by setting the parameter to `all` or use a specific 2 digit country language code to further limit it.
		/// 
		/// **Note:** This returns a lot of data, so please only use this parameter if you actually need it!
		/// Shows_idSeasons_seasonGetByTranslations shows/{id}/seasons/{season}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="translations">include episode translations</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonGetByTranslationsAsync(string id, int season, string translations, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"&translations=" + (translations==null? "" : System.Uri.EscapeDataString(translations));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all season comments
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all top level comments for a season. By default, the `newest` comments are returned first. Other sorting options include `oldest`, most `likes`, most `replies`, `highest` rated, `lowest` rated, most `plays`, and highest `watched` percentage.
		/// Shows_idSeasons_seasonComments_sortGet shows/{id}/seasons/{season}/comments/{sort}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="sort">how to sort</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonComments_sortGetAsync(string id, int season, Shows_idComments_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/comments/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a single episode for a show
		/// #### &#10024; Extended Info
		/// 
		/// Returns a single episode's details. All date and times are in UTC and were calculated using the episode's `air_date` and show's `country` and `air_time`.
		/// 
		/// **Note:** If the `first_aired` is unknown, it will be set to `null`.
		/// Shows_idSeasons_seasonEpisodes_episodeGet shows/{id}/seasons/{season}/episodes/{episode}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="episode">episode number</param>
		/// <returns>```
		/// /shows/game-of-thrones/seasons/1/episodes/1?extended=full
		///```</returns>
		public async Task Shows_idSeasons_seasonEpisodes_episodeGetAsync(string id, int season, int episode, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/episodes/"+episode;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all episode comments
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all top level comments for an episode. By default, the `newest` comments are returned first. Other sorting options include `oldest`, most `likes`, most `replies`, `highest` rated, `lowest` rated, and most `plays`.
		/// Shows_idSeasons_seasonEpisodes_episodeComments_sortGet shows/{id}/seasons/{season}/episodes/{episode}/comments/{sort}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="episode">episode number</param>
		/// <param name="sort">how to sort</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonEpisodes_episodeComments_sortGetAsync(string id, int season, int episode, Movies_idComments_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/episodes/"+episode+"/comments/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get lists containing this episode
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all lists that contain this episode. By default, `personal` lists are returned sorted by the most `popular`.
		/// Shows_idSeasons_seasonEpisodes_episodeLists_type_sortGet shows/{id}/seasons/{season}/episodes/{episode}/lists/{type}/{sort}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="episode">episode number</param>
		/// <param name="type">Filter for a specific list type</param>
		/// <param name="sort">How to sort</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonEpisodes_episodeLists_type_sortGetAsync(string id, int season, int episode, Shows_idSeasons_seasonEpisodes_episodeLists_type_sortGetType type, Movies_idLists_type_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/episodes/"+episode+"/lists/"+type+"/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all people for an episode
		/// #### &#10024; Extended Info
		/// 
		/// Returns all `cast` and `crew` for an episode. Each `cast` member will have a `characters` array and a standard `person` object.
		/// 
		/// The `crew` object will be broken up by department into `production`, `art`, `crew`, `costume & make-up`, `directing`, `writing`, `sound`, `camera`, `visual effects`, `lighting`, and `editing` (if there are people for those crew positions). Each of those members will have a `jobs` array and a standard `person` object.
		/// 
		/// #### Guest Stars
		/// 
		/// If you add `?extended=guest_stars` to the URL, it will return all guest stars that appeared in the episode.
		/// 
		/// **Note:** This returns a lot of data, so please only use this extended parameter if you actually need it!
		/// Shows_idSeasons_seasonEpisodes_episodePeopleGet shows/{id}/seasons/{season}/episodes/{episode}/people
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="episode">episode number</param>
		/// <returns>```
		/// /shows/game-of-thrones/seasons/1/episodes/1/people?extended=guest_stars
		///```</returns>
		public async Task Shows_idSeasons_seasonEpisodes_episodePeopleGetAsync(string id, int season, int episode, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/episodes/"+episode+"/people";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get episode ratings
		/// Returns rating (between 0 and 10) and distribution for an episode.
		/// Shows_idSeasons_seasonEpisodes_episodeRatingsGet shows/{id}/seasons/{season}/episodes/{episode}/ratings
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="episode">episode number</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonEpisodes_episodeRatingsGetAsync(string id, int season, int episode, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/episodes/"+episode+"/ratings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get episode stats
		/// Returns lots of episode stats.
		/// Shows_idSeasons_seasonEpisodes_episodeStatsGet shows/{id}/seasons/{season}/episodes/{episode}/stats
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="episode">episode number</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonEpisodes_episodeStatsGetAsync(string id, int season, int episode, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/episodes/"+episode+"/stats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all episode translations
		/// Returns all translations for an episode, including language and translated values for title and overview.
		/// Shows_idSeasons_seasonEpisodes_episodeTranslations_languageGet shows/{id}/seasons/{season}/episodes/{episode}/translations/{language}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="episode">episode number</param>
		/// <param name="language">2 character language code</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonEpisodes_episodeTranslations_languageGetAsync(string id, int season, int episode, string language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/episodes/"+episode+"/translations/"+ (language==null? "" : System.Uri.EscapeDataString(language));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get users watching right now
		/// #### &#10024; Extended Info
		/// 
		/// Returns all users watching this episode right now.
		/// Shows_idSeasons_seasonEpisodes_episodeWatchingGet shows/{id}/seasons/{season}/episodes/{episode}/watching
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="episode">episode number</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonEpisodes_episodeWatchingGetAsync(string id, int season, int episode, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/episodes/"+episode+"/watching";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get lists containing this season
		/// #### &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all lists that contain this season. By default, `personal` lists are returned sorted by the most `popular`.
		/// Shows_idSeasons_seasonLists_type_sortGet shows/{id}/seasons/{season}/lists/{type}/{sort}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="type">Filter for a specific list type</param>
		/// <param name="sort">How to sort</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonLists_type_sortGetAsync(string id, int season, Shows_idSeasons_seasonEpisodes_episodeLists_type_sortGetType type, Movies_idLists_type_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/lists/"+type+"/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all people for a season
		/// #### &#10024; Extended Info
		/// 
		/// Returns all `cast` and `crew` for a season, including the `episode_count` for which they appear. Each `cast` member will have a `characters` array and a standard `person` object.
		/// 
		/// The `crew` object will be broken up by department into `production`, `art`, `crew`, `costume & make-up`, `directing`, `writing`, `sound`, `camera`, `visual effects`, `lighting`, and `editing` (if there are people for those crew positions).. Each of those members will have a `jobs` array and a standard `person` object.
		/// 
		/// #### Guest Stars
		/// 
		/// If you add `?extended=guest_stars` to the URL, it will return all guest stars that appeared in at least 1 episode of the season.
		/// 
		/// **Note:** This returns a lot of data, so please only use this extended parameter if you actually need it!
		/// Shows_idSeasons_seasonPeopleGet shows/{id}/seasons/{season}/people
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <returns>```
		/// /shows/game-of-thrones/seasons/1/people?extended=guest_stars
		///```</returns>
		public async Task Shows_idSeasons_seasonPeopleGetAsync(string id, int season, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/people";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get season ratings
		/// Returns rating (between 0 and 10) and distribution for a season.
		/// Shows_idSeasons_seasonRatingsGet shows/{id}/seasons/{season}/ratings
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonRatingsGetAsync(string id, int season, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/ratings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get season stats
		/// Returns lots of season stats.
		/// Shows_idSeasons_seasonStatsGet shows/{id}/seasons/{season}/stats
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonStatsGetAsync(string id, int season, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/stats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all season translations
		/// Returns all translations for an season, including language and translated values for title and overview.
		/// Shows_idSeasons_seasonTranslations_languageGet shows/{id}/seasons/{season}/translations/{language}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <param name="language">2 character language code</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonTranslations_languageGetAsync(string id, int season, string language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/translations/"+ (language==null? "" : System.Uri.EscapeDataString(language));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get users watching right now
		/// #### &#10024; Extended Info
		/// 
		/// Returns all users watching this season right now.
		/// Shows_idSeasons_seasonWatchingGet shows/{id}/seasons/{season}/watching
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="season">season number</param>
		/// <returns>OK</returns>
		public async Task Shows_idSeasons_seasonWatchingGetAsync(string id, int season, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/seasons/"+season+"/watching";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get show stats
		/// Returns lots of show stats.
		/// Shows_idStatsGet shows/{id}/stats
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Shows_idStatsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/stats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get show studios
		/// Returns all studios for a show.
		/// Shows_idStudiosGet shows/{id}/studios
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Shows_idStudiosGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/studios";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all show translations
		/// Returns all translations for a show, including language and translated values for title and overview.
		/// Shows_idTranslations_languageGet shows/{id}/translations/{language}
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <param name="language">2 character language code</param>
		/// <returns>OK</returns>
		public async Task Shows_idTranslations_languageGetAsync(string id, string language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/translations/"+ (language==null? "" : System.Uri.EscapeDataString(language));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get users watching right now
		/// #### &#10024; Extended Info
		/// 
		/// Returns all users watching this show right now.
		/// Shows_idWatchingGet shows/{id}/watching
		/// </summary>
		/// <param name="id">Trakt ID, Trakt slug, or IMDB ID</param>
		/// <returns>OK</returns>
		public async Task Shows_idWatchingGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "shows/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/watching";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add items to collection
		/// #### &#128274; OAuth Required
		/// 
		/// Add items to a user's collection. Accepts shows, seasons, episodes and movies. If only a show is passed, all episodes for the show will be collected. If seasons are specified, all episodes in those seasons will be collected.
		/// 
		/// Send a `collected_at` UTC datetime to mark items as collected in the past. You can also send additional metadata about the media itself to have a very accurate collection. Showcase what is available to watch from your epic HD DVD collection down to your downloaded iTunes movies.
		/// 
		/// **Note:** You can resend items already in your collection and they will be updated with any new values. This includes the `collected_at` and any other metadata.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `episodes` | array | Array of `episode` objects. |
		/// 
		/// #### Media Object POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | item <span style="color:red;">*</a> | object | `movie`, `show`, or `episode` object. |
		/// | `collected_at` | datetime | UTC datetime when the item was collected. Set to `released` to automatically use the inital release date + runtime *(episodes only)*). |
		/// | `media_type` | string | Set to `digital`, `bluray`, `hddvd`, `dvd`, `vcd`, `vhs`, `betamax`, or `laserdisc`. |
		/// | `resolution` | string | Set to `uhd_4k`, `hd_1080p`, `hd_1080i`, `hd_720p`, `sd_480p`, `sd_480i`, `sd_576p`, or `sd_576i`. |
		/// | `hdr` | string | Set to `dolby_vision`, `hdr10`, `hdr10_plus`, or `hlg`. |
		/// | `audio` | string | Set to `dolby_digital`, `dolby_digital_plus`, `dolby_digital_plus_atmos`, `dolby_truehd`, `dolby_atmos` *(Dolby TrueHD Atmos)*, `dolby_prologic`, `dts`, `dts_ma`, `dts_hr`, `dts_x`, `auro_3d`, `mp3`, `mp2`, `aac`, `lpcm`, `ogg` *(Ogg Vorbis)*, `ogg_opus`, `wma`, or `flac`. |
		/// | `audio_channels` | string | Set to `1.0`, `2.0`, `2.1`, `3.0`, `3.1`, `4.0`, `4.1`, `5.0`, `5.1`, `5.1.2`, `5.1.4`, `6.1`, `7.1`, `7.1.2`, `7.1.4`, `9.1`, or `10.1` |
		/// | `3d` | boolean | Set `true` if in 3D. |
		/// SyncCollectionPost sync/collection
		/// </summary>
		public async Task SyncCollectionPostAsync(SyncCollectionPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/collection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove items from collection
		/// #### &#128274; OAuth Required
		/// 
		/// Remove one or more items from a user's collection.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `episodes` | array | Array of `episode` objects. |
		/// SyncCollectionRemovePost sync/collection/remove
		/// </summary>
		/// <returns>OK</returns>
		public async Task SyncCollectionRemovePostAsync(Remove_items_from_collectionBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/collection/remove";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get collection
		/// #### &#128274; OAuth Required &#10024; Extended Info
		/// 
		/// Get all collected items in a user's collection. A collected item indicates availability to watch digitally or on physical media.
		/// 
		/// Each `movie` object contains `collected_at` and `updated_at` timestamps. Since users can set custom dates when they collected movies, it is possible for `collected_at` to be in the past. We also include `updated_at` to help sync Trakt data with your app. Cache this timestamp locally and only re-process the movie if you see a newer timestamp.
		/// 
		/// Each `show` object contains `last_collected_at` and `last_updated_at` timestamps. Since users can set custom dates when they collected episodes, it is possible for `last_collected_at` to be in the past. We also include `last_updated_at` to help sync Trakt data with your app. Cache this timestamp locally and only re-process the show if you see a newer timestamp.
		/// 
		/// If you add `?extended=metadata` to the URL, it will return the additional `media_type`, `resolution`, `hdr`, `audio`, `audio_channels` and '3d' metadata. It will use `null` if the metadata isn't set for an item.
		/// SyncCollection_typeGet sync/collection/{type}
		/// </summary>
		/// <returns>```
		/// /sync/collection/shows?extended=metadata
		///```</returns>
		public async Task SyncCollection_typeGetAsync(Certifications_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/collection/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add items to watched history
		/// #### &#128274; OAuth Required
		/// 
		/// Add items to a user's watch history. Accepts shows, seasons, episodes and movies. If only a show is passed, all episodes for the show will be added. If seasons are specified, only episodes in those seasons will be added.
		/// 
		/// Send a `watched_at` UTC datetime to mark items as watched in the past. This is useful for syncing past watches from a media center.
		/// 
		/// **Note:** Please be careful with sending duplicate data. We don't verify the `item` + `watched_at` to ensure it's unique, it is up to your app to veify this and not send duplicate plays.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `episodes` | array | Array of `episode` objects. |
		/// 
		/// #### Media Object POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | item <span style="color:red;">*</a> | object | `movie`, `show`, or `episode` object. |
		/// | `watched_at` | datetime | UTC datetime when the item was watched. Set to `released` to automatically use the initial release date + runtime *(episodes only)*. |
		/// SyncHistoryPost sync/history
		/// </summary>
		public async Task SyncHistoryPostAsync(SyncHistoryPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/history";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove items from history
		/// #### &#128274; OAuth Required
		/// 
		/// Remove items from a user's watch history including all watches, scrobbles, and checkins. Accepts shows, seasons, episodes and movies. If only a show is passed, all episodes for the show will be removed. If seasons are specified, only episodes in those seasons will be removed.
		/// 
		/// You can also send a list of raw history `ids` _(64-bit integers)_ to delete single plays from the watched history. The [**/sync/history**](#reference/sync/get-history) method will return an individual `id` _(64-bit integer)_ for each history item.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `episodes` | array | Array of `episode` objects. |
		/// | `ids` | array | Array of history ids. |
		/// SyncHistoryRemovePost sync/history/remove
		/// </summary>
		/// <returns>OK</returns>
		public async Task SyncHistoryRemovePostAsync(SyncHistoryRemovePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/history/remove";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get watched history
		/// #### &#128274; OAuth Required &#128196; Pagination &#10024; Extended Info
		/// 
		/// Returns movies and episodes that a user has watched, sorted by most recent. You can optionally limit the `type` to `movies` or `episodes`. The `id` _(64-bit integer)_ in each history item uniquely identifies the event and can be used to remove individual events by using the [**/sync/history/remove**](#reference/sync/remove-from-history/get-watched-history) method. The `action` will be set to `scrobble`, `checkin`, or `watch`.
		/// 
		/// Specify a `type` and trakt `id` to limit the history for just that item. If the `id` is valid, but there is no history, an empty array will be returned.
		/// 
		/// | Example URL | Returns watches for... |
		/// |---|---|
		/// | `/history/movies/12601` | TRON: Legacy |
		/// | `/history/shows/1388` | All episodes of Breaking Bad |
		/// | `/history/seasons/3950` | All episodes of Breaking Bad: Season 1 |
		/// | `/history/episodes/73482` | Only episode 1 for Breaking Bad: Season 1 |
		/// SyncHistory_type_idGetByStart_atAndEnd_at sync/history/{type}/{id}
		/// </summary>
		/// <param name="id">Trakt ID for a specific item.</param>
		/// <param name="start_at">Starting date.</param>
		/// <param name="end_at">Ending date.</param>
		/// <returns>```
		/// /sync/history/episodes
		///```</returns>
		public async Task SyncHistory_type_idGetByStart_atAndEnd_atAsync(SyncHistory_type_idGetByStart_atAndEnd_atType type, int id, string start_at, string end_at, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/history/"+type+"/"+id+"?start_at=" + (start_at==null? "" : System.Uri.EscapeDataString(start_at))+"&end_at=" + (end_at==null? "" : System.Uri.EscapeDataString(end_at));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get last activity
		/// #### &#128274; OAuth Required
		/// 
		/// This method is a useful first step in the syncing process. We recommended caching these dates locally, then you can compare to know exactly what data has changed recently. This can greatly optimize your syncs so you don't pull down a ton of data only to see nothing has actually changed.
		/// 
		/// #### Account
		/// 
		/// `settings_at` is set when the OAuth user updates any of their Trakt settings on the website. `followed_at` is set when another Trakt user follows or unfollows the OAuth user. `following_at` is set when the OAuth user follows or unfollows another Trakt user. `pending_at` is set when the OAuth user follows a private account, which requires their approval. `requested_at` is set when the OAuth user has a private account and someone requests to follow them.
		/// SyncLast_activitiesGet sync/last_activities
		/// </summary>
		/// <returns>OK</returns>
		public async Task SyncLast_activitiesGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/last_activities";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove a playback item
		/// #### &#128274; OAuth Required
		/// 
		/// Remove a playback item from a user's playback progress list. A `404` will be returned if the `id` is invalid.
		/// SyncPlayback_idDelete sync/playback/{id}
		/// </summary>
		/// <param name="id">playback ID</param>
		public async Task SyncPlayback_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/playback/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get playback progress
		/// #### &#128274; OAuth Required &#128196; Pagination Optional
		/// 
		/// Whenever a scrobble is paused, the playback progress is saved. Use this progress to sync up playback across different media centers or apps. For example, you can start watching a movie in a media center, stop it, then resume on your tablet from the same spot. Each item will have the `progress` percentage between 0 and 100.
		/// 
		/// You can optionally specify a `type` to only get `movies` or `episodes`.
		/// 
		/// By default, all results will be returned. Pagination is optional and can be used for something like an "on deck" feature, or if you only need a limited data set.
		/// 
		/// **Note:** We only save playback progress for the last 6 months.
		/// SyncPlayback_typeGetByStart_atAndEnd_at sync/playback/{type}
		/// </summary>
		/// <param name="start_at">Starting date.</param>
		/// <param name="end_at">Ending date.</param>
		/// <returns>OK</returns>
		public async Task SyncPlayback_typeGetByStart_atAndEnd_atAsync(SyncPlayback_typeGetByStart_atAndEnd_atType type, string start_at, string end_at, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/playback/"+type+"?start_at=" + (start_at==null? "" : System.Uri.EscapeDataString(start_at))+"&end_at=" + (end_at==null? "" : System.Uri.EscapeDataString(end_at));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add new ratings
		/// #### &#128274; OAuth Required
		/// 
		/// Rate one or more items. Accepts shows, seasons, episodes and movies. If only a show is passed, only the show itself will be rated. If seasons are specified, all of those seasons will be rated.
		/// 
		/// Send a `rated_at` UTC datetime to mark items as rated in the past. This is useful for syncing ratings from a media center.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `episodes` | array | Array of `episode` objects. |
		/// 
		/// #### Media Object POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | item <span style="color:red;">*</a> | object | `movie`, `show`, `season`, or `episode` object. |
		/// | `rating` <span style="color:red;">*</a> | integer | Between 1 and 10. |
		/// | `rated_at` | datetime | UTC datetime when the item was rated. |
		/// SyncRatingsPost sync/ratings
		/// </summary>
		public async Task SyncRatingsPostAsync(SyncRatingsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/ratings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove ratings
		/// #### &#128274; OAuth Required
		/// 
		/// Remove ratings for one or more items.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `episodes` | array | Array of `episode` objects. |
		/// SyncRatingsRemovePost sync/ratings/remove
		/// </summary>
		/// <returns>OK</returns>
		public async Task SyncRatingsRemovePostAsync(Remove_items_from_collectionBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/ratings/remove";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get ratings
		/// #### &#128274; OAuth Required &#128196; Pagination Optional &#10024; Extended Info
		/// 
		/// Get a user's ratings filtered by `type`. You can optionally filter for a specific `rating` between 1 and 10. Send a comma separated string for `rating` if you need multiple ratings.
		/// SyncRatings_type_ratingGet sync/ratings/{type}/{rating}
		/// </summary>
		/// <param name="rating">Filter for a specific rating.</param>
		/// <returns>```
		/// /sync/ratings/episodes
		///```</returns>
		public async Task SyncRatings_type_ratingGetAsync(SyncRatings_type_ratingGetType type, SyncRatings_type_ratingGetRating rating, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/ratings/"+type+"/"+rating;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add items to personal recommendations
		/// #### &#128274; OAuth Required &#128513; Emojis
		/// 
		/// If the user only had 50 movies and TV shows to bring with them on a desert island, what would they be? These recommendations are used to enchance Trakt's social recommendation algorithm. Apps should encourage user's to build their personal recommendations so the algorithm keeps getting better.
		/// 
		/// #### Notes
		/// 
		/// Each recommendation can optionally accept a `notes` *(255 maximum characters)* field explaining why the user recommended the item.
		/// 
		/// #### Limits
		/// 
		/// If the user has recommended 50 items already, a `420` HTTP error code is returned. This limit applies to all users.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// SyncRecommendationsPost sync/recommendations
		/// </summary>
		public async Task SyncRecommendationsPostAsync(SyncRecommendationsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/recommendations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove items from personal recommendations
		/// #### &#128274; OAuth Required
		/// 
		/// Remove items from a user's personal recommendations. These recommendations are used to enchance Trakt's social recommendation algorithm. Apps should encourage user's to build their personal recommendations so the algorithm keeps getting better.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// SyncRecommendationsRemovePost sync/recommendations/remove
		/// </summary>
		/// <returns>OK</returns>
		public async Task SyncRecommendationsRemovePostAsync(SyncRecommendationsRemovePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/recommendations/remove";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reorder personally recommended items
		/// #### &#128274; OAuth Required
		/// 
		/// Reorder all items on a user's personal recommendations by sending the updated `rank` of list item ids. Use the [**/sync/recommendations**](#reference/sync/get-personal-recommendations) method to get all list item ids.
		/// SyncRecommendationsReorderPost sync/recommendations/reorder
		/// </summary>
		/// <returns>OK</returns>
		public async Task SyncRecommendationsReorderPostAsync(Reorder_watchlist_itemsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/recommendations/reorder";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get personal recommendations
		/// #### &#128274; OAuth Required &#128196; Pagination Optional &#10024; Extended Info &#128513; Emojis
		/// 
		/// If the user only had 50 movies and TV shows to bring with them on a desert island, what would they be? These recommendations are used to enchance Trakt's social recommendation algorithm. Apps should encourage user's to build their personal recommendations so the algorithm keeps getting better.
		/// 
		/// #### Notes
		/// 
		/// Each recommendation contains a `notes` field explaining why the user recommended the item.
		/// SyncRecommendations_type_sortGet sync/recommendations/{type}/{sort}
		/// </summary>
		/// <param name="type">Filter for a specific item type</param>
		/// <param name="sort">How to sort (only if type is also sent)</param>
		/// <returns>```
		/// /sync/recommendations/shows
		///```</returns>
		public async Task SyncRecommendations_type_sortGetAsync(Certifications_typeGetType type, SyncRecommendations_type_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/recommendations/"+type+"/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get watched
		/// #### &#128274; OAuth Required &#10024; Extended Info
		/// 
		/// Returns all movies or shows a user has watched sorted by most plays.
		/// 
		/// If `type` is set to _shows_ and you add `?extended=noseasons` to the URL, it won't return season or episode info.
		/// 
		/// Each `movie` and `show` object contains `last_watched_at` and `last_updated_at` timestamps. Since users can set custom dates when they watched movies and episodes, it is possible for `last_watched_at` to be in the past. We also include `last_updated_at` to help sync Trakt data with your app. Cache this timestamp locally and only re-process the movies and shows if you see a newer timestamp.
		/// 
		/// Each `show` object contains a `reset_at` timestamp. If not `null`, this is when the user started re-watching the show. Your app can adjust the progress by ignoring episodes with a `last_watched_at` prior to the `reset_at`.
		/// SyncWatched_typeGet sync/watched/{type}
		/// </summary>
		/// <returns>```
		/// /sync/watched/shows?extended=noseasons
		///```</returns>
		public async Task SyncWatched_typeGetAsync(Certifications_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/watched/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add items to watchlist
		/// #### &#128274; OAuth Required &#128513; Emojis 🔥 VIP Enhanced
		/// 
		/// Add one of more items to a user's watchlist. Accepts shows, seasons, episodes and movies. If only a show is passed, only the show itself will be added. If seasons are specified, all of those seasons will be added.
		/// 
		/// #### Notes
		/// 
		/// Each watchlist item can optionally accept a `notes` *(255 maximum characters)* field with custom text. The user must be a [**Trakt VIP**](https://trakt.tv/vip) to send `notes`.
		/// 
		/// #### Limits
		/// 
		/// If the user's watchlist limit is exceeded, a `420` HTTP error code is returned. Use the [**/users/settings**](/reference/users/settings) method to get all limits for a user account. In most cases, upgrading to [**Trakt VIP**](https://trakt.tv/vip) will increase the limits.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `episodes` | array | Array of `episode` objects. |
		/// SyncWatchlistPost sync/watchlist
		/// </summary>
		public async Task SyncWatchlistPostAsync(SyncWatchlistPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/watchlist";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove items from watchlist
		/// #### &#128274; OAuth Required
		/// 
		/// Remove one or more items from a user's watchlist.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `episodes` | array | Array of `episode` objects. |
		/// SyncWatchlistRemovePost sync/watchlist/remove
		/// </summary>
		/// <returns>OK</returns>
		public async Task SyncWatchlistRemovePostAsync(Remove_items_from_collectionBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/watchlist/remove";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reorder watchlist items
		/// #### &#128274; OAuth Required
		/// 
		/// Reorder all items on a user's watchlist by sending the updated `rank` of list item ids. Use the [**/sync/watchlist**](#reference/sync/get-watchlist) method to get all list item ids.
		/// SyncWatchlistReorderPost sync/watchlist/reorder
		/// </summary>
		/// <returns>OK</returns>
		public async Task SyncWatchlistReorderPostAsync(Reorder_watchlist_itemsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/watchlist/reorder";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get watchlist
		/// #### &#128274; OAuth Required &#128196; Pagination Optional &#10024; Extended Info &#128513; Emojis
		/// 
		/// Returns all items in a user's watchlist filtered by type.
		/// 
		/// #### Notes
		/// 
		/// Each watchlist item contains a `notes` field with text entered by the user.
		/// 
		/// #### Sorting Headers
		/// 
		/// By default, all list items are sorted by `rank` `asc`. We send `X-Applied-Sort-By` and `X-Applied-Sort-How` headers to indicate how the results are actually being sorted.
		/// 
		/// We also send `X-Sort-By` and `X-Sort-How` headers which indicate the user's sort preference. Use these to to custom sort the watchlist _**in your app**_ for more advanced sort abilities we can't do in the API. Values for `X-Sort-By` include `rank`, `added`, `title`, `released`, `runtime`, `popularity`, `percentage`, and `votes`. Values for `X-Sort-How` include `asc` and `desc`.
		/// 
		/// #### Auto Removal
		/// 
		/// When an item is watched, it will be automatically removed from the watchlist. For shows and seasons, watching 1 episode will remove the entire show or season.
		/// 
		/// _**The watchlist should not be used as a list of what the user is actively watching.**_
		/// 
		/// Use a combination of the [**/sync/watched**](/reference/sync/get-watched) and [**/shows/:id/progress**](/reference/shows/watched-progress) methods to get what the user is actively watching.
		/// SyncWatchlist_type_sortGet sync/watchlist/{type}/{sort}
		/// </summary>
		/// <param name="type">Filter for a specific item type</param>
		/// <param name="sort">How to sort (only if type is also sent)</param>
		/// <returns>```
		/// /sync/watchlist/episodes
		///```</returns>
		public async Task SyncWatchlist_type_sortGetAsync(SyncHistory_type_idGetByStart_atAndEnd_atType type, SyncRecommendations_type_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "sync/watchlist/"+type+"/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get hidden items
		/// #### &#128274; OAuth Required &#128196; Pagination &#10024; Extended Info
		/// 
		/// Get hidden items for a section. This will return an array of standard media objects. You can optionally limit the `type` of results to return.
		/// UsersHidden_sectionGetByType users/hidden/{section}
		/// </summary>
		/// <param name="type">Narrow down by element type.</param>
		/// <returns>OK</returns>
		public async Task UsersHidden_sectionGetByTypeAsync(UsersHidden_sectionGetByTypeSection section, UsersHidden_sectionGetByTypeType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/hidden/"+section+"?type=" + type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add hidden items
		/// #### &#128274; OAuth Required
		/// 
		/// Hide items for a specific section. Here's what type of items can hidden for each section.
		/// 
		/// #### Hideable Media Objects
		/// 
		/// | Section | Objects |
		/// |---|---|---|
		/// | `calendar` | `movie`, `show` |
		/// | `progress_watched` | `show`, `season` |
		/// | `progress_collected` | `show`, `season` |
		/// | `recommendations` | `movie`, `show` |
		/// | `comments` | `user` |
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `users` | array | Array of `user` objects. |
		/// UsersHidden_sectionPost users/hidden/{section}
		/// </summary>
		public async Task UsersHidden_sectionPostAsync(UsersHidden_sectionPostSection section, Add_hidden_itemsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/hidden/"+section;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove hidden items
		/// #### &#128274; OAuth Required
		/// 
		/// Unhide items for a specific section. Here's what type of items can unhidden for each section.
		/// 
		/// #### Unhideable Media Objects
		/// 
		/// | Section | Objects |
		/// |---|---|---|
		/// | `calendar` | `movie`, `show` |
		/// | `progress_watched` | `show`, `season` |
		/// | `progress_collected` | `show`, `season` |
		/// | `recommendations` | `movie`, `show` |
		/// | `comments` | `user` |
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `users` | array | Array of `user` objects. |
		/// UsersHidden_sectionRemovePost users/hidden/{section}/remove
		/// </summary>
		/// <returns>OK</returns>
		public async Task UsersHidden_sectionRemovePostAsync(UsersHidden_sectionRemovePostSection section, Add_hidden_itemsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/hidden/"+section+"/remove";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get follow requests
		/// #### &#128274; OAuth Required &#10024; Extended Info
		/// 
		/// List a user's pending follow requests so they can either approve or deny them.
		/// UsersRequestsGet users/requests
		/// </summary>
		/// <returns>OK</returns>
		public async Task UsersRequestsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/requests";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get pending following requests
		/// #### &#128274; OAuth Required &#10024; Extended Info
		/// 
		/// List a user's pending following requests that they're waiting for the other user's to approve.
		/// UsersRequestsFollowingGet users/requests/following
		/// </summary>
		/// <returns>OK</returns>
		public async Task UsersRequestsFollowingGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/requests/following";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deny follow request
		/// #### &#128274; OAuth Required
		/// 
		/// Deny a follower using the `id` of the request. If the `id` is not found, was already approved, or was already denied, a `404` error will be returned.
		/// UsersRequests_idDelete users/requests/{id}
		/// </summary>
		/// <param name="id">Automatically added</param>
		public async Task UsersRequests_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/requests/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Approve follow request
		/// #### &#128274; OAuth Required
		/// 
		/// Approve a follower using the `id` of the request. If the `id` is not found, was already approved, or was already denied, a `404` error will be returned.
		/// UsersRequests_idPost users/requests/{id}
		/// </summary>
		/// <param name="id">ID of the follower request.</param>
		/// <returns>OK</returns>
		public async Task UsersRequests_idPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/requests/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get saved filters
		/// #### &#128274; OAuth Required &#128196; Pagination 🔥 VIP Only
		/// 
		/// Get all saved filters a user has created. The `path` and `query` can be used to construct an API path to retrieve the saved data. Think of this like a dynamically updated list.
		/// UsersSaved_filters_sectionGet users/saved_filters/{section}
		/// </summary>
		/// <returns>OK</returns>
		public async Task UsersSaved_filters_sectionGetAsync(UsersSaved_filters_sectionGetSection section, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/saved_filters/"+section;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve settings
		/// #### &#128274; OAuth Required
		/// 
		/// Get the user's settings so you can align your app's experience with what they're used to on the trakt website. A globally unique `uuid` is also returned, which can be used to identify the user locally in your app if needed. However, the `uuid` can't be used to retrieve data from the Trakt API.
		/// UsersSettingsGet users/settings
		/// </summary>
		/// <returns>OK</returns>
		public async Task UsersSettingsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/settings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get user profile
		/// #### &#128275; OAuth Optional &#10024; Extended Info
		/// 
		/// Get a user's profile information. If the user is private, info will only be returned if you send OAuth and are either that user or an approved follower. Adding `?extended=vip` will return some additional VIP related fields so you can display the user's Trakt VIP status and year count.
		/// Users_idGet users/{id}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>```
		/// /users/sean?extended=vip
		///```</returns>
		public async Task Users_idGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get collection
		/// #### &#128275; OAuth Optional &#10024; Extended Info
		/// 
		/// Get all collected items in a user's collection. A collected item indicates availability to watch digitally or on physical media.
		/// 
		/// Each `movie` object contains `collected_at` and `updated_at` timestamps. Since users can set custom dates when they collected movies, it is possible for `collected_at` to be in the past. We also include `updated_at` to help sync Trakt data with your app. Cache this timestamp locally and only re-process the movie if you see a newer timestamp.
		/// 
		/// Each `show` object contains `last_collected_at` and `last_updated_at` timestamps. Since users can set custom dates when they collected episodes, it is possible for `last_collected_at` to be in the past. We also include `last_updated_at` to help sync Trakt data with your app. Cache this timestamp locally and only re-process the show if you see a newer timestamp.
		/// 
		/// If you add `?extended=metadata` to the URL, it will return the additional `media_type`, `resolution`, `hdr`, `audio`, `audio_channels` and '3d' metadata. It will use `null` if the metadata isn't set for an item.
		/// Users_idCollection_typeGet users/{id}/collection/{type}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>```
		/// /users/sean/collection/shows?extended=metadata
		///```</returns>
		public async Task Users_idCollection_typeGetAsync(string id, Certifications_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/collection/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get comments
		/// #### &#128275; OAuth Optional &#128196; Pagination &#10024; Extended Info
		/// 
		/// Returns the most recently written comments for the user. You can optionally filter by the `comment_type` and media `type` to limit what gets returned.
		/// 
		/// By default, only top level comments are returned. Set `?include_replies=true` to return replies in addition to top level comments. Set `?include_replies=only` to return only replies and no top level comments.
		/// Users_idComments_comment_type_typeGetByInclude_replies users/{id}/comments/{comment_type}/{type}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="include_replies">include comment replies</param>
		/// <returns>```
		/// /users/sean/comments
		///```</returns>
		public async Task Users_idComments_comment_type_typeGetByInclude_repliesAsync(string id, CommentsRecent_comment_type_typeGetByInclude_repliesComment_type comment_type, CommentsRecent_comment_type_typeGetByInclude_repliesType type, Users_idComments_comment_type_typeGetByInclude_repliesInclude_replies include_replies, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/comments/"+comment_type+"/"+type+"&include_replies=" + include_replies;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unfollow this user
		/// #### &#128274; OAuth Required
		/// 
		/// Unfollow someone you already follow.
		/// Users_idFollowDelete users/{id}/follow
		/// </summary>
		/// <param name="id">Automatically added</param>
		public async Task Users_idFollowDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/follow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Follow this user
		/// #### &#128274; OAuth Required
		/// 
		/// If the user has a private profile, the follow request will require approval (`approved_at` will be null). If a user is public, they will be followed immediately (`approved_at` will have a date).
		/// 
		/// **Note:** If this user is already being followed, a `409` HTTP status code will returned.
		/// Users_idFollowPost users/{id}/follow
		/// </summary>
		/// <param name="id">User slug</param>
		public async Task Users_idFollowPostAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/follow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get followers
		/// #### &#128275; OAuth Optional &#10024; Extended Info
		/// 
		/// Returns all followers including when the relationship began.
		/// Users_idFollowersGet users/{id}/followers
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>OK</returns>
		public async Task Users_idFollowersGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/followers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get following
		/// #### &#128275; OAuth Optional &#10024; Extended Info
		/// 
		/// Returns all user's they follow including when the relationship began.
		/// Users_idFollowingGet users/{id}/following
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>OK</returns>
		public async Task Users_idFollowingGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/following";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get friends
		/// #### &#128275; OAuth Optional &#10024; Extended Info
		/// 
		/// Returns all friends for a user including when the relationship began. Friendship is a 2 way relationship where each user follows the other.
		/// Users_idFriendsGet users/{id}/friends
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>OK</returns>
		public async Task Users_idFriendsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/friends";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get watched history
		/// #### &#128275; OAuth Optional &#128196; Pagination &#10024; Extended Info
		/// 
		/// Returns movies and episodes that a user has watched, sorted by most recent. You can optionally limit the `type` to `movies` or `episodes`. The `id` _(64-bit integer)_ in each history item uniquely identifies the event and can be used to remove individual events by using the [**/sync/history/remove**](#reference/sync/remove-from-history/get-watched-history) method. The `action` will be set to `scrobble`, `checkin`, or `watch`.
		/// 
		/// Specify a `type` and trakt `item_id` to limit the history for just that item. If the `item_id` is valid, but there is no history, an empty array will be returned.
		/// 
		/// | Example URL | Returns watches for... |
		/// |---|---|
		/// | `/history/movies/12601` | TRON: Legacy |
		/// | `/history/shows/1388` | All episodes of Breaking Bad |
		/// | `/history/seasons/3950` | All episodes of Breaking Bad: Season 1 |
		/// | `/history/episodes/73482` | Only episode 1 for Breaking Bad: Season 1 |
		/// Users_idHistory_type_item_idGetByStart_atAndEnd_at users/{id}/history/{type}/{item_id}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="item_id">Trakt ID for a specific item.</param>
		/// <param name="start_at">Starting date.</param>
		/// <param name="end_at">Ending date.</param>
		/// <returns>```
		/// /users/sean/history/episodes
		///```</returns>
		public async Task Users_idHistory_type_item_idGetByStart_atAndEnd_atAsync(string id, SyncHistory_type_idGetByStart_atAndEnd_atType type, int item_id, string start_at, string end_at, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/history/"+type+"/"+item_id+"&start_at=" + (start_at==null? "" : System.Uri.EscapeDataString(start_at))+"&end_at=" + (end_at==null? "" : System.Uri.EscapeDataString(end_at));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get likes
		/// #### &#128274; OAuth Optional &#128196; Pagination
		/// 
		/// Get items a user likes. This will return an array of standard media objects. You can optionally limit the `type` of results to return.
		/// 
		/// #### Comment Media Objects
		/// 
		/// If you add `?extended=comments` to the URL, it will return media objects for each comment like.
		/// 
		/// **Note:** This returns a lot of data, so please only use this extended parameter if you actually need it!
		/// Users_idLikes_typeGet users/{id}/likes/{type}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>```
		/// /users/sean/likes/lists
		///```</returns>
		public async Task Users_idLikes_typeGetAsync(string id, Users_idLikes_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/likes/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a user's personal lists
		/// #### &#128275; OAuth Optional &#128513; Emojis
		/// 
		/// Returns all personal lists for a user. Use the [**/users/:id/lists/:list_id/items**](#reference/users/list-items) method to get the actual items a specific list contains.
		/// Users_idListsGet users/{id}/lists
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>OK</returns>
		public async Task Users_idListsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create personal list
		/// #### &#128274; OAuth Required 🔥 VIP Enhanced
		/// 
		/// Create a new personal list. The `name` is the only required field, but the other info is recommended to ask for.
		/// 
		/// #### Limits
		/// 
		/// If the user's list limit is exceeded, a `420` HTTP error code is returned. Use the [**/users/settings**](/reference/users/settings) method to get all limits for a user account. In most cases, upgrading to [**Trakt VIP**](https://trakt.tv/vip) will increase the limits.
		/// 
		/// #### Privacy
		/// 
		/// Lists will be `private` by default. Here is what each value means.
		/// 
		/// | Value | Privacy impact... |
		/// |---|---|
		/// | `private` | Only you can see the list. |
		/// | `link` | Anyone with the `share_link` can see the list. |
		/// | `friends` | Only your friends can see the list. |
		/// | `public` | Anyone can see the list. |
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Default | Value |
		/// |---|---|---|---|
		/// | `name` <span style="color:red;">*</a> | string |  | Name of the list. |
		/// | `description` | string |  | Description for this list. |
		/// | `privacy` | string | `private` | `private`, `link`, `friends`, `public` |
		/// | `display_numbers` | boolean | `false` | Should each item be numbered? |
		/// | `allow_comments` | boolean | `true` | Are comments allowed? |
		/// | `sort_by` | string | `rank` | `rank`, `added`, `title`, `released`, `runtime`, `popularity`, `percentage`, `votes`, `my_rating`, `random`, `watched`, `collected` |
		/// | `sort_how` | string | `asc` | `asc`, `desc` |
		/// Users_idListsPost users/{id}/lists
		/// </summary>
		/// <param name="id">Automatically added</param>
		public async Task Users_idListsPostAsync(string id, Users_idListsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all lists a user can collaborate on
		/// #### &#128275; OAuth Optional
		/// 
		/// Returns all lists a user can collaborate on. This gives full access to add, remove, and re-order list items. It essentially works just like a list owned by the user, just make sure to use the correct list owner `user` when building the API URLs.
		/// Users_idListsCollaborationsGet users/{id}/lists/collaborations
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>OK</returns>
		public async Task Users_idListsCollaborationsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/collaborations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reorder a user's lists
		/// #### &#128274; OAuth Required
		/// 
		/// Reorder all lists by sending the updated `rank` of list ids. Use the [**/users/:id/lists**](#reference/users/lists) method to get all list ids.
		/// Users_idListsReorderPost users/{id}/lists/reorder
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>OK</returns>
		public async Task Users_idListsReorderPostAsync(string id, Users_idListsReorderPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/reorder";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a user's personal list
		/// #### &#128274; OAuth Required
		/// 
		/// Remove a personal list and all items it contains.
		/// Users_idLists_list_idDelete users/{id}/lists/{list_id}
		/// </summary>
		/// <param name="id">Automatically added</param>
		/// <param name="list_id">Automatically added</param>
		public async Task Users_idLists_list_idDeleteAsync(string id, string list_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get personal list
		/// #### &#128275; OAuth Optional &#128513; Emojis
		/// 
		/// Returns a single personal list. Use the [**/users/:id/lists/:list_id/items**](#reference/users/list-items) method to get the actual items this list contains.
		/// Users_idLists_list_idGet users/{id}/lists/{list_id}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="list_id">Trakt ID or Trakt slug</param>
		/// <returns>OK</returns>
		public async Task Users_idLists_list_idGetAsync(string id, string list_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update personal list
		/// #### &#128274; OAuth Required
		/// 
		/// Update a personal list by sending 1 or more parameters. If you update the list name, the original slug will still be retained so existing references to this list won't break.
		/// 
		/// #### Privacy
		/// 
		/// Lists will be `private` by default. Here is what each value means.
		/// 
		/// | Value | Privacy impact... |
		/// |---|---|
		/// | `private` | Only you can see the list. |
		/// | `link` | Anyone with the `share_link` can see the list. |
		/// | `friends` | Only your friends can see the list. |
		/// | `public` | Anyone can see the list. |
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|---|
		/// | `name` | string | Name of the list. |
		/// | `description` | string | Description for this list. |
		/// | `privacy` | string | `private`, `link`, `friends`, `public` |
		/// | `display_numbers` | boolean | Should each item be numbered? |
		/// | `allow_comments` | boolean | Are comments allowed? |
		/// | `sort_by` | string | `rank`, `added`, `title`, `released`, `runtime`, `popularity`, `percentage`, `votes`, `my_rating`, `random`, `watched`, `collected` |
		/// | `sort_how` | string | `asc`, `desc` |
		/// Users_idLists_list_idPut users/{id}/lists/{list_id}
		/// </summary>
		/// <param name="id">Automatically added</param>
		/// <param name="list_id">Automatically added</param>
		/// <returns>OK</returns>
		public async Task Users_idLists_list_idPutAsync(string id, string list_id, Users_idLists_list_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all list comments
		/// #### &#128275; OAuth Optional &#128196; Pagination &#128513; Emojis
		/// 
		/// Returns all top level comments for a list. By default, the `newest` comments are returned first. Other sorting options include `oldest`, most `likes`, and most `replies`.
		/// Users_idLists_list_idComments_sortGet users/{id}/lists/{list_id}/comments/{sort}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="list_id">Trakt ID or Trakt slug</param>
		/// <param name="sort">how to sort</param>
		/// <returns>OK</returns>
		public async Task Users_idLists_list_idComments_sortGetAsync(string id, string list_id, Lists_idComments_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id))+"/comments/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add items to personal list
		/// #### &#128274; OAuth Required &#128513; Emojis 🔥 VIP Enhanced
		/// 
		/// Add one or more items to a personal list. Items can be movies, shows, seasons, episodes, or people.
		/// 
		/// #### Notes
		/// 
		/// Each list item can optionally accept a `notes` *(255 maximum characters)* field with custom text. The user must be a [**Trakt VIP**](https://trakt.tv/vip) to send `notes`.
		/// 
		/// #### Limits
		/// 
		/// If the user's list item limit is exceeded, a `420` HTTP error code is returned. Use the [**/users/settings**](/reference/users/settings) method to get all limits for a user account. In most cases, upgrading to [**Trakt VIP**](https://trakt.tv/vip) will increase the limits.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `episodes` | array | Array of `episode` objects. |
		/// | `people` | array | Array of `person` objects. |
		/// Users_idLists_list_idItemsPost users/{id}/lists/{list_id}/items
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="list_id">Trakt ID or Trakt slug</param>
		public async Task Users_idLists_list_idItemsPostAsync(string id, string list_id, Users_idLists_list_idItemsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id))+"/items";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove items from personal list
		/// #### &#128274; OAuth Required
		/// 
		/// Remove one or more items from a personal list.
		/// 
		/// #### JSON POST Data
		/// 
		/// | Key | Type | Value |
		/// |---|---|---|
		/// | `movies` | array | Array of `movie` objects. (see examples &#8594;) |
		/// | `shows` | array | Array of `show` objects. |
		/// | `seasons` | array | Array of `season` objects. |
		/// | `episodes` | array | Array of `episode` objects. |
		/// | `people` | array | Array of `person` objects. |
		/// Users_idLists_list_idItemsRemovePost users/{id}/lists/{list_id}/items/remove
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="list_id">Trakt ID or Trakt slug</param>
		/// <returns>OK</returns>
		public async Task Users_idLists_list_idItemsRemovePostAsync(string id, string list_id, Users_idLists_list_idItemsRemovePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id))+"/items/remove";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reorder items on a list
		/// #### &#128274; OAuth Required
		/// 
		/// Reorder all items on a list by sending the updated `rank` of list item ids. Use the [**/users/:id/lists/:list_id/items**](#reference/users/list-items) method to get all list item ids.
		/// Users_idLists_list_idItemsReorderPost users/{id}/lists/{list_id}/items/reorder
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="list_id">Trakt ID or Trakt slug</param>
		/// <returns>OK</returns>
		public async Task Users_idLists_list_idItemsReorderPostAsync(string id, string list_id, Reorder_watchlist_itemsBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id))+"/items/reorder";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get items on a personal list
		/// #### &#128275; OAuth Optional &#128196; Pagination Optional &#10024; Extended Info &#128513; Emojis
		/// 
		/// Get all items on a personal list. Items can be a `movie`, `show`, `season`, `episode`, or `person`. You can optionally specify the `type` parameter with a single value or comma delimited string for multiple item types.
		/// 
		/// #### Notes
		/// 
		/// Each list item contains a `notes` field with text entered by the user.
		/// 
		/// #### Sorting Headers
		/// 
		/// All list items are sorted by ascending `rank`. We also send `X-Sort-By` and `X-Sort-How` headers which can be used to custom sort the list _**in your app**_ based on the user's preference. Values for `X-Sort-By` include `rank`, `added`, `title`, `released`, `runtime`, `popularity`, `percentage`, `votes`, `my_rating`, `random`, `watched`, and `collected`. Values for `X-Sort-How` include `asc` and `desc`.
		/// Users_idLists_list_idItems_typeGet users/{id}/lists/{list_id}/items/{type}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="list_id">Trakt ID or Trakt slug</param>
		/// <param name="type">Filter for a specific item type</param>
		/// <returns>OK</returns>
		public async Task Users_idLists_list_idItems_typeGetAsync(string id, string list_id, Lists_idItems_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id))+"/items/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove like on a list
		/// #### &#128274; OAuth Required
		/// 
		/// Remove a like on a list.
		/// Users_idLists_list_idLikeDelete users/{id}/lists/{list_id}/like
		/// </summary>
		/// <param name="id">Automatically added</param>
		/// <param name="list_id">Automatically added</param>
		public async Task Users_idLists_list_idLikeDeleteAsync(string id, string list_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id))+"/like";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Like a list
		/// #### &#128274; OAuth Required
		/// 
		/// Votes help determine popular lists. Only one like is allowed per list per user.
		/// Users_idLists_list_idLikePost users/{id}/lists/{list_id}/like
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="list_id">Trakt ID or Trakt slug</param>
		public async Task Users_idLists_list_idLikePostAsync(string id, string list_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id))+"/like";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all users who liked a list
		/// #### &#128275; OAuth Optional &#128196; Pagination
		/// 
		/// Returns all users who liked a list.
		/// Users_idLists_list_idLikesGet users/{id}/lists/{list_id}/likes
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="list_id">Trakt ID or Trakt slug</param>
		/// <returns>OK</returns>
		public async Task Users_idLists_list_idLikesGetAsync(string id, string list_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/lists/"+ (list_id==null? "" : System.Uri.EscapeDataString(list_id))+"/likes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get ratings
		/// #### &#128275; OAuth Optional &#128196; Pagination Optional &#10024; Extended Info
		/// 
		/// Get a user's ratings filtered by `type`. You can optionally filter for a specific `rating` between 1 and 10. Send a comma separated string for `rating` if you need multiple ratings.
		/// Users_idRatings_type_ratingGet users/{id}/ratings/{type}/{rating}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="rating">Filter for a specific rating.</param>
		/// <returns>```
		/// /users/sean/ratings/episodes
		///```</returns>
		public async Task Users_idRatings_type_ratingGetAsync(string id, SyncRatings_type_ratingGetType type, Users_idRatings_type_ratingGetRating rating, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/ratings/"+type+"/"+rating;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get personal recommendations
		/// #### &#128274; OAuth Required &#128196; Pagination Optional &#10024; Extended Info &#128513; Emojis
		/// 
		/// Returns the top 50 items a user personally recommendeds to others. These recommendations are used to enchance Trakt's social recommendation algorithm. Apps should encourage user's to build their personal recommendations so the algorithm keeps getting better.
		/// 
		/// #### Notes
		/// 
		/// Each recommendation contains a `notes` field explaining why the user recommended the item.
		/// Users_idRecommendations_type_sortGet users/{id}/recommendations/{type}/{sort}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="type">Filter for a specific item type</param>
		/// <param name="sort">How to sort (only if type is also sent)</param>
		/// <returns>```
		/// /users/justin/recommendations/shows
		///```</returns>
		public async Task Users_idRecommendations_type_sortGetAsync(string id, Certifications_typeGetType type, SyncRecommendations_type_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/recommendations/"+type+"/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get stats
		/// #### &#128275; OAuth Optional
		/// 
		/// Returns stats about the movies, shows, and episodes a user has watched, collected, and rated.
		/// Users_idStatsGet users/{id}/stats
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>OK</returns>
		public async Task Users_idStatsGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/stats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get watched
		/// #### &#128275; OAuth Optional &#10024; Extended Info
		/// 
		/// Returns all movies or shows a user has watched sorted by most plays.
		/// 
		/// If `type` is set to _shows_ and you add `?extended=noseasons` to the URL, it won't return season or episode info.
		/// 
		/// Each `movie` and `show` object contains `last_watched_at` and `last_updated_at` timestamps. Since users can set custom dates when they watched movies and episodes, it is possible for `last_watched_at` to be in the past. We also include `last_updated_at` to help sync Trakt data with your app. Cache this timestamp locally and only re-process the movies and shows if you see a newer timestamp.
		/// 
		/// Each `show` object contains a `reset_at` timestamp. If not `null`, this is when the user started re-watching the show. Your app can adjust the progress by ignoring episodes with a `last_watched_at` prior to the `reset_at`.
		/// Users_idWatched_typeGet users/{id}/watched/{type}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>```
		/// /users/sean/watched/shows?extended=noseasons
		///```</returns>
		public async Task Users_idWatched_typeGetAsync(string id, Certifications_typeGetType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/watched/"+type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get watching
		/// #### &#128275; OAuth Optional &#10024; Extended Info
		/// 
		/// Returns a movie or episode if the user is currently watching something.  If they are not, it returns no data and a `204` HTTP status code.
		/// Users_idWatchingGet users/{id}/watching
		/// </summary>
		/// <param name="id">User slug</param>
		/// <returns>Currently watching a `movie`.</returns>
		public async Task Users_idWatchingGetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/watching";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get watchlist
		/// #### &#128275; OAuth Optional &#128196; Pagination Optional &#10024; Extended Info &#128513; Emojis
		/// 
		/// Returns all items in a user's watchlist filtered by type.
		/// 
		/// #### Notes
		/// 
		/// Each watchlist item contains a `notes` field with text entered by the user.
		/// 
		/// #### Sorting Headers
		/// 
		/// By default, all list items are sorted by `rank` `asc`. We send `X-Applied-Sort-By` and `X-Applied-Sort-How` headers to indicate how the results are actually being sorted.
		/// 
		/// We also send `X-Sort-By` and `X-Sort-How` headers which indicate the user's sort preference. Use these to to custom sort the watchlist _**in your app**_ for more advanced sort abilities we can't do in the API. Values for `X-Sort-By` include `rank`, `added`, `title`, `released`, `runtime`, `popularity`, `percentage`, and `votes`. Values for `X-Sort-How` include `asc` and `desc`.
		/// 
		/// #### Auto Removal
		/// 
		/// When an item is watched, it will be automatically removed from the watchlist. For shows and seasons, watching 1 episode will remove the entire show or season.
		/// 
		/// _**The watchlist should not be used as a list of what the user is actively watching.**_
		/// 
		/// Use a combination of the [**/sync/watched**](/reference/sync/get-watched) and [**/shows/:id/progress**](/reference/shows/watched-progress) methods to get what the user is actively watching.
		/// Users_idWatchlist_type_sortGet users/{id}/watchlist/{type}/{sort}
		/// </summary>
		/// <param name="id">User slug</param>
		/// <param name="type">Filter for a specific item type</param>
		/// <param name="sort">How to sort (only if type is also sent)</param>
		/// <returns>```
		/// /users/sean/watchlist/episodes
		///```</returns>
		public async Task Users_idWatchlist_type_sortGetAsync(string id, SyncHistory_type_idGetByStart_atAndEnd_atType type, SyncRecommendations_type_sortGetSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/watchlist/"+type+"/"+sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Certifications_typeGetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movies = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		shows = 1,
	}
	
	public class CheckinPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="app_date")]
		public string App_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="app_version")]
		public string App_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movie")]
		public CheckinPostPostBodyMovie Movie { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sharing")]
		public CheckinPostPostBodySharing Sharing { get; set; }
	}
	
	public class CheckinPostPostBodyMovie
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public CheckinPostPostBodyMovieIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class CheckinPostPostBodyMovieIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class CheckinPostPostBodySharing
	{
		
		[System.Runtime.Serialization.DataMember(Name="mastodon")]
		public System.Nullable<System.Boolean> Mastodon { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tumblr")]
		public System.Nullable<System.Boolean> Tumblr { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="twitter")]
		public System.Nullable<System.Boolean> Twitter { get; set; }
	}
	
	public class CommentsPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movie")]
		public CommentsPostPostBodyMovie Movie { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sharing")]
		public CommentsPostPostBodySharing Sharing { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="spoiler")]
		public System.Nullable<System.Boolean> Spoiler { get; set; }
	}
	
	public class CommentsPostPostBodyMovie
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public CommentsPostPostBodyMovieIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class CommentsPostPostBodyMovieIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class CommentsPostPostBodySharing
	{
		
		[System.Runtime.Serialization.DataMember(Name="medium")]
		public System.Nullable<System.Boolean> Medium { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tumblr")]
		public System.Nullable<System.Boolean> Tumblr { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="twitter")]
		public System.Nullable<System.Boolean> Twitter { get; set; }
	}
	
	public enum CommentsRecent_comment_type_typeGetByInclude_repliesComment_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reviews = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		shouts = 2,
	}
	
	public enum CommentsRecent_comment_type_typeGetByInclude_repliesType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movies = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		shows = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		seasons = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		episodes = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lists = 5,
	}
	
	public class Comments_idPutPutBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="spoiler")]
		public System.Nullable<System.Boolean> Spoiler { get; set; }
	}
	
	public class Comments_idRepliesPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="spoiler")]
		public System.Nullable<System.Boolean> Spoiler { get; set; }
	}
	
	public enum Lists_idComments_sortGetSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		newest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		oldest = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		likes = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		replies = 3,
	}
	
	public enum Lists_idItems_typeGetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movie = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		season = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		episode = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		person = 4,
	}
	
	public enum MoviesCollected_periodGetPeriod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		daily = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		weekly = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		monthly = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		yearly = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 4,
	}
	
	public enum Movies_idComments_sortGetSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		newest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		oldest = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		likes = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		replies = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		highest = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lowest = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		plays = 6,
	}
	
	public enum Movies_idLists_type_sortGetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		personal = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		official = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		watchlists = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recommendations = 4,
	}
	
	public enum Movies_idLists_type_sortGetSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		popular = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		likes = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		comments = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		items = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		added = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		updated = 5,
	}
	
	public class OauthDeviceCodePostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
	}
	
	public class OauthDeviceTokenPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		public string Client_secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
	}
	
	public class OauthRevokePostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		public string Client_secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
	}
	
	public class OauthTokenPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		public string Client_secret { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="grant_type")]
		public string Grant_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="redirect_uri")]
		public string Redirect_uri { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="refresh_token")]
		public string Refresh_token { get; set; }
	}
	
	public enum People_idLists_type_sortGetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		personal = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		official = 2,
	}
	
	public enum RecommendationsMoviesGetByIgnore_collectedAndIgnore_watchlistedIgnore_collected
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="true")]
		_true = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false")]
		_false = 1,
	}
	
	public enum RecommendationsMoviesGetByIgnore_collectedAndIgnore_watchlistedIgnore_watchlisted
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="true")]
		_true = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false")]
		_false = 1,
	}
	
	public enum RecommendationsShowsGetByIgnore_collectedAndIgnore_watchlistedIgnore_collected
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="true")]
		_true = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false")]
		_false = 1,
	}
	
	public enum RecommendationsShowsGetByIgnore_collectedAndIgnore_watchlistedIgnore_watchlisted
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="true")]
		_true = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false")]
		_false = 1,
	}
	
	public class ScrobblePausePostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="app_date")]
		public string App_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="app_version")]
		public string App_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movie")]
		public ScrobblePausePostPostBodyMovie Movie { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public System.Nullable<System.Double> Progress { get; set; }
	}
	
	public class ScrobblePausePostPostBodyMovie
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public ScrobblePausePostPostBodyMovieIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class ScrobblePausePostPostBodyMovieIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class ScrobbleStartPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="app_date")]
		public string App_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="app_version")]
		public string App_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movie")]
		public ScrobbleStartPostPostBodyMovie Movie { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public System.Nullable<System.Double> Progress { get; set; }
	}
	
	public class ScrobbleStartPostPostBodyMovie
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public ScrobbleStartPostPostBodyMovieIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class ScrobbleStartPostPostBodyMovieIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class ScrobbleStopPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="app_date")]
		public string App_date { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="app_version")]
		public string App_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movie")]
		public ScrobbleStopPostPostBodyMovie Movie { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public System.Nullable<System.Double> Progress { get; set; }
	}
	
	public class ScrobbleStopPostPostBodyMovie
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public ScrobbleStopPostPostBodyMovieIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class ScrobbleStopPostPostBodyMovieIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public enum Search_id_type_idGetByTypeId_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		trakt = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		imdb = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tmdb = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tvdb = 3,
	}
	
	public enum Search_id_type_idGetByTypeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movie = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		episode = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		person = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		list = 4,
	}
	
	public enum Shows_idComments_sortGetSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		newest = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		oldest = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		likes = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		replies = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		highest = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lowest = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		plays = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		watched = 7,
	}
	
	public enum Shows_idSeasons_seasonEpisodes_episodeLists_type_sortGetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		personal = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		official = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		watchlists = 3,
	}
	
	public class SyncCollectionPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SyncCollectionPostPostBodyEpisodes[] SyncCollectionPostPostBodyEpisodes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public SyncCollectionPostPostBodyMovies[] SyncCollectionPostPostBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SyncCollectionPostPostBodySeasons[] SyncCollectionPostPostBodySeasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public SyncCollectionPostPostBodyShows[] SyncCollectionPostPostBodyShows { get; set; }
	}
	
	public class SyncCollectionPostPostBodyEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncCollectionPostPostBodyEpisodesIds Ids { get; set; }
	}
	
	public class SyncCollectionPostPostBodyEpisodesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncCollectionPostPostBodyMovies
	{
		
		[System.Runtime.Serialization.DataMember(Name="audio")]
		public string Audio { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="audio_channels")]
		public string Audio_channels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="collected_at")]
		public string Collected_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hdr")]
		public string Hdr { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncCollectionPostPostBodyMoviesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="media_type")]
		public string Media_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public string Resolution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class SyncCollectionPostPostBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class SyncCollectionPostPostBodySeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncCollectionPostPostBodySeasonsIds Ids { get; set; }
	}
	
	public class SyncCollectionPostPostBodySeasonsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncCollectionPostPostBodyShows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncCollectionPostPostBodyShowsIds Ids { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SyncCollectionPostPostBodyShowsSeasons[] SyncCollectionPostPostBodyShowsSeasons { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="year")]
		public double Year { get; set; }
	}
	
	public class SyncCollectionPostPostBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncCollectionPostPostBodyShowsSeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SyncCollectionPostPostBodyShowsSeasonsEpisodes[] SyncCollectionPostPostBodyShowsSeasonsEpisodes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	public class SyncCollectionPostPostBodyShowsSeasonsEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="audio")]
		public string Audio { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="audio_channels")]
		public string Audio_channels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="media_type")]
		public string Media_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resolution")]
		public string Resolution { get; set; }
	}
	
	public class SyncHistoryPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SyncHistoryPostPostBodyEpisodes[] SyncHistoryPostPostBodyEpisodes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public SyncHistoryPostPostBodyMovies[] SyncHistoryPostPostBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SyncHistoryPostPostBodySeasons[] SyncHistoryPostPostBodySeasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public SyncHistoryPostPostBodyShows[] SyncHistoryPostPostBodyShows { get; set; }
	}
	
	public class SyncHistoryPostPostBodyEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncHistoryPostPostBodyEpisodesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="watched_at")]
		public string Watched_at { get; set; }
	}
	
	public class SyncHistoryPostPostBodyEpisodesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncHistoryPostPostBodyMovies
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncHistoryPostPostBodyMoviesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="watched_at")]
		public string Watched_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class SyncHistoryPostPostBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class SyncHistoryPostPostBodySeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncHistoryPostPostBodySeasonsIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="watched_at")]
		public string Watched_at { get; set; }
	}
	
	public class SyncHistoryPostPostBodySeasonsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncHistoryPostPostBodyShows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncHistoryPostPostBodyShowsIds Ids { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SyncHistoryPostPostBodyShowsSeasons[] SyncHistoryPostPostBodyShowsSeasons { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="year")]
		public double Year { get; set; }
	}
	
	public class SyncHistoryPostPostBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncHistoryPostPostBodyShowsSeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SyncHistoryPostPostBodyShowsSeasonsEpisodes[] SyncHistoryPostPostBodyShowsSeasonsEpisodes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="watched_at")]
		public string Watched_at { get; set; }
	}
	
	public class SyncHistoryPostPostBodyShowsSeasonsEpisodes
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="watched_at")]
		public string Watched_at { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SyncHistoryRemovePostPostBodyEpisodes[] SyncHistoryRemovePostPostBodyEpisodes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public double[] Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public SyncHistoryRemovePostPostBodyMovies[] SyncHistoryRemovePostPostBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SyncHistoryRemovePostPostBodySeasons[] SyncHistoryRemovePostPostBodySeasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public SyncHistoryRemovePostPostBodyShows[] SyncHistoryRemovePostPostBodyShows { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBodyEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncHistoryRemovePostPostBodyEpisodesIds Ids { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBodyEpisodesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBodyMovies
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncHistoryRemovePostPostBodyMoviesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBodySeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncHistoryRemovePostPostBodySeasonsIds Ids { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBodySeasonsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBodyShows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncHistoryRemovePostPostBodyShowsIds Ids { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SyncHistoryRemovePostPostBodyShowsSeasons[] SyncHistoryRemovePostPostBodyShowsSeasons { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="year")]
		public double Year { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBodyShowsSeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SyncHistoryRemovePostPostBodyShowsSeasonsEpisodes[] SyncHistoryRemovePostPostBodyShowsSeasonsEpisodes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	public class SyncHistoryRemovePostPostBodyShowsSeasonsEpisodes
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	public enum SyncHistory_type_idGetByStart_atAndEnd_atType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movies = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		shows = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		seasons = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		episodes = 3,
	}
	
	public enum SyncPlayback_typeGetByStart_atAndEnd_atType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movies = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		episodes = 1,
	}
	
	public class SyncRatingsPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SyncRatingsPostPostBodyEpisodes[] SyncRatingsPostPostBodyEpisodes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public SyncRatingsPostPostBodyMovies[] SyncRatingsPostPostBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SyncRatingsPostPostBodySeasons[] SyncRatingsPostPostBodySeasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public SyncRatingsPostPostBodyShows[] SyncRatingsPostPostBodyShows { get; set; }
	}
	
	public class SyncRatingsPostPostBodyEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncRatingsPostPostBodyEpisodesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rating")]
		public System.Nullable<System.Double> Rating { get; set; }
	}
	
	public class SyncRatingsPostPostBodyEpisodesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncRatingsPostPostBodyMovies
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncRatingsPostPostBodyMoviesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rated_at")]
		public string Rated_at { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rating")]
		public double Rating { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class SyncRatingsPostPostBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class SyncRatingsPostPostBodySeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncRatingsPostPostBodySeasonsIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rating")]
		public System.Nullable<System.Double> Rating { get; set; }
	}
	
	public class SyncRatingsPostPostBodySeasonsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncRatingsPostPostBodyShows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncRatingsPostPostBodyShowsIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rating")]
		public System.Nullable<System.Double> Rating { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SyncRatingsPostPostBodyShowsSeasons[] SyncRatingsPostPostBodyShowsSeasons { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="year")]
		public double Year { get; set; }
	}
	
	public class SyncRatingsPostPostBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncRatingsPostPostBodyShowsSeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SyncRatingsPostPostBodyShowsSeasonsEpisodes[] SyncRatingsPostPostBodyShowsSeasonsEpisodes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rating")]
		public System.Nullable<System.Double> Rating { get; set; }
	}
	
	public class SyncRatingsPostPostBodyShowsSeasonsEpisodes
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rating")]
		public double Rating { get; set; }
	}
	
	public enum SyncRatings_type_ratingGetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movies = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		shows = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		seasons = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		episodes = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 4,
	}
	
	public enum SyncRatings_type_ratingGetRating
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1")]
		_1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3")]
		_3 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4")]
		_4 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="7")]
		_7 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8")]
		_8 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="9")]
		_9 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10")]
		_10 = 9,
	}
	
	public class SyncRecommendationsPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public SyncRecommendationsPostPostBodyMovies[] SyncRecommendationsPostPostBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public SyncRecommendationsPostPostBodyShows[] SyncRecommendationsPostPostBodyShows { get; set; }
	}
	
	public class SyncRecommendationsPostPostBodyMovies
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncRecommendationsPostPostBodyMoviesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class SyncRecommendationsPostPostBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class SyncRecommendationsPostPostBodyShows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncRecommendationsPostPostBodyShowsIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="year")]
		public double Year { get; set; }
	}
	
	public class SyncRecommendationsPostPostBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncRecommendationsRemovePostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public SyncRecommendationsRemovePostPostBodyMovies[] SyncRecommendationsRemovePostPostBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public SyncRecommendationsRemovePostPostBodyShows[] SyncRecommendationsRemovePostPostBodyShows { get; set; }
	}
	
	public class SyncRecommendationsRemovePostPostBodyMovies
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncRecommendationsRemovePostPostBodyMoviesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class SyncRecommendationsRemovePostPostBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class SyncRecommendationsRemovePostPostBodyShows
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncRecommendationsRemovePostPostBodyShowsIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class SyncRecommendationsRemovePostPostBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public enum SyncRecommendations_type_sortGetSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		rank = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		added = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		released = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		title = 3,
	}
	
	public class SyncWatchlistPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SyncWatchlistPostPostBodyEpisodes[] SyncWatchlistPostPostBodyEpisodes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public SyncWatchlistPostPostBodyMovies[] SyncWatchlistPostPostBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SyncWatchlistPostPostBodySeasons[] SyncWatchlistPostPostBodySeasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public SyncWatchlistPostPostBodyShows[] SyncWatchlistPostPostBodyShows { get; set; }
	}
	
	public class SyncWatchlistPostPostBodyEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncWatchlistPostPostBodyEpisodesIds Ids { get; set; }
	}
	
	public class SyncWatchlistPostPostBodyEpisodesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncWatchlistPostPostBodyMovies
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncWatchlistPostPostBodyMoviesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="year")]
		public System.Nullable<System.Double> Year { get; set; }
	}
	
	public class SyncWatchlistPostPostBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class SyncWatchlistPostPostBodySeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncWatchlistPostPostBodySeasonsIds Ids { get; set; }
	}
	
	public class SyncWatchlistPostPostBodySeasonsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncWatchlistPostPostBodyShows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public SyncWatchlistPostPostBodyShowsIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public SyncWatchlistPostPostBodyShowsSeasons[] SyncWatchlistPostPostBodyShowsSeasons { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="year")]
		public double Year { get; set; }
	}
	
	public class SyncWatchlistPostPostBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class SyncWatchlistPostPostBodyShowsSeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public SyncWatchlistPostPostBodyShowsSeasonsEpisodes[] SyncWatchlistPostPostBodyShowsSeasonsEpisodes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	public class SyncWatchlistPostPostBodyShowsSeasonsEpisodes
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	public enum UsersHidden_sectionGetByTypeSection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		calendar = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		progress_watched = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		progress_watched_reset = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		progress_collected = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recommendations = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		comments = 5,
	}
	
	public enum UsersHidden_sectionGetByTypeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movie = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		show = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		season = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user = 3,
	}
	
	public enum UsersHidden_sectionPostSection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		calendar = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		progress_watched = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		progress_collected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recommendations = 3,
	}
	
	public enum UsersHidden_sectionRemovePostSection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		calendar = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		progress_watched = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		progress_collected = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		recommendations = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		comments = 4,
	}
	
	public enum UsersSaved_filters_sectionGetSection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		movies = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		shows = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		calendars = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		search = 3,
	}
	
	public enum Users_idComments_comment_type_typeGetByInclude_repliesInclude_replies
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="true")]
		_true = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false")]
		_false = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		only = 2,
	}
	
	public enum Users_idLikes_typeGetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		comments = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		lists = 1,
	}
	
	public class Users_idListsPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="allow_comments")]
		public System.Nullable<System.Boolean> Allow_comments { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="display_numbers")]
		public System.Nullable<System.Boolean> Display_numbers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public string Privacy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sort_by")]
		public string Sort_by { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sort_how")]
		public string Sort_how { get; set; }
	}
	
	public class Users_idListsReorderPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="rank")]
		public double[] Rank { get; set; }
	}
	
	public class Users_idLists_list_idPutPutBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="display_numbers")]
		public System.Nullable<System.Boolean> Display_numbers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public string Privacy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sort_by")]
		public string Sort_by { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sort_how")]
		public string Sort_how { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public Users_idLists_list_idItemsPostPostBodyEpisodes[] Users_idLists_list_idItemsPostPostBodyEpisodes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public Users_idLists_list_idItemsPostPostBodyMovies[] Users_idLists_list_idItemsPostPostBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="people")]
		public Users_idLists_list_idItemsPostPostBodyPeople[] Users_idLists_list_idItemsPostPostBodyPeople { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public Users_idLists_list_idItemsPostPostBodySeasons[] Users_idLists_list_idItemsPostPostBodySeasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public Users_idLists_list_idItemsPostPostBodyShows[] Users_idLists_list_idItemsPostPostBodyShows { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodyEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Users_idLists_list_idItemsPostPostBodyEpisodesIds Ids { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodyEpisodesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodyMovies
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Users_idLists_list_idItemsPostPostBodyMoviesIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodyPeople
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Users_idLists_list_idItemsPostPostBodyPeopleIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodyPeopleIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodySeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Users_idLists_list_idItemsPostPostBodySeasonsIds Ids { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodySeasonsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodyShows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Users_idLists_list_idItemsPostPostBodyShowsIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public Users_idLists_list_idItemsPostPostBodyShowsSeasons[] Users_idLists_list_idItemsPostPostBodyShowsSeasons { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodyShowsSeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public Users_idLists_list_idItemsPostPostBodyShowsSeasonsEpisodes[] Users_idLists_list_idItemsPostPostBodyShowsSeasonsEpisodes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	public class Users_idLists_list_idItemsPostPostBodyShowsSeasonsEpisodes
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public Users_idLists_list_idItemsRemovePostPostBodyEpisodes[] Users_idLists_list_idItemsRemovePostPostBodyEpisodes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="movies")]
		public Users_idLists_list_idItemsRemovePostPostBodyMovies[] Users_idLists_list_idItemsRemovePostPostBodyMovies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="people")]
		public Users_idLists_list_idItemsRemovePostPostBodyPeople[] Users_idLists_list_idItemsRemovePostPostBodyPeople { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public Users_idLists_list_idItemsRemovePostPostBodySeasons[] Users_idLists_list_idItemsRemovePostPostBodySeasons { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="shows")]
		public Users_idLists_list_idItemsRemovePostPostBodyShows[] Users_idLists_list_idItemsRemovePostPostBodyShows { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodyEpisodes
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Users_idLists_list_idItemsRemovePostPostBodyEpisodesIds Ids { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodyEpisodesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodyMovies
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Users_idLists_list_idItemsRemovePostPostBodyMoviesIds Ids { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodyMoviesIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodyPeople
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Users_idLists_list_idItemsRemovePostPostBodyPeopleIds Ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodyPeopleIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="imdb")]
		public string Imdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodySeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Users_idLists_list_idItemsRemovePostPostBodySeasonsIds Ids { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodySeasonsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="tmdb")]
		public System.Nullable<System.Double> Tmdb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tvdb")]
		public System.Nullable<System.Double> Tvdb { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodyShows
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ids")]
		public Users_idLists_list_idItemsRemovePostPostBodyShowsIds Ids { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="seasons")]
		public Users_idLists_list_idItemsRemovePostPostBodyShowsSeasons[] Users_idLists_list_idItemsRemovePostPostBodyShowsSeasons { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodyShowsIds
	{
		
		[System.Runtime.Serialization.DataMember(Name="trakt")]
		public System.Nullable<System.Double> Trakt { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodyShowsSeasons
	{
		
		[System.Runtime.Serialization.DataMember(Name="episodes")]
		public Users_idLists_list_idItemsRemovePostPostBodyShowsSeasonsEpisodes[] Users_idLists_list_idItemsRemovePostPostBodyShowsSeasonsEpisodes { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	public class Users_idLists_list_idItemsRemovePostPostBodyShowsSeasonsEpisodes
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="number")]
		public double Number { get; set; }
	}
	
	public enum Users_idRatings_type_ratingGetRating
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="1")]
		_1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="2")]
		_2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="3")]
		_3 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="4")]
		_4 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="5")]
		_5 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="6")]
		_6 = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="7")]
		_7 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="8")]
		_8 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="9")]
		_9 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="10")]
		_10 = 9,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
