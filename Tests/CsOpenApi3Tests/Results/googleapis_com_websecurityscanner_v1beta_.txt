//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Scan authentication configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Authentication
	{
		
		/// <summary>
		/// Describes authentication configuration that uses a custom account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customAccount")]
		public CustomAccount CustomAccount { get; set; }
		
		/// <summary>
		/// Describes authentication configuration that uses a Google account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="googleAccount")]
		public GoogleAccount GoogleAccount { get; set; }
		
		/// <summary>
		/// Describes authentication configuration for Identity-Aware-Proxy (IAP).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iapCredential")]
		public IapCredential IapCredential { get; set; }
	}
	
	/// <summary>
	/// Describes authentication configuration that uses a custom account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CustomAccount
	{
		
		/// <summary>
		/// Required. The login form URL of the website.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loginUrl")]
		public string LoginUrl { get; set; }
		
		/// <summary>
		/// Required. Input only. The password of the custom account. The credential is stored encrypted and not returned in any response nor included in audit logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Required. The user name of the custom account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Describes authentication configuration that uses a Google account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleAccount
	{
		
		/// <summary>
		/// Required. Input only. The password of the Google account. The credential is stored encrypted and not returned in any response nor included in audit logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Required. The user name of the Google account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Describes authentication configuration for Identity-Aware-Proxy (IAP).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IapCredential
	{
		
		/// <summary>
		/// Describes authentication configuration when Web-Security-Scanner service account is added in Identity-Aware-Proxy (IAP) access policies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iapTestServiceAccountInfo")]
		public IapTestServiceAccountInfo IapTestServiceAccountInfo { get; set; }
	}
	
	/// <summary>
	/// Describes authentication configuration when Web-Security-Scanner service account is added in Identity-Aware-Proxy (IAP) access policies.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IapTestServiceAccountInfo
	{
		
		/// <summary>
		/// Required. Describes OAuth2 Client ID of resources protected by Identity-Aware-Proxy(IAP).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetAudienceClientId")]
		public string TargetAudienceClientId { get; set; }
	}
	
	/// <summary>
	/// A CrawledUrl resource represents a URL that was crawled during a ScanRun. Web Security Scanner Service crawls the web applications, following all links within the scope of sites, to find the URLs to test against.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CrawledUrl
	{
		
		/// <summary>
		/// The body of the request that was used to visit the URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The http method of the request that was used to visit the URL, in uppercase.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpMethod")]
		public string HttpMethod { get; set; }
		
		/// <summary>
		/// The URL that was crawled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Empty
	{
	}
	
	/// <summary>
	/// A Finding resource represents a vulnerability instance identified during a ScanRun.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Finding
	{
		
		/// <summary>
		/// The body of the request that triggered the vulnerability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The description of the vulnerability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The URL where the browser lands when the vulnerability is detected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="finalUrl")]
		public string FinalUrl { get; set; }
		
		/// <summary>
		/// The type of the Finding. Detailed and up-to-date information on findings can be found here: https://cloud.google.com/security-command-center/docs/how-to-remediate-web-security-scanner
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="findingType")]
		public string FindingType { get; set; }
		
		/// <summary>
		/// ! Information about a vulnerability with an HTML.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="form")]
		public Form Form { get; set; }
		
		/// <summary>
		/// If the vulnerability was originated from nested IFrame, the immediate parent IFrame is reported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="frameUrl")]
		public string FrameUrl { get; set; }
		
		/// <summary>
		/// The URL produced by the server-side fuzzer and used in the request that triggered the vulnerability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fuzzedUrl")]
		public string FuzzedUrl { get; set; }
		
		/// <summary>
		/// The http method of the request that triggered the vulnerability, in uppercase.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpMethod")]
		public string HttpMethod { get; set; }
		
		/// <summary>
		/// The resource name of the Finding. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}/scanruns/{scanRunId}/findings/{findingId}'. The finding IDs are generated by the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Information reported for an outdated library.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outdatedLibrary")]
		public OutdatedLibrary OutdatedLibrary { get; set; }
		
		/// <summary>
		/// The URL containing human-readable payload that user can leverage to reproduce the vulnerability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reproductionUrl")]
		public string ReproductionUrl { get; set; }
		
		/// <summary>
		/// The severity level of the reported vulnerability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public System.Nullable<FindingSeverity> Severity { get; set; }
		
		/// <summary>
		/// The tracking ID uniquely identifies a vulnerability instance across multiple ScanRuns.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trackingId")]
		public string TrackingId { get; set; }
		
		/// <summary>
		/// Information regarding any resource causing the vulnerability such as JavaScript sources, image, audio files, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="violatingResource")]
		public ViolatingResource ViolatingResource { get; set; }
		
		/// <summary>
		/// Information about vulnerable or missing HTTP Headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vulnerableHeaders")]
		public VulnerableHeaders VulnerableHeaders { get; set; }
		
		/// <summary>
		/// Information about vulnerable request parameters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vulnerableParameters")]
		public VulnerableParameters VulnerableParameters { get; set; }
		
		/// <summary>
		/// Information reported for an XSS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xss")]
		public Xss Xss { get; set; }
		
		/// <summary>
		/// Information reported for an XXE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xxe")]
		public Xxe Xxe { get; set; }
	}
	
	/// <summary>
	/// ! Information about a vulnerability with an HTML.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Form
	{
		
		/// <summary>
		/// ! The URI where to send the form when it's submitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionUri")]
		public string ActionUri { get; set; }
		
		/// <summary>
		/// ! The names of form fields related to the vulnerability.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public string[] Fields { get; set; }
	}
	
	/// <summary>
	/// Information reported for an outdated library.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OutdatedLibrary
	{
		
		/// <summary>
		/// URLs to learn more information about the vulnerabilities in the library.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="learnMoreUrls")]
		public string[] LearnMoreUrls { get; set; }
		
		/// <summary>
		/// The name of the outdated library.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="libraryName")]
		public string LibraryName { get; set; }
		
		/// <summary>
		/// The version number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FindingSeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEVERITY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CRITICAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIGH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MEDIUM = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOW = 4,
	}
	
	/// <summary>
	/// Information regarding any resource causing the vulnerability such as JavaScript sources, image, audio files, etc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ViolatingResource
	{
		
		/// <summary>
		/// The MIME type of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentType")]
		public string ContentType { get; set; }
		
		/// <summary>
		/// URL of this violating resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceUrl")]
		public string ResourceUrl { get; set; }
	}
	
	/// <summary>
	/// Information about vulnerable or missing HTTP Headers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VulnerableHeaders
	{
		
		/// <summary>
		/// List of vulnerable headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Header[] Headers { get; set; }
		
		/// <summary>
		/// List of missing headers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="missingHeaders")]
		public Header[] MissingHeaders { get; set; }
	}
	
	/// <summary>
	/// Describes a HTTP Header.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Header
	{
		
		/// <summary>
		/// Header name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Header value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Information about vulnerable request parameters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VulnerableParameters
	{
		
		/// <summary>
		/// The vulnerable parameter names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameterNames")]
		public string[] ParameterNames { get; set; }
	}
	
	/// <summary>
	/// Information reported for an XSS.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Xss
	{
		
		/// <summary>
		/// An error message generated by a javascript breakage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorMessage")]
		public string ErrorMessage { get; set; }
		
		/// <summary>
		/// Stack traces leading to the point where the XSS occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackTraces")]
		public string[] StackTraces { get; set; }
	}
	
	/// <summary>
	/// Information reported for an XXE.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Xxe
	{
		
		/// <summary>
		/// Location within the request where the payload was placed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadLocation")]
		public System.Nullable<XxePayloadLocation> PayloadLocation { get; set; }
		
		/// <summary>
		/// The XML string that triggered the XXE vulnerability. Non-payload values might be redacted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadValue")]
		public string PayloadValue { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum XxePayloadLocation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCATION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETE_REQUEST_BODY = 1,
	}
	
	/// <summary>
	/// A FindingTypeStats resource represents stats regarding a specific FindingType of Findings under a given ScanRun.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FindingTypeStats
	{
		
		/// <summary>
		/// The count of findings belonging to this finding type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="findingCount")]
		public System.Nullable<System.Int32> FindingCount { get; set; }
		
		/// <summary>
		/// The finding type associated with the stats.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="findingType")]
		public string FindingType { get; set; }
	}
	
	/// <summary>
	/// Response for the `ListCrawledUrls` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListCrawledUrlsResponse
	{
		
		/// <summary>
		/// The list of CrawledUrls returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="crawledUrls")]
		public CrawledUrl[] CrawledUrls { get; set; }
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Response for the `ListFindingTypeStats` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListFindingTypeStatsResponse
	{
		
		/// <summary>
		/// The list of FindingTypeStats returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="findingTypeStats")]
		public FindingTypeStats[] FindingTypeStats { get; set; }
	}
	
	/// <summary>
	/// Response for the `ListFindings` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListFindingsResponse
	{
		
		/// <summary>
		/// The list of Findings returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="findings")]
		public Finding[] Findings { get; set; }
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Response for the `ListScanConfigs` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListScanConfigsResponse
	{
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of ScanConfigs returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanConfigs")]
		public ScanConfig[] ScanConfigs { get; set; }
	}
	
	/// <summary>
	/// A ScanConfig resource contains the configurations to launch a scan.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScanConfig
	{
		
		/// <summary>
		/// Scan authentication configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public Authentication Authentication { get; set; }
		
		/// <summary>
		/// The excluded URL patterns as described in https://cloud.google.com/security-command-center/docs/how-to-use-web-security-scanner#excluding_urls
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blacklistPatterns")]
		public string[] BlacklistPatterns { get; set; }
		
		/// <summary>
		/// Required. The user provided display name of the ScanConfig.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Controls export of scan configurations and results to Security Command Center.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportToSecurityCommandCenter")]
		public System.Nullable<ScanConfigExportToSecurityCommandCenter> ExportToSecurityCommandCenter { get; set; }
		
		/// <summary>
		/// Whether to keep scanning even if most requests return HTTP error codes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ignoreHttpStatusErrors")]
		public System.Nullable<System.Boolean> IgnoreHttpStatusErrors { get; set; }
		
		/// <summary>
		/// A ScanRun is a output-only resource representing an actual run of the scan. Next id: 12
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latestRun")]
		public ScanRun LatestRun { get; set; }
		
		/// <summary>
		/// Whether the scan config is managed by Web Security Scanner, output only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedScan")]
		public System.Nullable<System.Boolean> ManagedScan { get; set; }
		
		/// <summary>
		/// The maximum QPS during scanning. A valid value ranges from 5 to 20 inclusively. If the field is unspecified or its value is set 0, server will default to 15. Other values outside of [5, 20] range will be rejected with INVALID_ARGUMENT error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxQps")]
		public System.Nullable<System.Int32> MaxQps { get; set; }
		
		/// <summary>
		/// The resource name of the ScanConfig. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}'. The ScanConfig IDs are generated by the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The risk level selected for the scan
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="riskLevel")]
		public System.Nullable<ScanConfigRiskLevel> RiskLevel { get; set; }
		
		/// <summary>
		/// Scan schedule configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public Schedule Schedule { get; set; }
		
		/// <summary>
		/// Required. The starting URLs from which the scanner finds site pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startingUrls")]
		public string[] StartingUrls { get; set; }
		
		/// <summary>
		/// Whether the scan configuration has enabled static IP address scan feature. If enabled, the scanner will access applications from static IP addresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticIpScan")]
		public System.Nullable<System.Boolean> StaticIpScan { get; set; }
		
		/// <summary>
		/// Set of Google Cloud platforms targeted by the scan. If empty, APP_ENGINE will be used as a default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPlatforms")]
		public string[] TargetPlatforms { get; set; }
		
		/// <summary>
		/// The user agent used during scanning.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userAgent")]
		public System.Nullable<ScanConfigUserAgent> UserAgent { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanConfigExportToSecurityCommandCenter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPORT_TO_SECURITY_COMMAND_CENTER_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 2,
	}
	
	/// <summary>
	/// A ScanRun is a output-only resource representing an actual run of the scan. Next id: 12
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScanRun
	{
		
		/// <summary>
		/// The time at which the ScanRun reached termination state - that the ScanRun is either finished or stopped by user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Output only. Defines an error trace message for a ScanRun.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorTrace")]
		public ScanRunErrorTrace ErrorTrace { get; set; }
		
		/// <summary>
		/// The execution state of the ScanRun.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionState")]
		public System.Nullable<ScanRunExecutionState> ExecutionState { get; set; }
		
		/// <summary>
		/// Whether the scan run has found any vulnerabilities.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasVulnerabilities")]
		public System.Nullable<System.Boolean> HasVulnerabilities { get; set; }
		
		/// <summary>
		/// The resource name of the ScanRun. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'. The ScanRun IDs are generated by the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The percentage of total completion ranging from 0 to 100. If the scan is in queue, the value is 0. If the scan is running, the value ranges from 0 to 100. If the scan is finished, the value is 100.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progressPercent")]
		public System.Nullable<System.Int32> ProgressPercent { get; set; }
		
		/// <summary>
		/// The result state of the ScanRun. This field is only available after the execution state reaches "FINISHED".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resultState")]
		public System.Nullable<ScanRunResultState> ResultState { get; set; }
		
		/// <summary>
		/// The time at which the ScanRun started.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// The number of URLs crawled during this ScanRun. If the scan is in progress, the value represents the number of URLs crawled up to now.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlsCrawledCount")]
		public string UrlsCrawledCount { get; set; }
		
		/// <summary>
		/// The number of URLs tested during this ScanRun. If the scan is in progress, the value represents the number of URLs tested up to now. The number of URLs tested is usually larger than the number URLS crawled because typically a crawled URL is tested with multiple test payloads.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlsTestedCount")]
		public string UrlsTestedCount { get; set; }
		
		/// <summary>
		/// A list of warnings, if such are encountered during this scan run.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warningTraces")]
		public ScanRunWarningTrace[] WarningTraces { get; set; }
	}
	
	/// <summary>
	/// Output only. Defines an error trace message for a ScanRun.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScanRunErrorTrace
	{
		
		/// <summary>
		/// Indicates the error reason code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<ScanRunErrorTraceCode> Code { get; set; }
		
		/// <summary>
		/// If the scan encounters TOO_MANY_HTTP_ERRORS, this field indicates the most common HTTP error code, if such is available. For example, if this code is 404, the scan has encountered too many NOT_FOUND responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mostCommonHttpErrorCode")]
		public System.Nullable<System.Int32> MostCommonHttpErrorCode { get; set; }
		
		/// <summary>
		/// Defines a custom error message used by CreateScanConfig and UpdateScanConfig APIs when scan configuration validation fails. It is also reported as part of a ScanRunErrorTrace message if scan validation fails due to a scan configuration error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanConfigError")]
		public ScanConfigError ScanConfigError { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanRunErrorTraceCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL_ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCAN_CONFIG_ISSUE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTHENTICATION_CONFIG_ISSUE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIMED_OUT_WHILE_SCANNING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOO_MANY_REDIRECTS = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOO_MANY_HTTP_ERRORS = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING_URLS_CRAWL_HTTP_ERRORS = 7,
	}
	
	/// <summary>
	/// Defines a custom error message used by CreateScanConfig and UpdateScanConfig APIs when scan configuration validation fails. It is also reported as part of a ScanRunErrorTrace message if scan validation fails due to a scan configuration error.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScanConfigError
	{
		
		/// <summary>
		/// Indicates the reason code for a configuration failure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<ScanConfigErrorCode> Code { get; set; }
		
		/// <summary>
		/// Indicates the full name of the ScanConfig field that triggers this error, for example "scan_config.max_qps". This field is provided for troubleshooting purposes only and its actual value can change in the future.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fieldName")]
		public string FieldName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanConfigErrorCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL_ERROR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPENGINE_API_BACKEND_ERROR = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPENGINE_API_NOT_ACCESSIBLE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPENGINE_DEFAULT_HOST_MISSING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANNOT_USE_GOOGLE_COM_ACCOUNT = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANNOT_USE_OWNER_ACCOUNT = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_API_BACKEND_ERROR = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_API_NOT_ACCESSIBLE = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_LOGIN_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_LOGIN_URL_MALFORMED = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_LOGIN_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_LOGIN_URL_MAPPED_TO_UNRESERVED_ADDRESS = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_LOGIN_URL_HAS_NON_ROUTABLE_IP_ADDRESS = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_LOGIN_URL_HAS_UNRESERVED_IP_ADDRESS = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DUPLICATE_SCAN_NAME = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_FIELD_VALUE = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED_TO_AUTHENTICATE_TO_TARGET = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINDING_TYPE_UNSPECIFIED = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FORBIDDEN_TO_SCAN_COMPUTE = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FORBIDDEN_UPDATE_TO_MANAGED_SCAN = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MALFORMED_FILTER = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MALFORMED_RESOURCE_NAME = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROJECT_INACTIVE = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REQUIRED_FIELD = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOURCE_NAME_INCONSISTENT = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCAN_ALREADY_RUNNING = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCAN_NOT_RUNNING = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEED_URL_DOES_NOT_BELONG_TO_CURRENT_PROJECT = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEED_URL_MALFORMED = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEED_URL_MAPPED_TO_NON_ROUTABLE_ADDRESS = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEED_URL_MAPPED_TO_UNRESERVED_ADDRESS = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEED_URL_HAS_NON_ROUTABLE_IP_ADDRESS = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEED_URL_HAS_UNRESERVED_IP_ADDRESS = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVICE_ACCOUNT_NOT_CONFIGURED = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOO_MANY_SCANS = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNABLE_TO_RESOLVE_PROJECT_INFO = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSUPPORTED_BLACKLIST_PATTERN_FORMAT = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSUPPORTED_FILTER = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSUPPORTED_FINDING_TYPE = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSUPPORTED_URL_SCHEME = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOUD_ASSET_INVENTORY_ASSET_NOT_FOUND = 42,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanRunExecutionState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTION_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QUEUED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCANNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINISHED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanRunResultState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESULT_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KILLED = 3,
	}
	
	/// <summary>
	/// Output only. Defines a warning trace message for ScanRun. Warning traces provide customers with useful information that helps make the scanning process more effective.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScanRunWarningTrace
	{
		
		/// <summary>
		/// Indicates the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<ScanRunWarningTraceCode> Code { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanRunWarningTraceCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INSUFFICIENT_CRAWL_RESULTS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOO_MANY_CRAWL_RESULTS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOO_MANY_FUZZ_TASKS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BLOCKED_BY_IAP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_STARTING_URL_FOUND_FOR_MANAGED_SCAN = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanConfigRiskLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RISK_LEVEL_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOW = 2,
	}
	
	/// <summary>
	/// Scan schedule configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Schedule
	{
		
		/// <summary>
		/// Required. The duration of time between executions in days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="intervalDurationDays")]
		public System.Nullable<System.Int32> IntervalDurationDays { get; set; }
		
		/// <summary>
		/// A timestamp indicates when the next run will be scheduled. The value is refreshed by the server after each run. If unspecified, it will default to current server time, which means the scan will be scheduled to start immediately.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleTime")]
		public string ScheduleTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ScanConfigUserAgent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER_AGENT_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHROME_LINUX = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CHROME_ANDROID = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SAFARI_IPHONE = 3,
	}
	
	/// <summary>
	/// Response for the `ListScanRuns` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListScanRunsResponse
	{
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of ScanRuns returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanRuns")]
		public ScanRun[] ScanRuns { get; set; }
	}
	
	/// <summary>
	/// Request for the `StartScanRun` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StartScanRunRequest
	{
	}
	
	/// <summary>
	/// Request for the `StopScanRun` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StopScanRunRequest
	{
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Deletes an existing ScanConfig and its child resources.
		/// Websecurityscanner_projects_scanConfigs_delete v1beta/{name}
		/// </summary>
		/// <param name="name">Required. The resource name of the ScanConfig to be deleted. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Websecurityscanner_projects_scanConfigs_deleteAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a Finding.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_findings_get v1beta/{name}
		/// </summary>
		/// <param name="name">Required. The resource name of the Finding to be returned. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}/findings/{findingId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<Finding> Websecurityscanner_projects_scanConfigs_scanRuns_findings_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Finding>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a ScanConfig. This method support partial update of a ScanConfig.
		/// Websecurityscanner_projects_scanConfigs_patch v1beta/{name}
		/// </summary>
		/// <param name="name">The resource name of the ScanConfig. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}'. The ScanConfig IDs are generated by the system.</param>
		/// <param name="updateMask">Required. The update mask applies to the resource. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask</param>
		/// <returns>Successful response</returns>
		public async Task<ScanConfig> Websecurityscanner_projects_scanConfigs_patchAsync(string name, string updateMask, ScanConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ScanConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start a ScanRun according to the given ScanConfig.
		/// Websecurityscanner_projects_scanConfigs_start v1beta/{name}:start
		/// </summary>
		/// <param name="name">Required. The resource name of the ScanConfig to be used. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<ScanRun> Websecurityscanner_projects_scanConfigs_startAsync(string name, StartScanRunRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":start";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ScanRun>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Stops a ScanRun. The stopped ScanRun is returned.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_stop v1beta/{name}:stop
		/// </summary>
		/// <param name="name">Required. The resource name of the ScanRun to be stopped. The name follows the format of 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<ScanRun> Websecurityscanner_projects_scanConfigs_scanRuns_stopAsync(string name, StopScanRunRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":stop";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ScanRun>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List CrawledUrls under a given ScanRun.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_crawledUrls_list v1beta/{parent}/crawledUrls
		/// </summary>
		/// <param name="parent">Required. The parent resource name, which should be a scan run resource name in the format 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.</param>
		/// <param name="pageSize">The maximum number of CrawledUrls to return, can be limited by server. If not specified or not positive, the implementation will select a reasonable value.</param>
		/// <param name="pageToken">A token identifying a page of results to be returned. This should be a `next_page_token` value returned from a previous List request. If unspecified, the first page of results is returned.</param>
		/// <returns>Successful response</returns>
		public async Task<ListCrawledUrlsResponse> Websecurityscanner_projects_scanConfigs_scanRuns_crawledUrls_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/crawledUrls&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListCrawledUrlsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all FindingTypeStats under a given ScanRun.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_findingTypeStats_list v1beta/{parent}/findingTypeStats
		/// </summary>
		/// <param name="parent">Required. The parent resource name, which should be a scan run resource name in the format 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<ListFindingTypeStatsResponse> Websecurityscanner_projects_scanConfigs_scanRuns_findingTypeStats_listAsync(string parent, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/findingTypeStats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListFindingTypeStatsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List Findings under a given ScanRun.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_findings_list v1beta/{parent}/findings
		/// </summary>
		/// <param name="parent">Required. The parent resource name, which should be a scan run resource name in the format 'projects/{projectId}/scanConfigs/{scanConfigId}/scanRuns/{scanRunId}'.</param>
		/// <param name="filter">Required. The filter expression. The expression must be in the format: . Supported field: 'finding_type'. Supported operator: '='.</param>
		/// <param name="pageSize">The maximum number of Findings to return, can be limited by server. If not specified or not positive, the implementation will select a reasonable value.</param>
		/// <param name="pageToken">A token identifying a page of results to be returned. This should be a `next_page_token` value returned from a previous List request. If unspecified, the first page of results is returned.</param>
		/// <returns>Successful response</returns>
		public async Task<ListFindingsResponse> Websecurityscanner_projects_scanConfigs_scanRuns_findings_listAsync(string parent, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/findings&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListFindingsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists ScanConfigs under a given project.
		/// Websecurityscanner_projects_scanConfigs_list v1beta/{parent}/scanConfigs
		/// </summary>
		/// <param name="parent">Required. The parent resource name, which should be a project resource name in the format 'projects/{projectId}'.</param>
		/// <param name="pageSize">The maximum number of ScanConfigs to return, can be limited by server. If not specified or not positive, the implementation will select a reasonable value.</param>
		/// <param name="pageToken">A token identifying a page of results to be returned. This should be a `next_page_token` value returned from a previous List request. If unspecified, the first page of results is returned.</param>
		/// <returns>Successful response</returns>
		public async Task<ListScanConfigsResponse> Websecurityscanner_projects_scanConfigs_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/scanConfigs&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListScanConfigsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new ScanConfig.
		/// Websecurityscanner_projects_scanConfigs_create v1beta/{parent}/scanConfigs
		/// </summary>
		/// <param name="parent">Required. The parent resource name where the scan is created, which should be a project resource name in the format 'projects/{projectId}'.</param>
		/// <returns>Successful response</returns>
		public async Task<ScanConfig> Websecurityscanner_projects_scanConfigs_createAsync(string parent, ScanConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/scanConfigs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ScanConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists ScanRuns under a given ScanConfig, in descending order of ScanRun stop time.
		/// Websecurityscanner_projects_scanConfigs_scanRuns_list v1beta/{parent}/scanRuns
		/// </summary>
		/// <param name="parent">Required. The parent resource name, which should be a scan resource name in the format 'projects/{projectId}/scanConfigs/{scanConfigId}'.</param>
		/// <param name="pageSize">The maximum number of ScanRuns to return, can be limited by server. If not specified or not positive, the implementation will select a reasonable value.</param>
		/// <param name="pageToken">A token identifying a page of results to be returned. This should be a `next_page_token` value returned from a previous List request. If unspecified, the first page of results is returned.</param>
		/// <returns>Successful response</returns>
		public async Task<ListScanRunsResponse> Websecurityscanner_projects_scanConfigs_scanRuns_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/scanRuns&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListScanRunsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
