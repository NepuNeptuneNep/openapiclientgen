//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A breadcrumb represent a step preceding a log message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Breadcrumb
	{
		
		/// <summary>
		/// An action representing the breadcrumb. You can set a custom action or use one of the built-in: click, submit, navigation, request, error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string Action { get; set; }
		
		/// <summary>
		/// The date and time in UTC of the breadcrumb. If no date and time is provided, we will use the current date and time in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dateTime")]
		public System.Nullable<System.DateTimeOffset> DateTime { get; set; }
		
		/// <summary>
		/// A message representing the breadcrumb. This should elaborate on the action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// An enum value representing the severity of this breadcrumb. The following values are allowed: Verbose, Debug, Information, Warning, Error, Fatal.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public string Severity { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateBulkMessageResult
	{
		
		/// <summary>
		/// The location of the created message if StatusCode equals Created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Status code of the individual messages as if it were being created through the non-bulk endpoint.
		///If a message was succesfully created, the status code will be 201 and location will contain an URL.
		///If a message was ignored, the status code will be 200 and the location will be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public System.Nullable<System.Int32> StatusCode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateDeployment
	{
		
		/// <summary>
		/// When was this deployment created in UTC. Defaults to current time if not specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// Optional description of this deployment. Can be markdown or clear text.
		/// Max length: 8192
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MaxLength(8192)]
		public string Description { get; set; }
		
		/// <summary>
		/// As default, deployments are attached all logs of the organization. If you want a deployment to
		///attach to a single log only, set this to the ID of that log.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logId")]
		public string LogId { get; set; }
		
		/// <summary>
		/// The email of the person responsible for creating this deployment. This can be the email taken from
		///your deployment server (like Azure DevOps or Octopus).
		/// Max length: 320
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userEmail")]
		[System.ComponentModel.DataAnnotations.MaxLength(320)]
		public string UserEmail { get; set; }
		
		/// <summary>
		/// The name of the person responsible for creating this deployment. This can be the name taken from
		///your deployment server (like Azure DevOps or Octopus).
		/// Max length: 256
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userName")]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string UserName { get; set; }
		
		/// <summary>
		/// The version number of this deployment. The value of version can be a SemVer compliant string or any other
		///syntax that you are using as your version numbering scheme.
		/// Required
		/// Max length: 256
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateDeploymentResult
	{
		
		/// <summary>
		/// The location of the created deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateHeartbeat
	{
		
		/// <summary>
		/// Optional string to identify which application logged this message. You can use this if you have multiple applications and services logging to the same log.
		///If not set, the application name "Heartbeats" will be set on all log messages generated from this heartbeat.
		/// Max length: 256
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="application")]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string Application { get; set; }
		
		/// <summary>
		/// If result is "Degraded" or "Unhealthy" you can use this property to specify why.
		/// Max length: 8192
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reason")]
		[System.ComponentModel.DataAnnotations.MaxLength(8192)]
		public string Reason { get; set; }
		
		/// <summary>
		/// The result of this heartbeat. Can be "Healthy, "Degraded", or "Unhealthy". Defaults to "Healthy"
		/// Max length: 9
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		[System.ComponentModel.DataAnnotations.MaxLength(9)]
		public string Result { get; set; }
		
		/// <summary>
		/// Optional long for specifying how many milliseconds it took to execute the task resulting in this heartbeat. This can be used to get a better overview
		///of how long a scheduled task or service is running or to figure out if the grace period should be increased.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="took")]
		public System.Nullable<System.Int64> Took { get; set; }
		
		/// <summary>
		/// Optional string to identify which version of your application logged this message. If not specified, any errors, warnings, or information messages will get
		///the newest version number created through deployment tracking as with normal log messages.
		/// Max length: 256
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateLog
	{
		
		/// <summary>
		/// Color of the log. The color must be one of the following (green on unknown value or missing):
		///green, lightgreen, lime, yellow, orange, deeporange, red, pink, purple, deeppurple, blue, lightblue
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// Set to true to disable the log on creation. Defaults to false. A log can be enabled/disabled
		///afterwards by calling the _disable and _enable endpoints.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// Environment name of the new log. Must match an environment name (case insensitive).
		///If a matching environment name was not found or the property is not set, the log
		///will appear under "Other" in the UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="environmentName")]
		public string EnvironmentName { get; set; }
		
		/// <summary>
		/// Name of the new log.
		/// Required
		/// Max length: 256
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateLogResult
	{
		
		/// <summary>
		/// The location of the created log.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateMessage
	{
		
		/// <summary>
		/// Used to identify which application logged this message. You can use this if you have multiple applications and services logging to the same log
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="application")]
		public string Application { get; set; }
		
		/// <summary>
		/// A list of breadcrumbs preceding this log message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="breadcrumbs")]
		public Breadcrumb[] Breadcrumbs { get; set; }
		
		/// <summary>
		/// The log message category. Category can be a string of choice but typically contain a logging category set by a logging framework like NLog or Serilog.
		///When logging through a logging framework, this field will be provided by the framework and not something that needs to be set manually.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// Code can be used to include source code related to the log message. The code will typically span from a few lines before the line causing the log message
		///to a few lines after. For now, all lines above 21 will be removed. This makes room for showing 10 lines before the logging line, the logging line, and
		///10 lines after the logging line. Don't include a very large string in this property since that will quickly make the entire messages exceed the max limit
		///of 256 kb.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// A key/value pair of cookies. This property only makes sense for logging messages related to web requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookies")]
		public Item[] Cookies { get; set; }
		
		/// <summary>
		/// CorrelationId can be used to group similar log messages together into a single discoverable batch. A correlation ID could be a session ID from ASP.NET Core,
		///a unique string spanning multiple microsservices handling the same request, or similar.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="correlationId")]
		public string CorrelationId { get; set; }
		
		/// <summary>
		/// A key/value pair of user-defined fields and their values. When logging an exception, the Data dictionary of
		///the exception is copied to this property. You can add additional key/value pairs, by modifying the Data
		///dictionary on the exception or by supplying additional key/values to this API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Item[] Data { get; set; }
		
		/// <summary>
		/// The date and time in UTC of the message. If you don't provide us with a value in dateTime, we will set the current date and time in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dateTime")]
		public System.Nullable<System.DateTimeOffset> DateTime { get; set; }
		
		/// <summary>
		/// A longer description of the message. For errors this could be a stacktrace, but it's really up to you what to log in there.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		/// <summary>
		/// A key/value pair of form fields and their values. This property makes sense if logging message related to users inputting data in a form.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="form")]
		public Item[] Form { get; set; }
		
		/// <summary>
		/// The hostname of the server logging the message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// If message relates to a HTTP request, you may send the HTTP method of that request. If you don't provide us with a method, we will try to find a key named REQUEST_METHOD in serverVariables.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		/// <summary>
		/// A key/value pair of query string parameters. This property makes sense if logging message related to a HTTP request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryString")]
		public Item[] QueryString { get; set; }
		
		/// <summary>
		/// A key/value pair of server values. Server variables are typically related to handling requests in a webserver but could be used for other types of information as well.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverVariables")]
		public Item[] ServerVariables { get; set; }
		
		/// <summary>
		/// An enum value representing the severity of this message. The following values are allowed: Verbose, Debug, Information, Warning, Error, Fatal
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public string Severity { get; set; }
		
		/// <summary>
		/// The source of the code logging the message. This could be the assembly name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// If the message logged relates to a HTTP status code, you can put the code in this property. This would probably only be relevant for errors,
		///but could be used for logging successful status codes as well.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public System.Nullable<System.Int32> StatusCode { get; set; }
		
		/// <summary>
		/// The textual title or headline of the message to log.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// The title template of the message to log. This property can be used from logging frameworks that supports
		///structured logging like: "{user} says {quote}". In the example, titleTemplate will be this string and title
		///will be "Gilfoyle says It's not magic. It's talent and sweat".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="titleTemplate")]
		public string TitleTemplate { get; set; }
		
		/// <summary>
		/// The type of message. If logging an error, the type of the exception would go into type but you can put anything in there, that makes sense for your domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// If message relates to a HTTP request, you may send the URL of that request. If you don't provide us with an URL, we will try to find a key named URL in serverVariables.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// An identification of the user triggering this message. You can put the users email address or your user key into this property.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
		
		/// <summary>
		/// Versions can be used to distinguish messages from different versions of your software. The value of version can be a SemVer compliant string or any other
		///syntax that you are using as your version numbering scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Represents a key value pair.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Item
	{
		
		/// <summary>
		/// The key of the item.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The value of the item.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateMessageResult
	{
		
		/// <summary>
		/// The location of the created message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Deployment
	{
		
		/// <summary>
		/// When was this deployment created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public System.Nullable<System.DateTimeOffset> Created { get; set; }
		
		/// <summary>
		/// The elmah.io id of the user creating this deployment. Since deployments are created on a subscription,
		///the CreatedBy will contain the id of the user with the subscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Sescription of this deployment in markdown or clear text.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The ID of this deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If the deployment is attached a single log, this property is set to the ID of that log.
		///If null, the deployment is attached all logs on the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logId")]
		public string LogId { get; set; }
		
		/// <summary>
		/// The email of the person responsible for creating this deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userEmail")]
		public string UserEmail { get; set; }
		
		/// <summary>
		/// The name of the person responsible for creating this deployment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userName")]
		public string UserName { get; set; }
		
		/// <summary>
		/// The version number of this deployment. The value of version can be a SemVer compliant string or any other
		///syntax that you are using as your version numbering scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Log
	{
		
		/// <summary>
		/// Color of the log. The color will always be one of the following (green being the default):
		///green, lightgreen, lime, yellow, orange, deeporange, red, pink, purple, deeppurple, blue, lightblue
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="color")]
		public string Color { get; set; }
		
		/// <summary>
		/// Returns true if the log is currently disabled. A log can be disabled either through the API
		///or in the elmah.io UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// Environment name this log is in or "Other" if not in an environment.
		///"Other" is chosen over null to mimic the experience in the elmah.io UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="environmentName")]
		public string EnvironmentName { get; set; }
		
		/// <summary>
		/// ID of the log.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the log.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Message
	{
		
		/// <summary>
		/// Used to identify which application logged this message. You can use this if you have multiple applications and services logging to the same log
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="application")]
		public string Application { get; set; }
		
		/// <summary>
		/// A list of breadcrumbs preceding this log message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="breadcrumbs")]
		public Breadcrumb[] Breadcrumbs { get; set; }
		
		/// <summary>
		/// The log message category. Category can be a string of choice but typically contain a logging category set by a logging framework like NLog or Serilog.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// Code can be used to include source code related to the log message. The code will typically span from a few lines before the line causing the log message
		///to a few lines after. For now, all lines above 21 will be removed. This makes room for showing 10 lines before the logging line, the logging line, and
		///10 lines after the logging line. Don't include a very large string in this property since that will quickly make the entire messages exceed the max limit
		///of 256 kb.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// A key/value pair of cookies. This property only makes sense for logging messages related to web requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookies")]
		public Item[] Cookies { get; set; }
		
		/// <summary>
		/// CorrelationId can be used to group similar log messages together into a single discoverable batch. A correlation ID could be a session ID from ASP.NET Core,
		///a unique string spanning multiple microsservices handling the same request, or similar.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="correlationId")]
		public string CorrelationId { get; set; }
		
		/// <summary>
		/// A key/value pair of user-defined fields and their values. When logging an exception, the Data dictionary of
		///the exception is copied to this property. You can add additional key/value pairs, by modifying the Data
		///dictionary on the exception or by supplying additional key/values to this API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Item[] Data { get; set; }
		
		/// <summary>
		/// The date and time in UTC of the message. If you don't provide us with a value in dateTime, we will set the current date and time in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dateTime")]
		public System.Nullable<System.DateTimeOffset> DateTime { get; set; }
		
		/// <summary>
		/// A longer description of the message. For errors this could be a stacktrace, but it's really up to you what to log in there.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		/// <summary>
		/// A key/value pair of form fields and their values. This property makes sense if logging message related to users inputting data in a form.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="form")]
		public Item[] Form { get; set; }
		
		/// <summary>
		/// The hostname of the server logging the message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// The ID of this message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If message relates to a HTTP request, you may send the HTTP method of that request. If you don't provide us with a method, we will try to find a key named REQUEST_METHOD in serverVariables.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		/// <summary>
		/// A key/value pair of query string parameters. This property makes sense if logging message related to a HTTP request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryString")]
		public Item[] QueryString { get; set; }
		
		/// <summary>
		/// A key/value pair of server values. Server variables are typically related to handling requests in a webserver but could be used for other types of information as well.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverVariables")]
		public Item[] ServerVariables { get; set; }
		
		/// <summary>
		/// An enum value representing the severity of this message. The following values are allowed: Verbose, Debug, Information, Warning, Error, Fatal
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public string Severity { get; set; }
		
		/// <summary>
		/// The source of the code logging the message. This could be the assembly name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// If the message logged relates to a HTTP status code, you can put the code in this property. This would probably only be relevant for errors,
		///but could be used for logging successful status codes as well.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public System.Nullable<System.Int32> StatusCode { get; set; }
		
		/// <summary>
		/// The textual title or headline of the message to log.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// The title template of the message to log. This property can be used from logging frameworks that supports
		///structured logging like: "{user} says {quote}". In the example, titleTemplate will be this string and title
		///will be "Gilfoyle says It's not magic. It's talent and sweat".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="titleTemplate")]
		public string TitleTemplate { get; set; }
		
		/// <summary>
		/// The type of message. If logging an error, the type of the exception would go into type but you can put anything in there, that makes sense for your domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// If message relates to a HTTP request, you may send the URL of that request. If you don't provide us with an URL, we will try to find a key named URL in serverVariables.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// An identification of the user triggering this message. You can put the users email address or your user key into this property.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
		
		/// <summary>
		/// Versions can be used to distinguish messages from different versions of your software. The value of version can be a SemVer compliant string or any other
		///syntax that you are using as your version numbering scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MessageOverview
	{
		
		/// <summary>
		/// Used to identify which application logged this message. You can use this if you have multiple applications and services logging to the same log
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="application")]
		public string Application { get; set; }
		
		/// <summary>
		/// A list of breadcrumbs preceding this log message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="breadcrumbs")]
		public Breadcrumb[] Breadcrumbs { get; set; }
		
		/// <summary>
		/// The log message category. Category can be a string of choice but typically contain a logging category set by a logging framework like NLog or Serilog.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// Code can be used to include source code related to the log message. The code will typically span from a few lines before the line causing the log message
		///to a few lines after. For now, all lines above 21 will be removed. This makes room for showing 10 lines before the logging line, the logging line, and
		///10 lines after the logging line. Don't include a very large string in this property since that will quickly make the entire messages exceed the max limit
		///of 256 kb.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// A key/value pair of cookies. This property only makes sense for logging messages related to web requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookies")]
		public Item[] Cookies { get; set; }
		
		/// <summary>
		/// CorrelationId can be used to group similar log messages together into a single discoverable batch. A correlation ID could be a session ID from ASP.NET Core,
		///a unique string spanning multiple microsservices handling the same request, or similar.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="correlationId")]
		public string CorrelationId { get; set; }
		
		/// <summary>
		/// A key/value pair of user-defined fields and their values. When logging an exception, the Data dictionary of
		///the exception is copied to this property. You can add additional key/value pairs, by modifying the Data
		///dictionary on the exception or by supplying additional key/values to this API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Item[] Data { get; set; }
		
		/// <summary>
		/// The date and time in UTC of the message. If you don't provide us with a value in dateTime, we will set the current date and time in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dateTime")]
		public System.Nullable<System.DateTimeOffset> DateTime { get; set; }
		
		/// <summary>
		/// A longer description of the message. For errors this could be a stacktrace, but it's really up to you what to log in there.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		/// <summary>
		/// A key/value pair of form fields and their values. This property makes sense if logging message related to users inputting data in a form.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="form")]
		public Item[] Form { get; set; }
		
		/// <summary>
		/// The hostname of the server logging the message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// The ID of this message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// If message relates to a HTTP request, you may send the HTTP method of that request. If you don't provide us with a method, we will try to find a key named REQUEST_METHOD in serverVariables.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		/// <summary>
		/// A key/value pair of query string parameters. This property makes sense if logging message related to a HTTP request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryString")]
		public Item[] QueryString { get; set; }
		
		/// <summary>
		/// A key/value pair of server values. Server variables are typically related to handling requests in a webserver but could be used for other types of information as well.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverVariables")]
		public Item[] ServerVariables { get; set; }
		
		/// <summary>
		/// An enum value representing the severity of this message. The following values are allowed: Verbose, Debug, Information, Warning, Error, Fatal
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public string Severity { get; set; }
		
		/// <summary>
		/// The source of the code logging the message. This could be the assembly name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// If the message logged relates to a HTTP status code, you can put the code in this property. This would probably only be relevant for errors,
		///but could be used for logging successful status codes as well.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusCode")]
		public System.Nullable<System.Int32> StatusCode { get; set; }
		
		/// <summary>
		/// The textual title or headline of the message to log.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// The title template of the message to log. This property can be used from logging frameworks that supports
		///structured logging like: "{user} says {quote}". In the example, titleTemplate will be this string and title
		///will be "Gilfoyle says It's not magic. It's talent and sweat".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="titleTemplate")]
		public string TitleTemplate { get; set; }
		
		/// <summary>
		/// The type of message. If logging an error, the type of the exception would go into type but you can put anything in there, that makes sense for your domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// If message relates to a HTTP request, you may send the URL of that request. If you don't provide us with an URL, we will try to find a key named URL in serverVariables.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// An identification of the user triggering this message. You can put the users email address or your user key into this property.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
		
		/// <summary>
		/// Versions can be used to distinguish messages from different versions of your software. The value of version can be a SemVer compliant string or any other
		///syntax that you are using as your version numbering scheme.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MessagesResult
	{
		
		/// <summary>
		/// Log messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messages")]
		public MessageOverview[] Messages { get; set; }
		
		/// <summary>
		/// The total number of log messages found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Search
	{
		
		/// <summary>
		/// Search from this date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public System.Nullable<System.DateTimeOffset> From { get; set; }
		
		/// <summary>
		/// Lucene query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query")]
		public string Query { get; set; }
		
		/// <summary>
		/// Search to this date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public System.Nullable<System.DateTimeOffset> To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UptimeCheck
	{
		
		/// <summary>
		/// ID of the uptime check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the uptime check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Current status of the uptime check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Url of the uptime check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Fetch a list of deployments.
		/// Required permission: `deployments_read`
		/// Deployments_GetAll v3/deployments
		/// </summary>
		/// <returns>Request for deployments successful.</returns>
		public async Task<Deployment[]> Deployments_GetAllAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/deployments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deployment[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new deployment.
		/// Required permission: `deployments_write`
		/// Deployments_Create v3/deployments
		/// </summary>
		/// <param name="requestBody">The deployment object to create.</param>
		public async Task Deployments_CreateAsync(CreateDeployment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/deployments";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a deployment by its ID.
		/// This endpoint doesn't clear the version number of messages already annotated with this deployment version.<br/><br/>Required permission: `deployments_delete`
		/// Deployments_Delete v3/deployments/{id}
		/// </summary>
		/// <param name="id">The ID of the deployment to delete.</param>
		public async Task Deployments_DeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/deployments/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a deployment by its ID.
		/// Required permission: `deployments_read`
		/// Deployments_Get v3/deployments/{id}
		/// </summary>
		/// <param name="id">The ID of the deployment to fetch.</param>
		/// <returns>Request for deployment successful.</returns>
		public async Task<Deployment> Deployments_GetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/deployments/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Deployment>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new heartbeat.
		/// Required permission: `heartbeats_write`
		/// Heartbeats_Create v3/heartbeats/{logId}/{id}
		/// </summary>
		/// <param name="id">The ID of the heartbeat check.</param>
		/// <param name="logId">The ID of the log containing the heartbeat check.</param>
		/// <param name="requestBody">The details of the heartbeat.</param>
		/// <returns>Heartbeat was created.</returns>
		public async Task Heartbeats_CreateAsync(string id, string logId, CreateHeartbeat requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/heartbeats/"+ (logId==null? "" : System.Uri.EscapeDataString(logId))+"/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a list of logs.
		/// Required permission: `logs_read`
		/// Logs_GetAll v3/logs
		/// </summary>
		/// <returns>Request for logs successful.</returns>
		public async Task<Log[]> Logs_GetAllAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/logs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Log[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new log.
		/// Required permission: `logs_write`
		/// Logs_Create v3/logs
		/// </summary>
		/// <param name="requestBody">The log object to create.</param>
		public async Task Logs_CreateAsync(CreateLog requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/logs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a log by its ID.
		/// Required permission: `logs_read`
		/// Logs_Get v3/logs/{id}
		/// </summary>
		/// <param name="id">The ID of the log to fetch.</param>
		/// <returns>Request for log successful.</returns>
		public async Task<Log> Logs_GetAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/logs/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Log>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Help diagnose logging problems.
		/// Required permission: `messages_write`
		/// Logs_Diagnose v3/logs/{id}/_diagnose
		/// </summary>
		/// <param name="id">The ID of the log to diagnose.</param>
		/// <returns>Log was diagnosed.</returns>
		public async Task<string[]> Logs_DiagnoseAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/logs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/_diagnose";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<string[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable a log by its ID.
		/// Required permission: `logs_write`
		/// Logs_Disable v3/logs/{id}/_disable
		/// </summary>
		/// <param name="id">The ID of the log to disable.</param>
		/// <returns>Log was disabled.</returns>
		public async Task Logs_DisableAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/logs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/_disable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable a log by its ID.
		/// Required permission: `logs_write`
		/// Logs_Enable v3/logs/{id}/_enable
		/// </summary>
		/// <param name="id">The ID of the log to enable.</param>
		/// <returns>Log was enabled.</returns>
		public async Task Logs_EnableAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/logs/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/_enable";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a list of messages by logid and query.
		/// Required permission: `messages_delete`
		/// Messages_DeleteAll v3/messages/{logId}
		/// </summary>
		/// <param name="logId">The ID of the log containing the message.</param>
		/// <returns>Messages where deleted.</returns>
		public async Task Messages_DeleteAllAsync(string logId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/messages/"+ (logId==null? "" : System.Uri.EscapeDataString(logId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch messages from a log.
		/// Required permission: `messages_read`
		/// Messages_GetAll v3/messages/{logId}
		/// </summary>
		/// <param name="logId">The ID of the log containing the messages.</param>
		/// <param name="pageIndex">The page number of the result.</param>
		/// <param name="pageSize">The number of messages to load (max 100) or 15 if not set.</param>
		/// <param name="query">A full-text or Lucene query to limit the messages by.</param>
		/// <param name="from">A start date and time to search from (not included).</param>
		/// <param name="to">An end date and time to search to (not included).</param>
		/// <param name="includeHeaders">Include headers like server variables and cookies in the result (slower).</param>
		/// <returns>Log found and may contain messages.</returns>
		public async Task<MessagesResult> Messages_GetAllAsync(string logId, int pageIndex, int pageSize, string query, System.DateTimeOffset from, System.DateTimeOffset to, bool includeHeaders, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/messages/"+ (logId==null? "" : System.Uri.EscapeDataString(logId))+"&pageIndex="+pageIndex+"&pageSize="+pageSize+"&query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&from=" + from.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&to=" + to.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&includeHeaders="+includeHeaders;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<MessagesResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new message.
		/// Required permission: `messages_write`
		/// Messages_Create v3/messages/{logId}
		/// </summary>
		/// <param name="logId">The ID of the log which should contain the new message.</param>
		/// <param name="requestBody">The message object to create.</param>
		/// <returns>Message was not created.</returns>
		public async Task<CreateMessageResult> Messages_CreateAsync(string logId, CreateMessage requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/messages/"+ (logId==null? "" : System.Uri.EscapeDataString(logId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateMessageResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create one or more new messages.
		/// Required permission: `messages_write`
		/// Messages_CreateBulk v3/messages/{logId}/_bulk
		/// </summary>
		/// <param name="logId">The ID of the log which should contain the new messages.</param>
		/// <param name="requestBody">The messages to create.</param>
		/// <returns>Zero or more messages where successfully created. Check the response body for details.</returns>
		public async Task<CreateBulkMessageResult[]> Messages_CreateBulkAsync(string logId, CreateMessage[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/messages/"+ (logId==null? "" : System.Uri.EscapeDataString(logId))+"/_bulk";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateBulkMessageResult[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Mark a list of messages as fixed by logid and query.
		/// Required permission: `messages_write`
		/// Messages_FixAll v3/messages/{logId}/_fix
		/// </summary>
		/// <param name="logId">The ID of the log containing the messages.</param>
		/// <param name="requestBody">A search object containing query, time filters etc.</param>
		/// <returns>Messages where marked as fixed.</returns>
		public async Task Messages_FixAllAsync(string logId, Search requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/messages/"+ (logId==null? "" : System.Uri.EscapeDataString(logId))+"/_fix";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a message by its ID.
		/// Required permission: `messages_delete`
		/// Messages_Delete v3/messages/{logId}/{id}
		/// </summary>
		/// <param name="id">The ID of the message to delete.</param>
		/// <param name="logId">The ID of the log containing the message.</param>
		/// <returns>Message where deleted.</returns>
		public async Task Messages_DeleteAsync(string id, string logId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/messages/"+ (logId==null? "" : System.Uri.EscapeDataString(logId))+"/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a message by its ID.
		/// Required permission: `messages_read`
		/// Messages_Get v3/messages/{logId}/{id}
		/// </summary>
		/// <param name="id">The ID of the message to fetch.</param>
		/// <param name="logId">The ID of the log containing the message.</param>
		/// <returns>Message found.</returns>
		public async Task<Message> Messages_GetAsync(string id, string logId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/messages/"+ (logId==null? "" : System.Uri.EscapeDataString(logId))+"/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Message>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fix a message by its ID.
		/// Required permission: `messages_write`
		/// Messages_Fix v3/messages/{logId}/{id}/_fix
		/// </summary>
		/// <param name="id">The ID of the message to fix.</param>
		/// <param name="logId">The ID of the log containing the message.</param>
		/// <param name="markAllAsFixed">If set to true, all instances of the log message are set to fixed.</param>
		/// <returns>Message was fixed.</returns>
		public async Task Messages_FixAsync(string id, string logId, bool markAllAsFixed, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/messages/"+ (logId==null? "" : System.Uri.EscapeDataString(logId))+"/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/_fix&markAllAsFixed="+markAllAsFixed;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Hide a message by its ID.
		/// Required permission: `messages_write`
		/// Messages_Hide v3/messages/{logId}/{id}/_hide
		/// </summary>
		/// <param name="id">The ID of the message to hide.</param>
		/// <param name="logId">The ID of the log containing the message.</param>
		/// <returns>Message was hidden.</returns>
		public async Task Messages_HideAsync(string id, string logId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/messages/"+ (logId==null? "" : System.Uri.EscapeDataString(logId))+"/"+ (id==null? "" : System.Uri.EscapeDataString(id))+"/_hide";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch a list of uptime checks. Currently in closed beta. Get in contact to get access to this endpoint.
		/// Required permission: `uptimechecks_read`
		/// UptimeChecks_GetAll v3/uptimechecks
		/// </summary>
		/// <returns>Request for uptime checks successful.</returns>
		public async Task<UptimeCheck[]> UptimeChecks_GetAllAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v3/uptimechecks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UptimeCheck[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
