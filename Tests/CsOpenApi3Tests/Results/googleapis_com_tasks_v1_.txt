//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Task_
	{
		
		/// <summary>
		/// Completion date of the task (as a RFC 3339 timestamp). This field is omitted if the task has not been completed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completed")]
		public string Completed { get; set; }
		
		/// <summary>
		/// Flag indicating whether the task has been deleted. The default is False.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// Due date of the task (as a RFC 3339 timestamp). Optional. The due date only records date information; the time portion of the timestamp is discarded when setting the due date. It isn't possible to read or write the time that a task is due via the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="due")]
		public string Due { get; set; }
		
		/// <summary>
		/// ETag of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Flag indicating whether the task is hidden. This is the case if the task had been marked completed when the task list was last cleared. The default is False. This field is read-only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hidden")]
		public System.Nullable<System.Boolean> Hidden { get; set; }
		
		/// <summary>
		/// Task identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Type of the resource. This is always "tasks#task".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Collection of links. This collection is read-only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public Task_Links[] Task_Links { get; set; }
		
		/// <summary>
		/// Notes describing the task. Optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		public string Notes { get; set; }
		
		/// <summary>
		/// Parent task identifier. This field is omitted if it is a top-level task. This field is read-only. Use the "move" method to move the task under a different parent or to the top level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public string Parent { get; set; }
		
		/// <summary>
		/// String indicating the position of the task among its sibling tasks under the same parent task or at the top level. If this string is greater than another task's corresponding position string according to lexicographical ordering, the task is positioned after the other task under the same parent task (or at the top level). This field is read-only. Use the "move" method to move the task to another position.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="position")]
		public string Position { get; set; }
		
		/// <summary>
		/// URL pointing to this task. Used to retrieve, update, or delete this task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Status of the task. This is either "needsAction" or "completed".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Title of the task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Last modification time of the task (as a RFC 3339 timestamp).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
	}
	
	public class Task_Links
	{
		
		/// <summary>
		/// The description. In HTML speak: Everything between <a> and </a>.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="link")]
		public string Link { get; set; }
		
		/// <summary>
		/// Type of the link, e.g. "email".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskList
	{
		
		/// <summary>
		/// ETag of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Task list identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Type of the resource. This is always "tasks#taskList".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// URL pointing to this task list. Used to retrieve, update, or delete this task list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Title of the task list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Last modification time of the task list (as a RFC 3339 timestamp).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TaskLists
	{
		
		/// <summary>
		/// ETag of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Collection of task lists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TaskList[] Items { get; set; }
		
		/// <summary>
		/// Type of the resource. This is always "tasks#taskLists".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token that can be used to request the next page of this result.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tasks
	{
		
		/// <summary>
		/// ETag of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Collection of tasks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Task_[] Items { get; set; }
		
		/// <summary>
		/// Type of the resource. This is always "tasks#tasks".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token used to access the next page of this result.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Clears all completed tasks from the specified task list. The affected tasks will be marked as 'hidden' and no longer be returned by default when retrieving all tasks for a task list.
		/// Tasks_tasks_clear tasks/v1/lists/{tasklist}/clear
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <returns>Successful response</returns>
		public async Task Tasks_tasks_clearAsync(string tasklist, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist))+"/clear";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all tasks in the specified task list.
		/// Tasks_tasks_list tasks/v1/lists/{tasklist}/tasks
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <param name="completedMax">Upper bound for a task's completion date (as a RFC 3339 timestamp) to filter by. Optional. The default is not to filter by completion date.</param>
		/// <param name="completedMin">Lower bound for a task's completion date (as a RFC 3339 timestamp) to filter by. Optional. The default is not to filter by completion date.</param>
		/// <param name="dueMax">Upper bound for a task's due date (as a RFC 3339 timestamp) to filter by. Optional. The default is not to filter by due date.</param>
		/// <param name="dueMin">Lower bound for a task's due date (as a RFC 3339 timestamp) to filter by. Optional. The default is not to filter by due date.</param>
		/// <param name="maxResults">Maximum number of task lists returned on one page. Optional. The default is 20 (max allowed: 100).</param>
		/// <param name="pageToken">Token specifying the result page to return. Optional.</param>
		/// <param name="showCompleted">Flag indicating whether completed tasks are returned in the result. Optional. The default is True. Note that showHidden must also be True to show tasks completed in first party clients, such as the web UI and Google's mobile apps.</param>
		/// <param name="showDeleted">Flag indicating whether deleted tasks are returned in the result. Optional. The default is False.</param>
		/// <param name="showHidden">Flag indicating whether hidden tasks are returned in the result. Optional. The default is False.</param>
		/// <param name="updatedMin">Lower bound for a task's last modification time (as a RFC 3339 timestamp) to filter by. Optional. The default is not to filter by last modification time.</param>
		/// <returns>Successful response</returns>
		public async Task<Tasks> Tasks_tasks_listAsync(string tasklist, string completedMax, string completedMin, string dueMax, string dueMin, int maxResults, string pageToken, bool showCompleted, bool showDeleted, bool showHidden, string updatedMin, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist))+"/tasks&completedMax=" + (completedMax==null? "" : System.Uri.EscapeDataString(completedMax))+"&completedMin=" + (completedMin==null? "" : System.Uri.EscapeDataString(completedMin))+"&dueMax=" + (dueMax==null? "" : System.Uri.EscapeDataString(dueMax))+"&dueMin=" + (dueMin==null? "" : System.Uri.EscapeDataString(dueMin))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&showCompleted="+showCompleted+"&showDeleted="+showDeleted+"&showHidden="+showHidden+"&updatedMin=" + (updatedMin==null? "" : System.Uri.EscapeDataString(updatedMin));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Tasks>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new task on the specified task list.
		/// Tasks_tasks_insert tasks/v1/lists/{tasklist}/tasks
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <param name="parent">Parent task identifier. If the task is created at the top level, this parameter is omitted. Optional.</param>
		/// <param name="previous">Previous sibling task identifier. If the task is created at the first position among its siblings, this parameter is omitted. Optional.</param>
		/// <returns>Successful response</returns>
		public async Task<Task_> Tasks_tasks_insertAsync(string tasklist, string parent, string previous, Task_ requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist))+"/tasks&parent=" + (parent==null? "" : System.Uri.EscapeDataString(parent))+"&previous=" + (previous==null? "" : System.Uri.EscapeDataString(previous));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Task_>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified task from the task list.
		/// Tasks_tasks_delete tasks/v1/lists/{tasklist}/tasks/{task}
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <param name="task">Task identifier.</param>
		/// <returns>Successful response</returns>
		public async Task Tasks_tasks_deleteAsync(string tasklist, string task, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist))+"/tasks/"+ (task==null? "" : System.Uri.EscapeDataString(task));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified task.
		/// Tasks_tasks_get tasks/v1/lists/{tasklist}/tasks/{task}
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <param name="task">Task identifier.</param>
		/// <returns>Successful response</returns>
		public async Task<Task_> Tasks_tasks_getAsync(string tasklist, string task, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist))+"/tasks/"+ (task==null? "" : System.Uri.EscapeDataString(task));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Task_>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified task. This method supports patch semantics.
		/// Tasks_tasks_patch tasks/v1/lists/{tasklist}/tasks/{task}
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <param name="task">Task identifier.</param>
		/// <returns>Successful response</returns>
		public async Task<Task_> Tasks_tasks_patchAsync(string tasklist, string task, Task_ requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist))+"/tasks/"+ (task==null? "" : System.Uri.EscapeDataString(task));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Task_>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the specified task.
		/// Tasks_tasks_update tasks/v1/lists/{tasklist}/tasks/{task}
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <param name="task">Task identifier.</param>
		/// <returns>Successful response</returns>
		public async Task<Task_> Tasks_tasks_updateAsync(string tasklist, string task, Task_ requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist))+"/tasks/"+ (task==null? "" : System.Uri.EscapeDataString(task));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Task_>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Moves the specified task to another position in the task list. This can include putting it as a child task under a new parent and/or move it to a different position among its sibling tasks.
		/// Tasks_tasks_move tasks/v1/lists/{tasklist}/tasks/{task}/move
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <param name="task">Task identifier.</param>
		/// <param name="parent">New parent task identifier. If the task is moved to the top level, this parameter is omitted. Optional.</param>
		/// <param name="previous">New previous sibling task identifier. If the task is moved to the first position among its siblings, this parameter is omitted. Optional.</param>
		/// <returns>Successful response</returns>
		public async Task<Task_> Tasks_tasks_moveAsync(string tasklist, string task, string parent, string previous, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist))+"/tasks/"+ (task==null? "" : System.Uri.EscapeDataString(task))+"/move&parent=" + (parent==null? "" : System.Uri.EscapeDataString(parent))+"&previous=" + (previous==null? "" : System.Uri.EscapeDataString(previous));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Task_>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all the authenticated user's task lists.
		/// Tasks_tasklists_list tasks/v1/users/@me/lists
		/// </summary>
		/// <param name="maxResults">Maximum number of task lists returned on one page. Optional. The default is 20 (max allowed: 100).</param>
		/// <param name="pageToken">Token specifying the result page to return. Optional.</param>
		/// <returns>Successful response</returns>
		public async Task<TaskLists> Tasks_tasklists_listAsync(int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/users/@me/lists?maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskLists>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new task list and adds it to the authenticated user's task lists.
		/// Tasks_tasklists_insert tasks/v1/users/@me/lists
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<TaskList> Tasks_tasklists_insertAsync(TaskList requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/users/@me/lists";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the authenticated user's specified task list.
		/// Tasks_tasklists_delete tasks/v1/users/@me/lists/{tasklist}
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <returns>Successful response</returns>
		public async Task Tasks_tasklists_deleteAsync(string tasklist, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/users/@me/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the authenticated user's specified task list.
		/// Tasks_tasklists_get tasks/v1/users/@me/lists/{tasklist}
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <returns>Successful response</returns>
		public async Task<TaskList> Tasks_tasklists_getAsync(string tasklist, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/users/@me/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the authenticated user's specified task list. This method supports patch semantics.
		/// Tasks_tasklists_patch tasks/v1/users/@me/lists/{tasklist}
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <returns>Successful response</returns>
		public async Task<TaskList> Tasks_tasklists_patchAsync(string tasklist, TaskList requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/users/@me/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the authenticated user's specified task list.
		/// Tasks_tasklists_update tasks/v1/users/@me/lists/{tasklist}
		/// </summary>
		/// <param name="tasklist">Task list identifier.</param>
		/// <returns>Successful response</returns>
		public async Task<TaskList> Tasks_tasklists_updateAsync(string tasklist, TaskList requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tasks/v1/users/@me/lists/"+ (tasklist==null? "" : System.Uri.EscapeDataString(tasklist));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TaskList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
