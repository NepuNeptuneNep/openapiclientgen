//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Annotation
	{
		
		/// <summary>
		/// Anchor text after excerpt. For requests, if the user bookmarked a screen that has no flowing text on it, then this field should be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="afterSelectedText")]
		public string AfterSelectedText { get; set; }
		
		/// <summary>
		/// Anchor text before excerpt. For requests, if the user bookmarked a screen that has no flowing text on it, then this field should be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="beforeSelectedText")]
		public string BeforeSelectedText { get; set; }
		
		/// <summary>
		/// Selection ranges sent from the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientVersionRanges")]
		public AnnotationClientVersionRanges ClientVersionRanges { get; set; }
		
		/// <summary>
		/// Timestamp for the created time of this annotation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Selection ranges for the most recent content version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersionRanges")]
		public AnnotationCurrentVersionRanges CurrentVersionRanges { get; set; }
		
		/// <summary>
		/// User-created data for this annotation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
		
		/// <summary>
		/// Indicates that this annotation is deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// The highlight style for this annotation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="highlightStyle")]
		public string HighlightStyle { get; set; }
		
		/// <summary>
		/// Id of this annotation, in the form of a GUID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The layer this annotation is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="layerId")]
		public string LayerId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="layerSummary")]
		public AnnotationLayerSummary LayerSummary { get; set; }
		
		/// <summary>
		/// Pages that this annotation spans.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pageIds")]
		public string[] PageIds { get; set; }
		
		/// <summary>
		/// Excerpt from the volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selectedText")]
		public string SelectedText { get; set; }
		
		/// <summary>
		/// URL to this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Timestamp for the last time this annotation was modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
		
		/// <summary>
		/// The volume that this annotation belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	public class AnnotationClientVersionRanges
	{
		
		[System.Runtime.Serialization.DataMember(Name="cfiRange")]
		public BooksAnnotationsRange CfiRange { get; set; }
		
		/// <summary>
		/// Content version the client sent in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentVersion")]
		public string ContentVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gbImageRange")]
		public BooksAnnotationsRange GbImageRange { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gbTextRange")]
		public BooksAnnotationsRange GbTextRange { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageCfiRange")]
		public BooksAnnotationsRange ImageCfiRange { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BooksAnnotationsRange
	{
		
		/// <summary>
		/// The offset from the ending position.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endOffset")]
		public string EndOffset { get; set; }
		
		/// <summary>
		/// The ending position for the range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endPosition")]
		public string EndPosition { get; set; }
		
		/// <summary>
		/// The offset from the starting position.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startOffset")]
		public string StartOffset { get; set; }
		
		/// <summary>
		/// The starting position for the range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startPosition")]
		public string StartPosition { get; set; }
	}
	
	public class AnnotationCurrentVersionRanges
	{
		
		[System.Runtime.Serialization.DataMember(Name="cfiRange")]
		public BooksAnnotationsRange CfiRange { get; set; }
		
		/// <summary>
		/// Content version applicable to ranges below.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentVersion")]
		public string ContentVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gbImageRange")]
		public BooksAnnotationsRange GbImageRange { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gbTextRange")]
		public BooksAnnotationsRange GbTextRange { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageCfiRange")]
		public BooksAnnotationsRange ImageCfiRange { get; set; }
	}
	
	public class AnnotationLayerSummary
	{
		
		/// <summary>
		/// Maximum allowed characters on this layer, especially for the "copy" layer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedCharacterCount")]
		public System.Nullable<System.Int32> AllowedCharacterCount { get; set; }
		
		/// <summary>
		/// Type of limitation on this layer. "limited" or "unlimited" for the "copy" layer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitType")]
		public string LimitType { get; set; }
		
		/// <summary>
		/// Remaining allowed characters on this layer, especially for the "copy" layer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remainingCharacterCount")]
		public System.Nullable<System.Int32> RemainingCharacterCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Annotations
	{
		
		/// <summary>
		/// A list of annotations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Annotation[] Items { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token to pass in for pagination for the next page. This will not be present if this request does not have more results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Total number of annotations found. This may be greater than the number of notes returned in this response if results have been paginated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalItems")]
		public System.Nullable<System.Int32> TotalItems { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AnnotationsSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="layers")]
		public AnnotationsSummaryLayers[] AnnotationsSummaryLayers { get; set; }
	}
	
	public class AnnotationsSummaryLayers
	{
		
		[System.Runtime.Serialization.DataMember(Name="allowedCharacterCount")]
		public System.Nullable<System.Int32> AllowedCharacterCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="layerId")]
		public string LayerId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="limitType")]
		public string LimitType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="remainingCharacterCount")]
		public System.Nullable<System.Int32> RemainingCharacterCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Annotationsdata
	{
		
		/// <summary>
		/// A list of Annotation Data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public GeoAnnotationdata[] Items { get; set; }
		
		/// <summary>
		/// Resource type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token to pass in for pagination for the next page. This will not be present if this request does not have more results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The total number of volume annotations found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalItems")]
		public System.Nullable<System.Int32> TotalItems { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GeoAnnotationdata
	{
		
		/// <summary>
		/// The type of annotation this data is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotationType")]
		public string AnnotationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Geolayerdata Data { get; set; }
		
		/// <summary>
		/// Base64 encoded data for this annotation data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encodedData")]
		public string EncodedData { get; set; }
		
		/// <summary>
		/// Unique id for this annotation data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Resource Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The Layer id for this data. *
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="layerId")]
		public string LayerId { get; set; }
		
		/// <summary>
		/// URL for this resource. *
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Timestamp for the last time this data was updated. (RFC 3339 UTC date-time format).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
		
		/// <summary>
		/// The volume id for this data. *
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Geolayerdata
	{
		
		[System.Runtime.Serialization.DataMember(Name="common")]
		public GeolayerdataCommon Common { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="geo")]
		public GeolayerdataGeo Geo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	public class GeolayerdataCommon
	{
		
		/// <summary>
		/// The language of the information url and description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lang")]
		public string Lang { get; set; }
		
		/// <summary>
		/// The URL for the preview image information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="previewImageUrl")]
		public string PreviewImageUrl { get; set; }
		
		/// <summary>
		/// The description for this location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snippet")]
		public string Snippet { get; set; }
		
		/// <summary>
		/// The URL for information for this location. Ex: wikipedia link.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snippetUrl")]
		public string SnippetUrl { get; set; }
		
		/// <summary>
		/// The display title and localized canonical name to use when searching for this entity on Google search.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class GeolayerdataGeo
	{
		
		/// <summary>
		/// The boundary of the location as a set of loops containing pairs of latitude, longitude coordinates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="boundary")]
		public string[] Boundary { get; set; }
		
		/// <summary>
		/// The cache policy active for this data. EX: UNRESTRICTED, RESTRICTED, NEVER
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cachePolicy")]
		public string CachePolicy { get; set; }
		
		/// <summary>
		/// The country code of the location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="countryCode")]
		public string CountryCode { get; set; }
		
		/// <summary>
		/// The latitude of the location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public System.Nullable<System.Double> Latitude { get; set; }
		
		/// <summary>
		/// The longitude of the location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public System.Nullable<System.Double> Longitude { get; set; }
		
		/// <summary>
		/// The type of map that should be used for this location. EX: HYBRID, ROADMAP, SATELLITE, TERRAIN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mapType")]
		public string MapType { get; set; }
		
		/// <summary>
		/// The viewport for showing this location. This is a latitude, longitude rectangle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="viewport")]
		public GeolayerdataGeoViewport Viewport { get; set; }
		
		/// <summary>
		/// The Zoom level to use for the map. Zoom levels between 0 (the lowest zoom level, in which the entire world can be seen on one map) to 21+ (down to individual buildings). See: https: //developers.google.com/maps/documentation/staticmaps/#Zoomlevels
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zoom")]
		public System.Nullable<System.Int32> Zoom { get; set; }
	}
	
	public class GeolayerdataGeoViewport
	{
		
		[System.Runtime.Serialization.DataMember(Name="hi")]
		public GeolayerdataGeoViewportHi Hi { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lo")]
		public GeolayerdataGeoViewportLo Lo { get; set; }
	}
	
	public class GeolayerdataGeoViewportHi
	{
		
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public System.Nullable<System.Double> Latitude { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public System.Nullable<System.Double> Longitude { get; set; }
	}
	
	public class GeolayerdataGeoViewportLo
	{
		
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public System.Nullable<System.Double> Latitude { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public System.Nullable<System.Double> Longitude { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BooksCloudloadingResource
	{
		
		[System.Runtime.Serialization.DataMember(Name="author")]
		public string Author { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="processingState")]
		public string ProcessingState { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BooksVolumesRecommendedRateResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="consistency_token")]
		public string Consistency_token { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Bookshelf
	{
		
		/// <summary>
		/// Whether this bookshelf is PUBLIC or PRIVATE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="access")]
		public string Access { get; set; }
		
		/// <summary>
		/// Created time for this bookshelf (formatted UTC timestamp with millisecond resolution).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Description of this bookshelf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Id of this bookshelf, only unique by user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Resource type for bookshelf metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// URL to this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Title of this bookshelf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Last modified time of this bookshelf (formatted UTC timestamp with millisecond resolution).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
		
		/// <summary>
		/// Number of volumes in this bookshelf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeCount")]
		public System.Nullable<System.Int32> VolumeCount { get; set; }
		
		/// <summary>
		/// Last time a volume was added or removed from this bookshelf (formatted UTC timestamp with millisecond resolution).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumesLastUpdated")]
		public string VolumesLastUpdated { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Bookshelves
	{
		
		/// <summary>
		/// A list of bookshelves.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Bookshelf[] Items { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Category
	{
		
		/// <summary>
		/// A list of onboarding categories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public CategoryItems[] CategoryItems { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	public class CategoryItems
	{
		
		[System.Runtime.Serialization.DataMember(Name="badgeUrl")]
		public string BadgeUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="categoryId")]
		public string CategoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConcurrentAccessRestriction
	{
		
		/// <summary>
		/// Whether access is granted for this (user, device, volume).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceAllowed")]
		public System.Nullable<System.Boolean> DeviceAllowed { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The maximum number of concurrent access licenses for this volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConcurrentDevices")]
		public System.Nullable<System.Int32> MaxConcurrentDevices { get; set; }
		
		/// <summary>
		/// Error/warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Client nonce for verification. Download access and client-validation only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nonce")]
		public string Nonce { get; set; }
		
		/// <summary>
		/// Error/warning reason code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reasonCode")]
		public string ReasonCode { get; set; }
		
		/// <summary>
		/// Whether this volume has any concurrent access restrictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted")]
		public System.Nullable<System.Boolean> Restricted { get; set; }
		
		/// <summary>
		/// Response signature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
		
		/// <summary>
		/// Client app identifier for verification. Download access and client-validation only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// Time in seconds for license auto-expiration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeWindowSeconds")]
		public System.Nullable<System.Int32> TimeWindowSeconds { get; set; }
		
		/// <summary>
		/// Identifies the volume for which this entry applies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DictionaryAnnotationdata
	{
		
		/// <summary>
		/// The type of annotation this data is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotationType")]
		public string AnnotationType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public Dictlayerdata Data { get; set; }
		
		/// <summary>
		/// Base64 encoded data for this annotation data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encodedData")]
		public string EncodedData { get; set; }
		
		/// <summary>
		/// Unique id for this annotation data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Resource Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The Layer id for this data. *
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="layerId")]
		public string LayerId { get; set; }
		
		/// <summary>
		/// URL for this resource. *
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Timestamp for the last time this data was updated. (RFC 3339 UTC date-time format).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
		
		/// <summary>
		/// The volume id for this data. *
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Dictlayerdata
	{
		
		[System.Runtime.Serialization.DataMember(Name="common")]
		public DictlayerdataCommon Common { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dict")]
		public DictlayerdataDict Dict { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	public class DictlayerdataCommon
	{
		
		/// <summary>
		/// The display title and localized canonical name to use when searching for this entity on Google search.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class DictlayerdataDict
	{
		
		/// <summary>
		/// The source, url and attribution for this dictionary data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public DictlayerdataDictSource Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="words")]
		public DictlayerdataDictWords[] DictlayerdataDictWords { get; set; }
	}
	
	public class DictlayerdataDictSource
	{
		
		[System.Runtime.Serialization.DataMember(Name="attribution")]
		public string Attribution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWords
	{
		
		[System.Runtime.Serialization.DataMember(Name="derivatives")]
		public DictlayerdataDictWordsDerivatives[] DictlayerdataDictWordsDerivatives { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="examples")]
		public DictlayerdataDictWordsExamples[] DictlayerdataDictWordsExamples { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="senses")]
		public DictlayerdataDictWordsSenses[] DictlayerdataDictWordsSenses { get; set; }
		
		/// <summary>
		/// The words with different meanings but not related words, e.g. "go" (game) and "go" (verb).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public DictlayerdataDictWordsSource Source { get; set; }
	}
	
	public class DictlayerdataDictWordsDerivatives
	{
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public DictlayerdataDictWordsDerivativesSource Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class DictlayerdataDictWordsDerivativesSource
	{
		
		[System.Runtime.Serialization.DataMember(Name="attribution")]
		public string Attribution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWordsExamples
	{
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public DictlayerdataDictWordsExamplesSource Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class DictlayerdataDictWordsExamplesSource
	{
		
		[System.Runtime.Serialization.DataMember(Name="attribution")]
		public string Attribution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWordsSenses
	{
		
		[System.Runtime.Serialization.DataMember(Name="conjugations")]
		public DictlayerdataDictWordsSensesConjugations[] DictlayerdataDictWordsSensesConjugations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="definitions")]
		public DictlayerdataDictWordsSensesDefinitions[] DictlayerdataDictWordsSensesDefinitions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="partOfSpeech")]
		public string PartOfSpeech { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pronunciation")]
		public string Pronunciation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pronunciationUrl")]
		public string PronunciationUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public DictlayerdataDictWordsSensesSource Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="syllabification")]
		public string Syllabification { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="synonyms")]
		public DictlayerdataDictWordsSensesSynonyms[] DictlayerdataDictWordsSensesSynonyms { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesConjugations
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesDefinitions
	{
		
		[System.Runtime.Serialization.DataMember(Name="definition")]
		public string Definition { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="examples")]
		public DictlayerdataDictWordsSensesDefinitionsExamples[] DictlayerdataDictWordsSensesDefinitionsExamples { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesDefinitionsExamples
	{
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public DictlayerdataDictWordsSensesDefinitionsExamplesSource Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesDefinitionsExamplesSource
	{
		
		[System.Runtime.Serialization.DataMember(Name="attribution")]
		public string Attribution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesSource
	{
		
		[System.Runtime.Serialization.DataMember(Name="attribution")]
		public string Attribution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesSynonyms
	{
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public DictlayerdataDictWordsSensesSynonymsSource Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class DictlayerdataDictWordsSensesSynonymsSource
	{
		
		[System.Runtime.Serialization.DataMember(Name="attribution")]
		public string Attribution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class DictlayerdataDictWordsSource
	{
		
		[System.Runtime.Serialization.DataMember(Name="attribution")]
		public string Attribution { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Discoveryclusters
	{
		
		[System.Runtime.Serialization.DataMember(Name="clusters")]
		public DiscoveryclustersClusters[] DiscoveryclustersClusters { get; set; }
		
		/// <summary>
		/// Resorce type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalClusters")]
		public System.Nullable<System.Int32> TotalClusters { get; set; }
	}
	
	public class DiscoveryclustersClusters
	{
		
		[System.Runtime.Serialization.DataMember(Name="banner_with_content_container")]
		public DiscoveryclustersClustersBanner_with_content_container Banner_with_content_container { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subTitle")]
		public string SubTitle { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalVolumes")]
		public System.Nullable<System.Int32> TotalVolumes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uid")]
		public string Uid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="volumes")]
		public Volume[] Volumes { get; set; }
	}
	
	public class DiscoveryclustersClustersBanner_with_content_container
	{
		
		[System.Runtime.Serialization.DataMember(Name="fillColorArgb")]
		public string FillColorArgb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageUrl")]
		public string ImageUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maskColorArgb")]
		public string MaskColorArgb { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="moreButtonText")]
		public string MoreButtonText { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="moreButtonUrl")]
		public string MoreButtonUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="textColorArgb")]
		public string TextColorArgb { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Volume
	{
		
		/// <summary>
		/// Any information about a volume related to reading or obtaining that volume text. This information can depend on country (books may be public domain in one country but not in another, e.g.).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessInfo")]
		public VolumeAccessInfo AccessInfo { get; set; }
		
		/// <summary>
		/// Opaque identifier for a specific version of a volume resource. (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Unique identifier for a volume. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Resource type for a volume. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// What layers exist in this volume and high level information about them.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="layerInfo")]
		public VolumeLayerInfo LayerInfo { get; set; }
		
		/// <summary>
		/// Recommendation related information for this volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recommendedInfo")]
		public VolumeRecommendedInfo RecommendedInfo { get; set; }
		
		/// <summary>
		/// Any information about a volume related to the eBookstore and/or purchaseability. This information can depend on the country where the request originates from (i.e. books may not be for sale in certain countries).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="saleInfo")]
		public VolumeSaleInfo SaleInfo { get; set; }
		
		/// <summary>
		/// Search result information related to this volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="searchInfo")]
		public VolumeSearchInfo SearchInfo { get; set; }
		
		/// <summary>
		/// URL to this resource. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// User specific information related to this volume. (e.g. page this user last read or whether they purchased this book)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userInfo")]
		public VolumeUserInfo UserInfo { get; set; }
		
		/// <summary>
		/// General volume information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeInfo")]
		public VolumeVolumeInfo VolumeInfo { get; set; }
	}
	
	public class VolumeAccessInfo
	{
		
		/// <summary>
		/// Combines the access and viewability of this volume into a single status field for this user. Values can be FULL_PURCHASED, FULL_PUBLIC_DOMAIN, SAMPLE or NONE. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessViewStatus")]
		public string AccessViewStatus { get; set; }
		
		/// <summary>
		/// The two-letter ISO_3166-1 country code for which this access information is valid. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="downloadAccess")]
		public DownloadAccessRestriction DownloadAccess { get; set; }
		
		/// <summary>
		/// URL to the Google Drive viewer if this volume is uploaded by the user by selecting the file from Google Drive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="driveImportedContentLink")]
		public string DriveImportedContentLink { get; set; }
		
		/// <summary>
		/// Whether this volume can be embedded in a viewport using the Embedded Viewer API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="embeddable")]
		public System.Nullable<System.Boolean> Embeddable { get; set; }
		
		/// <summary>
		/// Information about epub content. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="epub")]
		public VolumeAccessInfoEpub Epub { get; set; }
		
		/// <summary>
		/// Whether this volume requires that the client explicitly request offline download license rather than have it done automatically when loading the content, if the client supports it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="explicitOfflineLicenseManagement")]
		public System.Nullable<System.Boolean> ExplicitOfflineLicenseManagement { get; set; }
		
		/// <summary>
		/// Information about pdf content. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pdf")]
		public VolumeAccessInfoPdf Pdf { get; set; }
		
		/// <summary>
		/// Whether or not this book is public domain in the country listed above.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicDomain")]
		public System.Nullable<System.Boolean> PublicDomain { get; set; }
		
		/// <summary>
		/// Whether quote sharing is allowed for this volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quoteSharingAllowed")]
		public System.Nullable<System.Boolean> QuoteSharingAllowed { get; set; }
		
		/// <summary>
		/// Whether text-to-speech is permitted for this volume. Values can be ALLOWED, ALLOWED_FOR_ACCESSIBILITY, or NOT_ALLOWED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="textToSpeechPermission")]
		public string TextToSpeechPermission { get; set; }
		
		/// <summary>
		/// For ordered but not yet processed orders, we give a URL that can be used to go to the appropriate Google Wallet page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="viewOrderUrl")]
		public string ViewOrderUrl { get; set; }
		
		/// <summary>
		/// The read access of a volume. Possible values are PARTIAL, ALL_PAGES, NO_PAGES or UNKNOWN. This value depends on the country listed above. A value of PARTIAL means that the publisher has allowed some portion of the volume to be viewed publicly, without purchase. This can apply to eBooks as well as non-eBooks. Public domain books will always have a value of ALL_PAGES.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="viewability")]
		public string Viewability { get; set; }
		
		/// <summary>
		/// URL to read this volume on the Google Books site. Link will not allow users to read non-viewable volumes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="webReaderLink")]
		public string WebReaderLink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DownloadAccessRestriction
	{
		
		/// <summary>
		/// If restricted, whether access is granted for this (user, device, volume).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceAllowed")]
		public System.Nullable<System.Boolean> DeviceAllowed { get; set; }
		
		/// <summary>
		/// If restricted, the number of content download licenses already acquired (including the requesting client, if licensed).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadsAcquired")]
		public System.Nullable<System.Int32> DownloadsAcquired { get; set; }
		
		/// <summary>
		/// If deviceAllowed, whether access was just acquired with this request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="justAcquired")]
		public System.Nullable<System.Boolean> JustAcquired { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// If restricted, the maximum number of content download licenses for this volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxDownloadDevices")]
		public System.Nullable<System.Int32> MaxDownloadDevices { get; set; }
		
		/// <summary>
		/// Error/warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Client nonce for verification. Download access and client-validation only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nonce")]
		public string Nonce { get; set; }
		
		/// <summary>
		/// Error/warning reason code. Additional codes may be added in the future. 0 OK 100 ACCESS_DENIED_PUBLISHER_LIMIT 101 ACCESS_DENIED_LIMIT 200 WARNING_USED_LAST_ACCESS
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reasonCode")]
		public string ReasonCode { get; set; }
		
		/// <summary>
		/// Whether this volume has any download access restrictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restricted")]
		public System.Nullable<System.Boolean> Restricted { get; set; }
		
		/// <summary>
		/// Response signature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
		
		/// <summary>
		/// Client app identifier for verification. Download access and client-validation only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// Identifies the volume for which this entry applies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	public class VolumeAccessInfoEpub
	{
		
		/// <summary>
		/// URL to retrieve ACS token for epub download. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acsTokenLink")]
		public string AcsTokenLink { get; set; }
		
		/// <summary>
		/// URL to download epub. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadLink")]
		public string DownloadLink { get; set; }
		
		/// <summary>
		/// Is a flowing text epub available either as public domain or for purchase. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAvailable")]
		public System.Nullable<System.Boolean> IsAvailable { get; set; }
	}
	
	public class VolumeAccessInfoPdf
	{
		
		/// <summary>
		/// URL to retrieve ACS token for pdf download. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acsTokenLink")]
		public string AcsTokenLink { get; set; }
		
		/// <summary>
		/// URL to download pdf. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadLink")]
		public string DownloadLink { get; set; }
		
		/// <summary>
		/// Is a scanned image pdf available either as public domain or for purchase. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAvailable")]
		public System.Nullable<System.Boolean> IsAvailable { get; set; }
	}
	
	public class VolumeLayerInfo
	{
		
		/// <summary>
		/// A layer should appear here if and only if the layer exists for this book.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="layers")]
		public VolumeLayerInfoLayers[] VolumeLayerInfoLayers { get; set; }
	}
	
	public class VolumeLayerInfoLayers
	{
		
		/// <summary>
		/// The layer id of this layer (e.g. "geo").
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="layerId")]
		public string LayerId { get; set; }
		
		/// <summary>
		/// The current version of this layer's volume annotations. Note that this version applies only to the data in the books.layers.volumeAnnotations.* responses. The actual annotation data is versioned separately.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeAnnotationsVersion")]
		public string VolumeAnnotationsVersion { get; set; }
	}
	
	public class VolumeRecommendedInfo
	{
		
		/// <summary>
		/// A text explaining why this volume is recommended.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="explanation")]
		public string Explanation { get; set; }
	}
	
	public class VolumeSaleInfo
	{
		
		/// <summary>
		/// URL to purchase this volume on the Google Books site. (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="buyLink")]
		public string BuyLink { get; set; }
		
		/// <summary>
		/// The two-letter ISO_3166-1 country code for which this sale information is valid. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Whether or not this volume is an eBook (can be added to the My eBooks shelf).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isEbook")]
		public System.Nullable<System.Boolean> IsEbook { get; set; }
		
		/// <summary>
		/// Suggested retail price. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listPrice")]
		public VolumeSaleInfoListPrice ListPrice { get; set; }
		
		/// <summary>
		/// Offers available for this volume (sales and rentals).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="offers")]
		public VolumeSaleInfoOffers[] VolumeSaleInfoOffers { get; set; }
		
		/// <summary>
		/// The date on which this book is available for sale.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="onSaleDate")]
		public string OnSaleDate { get; set; }
		
		/// <summary>
		/// The actual selling price of the book. This is the same as the suggested retail or list price unless there are offers or discounts on this volume. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retailPrice")]
		public VolumeSaleInfoRetailPrice RetailPrice { get; set; }
		
		/// <summary>
		/// Whether or not this book is available for sale or offered for free in the Google eBookstore for the country listed above. Possible values are FOR_SALE, FOR_RENTAL_ONLY, FOR_SALE_AND_RENTAL, FREE, NOT_FOR_SALE, or FOR_PREORDER.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="saleability")]
		public string Saleability { get; set; }
	}
	
	public class VolumeSaleInfoListPrice
	{
		
		/// <summary>
		/// Amount in the currency listed below. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// An ISO 4217, three-letter currency code. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currencyCode")]
		public string CurrencyCode { get; set; }
	}
	
	public class VolumeSaleInfoOffers
	{
		
		/// <summary>
		/// The finsky offer type (e.g., PURCHASE=0 RENTAL=3)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="finskyOfferType")]
		public System.Nullable<System.Int32> FinskyOfferType { get; set; }
		
		/// <summary>
		/// Indicates whether the offer is giftable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="giftable")]
		public System.Nullable<System.Boolean> Giftable { get; set; }
		
		/// <summary>
		/// Offer list (=undiscounted) price in Micros.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listPrice")]
		public VolumeSaleInfoOffersListPrice ListPrice { get; set; }
		
		/// <summary>
		/// The rental duration (for rental offers only).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rentalDuration")]
		public VolumeSaleInfoOffersRentalDuration RentalDuration { get; set; }
		
		/// <summary>
		/// Offer retail (=discounted) price in Micros
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retailPrice")]
		public VolumeSaleInfoOffersRetailPrice RetailPrice { get; set; }
	}
	
	public class VolumeSaleInfoOffersListPrice
	{
		
		[System.Runtime.Serialization.DataMember(Name="amountInMicros")]
		public System.Nullable<System.Double> AmountInMicros { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="currencyCode")]
		public string CurrencyCode { get; set; }
	}
	
	public class VolumeSaleInfoOffersRentalDuration
	{
		
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Double> Count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="unit")]
		public string Unit { get; set; }
	}
	
	public class VolumeSaleInfoOffersRetailPrice
	{
		
		[System.Runtime.Serialization.DataMember(Name="amountInMicros")]
		public System.Nullable<System.Double> AmountInMicros { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="currencyCode")]
		public string CurrencyCode { get; set; }
	}
	
	public class VolumeSaleInfoRetailPrice
	{
		
		/// <summary>
		/// Amount in the currency listed below. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public System.Nullable<System.Double> Amount { get; set; }
		
		/// <summary>
		/// An ISO 4217, three-letter currency code. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currencyCode")]
		public string CurrencyCode { get; set; }
	}
	
	public class VolumeSearchInfo
	{
		
		/// <summary>
		/// A text snippet containing the search query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="textSnippet")]
		public string TextSnippet { get; set; }
	}
	
	public class VolumeUserInfo
	{
		
		/// <summary>
		/// Timestamp when this volume was acquired by the user. (RFC 3339 UTC date-time format) Acquiring includes purchase, user upload, receiving family sharing, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acquiredTime")]
		public string AcquiredTime { get; set; }
		
		/// <summary>
		/// How this volume was acquired.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acquisitionType")]
		public System.Nullable<System.Int32> AcquisitionType { get; set; }
		
		/// <summary>
		/// Copy/Paste accounting information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="copy")]
		public VolumeUserInfoCopy Copy { get; set; }
		
		/// <summary>
		/// Whether this volume is purchased, sample, pd download etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entitlementType")]
		public System.Nullable<System.Int32> EntitlementType { get; set; }
		
		/// <summary>
		/// Information on the ability to share with the family.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="familySharing")]
		public VolumeUserInfoFamilySharing FamilySharing { get; set; }
		
		/// <summary>
		/// Whether or not the user shared this volume with the family.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isFamilySharedFromUser")]
		public System.Nullable<System.Boolean> IsFamilySharedFromUser { get; set; }
		
		/// <summary>
		/// Whether or not the user received this volume through family sharing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isFamilySharedToUser")]
		public System.Nullable<System.Boolean> IsFamilySharedToUser { get; set; }
		
		/// <summary>
		/// Deprecated: Replaced by familySharing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isFamilySharingAllowed")]
		public System.Nullable<System.Boolean> IsFamilySharingAllowed { get; set; }
		
		/// <summary>
		/// Deprecated: Replaced by familySharing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isFamilySharingDisabledByFop")]
		public System.Nullable<System.Boolean> IsFamilySharingDisabledByFop { get; set; }
		
		/// <summary>
		/// Whether or not this volume is currently in "my books."
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isInMyBooks")]
		public System.Nullable<System.Boolean> IsInMyBooks { get; set; }
		
		/// <summary>
		/// Whether or not this volume was pre-ordered by the authenticated user making the request. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPreordered")]
		public System.Nullable<System.Boolean> IsPreordered { get; set; }
		
		/// <summary>
		/// Whether or not this volume was purchased by the authenticated user making the request. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isPurchased")]
		public System.Nullable<System.Boolean> IsPurchased { get; set; }
		
		/// <summary>
		/// Whether or not this volume was user uploaded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isUploaded")]
		public System.Nullable<System.Boolean> IsUploaded { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="readingPosition")]
		public ReadingPosition ReadingPosition { get; set; }
		
		/// <summary>
		/// Period during this book is/was a valid rental.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rentalPeriod")]
		public VolumeUserInfoRentalPeriod RentalPeriod { get; set; }
		
		/// <summary>
		/// Whether this book is an active or an expired rental.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rentalState")]
		public string RentalState { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="review")]
		public Review Review { get; set; }
		
		/// <summary>
		/// Timestamp when this volume was last modified by a user action, such as a reading position update, volume purchase or writing a review. (RFC 3339 UTC date-time format).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="userUploadedVolumeInfo")]
		public VolumeUserInfoUserUploadedVolumeInfo UserUploadedVolumeInfo { get; set; }
	}
	
	public class VolumeUserInfoCopy
	{
		
		[System.Runtime.Serialization.DataMember(Name="allowedCharacterCount")]
		public System.Nullable<System.Int32> AllowedCharacterCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="limitType")]
		public string LimitType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="remainingCharacterCount")]
		public System.Nullable<System.Int32> RemainingCharacterCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
	}
	
	public class VolumeUserInfoFamilySharing
	{
		
		/// <summary>
		/// The role of the user in the family.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="familyRole")]
		public string FamilyRole { get; set; }
		
		/// <summary>
		/// Whether or not this volume can be shared with the family by the user. This includes sharing eligibility of both the volume and the user. If the value is true, the user can initiate a family sharing action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isSharingAllowed")]
		public System.Nullable<System.Boolean> IsSharingAllowed { get; set; }
		
		/// <summary>
		/// Whether or not sharing this volume is temporarily disabled due to issues with the Family Wallet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isSharingDisabledByFop")]
		public System.Nullable<System.Boolean> IsSharingDisabledByFop { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReadingPosition
	{
		
		/// <summary>
		/// Position in an EPUB as a CFI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="epubCfiPosition")]
		public string EpubCfiPosition { get; set; }
		
		/// <summary>
		/// Position in a volume for image-based content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gbImagePosition")]
		public string GbImagePosition { get; set; }
		
		/// <summary>
		/// Position in a volume for text-based content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gbTextPosition")]
		public string GbTextPosition { get; set; }
		
		/// <summary>
		/// Resource type for a reading position.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Position in a PDF file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pdfPosition")]
		public string PdfPosition { get; set; }
		
		/// <summary>
		/// Timestamp when this reading position was last updated (formatted UTC timestamp with millisecond resolution).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
		
		/// <summary>
		/// Volume id associated with this reading position.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	public class VolumeUserInfoRentalPeriod
	{
		
		[System.Runtime.Serialization.DataMember(Name="endUtcSec")]
		public string EndUtcSec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startUtcSec")]
		public string StartUtcSec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Review
	{
		
		/// <summary>
		/// Author of this review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author")]
		public ReviewAuthor Author { get; set; }
		
		/// <summary>
		/// Review text.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Date of this review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date")]
		public string Date { get; set; }
		
		/// <summary>
		/// URL for the full review text, for reviews gathered from the web.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullTextUrl")]
		public string FullTextUrl { get; set; }
		
		/// <summary>
		/// Resource type for a review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Star rating for this review. Possible values are ONE, TWO, THREE, FOUR, FIVE or NOT_RATED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rating")]
		public string Rating { get; set; }
		
		/// <summary>
		/// Information regarding the source of this review, when the review is not from a Google Books user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public ReviewSource Source { get; set; }
		
		/// <summary>
		/// Title for this review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// Source type for this review. Possible values are EDITORIAL, WEB_USER or GOOGLE_USER.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Volume that this review is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	public class ReviewAuthor
	{
		
		/// <summary>
		/// Name of this person.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
	}
	
	public class ReviewSource
	{
		
		/// <summary>
		/// Name of the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Extra text about the source of the review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extraDescription")]
		public string ExtraDescription { get; set; }
		
		/// <summary>
		/// URL of the source of the review.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class VolumeUserInfoUserUploadedVolumeInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="processingState")]
		public string ProcessingState { get; set; }
	}
	
	public class VolumeVolumeInfo
	{
		
		/// <summary>
		/// Whether anonymous logging should be allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowAnonLogging")]
		public System.Nullable<System.Boolean> AllowAnonLogging { get; set; }
		
		/// <summary>
		/// The names of the authors and/or editors for this volume. (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authors")]
		public string[] Authors { get; set; }
		
		/// <summary>
		/// The mean review rating for this volume. (min = 1.0, max = 5.0)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="averageRating")]
		public System.Nullable<System.Double> AverageRating { get; set; }
		
		/// <summary>
		/// Canonical URL for a volume. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canonicalVolumeLink")]
		public string CanonicalVolumeLink { get; set; }
		
		/// <summary>
		/// A list of subject categories, such as "Fiction", "Suspense", etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="categories")]
		public string[] Categories { get; set; }
		
		/// <summary>
		/// Whether the volume has comics content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comicsContent")]
		public System.Nullable<System.Boolean> ComicsContent { get; set; }
		
		/// <summary>
		/// An identifier for the version of the volume content (text & images). (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentVersion")]
		public string ContentVersion { get; set; }
		
		/// <summary>
		/// A synopsis of the volume. The text of the description is formatted in HTML and includes simple formatting elements, such as b, i, and br tags. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Physical dimensions of this volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dimensions")]
		public VolumeVolumeInfoDimensions Dimensions { get; set; }
		
		/// <summary>
		/// A list of image links for all the sizes that are available. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageLinks")]
		public VolumeVolumeInfoImageLinks ImageLinks { get; set; }
		
		/// <summary>
		/// Industry standard identifiers for this volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="industryIdentifiers")]
		public VolumeVolumeInfoIndustryIdentifiers[] VolumeVolumeInfoIndustryIdentifiers { get; set; }
		
		/// <summary>
		/// URL to view information about this volume on the Google Books site. (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="infoLink")]
		public string InfoLink { get; set; }
		
		/// <summary>
		/// Best language for this volume (based on content). It is the two-letter ISO 639-1 code such as 'fr', 'en', etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// The main category to which this volume belongs. It will be the category from the categories list returned below that has the highest weight.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mainCategory")]
		public string MainCategory { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maturityRating")]
		public string MaturityRating { get; set; }
		
		/// <summary>
		/// Total number of pages as per publisher metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pageCount")]
		public System.Nullable<System.Int32> PageCount { get; set; }
		
		/// <summary>
		/// A top-level summary of the panelization info in this volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="panelizationSummary")]
		public VolumeVolumeInfoPanelizationSummary PanelizationSummary { get; set; }
		
		/// <summary>
		/// URL to preview this volume on the Google Books site.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="previewLink")]
		public string PreviewLink { get; set; }
		
		/// <summary>
		/// Type of publication of this volume. Possible values are BOOK or MAGAZINE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="printType")]
		public string PrintType { get; set; }
		
		/// <summary>
		/// Total number of printed pages in generated pdf representation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="printedPageCount")]
		public System.Nullable<System.Int32> PrintedPageCount { get; set; }
		
		/// <summary>
		/// Date of publication. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publishedDate")]
		public string PublishedDate { get; set; }
		
		/// <summary>
		/// Publisher of this volume. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publisher")]
		public string Publisher { get; set; }
		
		/// <summary>
		/// The number of review ratings for this volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ratingsCount")]
		public System.Nullable<System.Int32> RatingsCount { get; set; }
		
		/// <summary>
		/// The reading modes available for this volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="readingModes")]
		public VolumeVolumeInfoReadingModes ReadingModes { get; set; }
		
		/// <summary>
		/// Total number of sample pages as per publisher metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="samplePageCount")]
		public System.Nullable<System.Int32> SamplePageCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seriesInfo")]
		public Volumeseriesinfo SeriesInfo { get; set; }
		
		/// <summary>
		/// Volume subtitle. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subtitle")]
		public string Subtitle { get; set; }
		
		/// <summary>
		/// Volume title. (In LITE projection.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class VolumeVolumeInfoDimensions
	{
		
		/// <summary>
		/// Height or length of this volume (in cm).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public string Height { get; set; }
		
		/// <summary>
		/// Thickness of this volume (in cm).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thickness")]
		public string Thickness { get; set; }
		
		/// <summary>
		/// Width of this volume (in cm).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public string Width { get; set; }
	}
	
	public class VolumeVolumeInfoImageLinks
	{
		
		/// <summary>
		/// Image link for extra large size (width of ~1280 pixels). (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extraLarge")]
		public string ExtraLarge { get; set; }
		
		/// <summary>
		/// Image link for large size (width of ~800 pixels). (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="large")]
		public string Large { get; set; }
		
		/// <summary>
		/// Image link for medium size (width of ~575 pixels). (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="medium")]
		public string Medium { get; set; }
		
		/// <summary>
		/// Image link for small size (width of ~300 pixels). (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="small")]
		public string Small { get; set; }
		
		/// <summary>
		/// Image link for small thumbnail size (width of ~80 pixels). (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="smallThumbnail")]
		public string SmallThumbnail { get; set; }
		
		/// <summary>
		/// Image link for thumbnail size (width of ~128 pixels). (In LITE projection)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnail")]
		public string Thumbnail { get; set; }
	}
	
	public class VolumeVolumeInfoIndustryIdentifiers
	{
		
		/// <summary>
		/// Industry specific volume identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="identifier")]
		public string Identifier { get; set; }
		
		/// <summary>
		/// Identifier type. Possible values are ISBN_10, ISBN_13, ISSN and OTHER.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class VolumeVolumeInfoPanelizationSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="containsEpubBubbles")]
		public System.Nullable<System.Boolean> ContainsEpubBubbles { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="containsImageBubbles")]
		public System.Nullable<System.Boolean> ContainsImageBubbles { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="epubBubbleVersion")]
		public string EpubBubbleVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageBubbleVersion")]
		public string ImageBubbleVersion { get; set; }
	}
	
	public class VolumeVolumeInfoReadingModes
	{
		
		[System.Runtime.Serialization.DataMember(Name="image")]
		public System.Nullable<System.Boolean> Image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="text")]
		public System.Nullable<System.Boolean> Text { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Volumeseriesinfo
	{
		
		/// <summary>
		/// The display number string. This should be used only for display purposes and the actual sequence should be inferred from the below orderNumber.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bookDisplayNumber")]
		public string BookDisplayNumber { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Short book title in the context of the series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortSeriesBookTitle")]
		public string ShortSeriesBookTitle { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="volumeSeries")]
		public VolumeseriesinfoVolumeSeries[] VolumeseriesinfoVolumeSeries { get; set; }
	}
	
	public class VolumeseriesinfoVolumeSeries
	{
		
		/// <summary>
		/// List of issues. Applicable only for Collection Edition and Omnibus.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issue")]
		public VolumeseriesinfoVolumeSeriesIssue[] VolumeseriesinfoVolumeSeriesIssue { get; set; }
		
		/// <summary>
		/// The book order number in the series.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orderNumber")]
		public System.Nullable<System.Int32> OrderNumber { get; set; }
		
		/// <summary>
		/// The book type in the context of series. Examples - Single Issue, Collection Edition, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seriesBookType")]
		public string SeriesBookType { get; set; }
		
		/// <summary>
		/// The series id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seriesId")]
		public string SeriesId { get; set; }
	}
	
	public class VolumeseriesinfoVolumeSeriesIssue
	{
		
		[System.Runtime.Serialization.DataMember(Name="issueDisplayNumber")]
		public string IssueDisplayNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="issueOrderNumber")]
		public System.Nullable<System.Int32> IssueOrderNumber { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DownloadAccesses
	{
		
		/// <summary>
		/// A list of download access responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadAccessList")]
		public DownloadAccessRestriction[] DownloadAccessList { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Empty
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FamilyInfo
	{
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Family membership info of the user that made the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="membership")]
		public FamilyInfoMembership Membership { get; set; }
	}
	
	public class FamilyInfoMembership
	{
		
		/// <summary>
		/// Restrictions on user buying and acquiring content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acquirePermission")]
		public string AcquirePermission { get; set; }
		
		/// <summary>
		/// The age group of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ageGroup")]
		public string AgeGroup { get; set; }
		
		/// <summary>
		/// The maximum allowed maturity rating for the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedMaturityRating")]
		public string AllowedMaturityRating { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isInFamily")]
		public System.Nullable<System.Boolean> IsInFamily { get; set; }
		
		/// <summary>
		/// The role of the user in the family.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Layersummaries
	{
		
		/// <summary>
		/// A list of layer summary items.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Layersummary[] Items { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The total number of layer summaries found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalItems")]
		public System.Nullable<System.Int32> TotalItems { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Layersummary
	{
		
		/// <summary>
		/// The number of annotations for this layer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotationCount")]
		public System.Nullable<System.Int32> AnnotationCount { get; set; }
		
		/// <summary>
		/// The list of annotation types contained for this layer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotationTypes")]
		public string[] AnnotationTypes { get; set; }
		
		/// <summary>
		/// Link to get data for this annotation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotationsDataLink")]
		public string AnnotationsDataLink { get; set; }
		
		/// <summary>
		/// The link to get the annotations for this layer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotationsLink")]
		public string AnnotationsLink { get; set; }
		
		/// <summary>
		/// The content version this resource is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentVersion")]
		public string ContentVersion { get; set; }
		
		/// <summary>
		/// The number of data items for this layer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataCount")]
		public System.Nullable<System.Int32> DataCount { get; set; }
		
		/// <summary>
		/// Unique id of this layer summary.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Resource Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The layer id for this summary.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="layerId")]
		public string LayerId { get; set; }
		
		/// <summary>
		/// URL to this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Timestamp for the last time an item in this layer was updated. (RFC 3339 UTC date-time format).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
		
		/// <summary>
		/// The current version of this layer's volume annotations. Note that this version applies only to the data in the books.layers.volumeAnnotations.* responses. The actual annotation data is versioned separately.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeAnnotationsVersion")]
		public string VolumeAnnotationsVersion { get; set; }
		
		/// <summary>
		/// The volume id this resource is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Metadata
	{
		
		/// <summary>
		/// A list of offline dictionary metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public MetadataItems[] MetadataItems { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	public class MetadataItems
	{
		
		[System.Runtime.Serialization.DataMember(Name="download_url")]
		public string Download_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="encrypted_key")]
		public string Encrypted_key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public string Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Notification
	{
		
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// The list of crm experiment ids.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="crmExperimentIds")]
		public string[] CrmExperimentIds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="doc_id")]
		public string Doc_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="doc_type")]
		public string Doc_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dont_show_notification")]
		public System.Nullable<System.Boolean> Dont_show_notification { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="iconUrl")]
		public string IconUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="is_document_mature")]
		public System.Nullable<System.Boolean> Is_document_mature { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notificationGroup")]
		public string NotificationGroup { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notification_type")]
		public string Notification_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pcampaign_id")]
		public string Pcampaign_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="show_notification_settings_action")]
		public System.Nullable<System.Boolean> Show_notification_settings_action { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="targetUrl")]
		public string TargetUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timeToExpireMs")]
		public string TimeToExpireMs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Offers
	{
		
		/// <summary>
		/// A list of offers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public OffersItems[] OffersItems { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	public class OffersItems
	{
		
		[System.Runtime.Serialization.DataMember(Name="artUrl")]
		public string ArtUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gservicesKey")]
		public string GservicesKey { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public OffersItemsItems[] OffersItemsItems { get; set; }
	}
	
	public class OffersItemsItems
	{
		
		[System.Runtime.Serialization.DataMember(Name="author")]
		public string Author { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="canonicalVolumeLink")]
		public string CanonicalVolumeLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="coverUrl")]
		public string CoverUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RequestAccessData
	{
		
		[System.Runtime.Serialization.DataMember(Name="concurrentAccess")]
		public ConcurrentAccessRestriction ConcurrentAccess { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="downloadAccess")]
		public DownloadAccessRestriction DownloadAccess { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Series
	{
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="series")]
		public SeriesSeries1[] SeriesSeries1 { get; set; }
	}
	
	public class SeriesSeries1
	{
		
		[System.Runtime.Serialization.DataMember(Name="bannerImageUrl")]
		public string BannerImageUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="eligibleForSubscription")]
		public System.Nullable<System.Boolean> EligibleForSubscription { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageUrl")]
		public string ImageUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isComplete")]
		public System.Nullable<System.Boolean> IsComplete { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seriesFormatType")]
		public string SeriesFormatType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seriesId")]
		public string SeriesId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seriesSubscriptionReleaseInfo")]
		public SeriesSeries1SeriesSubscriptionReleaseInfo SeriesSubscriptionReleaseInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seriesType")]
		public string SeriesType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscriptionId")]
		public string SubscriptionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class SeriesSeries1SeriesSubscriptionReleaseInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="cancelTime")]
		public string CancelTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="currentReleaseInfo")]
		public SeriesSeries1SeriesSubscriptionReleaseInfoCurrentReleaseInfo CurrentReleaseInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextReleaseInfo")]
		public SeriesSeries1SeriesSubscriptionReleaseInfoNextReleaseInfo NextReleaseInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="seriesSubscriptionType")]
		public string SeriesSubscriptionType { get; set; }
	}
	
	public class SeriesSeries1SeriesSubscriptionReleaseInfoCurrentReleaseInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="amountInMicros")]
		public System.Nullable<System.Double> AmountInMicros { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="currencyCode")]
		public string CurrencyCode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="releaseNumber")]
		public string ReleaseNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="releaseTime")]
		public string ReleaseTime { get; set; }
	}
	
	public class SeriesSeries1SeriesSubscriptionReleaseInfoNextReleaseInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="amountInMicros")]
		public System.Nullable<System.Double> AmountInMicros { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="currencyCode")]
		public string CurrencyCode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="releaseNumber")]
		public string ReleaseNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="releaseTime")]
		public string ReleaseTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Seriesmembership
	{
		
		/// <summary>
		/// Resorce type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="member")]
		public Volume[] Member { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Usersettings
	{
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// User settings in sub-objects, each for different purposes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notesExport")]
		public UsersettingsNotesExport NotesExport { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notification")]
		public UsersettingsNotification Notification { get; set; }
	}
	
	public class UsersettingsNotesExport
	{
		
		[System.Runtime.Serialization.DataMember(Name="folderName")]
		public string FolderName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="isEnabled")]
		public System.Nullable<System.Boolean> IsEnabled { get; set; }
	}
	
	public class UsersettingsNotification
	{
		
		[System.Runtime.Serialization.DataMember(Name="matchMyInterests")]
		public UsersettingsNotificationMatchMyInterests MatchMyInterests { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="moreFromAuthors")]
		public UsersettingsNotificationMoreFromAuthors MoreFromAuthors { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="moreFromSeries")]
		public UsersettingsNotificationMoreFromSeries MoreFromSeries { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="priceDrop")]
		public UsersettingsNotificationPriceDrop PriceDrop { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rewardExpirations")]
		public UsersettingsNotificationRewardExpirations RewardExpirations { get; set; }
	}
	
	public class UsersettingsNotificationMatchMyInterests
	{
		
		[System.Runtime.Serialization.DataMember(Name="opted_state")]
		public string Opted_state { get; set; }
	}
	
	public class UsersettingsNotificationMoreFromAuthors
	{
		
		[System.Runtime.Serialization.DataMember(Name="opted_state")]
		public string Opted_state { get; set; }
	}
	
	public class UsersettingsNotificationMoreFromSeries
	{
		
		[System.Runtime.Serialization.DataMember(Name="opted_state")]
		public string Opted_state { get; set; }
	}
	
	public class UsersettingsNotificationPriceDrop
	{
		
		[System.Runtime.Serialization.DataMember(Name="opted_state")]
		public string Opted_state { get; set; }
	}
	
	public class UsersettingsNotificationRewardExpirations
	{
		
		[System.Runtime.Serialization.DataMember(Name="opted_state")]
		public string Opted_state { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Volume2
	{
		
		/// <summary>
		/// A list of volumes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Volume[] Items { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Volumeannotation
	{
		
		/// <summary>
		/// The annotation data id for this volume annotation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotationDataId")]
		public string AnnotationDataId { get; set; }
		
		/// <summary>
		/// Link to get data for this annotation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotationDataLink")]
		public string AnnotationDataLink { get; set; }
		
		/// <summary>
		/// The type of annotation this is.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotationType")]
		public string AnnotationType { get; set; }
		
		/// <summary>
		/// The content ranges to identify the selected text.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentRanges")]
		public VolumeannotationContentRanges ContentRanges { get; set; }
		
		/// <summary>
		/// Data for this annotation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
		
		/// <summary>
		/// Indicates that this annotation is deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// Unique id of this volume annotation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Resource Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The Layer this annotation is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="layerId")]
		public string LayerId { get; set; }
		
		/// <summary>
		/// Pages the annotation spans.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pageIds")]
		public string[] PageIds { get; set; }
		
		/// <summary>
		/// Excerpt from the volume.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selectedText")]
		public string SelectedText { get; set; }
		
		/// <summary>
		/// URL to this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Timestamp for the last time this anntoation was updated. (RFC 3339 UTC date-time format).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string Updated { get; set; }
		
		/// <summary>
		/// The Volume this annotation is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	public class VolumeannotationContentRanges
	{
		
		[System.Runtime.Serialization.DataMember(Name="cfiRange")]
		public BooksAnnotationsRange CfiRange { get; set; }
		
		/// <summary>
		/// Content version applicable to ranges below.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentVersion")]
		public string ContentVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gbImageRange")]
		public BooksAnnotationsRange GbImageRange { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gbTextRange")]
		public BooksAnnotationsRange GbTextRange { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Volumeannotations
	{
		
		/// <summary>
		/// A list of volume annotations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Volumeannotation[] Items { get; set; }
		
		/// <summary>
		/// Resource type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token to pass in for pagination for the next page. This will not be present if this request does not have more results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The total number of volume annotations found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalItems")]
		public System.Nullable<System.Int32> TotalItems { get; set; }
		
		/// <summary>
		/// The version string for all of the volume annotations in this layer (not just the ones in this response). Note: the version string doesn't apply to the annotation data, just the information in this response (e.g. the location of annotations in the book).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Volumes
	{
		
		/// <summary>
		/// A list of volumes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Volume[] Items { get; set; }
		
		/// <summary>
		/// Resource type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Total number of volumes found. This might be greater than the number of volumes returned in this response if results have been paginated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalItems")]
		public System.Nullable<System.Int32> TotalItems { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Add a user-upload volume and triggers processing.
		/// Books_cloudloading_addBook books/v1/cloudloading/addBook
		/// </summary>
		/// <param name="drive_document_id">A drive document id. The upload_client_token must not be set.</param>
		/// <param name="mime_type">The document MIME type. It can be set only if the drive_document_id is set.</param>
		/// <param name="name">The document name. It can be set only if the drive_document_id is set.</param>
		/// <param name="upload_client_token">Scotty upload token.</param>
		/// <returns>Successful response</returns>
		public async Task<BooksCloudloadingResource> Books_cloudloading_addBookAsync(string drive_document_id, string mime_type, string name, string upload_client_token, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/cloudloading/addBook?drive_document_id=" + (drive_document_id==null? "" : System.Uri.EscapeDataString(drive_document_id))+"&mime_type=" + (mime_type==null? "" : System.Uri.EscapeDataString(mime_type))+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&upload_client_token=" + (upload_client_token==null? "" : System.Uri.EscapeDataString(upload_client_token));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<BooksCloudloadingResource>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove the book and its contents
		/// Books_cloudloading_deleteBook books/v1/cloudloading/deleteBook
		/// </summary>
		/// <param name="volumeId">The id of the book to be removed.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_cloudloading_deleteBookAsync(string volumeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/cloudloading/deleteBook?volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates a user-upload volume.
		/// Books_cloudloading_updateBook books/v1/cloudloading/updateBook
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<BooksCloudloadingResource> Books_cloudloading_updateBookAsync(BooksCloudloadingResource requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/cloudloading/updateBook";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<BooksCloudloadingResource>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a list of offline dictionary metadata available
		/// Books_dictionary_listOfflineMetadata books/v1/dictionary/listOfflineMetadata
		/// </summary>
		/// <param name="cpksver">The device/version ID from which to request the data.</param>
		/// <returns>Successful response</returns>
		public async Task<Metadata> Books_dictionary_listOfflineMetadataAsync(string cpksver, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/dictionary/listOfflineMetadata?cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Metadata>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets information regarding the family that the user is part of.
		/// Books_familysharing_getFamilyInfo books/v1/familysharing/getFamilyInfo
		/// </summary>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<FamilyInfo> Books_familysharing_getFamilyInfoAsync(string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/familysharing/getFamilyInfo?source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<FamilyInfo>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Initiates sharing of the content with the user's family. Empty response indicates success.
		/// Books_familysharing_share books/v1/familysharing/share
		/// </summary>
		/// <param name="docId">The docid to share.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="volumeId">The volume to share.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_familysharing_shareAsync(string docId, string source, string volumeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/familysharing/share?docId=" + (docId==null? "" : System.Uri.EscapeDataString(docId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Initiates revoking content that has already been shared with the user's family. Empty response indicates success.
		/// Books_familysharing_unshare books/v1/familysharing/unshare
		/// </summary>
		/// <param name="docId">The docid to unshare.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="volumeId">The volume to unshare.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_familysharing_unshareAsync(string docId, string source, string volumeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/familysharing/unshare?docId=" + (docId==null? "" : System.Uri.EscapeDataString(docId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets the current settings for the user.
		/// Books_myconfig_getUserSettings books/v1/myconfig/getUserSettings
		/// </summary>
		/// <param name="country">Unused. Added only to workaround TEX mandatory request template requirement</param>
		/// <returns>Successful response</returns>
		public async Task<Usersettings> Books_myconfig_getUserSettingsAsync(string country, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/myconfig/getUserSettings?country=" + (country==null? "" : System.Uri.EscapeDataString(country));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Usersettings>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Release downloaded content access restriction.
		/// Books_myconfig_releaseDownloadAccess books/v1/myconfig/releaseDownloadAccess
		/// </summary>
		/// <param name="cpksver">The device/version ID from which to release the restriction.</param>
		/// <param name="volumeIds">The volume(s) to release restrictions for.</param>
		/// <param name="locale">ISO-639-1, ISO-3166-1 codes for message localization, i.e. en_US.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<DownloadAccesses> Books_myconfig_releaseDownloadAccessAsync(string cpksver, string[] volumeIds, string locale, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/myconfig/releaseDownloadAccess?cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver))+"&"+string.Join("&", volumeIds.Select(z => $"volumeIds={System.Uri.EscapeDataString(z.ToString())}"))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DownloadAccesses>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Request concurrent and download access restrictions.
		/// Books_myconfig_requestAccess books/v1/myconfig/requestAccess
		/// </summary>
		/// <param name="cpksver">The device/version ID from which to request the restrictions.</param>
		/// <param name="nonce">The client nonce value.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="volumeId">The volume to request concurrent/download restrictions for.</param>
		/// <param name="licenseTypes">The type of access license to request. If not specified, the default is BOTH.</param>
		/// <param name="locale">ISO-639-1, ISO-3166-1 codes for message localization, i.e. en_US.</param>
		/// <returns>Successful response</returns>
		public async Task<RequestAccessData> Books_myconfig_requestAccessAsync(string cpksver, string nonce, string source, string volumeId, Books_myconfig_requestAccessLicenseTypes licenseTypes, string locale, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/myconfig/requestAccess?cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver))+"&nonce=" + (nonce==null? "" : System.Uri.EscapeDataString(nonce))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&licenseTypes=" + licenseTypes+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<RequestAccessData>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Request downloaded content access for specified volumes on the My eBooks shelf.
		/// Books_myconfig_syncVolumeLicenses books/v1/myconfig/syncVolumeLicenses
		/// </summary>
		/// <param name="cpksver">The device/version ID from which to release the restriction.</param>
		/// <param name="nonce">The client nonce value.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="features">List of features supported by the client, i.e., 'RENTALS'</param>
		/// <param name="includeNonComicsSeries">Set to true to include non-comics series. Defaults to false.</param>
		/// <param name="locale">ISO-639-1, ISO-3166-1 codes for message localization, i.e. en_US.</param>
		/// <param name="showPreorders">Set to true to show pre-ordered books. Defaults to false.</param>
		/// <param name="volumeIds">The volume(s) to request download restrictions for.</param>
		/// <returns>Successful response</returns>
		public async Task<Volumes> Books_myconfig_syncVolumeLicensesAsync(string cpksver, string nonce, string source, string[] features, bool includeNonComicsSeries, string locale, bool showPreorders, string[] volumeIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/myconfig/syncVolumeLicenses?cpksver=" + (cpksver==null? "" : System.Uri.EscapeDataString(cpksver))+"&nonce=" + (nonce==null? "" : System.Uri.EscapeDataString(nonce))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&"+string.Join("&", features.Select(z => $"features={System.Uri.EscapeDataString(z.ToString())}"))+"&includeNonComicsSeries="+includeNonComicsSeries+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&showPreorders="+showPreorders+"&"+string.Join("&", volumeIds.Select(z => $"volumeIds={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volumes>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Sets the settings for the user. If a sub-object is specified, it will overwrite the existing sub-object stored in the server. Unspecified sub-objects will retain the existing value.
		/// Books_myconfig_updateUserSettings books/v1/myconfig/updateUserSettings
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<Usersettings> Books_myconfig_updateUserSettingsAsync(Usersettings requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/myconfig/updateUserSettings";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Usersettings>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieves a list of annotations, possibly filtered.
		/// Books_mylibrary_annotations_list books/v1/mylibrary/annotations
		/// </summary>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="layerId">The layer ID to limit annotation by.</param>
		/// <param name="layerIds">The layer ID(s) to limit annotation by.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 40
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="showDeleted">Set to true to return deleted annotations. updatedMin must be in the request to use this. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="updatedMax">RFC 3339 timestamp to restrict to items updated prior to this timestamp (exclusive).</param>
		/// <param name="updatedMin">RFC 3339 timestamp to restrict to items updated since this timestamp (inclusive).</param>
		/// <param name="volumeId">The volume to restrict annotations to.</param>
		/// <returns>Successful response</returns>
		public async Task<Annotations> Books_mylibrary_annotations_listAsync(string contentVersion, string layerId, string[] layerIds, int maxResults, string pageToken, bool showDeleted, string source, string updatedMax, string updatedMin, string volumeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/annotations?contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&layerId=" + (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"&"+string.Join("&", layerIds.Select(z => $"layerIds={System.Uri.EscapeDataString(z.ToString())}"))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&showDeleted="+showDeleted+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&updatedMax=" + (updatedMax==null? "" : System.Uri.EscapeDataString(updatedMax))+"&updatedMin=" + (updatedMin==null? "" : System.Uri.EscapeDataString(updatedMin))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Annotations>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Inserts a new annotation.
		/// Books_mylibrary_annotations_insert books/v1/mylibrary/annotations
		/// </summary>
		/// <param name="annotationId">The ID for the annotation to insert.</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="showOnlySummaryInResponse">Requests that only the summary of the specified layer be provided in the response.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Annotation> Books_mylibrary_annotations_insertAsync(string annotationId, string country, bool showOnlySummaryInResponse, string source, Annotation requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/annotations?annotationId=" + (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&showOnlySummaryInResponse="+showOnlySummaryInResponse+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Annotation>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets the summary of specified layers.
		/// Books_mylibrary_annotations_summary books/v1/mylibrary/annotations/summary
		/// </summary>
		/// <param name="layerIds">Array of layer IDs to get the summary for.</param>
		/// <param name="volumeId">Volume id to get the summary for.</param>
		/// <returns>Successful response</returns>
		public async Task<AnnotationsSummary> Books_mylibrary_annotations_summaryAsync(string[] layerIds, string volumeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/annotations/summary?"+string.Join("&", layerIds.Select(z => $"layerIds={System.Uri.EscapeDataString(z.ToString())}"))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<AnnotationsSummary>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Deletes an annotation.
		/// Books_mylibrary_annotations_delete books/v1/mylibrary/annotations/{annotationId}
		/// </summary>
		/// <param name="annotationId">The ID for the annotation to delete.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_mylibrary_annotations_deleteAsync(string annotationId, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/annotations/"+ (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates an existing annotation.
		/// Books_mylibrary_annotations_update books/v1/mylibrary/annotations/{annotationId}
		/// </summary>
		/// <param name="annotationId">The ID for the annotation to update.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Annotation> Books_mylibrary_annotations_updateAsync(string annotationId, string source, Annotation requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/annotations/"+ (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var content = System.Net.Http.Json.JsonContent.Create(requestBody, mediaType: null, jsonSerializerSettings);
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Annotation>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieves a list of bookshelves belonging to the authenticated user.
		/// Books_mylibrary_bookshelves_list books/v1/mylibrary/bookshelves
		/// </summary>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Bookshelves> Books_mylibrary_bookshelves_listAsync(string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/bookshelves?source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Bookshelves>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieves metadata for a specific bookshelf belonging to the authenticated user.
		/// Books_mylibrary_bookshelves_get books/v1/mylibrary/bookshelves/{shelf}
		/// </summary>
		/// <param name="shelf">ID of bookshelf to retrieve.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Bookshelf> Books_mylibrary_bookshelves_getAsync(string shelf, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Bookshelf>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Adds a volume to a bookshelf.
		/// Books_mylibrary_bookshelves_addVolume books/v1/mylibrary/bookshelves/{shelf}/addVolume
		/// </summary>
		/// <param name="shelf">ID of bookshelf to which to add a volume.</param>
		/// <param name="volumeId">ID of volume to add.</param>
		/// <param name="reason">The reason for which the book is added to the library.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_mylibrary_bookshelves_addVolumeAsync(string shelf, string volumeId, Books_mylibrary_bookshelves_addVolumeReason reason, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/addVolume&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&reason=" + reason+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Clears all volumes from a bookshelf.
		/// Books_mylibrary_bookshelves_clearVolumes books/v1/mylibrary/bookshelves/{shelf}/clearVolumes
		/// </summary>
		/// <param name="shelf">ID of bookshelf from which to remove a volume.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_mylibrary_bookshelves_clearVolumesAsync(string shelf, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/clearVolumes&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Moves a volume within a bookshelf.
		/// Books_mylibrary_bookshelves_moveVolume books/v1/mylibrary/bookshelves/{shelf}/moveVolume
		/// </summary>
		/// <param name="shelf">ID of bookshelf with the volume.</param>
		/// <param name="volumeId">ID of volume to move.</param>
		/// <param name="volumePosition">Position on shelf to move the item (0 puts the item before the current first item, 1 puts it between the first and the second and so on.)</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_mylibrary_bookshelves_moveVolumeAsync(string shelf, string volumeId, int volumePosition, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/moveVolume&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&volumePosition="+volumePosition+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Removes a volume from a bookshelf.
		/// Books_mylibrary_bookshelves_removeVolume books/v1/mylibrary/bookshelves/{shelf}/removeVolume
		/// </summary>
		/// <param name="shelf">ID of bookshelf from which to remove a volume.</param>
		/// <param name="volumeId">ID of volume to remove.</param>
		/// <param name="reason">The reason for which the book is removed from the library.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_mylibrary_bookshelves_removeVolumeAsync(string shelf, string volumeId, Books_mylibrary_bookshelves_removeVolumeReason reason, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/removeVolume&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&reason=" + reason+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets volume information for volumes on a bookshelf.
		/// Books_mylibrary_bookshelves_volumes_list books/v1/mylibrary/bookshelves/{shelf}/volumes
		/// </summary>
		/// <param name="shelf">The bookshelf ID or name retrieve volumes for.</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		// </param>
		/// <param name="projection">Restrict information returned to a set of selected fields.</param>
		/// <param name="q">Full-text search query string in this bookshelf.</param>
		/// <param name="showPreorders">Set to true to show pre-ordered books. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first element to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public async Task<Volumes> Books_mylibrary_bookshelves_volumes_listAsync(string shelf, string country, int maxResults, Books_mylibrary_bookshelves_volumes_listProjection projection, string q, bool showPreorders, string source, int startIndex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/volumes&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&maxResults="+maxResults+"&projection=" + projection+"&q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&showPreorders="+showPreorders+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volumes>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieves my reading position information for a volume.
		/// Books_mylibrary_readingpositions_get books/v1/mylibrary/readingpositions/{volumeId}
		/// </summary>
		/// <param name="volumeId">ID of volume for which to retrieve a reading position.</param>
		/// <param name="contentVersion">Volume content version for which this reading position is requested.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<ReadingPosition> Books_mylibrary_readingpositions_getAsync(string volumeId, string contentVersion, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/readingpositions/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<ReadingPosition>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Sets my reading position information for a volume.
		/// Books_mylibrary_readingpositions_setPosition books/v1/mylibrary/readingpositions/{volumeId}/setPosition
		/// </summary>
		/// <param name="volumeId">ID of volume for which to update the reading position.</param>
		/// <param name="position">Position string for the new volume reading position.</param>
		/// <param name="timestamp">RFC 3339 UTC format timestamp associated with this reading position.</param>
		/// <param name="action">Action that caused this reading position to be set.</param>
		/// <param name="contentVersion">Volume content version for which this reading position applies.</param>
		/// <param name="deviceCookie">Random persistent device cookie optional on set position.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_mylibrary_readingpositions_setPositionAsync(string volumeId, string position, string timestamp, Books_mylibrary_readingpositions_setPositionAction action, string contentVersion, string deviceCookie, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/mylibrary/readingpositions/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/setPosition&position=" + (position==null? "" : System.Uri.EscapeDataString(position))+"&timestamp=" + (timestamp==null? "" : System.Uri.EscapeDataString(timestamp))+"&action=" + action+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&deviceCookie=" + (deviceCookie==null? "" : System.Uri.EscapeDataString(deviceCookie))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns notification details for a given notification id.
		/// Books_notification_get books/v1/notification/get
		/// </summary>
		/// <param name="notification_id">String to identify the notification.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating notification title and body.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Notification> Books_notification_getAsync(string notification_id, string locale, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/notification/get?notification_id=" + (notification_id==null? "" : System.Uri.EscapeDataString(notification_id))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Notification>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List categories for onboarding experience.
		/// Books_onboarding_listCategories books/v1/onboarding/listCategories
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Default is en-US if unset.</param>
		/// <returns>Successful response</returns>
		public async Task<Category> Books_onboarding_listCategoriesAsync(string locale, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/onboarding/listCategories?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Category>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List available volumes under categories for onboarding experience.
		/// Books_onboarding_listCategoryVolumes books/v1/onboarding/listCategoryVolumes
		/// </summary>
		/// <param name="categoryId">List of category ids requested.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Default is en-US if unset.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned volumes. Books with a higher maturity rating are filtered out.</param>
		/// <param name="pageSize">Number of maximum results per page to be included in the response.</param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <returns>Successful response</returns>
		public async Task<Volume2> Books_onboarding_listCategoryVolumesAsync(string[] categoryId, string locale, Books_onboarding_listCategoryVolumesMaxAllowedMaturityRating maxAllowedMaturityRating, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/onboarding/listCategoryVolumes?"+string.Join("&", categoryId.Select(z => $"categoryId={System.Uri.EscapeDataString(z.ToString())}"))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volume2>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a stream of personalized book clusters
		/// Books_personalizedstream_get books/v1/personalizedstream/get
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Discoveryclusters> Books_personalizedstream_getAsync(string locale, Books_personalizedstream_getMaxAllowedMaturityRating maxAllowedMaturityRating, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/personalizedstream/get?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Discoveryclusters>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Accepts the promo offer.
		/// Books_promooffer_accept books/v1/promooffer/accept
		/// </summary>
		/// <param name="androidId">device android_id</param>
		/// <param name="device">device device</param>
		/// <param name="manufacturer">device manufacturer</param>
		/// <param name="model">device model</param>
		/// <param name="product">device product</param>
		/// <param name="serial">device serial</param>
		/// <param name="volumeId">Volume id to exercise the offer</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_promooffer_acceptAsync(string androidId, string device, string manufacturer, string model, string offerId, string product, string serial, string volumeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/promooffer/accept?androidId=" + (androidId==null? "" : System.Uri.EscapeDataString(androidId))+"&device=" + (device==null? "" : System.Uri.EscapeDataString(device))+"&manufacturer=" + (manufacturer==null? "" : System.Uri.EscapeDataString(manufacturer))+"&model=" + (model==null? "" : System.Uri.EscapeDataString(model))+"&offerId=" + (offerId==null? "" : System.Uri.EscapeDataString(offerId))+"&product=" + (product==null? "" : System.Uri.EscapeDataString(product))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial))+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Marks the promo offer as dismissed.
		/// Books_promooffer_dismiss books/v1/promooffer/dismiss
		/// </summary>
		/// <param name="androidId">device android_id</param>
		/// <param name="device">device device</param>
		/// <param name="manufacturer">device manufacturer</param>
		/// <param name="model">device model</param>
		/// <param name="offerId">Offer to dimiss</param>
		/// <param name="product">device product</param>
		/// <param name="serial">device serial</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Books_promooffer_dismissAsync(string androidId, string device, string manufacturer, string model, string offerId, string product, string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/promooffer/dismiss?androidId=" + (androidId==null? "" : System.Uri.EscapeDataString(androidId))+"&device=" + (device==null? "" : System.Uri.EscapeDataString(device))+"&manufacturer=" + (manufacturer==null? "" : System.Uri.EscapeDataString(manufacturer))+"&model=" + (model==null? "" : System.Uri.EscapeDataString(model))+"&offerId=" + (offerId==null? "" : System.Uri.EscapeDataString(offerId))+"&product=" + (product==null? "" : System.Uri.EscapeDataString(product))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Empty>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns a list of promo offers available to the user
		/// Books_promooffer_get books/v1/promooffer/get
		/// </summary>
		/// <param name="androidId">device android_id</param>
		/// <param name="device">device device</param>
		/// <param name="manufacturer">device manufacturer</param>
		/// <param name="model">device model</param>
		/// <param name="product">device product</param>
		/// <param name="serial">device serial</param>
		/// <returns>Successful response</returns>
		public async Task<Offers> Books_promooffer_getAsync(string androidId, string device, string manufacturer, string model, string product, string serial, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/promooffer/get?androidId=" + (androidId==null? "" : System.Uri.EscapeDataString(androidId))+"&device=" + (device==null? "" : System.Uri.EscapeDataString(device))+"&manufacturer=" + (manufacturer==null? "" : System.Uri.EscapeDataString(manufacturer))+"&model=" + (model==null? "" : System.Uri.EscapeDataString(model))+"&product=" + (product==null? "" : System.Uri.EscapeDataString(product))+"&serial=" + (serial==null? "" : System.Uri.EscapeDataString(serial));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Offers>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns Series metadata for the given series ids.
		/// Books_series_get books/v1/series/get
		/// </summary>
		/// <param name="series_id">String that identifies the series</param>
		/// <returns>Successful response</returns>
		public async Task<Series> Books_series_getAsync(string[] series_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/series/get?"+string.Join("&", series_id.Select(z => $"series_id={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Series>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns Series membership data given the series id.
		/// Books_series_membership_get books/v1/series/membership/get
		/// </summary>
		/// <param name="series_id">String that identifies the series</param>
		/// <param name="page_size">Number of maximum results per page to be included in the response.</param>
		/// <param name="page_token">The value of the nextToken from the previous page.</param>
		/// <returns>Successful response</returns>
		public async Task<Seriesmembership> Books_series_membership_getAsync(string series_id, int page_size, string page_token, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/series/membership/get?series_id=" + (series_id==null? "" : System.Uri.EscapeDataString(series_id))+"&page_size="+page_size+"&page_token=" + (page_token==null? "" : System.Uri.EscapeDataString(page_token));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Seriesmembership>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieves a list of public bookshelves for the specified user.
		/// Books_bookshelves_list books/v1/users/{userId}/bookshelves
		/// </summary>
		/// <param name="userId">ID of user for whom to retrieve bookshelves.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Bookshelves> Books_bookshelves_listAsync(string userId, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/bookshelves&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Bookshelves>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieves metadata for a specific bookshelf for the specified user.
		/// Books_bookshelves_get books/v1/users/{userId}/bookshelves/{shelf}
		/// </summary>
		/// <param name="userId">ID of user for whom to retrieve bookshelves.</param>
		/// <param name="shelf">ID of bookshelf to retrieve.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Bookshelf> Books_bookshelves_getAsync(string userId, string shelf, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Bookshelf>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Retrieves volumes in a specific bookshelf for the specified user.
		/// Books_bookshelves_volumes_list books/v1/users/{userId}/bookshelves/{shelf}/volumes
		/// </summary>
		/// <param name="userId">ID of user for whom to retrieve bookshelf volumes.</param>
		/// <param name="shelf">ID of bookshelf to retrieve volumes.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		// </param>
		/// <param name="showPreorders">Set to true to show pre-ordered books. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first element to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public async Task<Volumes> Books_bookshelves_volumes_listAsync(string userId, string shelf, int maxResults, bool showPreorders, string source, int startIndex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/users/"+ (userId==null? "" : System.Uri.EscapeDataString(userId))+"/bookshelves/"+ (shelf==null? "" : System.Uri.EscapeDataString(shelf))+"/volumes&maxResults="+maxResults+"&showPreorders="+showPreorders+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volumes>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Performs a book search.
		/// Books_volumes_list books/v1/volumes
		/// </summary>
		/// <param name="q">Full-text search query string.</param>
		/// <param name="download">Restrict to volumes by download availability.</param>
		/// <param name="filter">Filter search results.</param>
		/// <param name="langRestrict">Restrict results to books with this language code.</param>
		/// <param name="libraryRestrict">Restrict search to this user's library.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="maxResults">Maximum number of results to return.
		/// Minimum: 0
		/// Maximum: 40
		// </param>
		/// <param name="orderBy">Sort search results.</param>
		/// <param name="partner">Restrict and brand results for partner ID.</param>
		/// <param name="printType">Restrict to books or magazines.</param>
		/// <param name="projection">Restrict information returned to a set of selected fields.</param>
		/// <param name="showPreorders">Set to true to show books available for preorder. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first result to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public async Task<Volumes> Books_volumes_listAsync(string q, Books_volumes_listDownload download, Books_volumes_listFilter filter, string langRestrict, Books_volumes_listLibraryRestrict libraryRestrict, Books_volumes_listMaxAllowedMaturityRating maxAllowedMaturityRating, int maxResults, Books_volumes_listOrderBy orderBy, string partner, Books_volumes_listPrintType printType, Books_mylibrary_bookshelves_volumes_listProjection projection, bool showPreorders, string source, int startIndex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&download=" + download+"&filter=" + filter+"&langRestrict=" + (langRestrict==null? "" : System.Uri.EscapeDataString(langRestrict))+"&libraryRestrict=" + libraryRestrict+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&maxResults="+maxResults+"&orderBy=" + orderBy+"&partner=" + (partner==null? "" : System.Uri.EscapeDataString(partner))+"&printType=" + printType+"&projection=" + projection+"&showPreorders="+showPreorders+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volumes>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a list of books in My Library.
		/// Books_volumes_mybooks_list books/v1/volumes/mybooks
		/// </summary>
		/// <param name="acquireMethod">How the book was acquired</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex:'en_US'. Used for generating recommendations.</param>
		/// <param name="maxResults">Maximum number of results to return.
		/// Minimum: 0
		/// Maximum: 100
		// </param>
		/// <param name="processingState">The processing state of the user uploaded volumes to be returned. Applicable only if the UPLOADED is specified in the acquireMethod.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first result to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <returns>Successful response</returns>
		public async Task<Volumes> Books_volumes_mybooks_listAsync(string[] acquireMethod, string country, string locale, int maxResults, string[] processingState, string source, int startIndex, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/mybooks?"+string.Join("&", acquireMethod.Select(z => $"acquireMethod={System.Uri.EscapeDataString(z.ToString())}"))+"&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&"+string.Join("&", processingState.Select(z => $"processingState={System.Uri.EscapeDataString(z.ToString())}"))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volumes>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a list of recommended books for the current user.
		/// Books_volumes_recommended_list books/v1/volumes/recommended
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Volumes> Books_volumes_recommended_listAsync(string locale, Books_volumes_recommended_listMaxAllowedMaturityRating maxAllowedMaturityRating, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/recommended?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volumes>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Rate a recommended book for the current user.
		/// Books_volumes_recommended_rate books/v1/volumes/recommended/rate
		/// </summary>
		/// <param name="rating">Rating to be given to the volume.</param>
		/// <param name="volumeId">ID of the source volume.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<BooksVolumesRecommendedRateResponse> Books_volumes_recommended_rateAsync(Books_volumes_recommended_rateRating rating, string volumeId, string locale, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/recommended/rate?rating=" + rating+"&volumeId=" + (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<BooksVolumesRecommendedRateResponse>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a list of books uploaded by the current user.
		/// Books_volumes_useruploaded_list books/v1/volumes/useruploaded
		/// </summary>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxResults">Maximum number of results to return.
		/// Minimum: 0
		/// Maximum: 40
		// </param>
		/// <param name="processingState">The processing state of the user uploaded volumes to be returned.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startIndex">Index of the first result to return (starts at 0)
		/// Minimum: 0
		// </param>
		/// <param name="volumeId">The ids of the volumes to be returned. If not specified all that match the processingState are returned.</param>
		/// <returns>Successful response</returns>
		public async Task<Volumes> Books_volumes_useruploaded_listAsync(string locale, int maxResults, string[] processingState, string source, int startIndex, string[] volumeId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/useruploaded?locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&"+string.Join("&", processingState.Select(z => $"processingState={System.Uri.EscapeDataString(z.ToString())}"))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startIndex="+startIndex+"&"+string.Join("&", volumeId.Select(z => $"volumeId={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volumes>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets volume information for a single volume.
		/// Books_volumes_get books/v1/volumes/{volumeId}
		/// </summary>
		/// <param name="volumeId">ID of volume to retrieve.</param>
		/// <param name="country">ISO-3166-1 code to override the IP-based location.</param>
		/// <param name="includeNonComicsSeries">Set to true to include non-comics series. Defaults to false.</param>
		/// <param name="partner">Brand results for partner ID.</param>
		/// <param name="projection">Restrict information returned to a set of selected fields.</param>
		/// <param name="source">string to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Volume> Books_volumes_getAsync(string volumeId, string country, bool includeNonComicsSeries, string partner, Books_mylibrary_bookshelves_volumes_listProjection projection, string source, bool user_library_consistent_read, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"&country=" + (country==null? "" : System.Uri.EscapeDataString(country))+"&includeNonComicsSeries="+includeNonComicsSeries+"&partner=" + (partner==null? "" : System.Uri.EscapeDataString(partner))+"&projection=" + projection+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&user_library_consistent_read="+user_library_consistent_read;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volume>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Return a list of associated books.
		/// Books_volumes_associated_list books/v1/volumes/{volumeId}/associated
		/// </summary>
		/// <param name="volumeId">ID of the source volume.</param>
		/// <param name="association">Association type.</param>
		/// <param name="locale">ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'. Used for generating recommendations.</param>
		/// <param name="maxAllowedMaturityRating">The maximum allowed maturity rating of returned recommendations. Books with a higher maturity rating are filtered out.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Volumes> Books_volumes_associated_listAsync(string volumeId, Books_volumes_associated_listAssociation association, string locale, Books_volumes_associated_listMaxAllowedMaturityRating maxAllowedMaturityRating, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/associated&association=" + association+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxAllowedMaturityRating=" + maxAllowedMaturityRating+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volumes>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets the volume annotations for a volume and layer.
		/// Books_layers_volumeAnnotations_list books/v1/volumes/{volumeId}/layers/{layerId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotations for.</param>
		/// <param name="layerId">The ID for the layer to get the annotations.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="endOffset">The end offset to end retrieving data from.</param>
		/// <param name="endPosition">The end position to end retrieving data from.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 200
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="showDeleted">Set to true to return deleted annotations. updatedMin must be in the request to use this. Defaults to false.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="startOffset">The start offset to start retrieving data from.</param>
		/// <param name="startPosition">The start position to start retrieving data from.</param>
		/// <param name="updatedMax">RFC 3339 timestamp to restrict to items updated prior to this timestamp (exclusive).</param>
		/// <param name="updatedMin">RFC 3339 timestamp to restrict to items updated since this timestamp (inclusive).</param>
		/// <param name="volumeAnnotationsVersion">The version of the volume annotations that you are requesting.</param>
		/// <returns>Successful response</returns>
		public async Task<Volumeannotations> Books_layers_volumeAnnotations_listAsync(
					string volumeId, 
					string layerId, 
					string contentVersion, 
					string endOffset, 
					string endPosition, 
					string locale, 
					int maxResults, 
					string pageToken, 
					bool showDeleted, 
					string source, 
					string startOffset, 
					string startPosition, 
					string updatedMax, 
					string updatedMin, 
					string volumeAnnotationsVersion, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&endOffset=" + (endOffset==null? "" : System.Uri.EscapeDataString(endOffset))+"&endPosition=" + (endPosition==null? "" : System.Uri.EscapeDataString(endPosition))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&showDeleted="+showDeleted+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&startOffset=" + (startOffset==null? "" : System.Uri.EscapeDataString(startOffset))+"&startPosition=" + (startPosition==null? "" : System.Uri.EscapeDataString(startPosition))+"&updatedMax=" + (updatedMax==null? "" : System.Uri.EscapeDataString(updatedMax))+"&updatedMin=" + (updatedMin==null? "" : System.Uri.EscapeDataString(updatedMin))+"&volumeAnnotationsVersion=" + (volumeAnnotationsVersion==null? "" : System.Uri.EscapeDataString(volumeAnnotationsVersion));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volumeannotations>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets the volume annotation.
		/// Books_layers_volumeAnnotations_get books/v1/volumes/{volumeId}/layers/{layerId}/annotations/{annotationId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotations for.</param>
		/// <param name="layerId">The ID for the layer to get the annotations.</param>
		/// <param name="annotationId">The ID of the volume annotation to retrieve.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Volumeannotation> Books_layers_volumeAnnotations_getAsync(string volumeId, string layerId, string annotationId, string locale, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"/annotations/"+ (annotationId==null? "" : System.Uri.EscapeDataString(annotationId))+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Volumeannotation>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets the annotation data for a volume and layer.
		/// Books_layers_annotationData_list books/v1/volumes/{volumeId}/layers/{layerId}/data
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotation data for.</param>
		/// <param name="layerId">The ID for the layer to get the annotation data.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="annotationDataId">The list of Annotation Data Ids to retrieve. Pagination is ignored if this is set.</param>
		/// <param name="h">The requested pixel height for any images. If height is provided width must also be provided.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 200
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="scale">The requested scale for the image.
		/// Minimum: 0
		// </param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="updatedMax">RFC 3339 timestamp to restrict to items updated prior to this timestamp (exclusive).</param>
		/// <param name="updatedMin">RFC 3339 timestamp to restrict to items updated since this timestamp (inclusive).</param>
		/// <param name="w">The requested pixel width for any images. If width is provided height must also be provided.</param>
		/// <returns>Successful response</returns>
		public async Task<Annotationsdata> Books_layers_annotationData_listAsync(string volumeId, string layerId, string contentVersion, string[] annotationDataId, int h, string locale, int maxResults, string pageToken, int scale, string source, string updatedMax, string updatedMin, int w, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"/data&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&"+string.Join("&", annotationDataId.Select(z => $"annotationDataId={System.Uri.EscapeDataString(z.ToString())}"))+"&h="+h+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&scale="+scale+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&updatedMax=" + (updatedMax==null? "" : System.Uri.EscapeDataString(updatedMax))+"&updatedMin=" + (updatedMin==null? "" : System.Uri.EscapeDataString(updatedMin))+"&w="+w;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Annotationsdata>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets the annotation data.
		/// Books_layers_annotationData_get books/v1/volumes/{volumeId}/layers/{layerId}/data/{annotationDataId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve annotations for.</param>
		/// <param name="layerId">The ID for the layer to get the annotations.</param>
		/// <param name="annotationDataId">The ID of the annotation data to retrieve.</param>
		/// <param name="contentVersion">The content version for the volume you are trying to retrieve.</param>
		/// <param name="allowWebDefinitions">For the dictionary layer. Whether or not to allow web definitions.</param>
		/// <param name="h">The requested pixel height for any images. If height is provided width must also be provided.</param>
		/// <param name="locale">The locale information for the data. ISO-639-1 language and ISO-3166-1 country code. Ex: 'en_US'.</param>
		/// <param name="scale">The requested scale for the image.
		/// Minimum: 0
		// </param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <param name="w">The requested pixel width for any images. If width is provided height must also be provided.</param>
		/// <returns>Successful response</returns>
		public async Task<DictionaryAnnotationdata> Books_layers_annotationData_getAsync(string volumeId, string layerId, string annotationDataId, string contentVersion, bool allowWebDefinitions, int h, string locale, int scale, string source, int w, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layers/"+ (layerId==null? "" : System.Uri.EscapeDataString(layerId))+"/data/"+ (annotationDataId==null? "" : System.Uri.EscapeDataString(annotationDataId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&allowWebDefinitions="+allowWebDefinitions+"&h="+h+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale))+"&scale="+scale+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source))+"&w="+w;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<DictionaryAnnotationdata>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List the layer summaries for a volume.
		/// Books_layers_list books/v1/volumes/{volumeId}/layersummary
		/// </summary>
		/// <param name="volumeId">The volume to retrieve layers for.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="maxResults">Maximum number of results to return
		/// Minimum: 0
		/// Maximum: 200
		// </param>
		/// <param name="pageToken">The value of the nextToken from the previous page.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Layersummaries> Books_layers_listAsync(string volumeId, string contentVersion, int maxResults, string pageToken, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layersummary&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Layersummaries>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Gets the layer summary for a volume.
		/// Books_layers_get books/v1/volumes/{volumeId}/layersummary/{summaryId}
		/// </summary>
		/// <param name="volumeId">The volume to retrieve layers for.</param>
		/// <param name="summaryId">The ID for the layer to get the summary for.</param>
		/// <param name="contentVersion">The content version for the requested volume.</param>
		/// <param name="source">String to identify the originator of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Layersummary> Books_layers_getAsync(string volumeId, string summaryId, string contentVersion, string source, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "books/v1/volumes/"+ (volumeId==null? "" : System.Uri.EscapeDataString(volumeId))+"/layersummary/"+ (summaryId==null? "" : System.Uri.EscapeDataString(summaryId))+"&contentVersion=" + (contentVersion==null? "" : System.Uri.EscapeDataString(contentVersion))+"&source=" + (source==null? "" : System.Uri.EscapeDataString(source));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				return JsonSerializer.Deserialize<Layersummary>(streamContent, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
	
	public enum Books_myconfig_requestAccessLicenseTypes
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LICENSE_TYPES_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOTH = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONCURRENT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOWNLOAD = 3,
	}
	
	public enum Books_mylibrary_bookshelves_addVolumeReason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REASON_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IOS_PREX = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IOS_SEARCH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONBOARDING = 3,
	}
	
	public enum Books_mylibrary_bookshelves_removeVolumeReason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REASON_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONBOARDING = 1,
	}
	
	public enum Books_mylibrary_bookshelves_volumes_listProjection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROJECTION_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LITE = 2,
	}
	
	public enum Books_mylibrary_readingpositions_setPositionAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTION_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		bookmark = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		chapter = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="next-page")]
		nextMinuspage = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="prev-page")]
		prevMinuspage = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		scroll = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		search = 6,
	}
	
	public enum Books_onboarding_listCategoryVolumesMaxAllowedMaturityRating
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAX_ALLOWED_MATURITY_RATING_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MATURE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="not-mature")]
		notMinusmature = 2,
	}
	
	public enum Books_personalizedstream_getMaxAllowedMaturityRating
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAX_ALLOWED_MATURITY_RATING_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MATURE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="not-mature")]
		notMinusmature = 2,
	}
	
	public enum Books_volumes_listDownload
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOWNLOAD_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EPUB = 1,
	}
	
	public enum Books_volumes_listFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FILTER_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ebooks = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="free-ebooks")]
		freeMinusebooks = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="paid-ebooks")]
		paidMinusebooks = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		@partial = 5,
	}
	
	public enum Books_volumes_listLibraryRestrict
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LIBRARY_RESTRICT_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="my-library")]
		myMinuslibrary = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="no-restrict")]
		noMinusrestrict = 2,
	}
	
	public enum Books_volumes_listMaxAllowedMaturityRating
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAX_ALLOWED_MATURITY_RATING_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MATURE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="not-mature")]
		notMinusmature = 2,
	}
	
	public enum Books_volumes_listOrderBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORDER_BY_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		newest = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		relevance = 2,
	}
	
	public enum Books_volumes_listPrintType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRINT_TYPE_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOOKS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAGAZINES = 3,
	}
	
	public enum Books_volumes_recommended_listMaxAllowedMaturityRating
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAX_ALLOWED_MATURITY_RATING_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MATURE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="not-mature")]
		notMinusmature = 2,
	}
	
	public enum Books_volumes_recommended_rateRating
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RATING_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HAVE_IT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_INTERESTED = 2,
	}
	
	public enum Books_volumes_associated_listAssociation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASSOCIATION_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="end-of-sample")]
		endMinusofMinussample = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="end-of-volume")]
		endMinusofMinusvolume = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="related-for-play")]
		relatedMinusforMinusplay = 3,
	}
	
	public enum Books_volumes_associated_listMaxAllowedMaturityRating
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAX_ALLOWED_MATURITY_RATING_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MATURE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="not-mature")]
		notMinusmature = 2,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
