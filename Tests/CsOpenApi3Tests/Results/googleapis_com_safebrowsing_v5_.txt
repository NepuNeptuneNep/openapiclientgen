//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// The full hash identified with one or more matches.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleSecuritySafebrowsingV5FullHash
	{
		
		/// <summary>
		/// The matching full hash. This is the SHA256 hash. The length will be exactly 32 bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullHash")]
		public string FullHash { get; set; }
		
		/// <summary>
		/// Unordered list. A repeated field identifying the details relevant to this full hash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullHashDetails")]
		public GoogleSecuritySafebrowsingV5FullHashFullHashDetail[] FullHashDetails { get; set; }
	}
	
	/// <summary>
	/// Details about a matching full hash. An important note about forward compatibility: new threat types and threat attributes may be added by the server at any time; those additions are considered minor version changes. It is Google's policy not to expose minor version numbers in APIs (see https://cloud.google.com/apis/design/versioning), so clients MUST be prepared to receive FullHashDetail messages containing ThreatType enum values or ThreatAttribute enum values that are considered invalid by the client. Therefore, it is the client's responsibility to check for the validity of all ThreatType and ThreatAttribute enum values; if any value is considered invalid, the client MUST disregard the entire FullHashDetail message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleSecuritySafebrowsingV5FullHashFullHashDetail
	{
		
		/// <summary>
		/// Unordered list. Additional attributes about those full hashes. This may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attributes")]
		public string[] Attributes { get; set; }
		
		/// <summary>
		/// The type of threat. This field will never be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatType")]
		public System.Nullable<GoogleSecuritySafebrowsingV5FullHashFullHashDetailThreatType> ThreatType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleSecuritySafebrowsingV5FullHashFullHashDetailThreatType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREAT_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MALWARE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOCIAL_ENGINEERING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNWANTED_SOFTWARE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POTENTIALLY_HARMFUL_APPLICATION = 4,
	}
	
	/// <summary>
	/// The response returned after searching threat hashes. Note that if nothing is found, the server will return an OK status (HTTP status code 200) with the `full_hashes` field empty, rather than returning a NOT_FOUND status (HTTP status code 404).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleSecuritySafebrowsingV5SearchHashesResponse
	{
		
		/// <summary>
		/// The client-side cache duration. The client shall add this duration to the current time to determine the expiration time. The expiration time then applies to every hash prefix queried by the client in the request, regardless of how many full hashes are returned in the response. Even if the server returns no full hashes for a particular hash prefix, this fact should also be cached by the client. Important: the client must not assume that the server will return the same cache duration for all responses. The server may choose different cache durations for different responses depending on the situation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheDuration")]
		public string CacheDuration { get; set; }
		
		/// <summary>
		/// Unordered list. The unordered list of full hashes found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullHashes")]
		public GoogleSecuritySafebrowsingV5FullHash[] FullHashes { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Search for full hashes matching the specified prefixes. This is a custom method as described by guidance at https://google.aip.dev/136
		/// Safebrowsing_hashes_search v5/hashes:search
		/// </summary>
		/// <param name="hashPrefixes">Required. The hash prefixes to be looked up.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleSecuritySafebrowsingV5SearchHashesResponse> Safebrowsing_hashes_searchAsync(string[] hashPrefixes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v5/hashes:search?"+string.Join("&", hashPrefixes.Select(z => $"hashPrefixes={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GoogleSecuritySafebrowsingV5SearchHashesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
