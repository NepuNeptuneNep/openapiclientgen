//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// AVRO file format configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AvroFileFormat
	{
	}
	
	/// <summary>
	/// Backfill strategy to automatically backfill the Stream's objects. Specific objects can be excluded.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackfillAllStrategy
	{
		
		/// <summary>
		/// MySQL database structure
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysqlExcludedObjects")]
		public MysqlRdbms MysqlExcludedObjects { get; set; }
		
		/// <summary>
		/// Oracle database structure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleExcludedObjects")]
		public OracleRdbms OracleExcludedObjects { get; set; }
		
		/// <summary>
		/// PostgreSQL database structure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postgresqlExcludedObjects")]
		public PostgresqlRdbms PostgresqlExcludedObjects { get; set; }
	}
	
	/// <summary>
	/// MySQL database structure
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MysqlRdbms
	{
		
		/// <summary>
		/// Mysql databases on the server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysqlDatabases")]
		public MysqlDatabase[] MysqlDatabases { get; set; }
	}
	
	/// <summary>
	/// MySQL database.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MysqlDatabase
	{
		
		/// <summary>
		/// Database name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="database")]
		public string Database { get; set; }
		
		/// <summary>
		/// Tables in the database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysqlTables")]
		public MysqlTable[] MysqlTables { get; set; }
	}
	
	/// <summary>
	/// MySQL table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MysqlTable
	{
		
		/// <summary>
		/// MySQL columns in the database. When unspecified as part of include/exclude objects, includes/excludes everything.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysqlColumns")]
		public MysqlColumn[] MysqlColumns { get; set; }
		
		/// <summary>
		/// Table name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="table")]
		public string Table { get; set; }
	}
	
	/// <summary>
	/// MySQL Column.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MysqlColumn
	{
		
		/// <summary>
		/// Column collation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="collation")]
		public string Collation { get; set; }
		
		/// <summary>
		/// Column name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="column")]
		public string Column { get; set; }
		
		/// <summary>
		/// The MySQL data type. Full data types list can be found here: https://dev.mysql.com/doc/refman/8.0/en/data-types.html
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataType")]
		public string DataType { get; set; }
		
		/// <summary>
		/// Column length.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="length")]
		public System.Nullable<System.Int32> Length { get; set; }
		
		/// <summary>
		/// Whether or not the column can accept a null value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nullable")]
		public System.Nullable<System.Boolean> Nullable { get; set; }
		
		/// <summary>
		/// The ordinal position of the column in the table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ordinalPosition")]
		public System.Nullable<System.Int32> OrdinalPosition { get; set; }
		
		/// <summary>
		/// Column precision.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="precision")]
		public System.Nullable<System.Int32> Precision { get; set; }
		
		/// <summary>
		/// Whether or not the column represents a primary key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryKey")]
		public System.Nullable<System.Boolean> PrimaryKey { get; set; }
		
		/// <summary>
		/// Column scale.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scale")]
		public System.Nullable<System.Int32> Scale { get; set; }
	}
	
	/// <summary>
	/// Oracle database structure.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleRdbms
	{
		
		/// <summary>
		/// Oracle schemas/databases in the database server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleSchemas")]
		public OracleSchema[] OracleSchemas { get; set; }
	}
	
	/// <summary>
	/// Oracle schema.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleSchema
	{
		
		/// <summary>
		/// Tables in the schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleTables")]
		public OracleTable[] OracleTables { get; set; }
		
		/// <summary>
		/// Schema name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
	}
	
	/// <summary>
	/// Oracle table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleTable
	{
		
		/// <summary>
		/// Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleColumns")]
		public OracleColumn[] OracleColumns { get; set; }
		
		/// <summary>
		/// Table name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="table")]
		public string Table { get; set; }
	}
	
	/// <summary>
	/// Oracle Column.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleColumn
	{
		
		/// <summary>
		/// Column name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="column")]
		public string Column { get; set; }
		
		/// <summary>
		/// The Oracle data type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataType")]
		public string DataType { get; set; }
		
		/// <summary>
		/// Column encoding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encoding")]
		public string Encoding { get; set; }
		
		/// <summary>
		/// Column length.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="length")]
		public System.Nullable<System.Int32> Length { get; set; }
		
		/// <summary>
		/// Whether or not the column can accept a null value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nullable")]
		public System.Nullable<System.Boolean> Nullable { get; set; }
		
		/// <summary>
		/// The ordinal position of the column in the table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ordinalPosition")]
		public System.Nullable<System.Int32> OrdinalPosition { get; set; }
		
		/// <summary>
		/// Column precision.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="precision")]
		public System.Nullable<System.Int32> Precision { get; set; }
		
		/// <summary>
		/// Whether or not the column represents a primary key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryKey")]
		public System.Nullable<System.Boolean> PrimaryKey { get; set; }
		
		/// <summary>
		/// Column scale.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scale")]
		public System.Nullable<System.Int32> Scale { get; set; }
	}
	
	/// <summary>
	/// PostgreSQL database structure.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PostgresqlRdbms
	{
		
		/// <summary>
		/// PostgreSQL schemas in the database server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postgresqlSchemas")]
		public PostgresqlSchema[] PostgresqlSchemas { get; set; }
	}
	
	/// <summary>
	/// PostgreSQL schema.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PostgresqlSchema
	{
		
		/// <summary>
		/// Tables in the schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postgresqlTables")]
		public PostgresqlTable[] PostgresqlTables { get; set; }
		
		/// <summary>
		/// Schema name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
	}
	
	/// <summary>
	/// PostgreSQL table.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PostgresqlTable
	{
		
		/// <summary>
		/// PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postgresqlColumns")]
		public PostgresqlColumn[] PostgresqlColumns { get; set; }
		
		/// <summary>
		/// Table name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="table")]
		public string Table { get; set; }
	}
	
	/// <summary>
	/// PostgreSQL Column.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PostgresqlColumn
	{
		
		/// <summary>
		/// Column name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="column")]
		public string Column { get; set; }
		
		/// <summary>
		/// The PostgreSQL data type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataType")]
		public string DataType { get; set; }
		
		/// <summary>
		/// Column length.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="length")]
		public System.Nullable<System.Int32> Length { get; set; }
		
		/// <summary>
		/// Whether or not the column can accept a null value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nullable")]
		public System.Nullable<System.Boolean> Nullable { get; set; }
		
		/// <summary>
		/// The ordinal position of the column in the table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ordinalPosition")]
		public System.Nullable<System.Int32> OrdinalPosition { get; set; }
		
		/// <summary>
		/// Column precision.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="precision")]
		public System.Nullable<System.Int32> Precision { get; set; }
		
		/// <summary>
		/// Whether or not the column represents a primary key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryKey")]
		public System.Nullable<System.Boolean> PrimaryKey { get; set; }
		
		/// <summary>
		/// Column scale.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scale")]
		public System.Nullable<System.Int32> Scale { get; set; }
	}
	
	/// <summary>
	/// Represents a backfill job on a specific stream object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackfillJob
	{
		
		/// <summary>
		/// Output only. Errors which caused the backfill job to fail.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public Error[] Errors { get; set; }
		
		/// <summary>
		/// Output only. Backfill job's end time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastEndTime")]
		public string LastEndTime { get; set; }
		
		/// <summary>
		/// Output only. Backfill job's start time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastStartTime")]
		public string LastStartTime { get; set; }
		
		/// <summary>
		/// Output only. Backfill job state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<BackfillJobState> State { get; set; }
		
		/// <summary>
		/// Backfill job's triggering reason.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trigger")]
		public System.Nullable<BackfillJobTrigger> Trigger { get; set; }
	}
	
	/// <summary>
	/// Represent a user-facing Error.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Error
	{
		
		/// <summary>
		/// Additional information about the error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public System.Collections.Generic.Dictionary<string, string> Details { get; set; }
		
		/// <summary>
		/// The time when the error occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorTime")]
		public string ErrorTime { get; set; }
		
		/// <summary>
		/// A unique identifier for this specific error, allowing it to be traced throughout the system in logs and API responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorUuid")]
		public string ErrorUuid { get; set; }
		
		/// <summary>
		/// A message containing more information about the error that occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// A title that explains the reason for the error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BackfillJobState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STATE_UNSPECIFIED")]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NOT_STARTED")]
		NOT_STARTED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PENDING")]
		PENDING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STOPPED")]
		STOPPED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="COMPLETED")]
		COMPLETED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UNSUPPORTED")]
		UNSUPPORTED = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BackfillJobTrigger
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TRIGGER_UNSPECIFIED")]
		TRIGGER_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AUTOMATIC")]
		AUTOMATIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MANUAL")]
		MANUAL = 2,
	}
	
	/// <summary>
	/// Backfill strategy to disable automatic backfill for the Stream's objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackfillNoneStrategy
	{
	}
	
	/// <summary>
	/// BigQuery destination configuration
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BigQueryDestinationConfig
	{
		
		/// <summary>
		/// The guaranteed data freshness (in seconds) when querying tables created by the stream. Editing this field will only affect new tables created in the future, but existing tables will not be impacted. Lower values mean that queries will return fresher data, but may result in higher cost.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataFreshness")]
		public string DataFreshness { get; set; }
		
		/// <summary>
		/// A single target dataset to which all data will be streamed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="singleTargetDataset")]
		public SingleTargetDataset SingleTargetDataset { get; set; }
		
		/// <summary>
		/// Destination datasets are created so that hierarchy of the destination data objects matches the source hierarchy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceHierarchyDatasets")]
		public SourceHierarchyDatasets SourceHierarchyDatasets { get; set; }
	}
	
	/// <summary>
	/// A single target dataset to which all data will be streamed.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SingleTargetDataset
	{
		
		/// <summary>
		/// The dataset ID of the target dataset. DatasetIds allowed characters: https://cloud.google.com/bigquery/docs/reference/rest/v2/datasets#datasetreference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datasetId")]
		public string DatasetId { get; set; }
	}
	
	/// <summary>
	/// Destination datasets are created so that hierarchy of the destination data objects matches the source hierarchy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceHierarchyDatasets
	{
		
		/// <summary>
		/// Dataset template used for dynamic dataset creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datasetTemplate")]
		public DatasetTemplate DatasetTemplate { get; set; }
	}
	
	/// <summary>
	/// Dataset template used for dynamic dataset creation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DatasetTemplate
	{
		
		/// <summary>
		/// If supplied, every created dataset will have its name prefixed by the provided value. The prefix and name will be separated by an underscore. i.e. _.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datasetIdPrefix")]
		public string DatasetIdPrefix { get; set; }
		
		/// <summary>
		/// Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table. The BigQuery Service Account associated with your project requires access to this encryption key. i.e. projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{cryptoKey}. See https://cloud.google.com/bigquery/docs/customer-managed-encryption for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kmsKeyName")]
		public string KmsKeyName { get; set; }
		
		/// <summary>
		/// Required. The geographic location where the dataset should reside. See https://cloud.google.com/bigquery/docs/locations for supported locations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
	}
	
	/// <summary>
	/// BigQuery warehouse profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BigQueryProfile
	{
	}
	
	/// <summary>
	/// The request message for Operations.CancelOperation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CancelOperationRequest
	{
	}
	
	/// <summary>
	/// The strategy that the stream uses for CDC replication.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CdcStrategy
	{
		
		/// <summary>
		/// CDC strategy to start replicating from the most recent position in the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mostRecentStartPosition")]
		public MostRecentStartPosition MostRecentStartPosition { get; set; }
		
		/// <summary>
		/// CDC strategy to resume replication from the next available position in the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextAvailableStartPosition")]
		public NextAvailableStartPosition NextAvailableStartPosition { get; set; }
		
		/// <summary>
		/// CDC strategy to start replicating from a specific position in the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="specificStartPosition")]
		public SpecificStartPosition SpecificStartPosition { get; set; }
	}
	
	/// <summary>
	/// CDC strategy to start replicating from the most recent position in the source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MostRecentStartPosition
	{
	}
	
	/// <summary>
	/// CDC strategy to resume replication from the next available position in the source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NextAvailableStartPosition
	{
	}
	
	/// <summary>
	/// CDC strategy to start replicating from a specific position in the source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SpecificStartPosition
	{
		
		/// <summary>
		/// MySQL log position
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysqlLogPosition")]
		public MysqlLogPosition MysqlLogPosition { get; set; }
	}
	
	/// <summary>
	/// MySQL log position
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MysqlLogPosition
	{
		
		/// <summary>
		/// Required. The binary log file name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logFile")]
		public string LogFile { get; set; }
		
		/// <summary>
		/// Optional. The position within the binary log file. Default is head of file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logPosition")]
		public System.Nullable<System.Int32> LogPosition { get; set; }
	}
	
	/// <summary>
	/// A set of reusable connection configurations to be used as a source or destination for a stream.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectionProfile
	{
		
		/// <summary>
		/// BigQuery warehouse profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bigqueryProfile")]
		public BigQueryProfile BigqueryProfile { get; set; }
		
		/// <summary>
		/// Output only. The create time of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Required. Display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Forward SSH Tunnel connectivity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forwardSshConnectivity")]
		public ForwardSshTunnelConnectivity ForwardSshConnectivity { get; set; }
		
		/// <summary>
		/// Cloud Storage bucket profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gcsProfile")]
		public GcsProfile GcsProfile { get; set; }
		
		/// <summary>
		/// Labels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// MySQL database profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysqlProfile")]
		public MysqlProfile MysqlProfile { get; set; }
		
		/// <summary>
		/// Output only. The resource's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Oracle database profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleProfile")]
		public OracleProfile OracleProfile { get; set; }
		
		/// <summary>
		/// PostgreSQL database profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postgresqlProfile")]
		public PostgresqlProfile PostgresqlProfile { get; set; }
		
		/// <summary>
		/// Private Connectivity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateConnectivity")]
		public PrivateConnectivity PrivateConnectivity { get; set; }
		
		/// <summary>
		/// Static IP address connectivity. Used when the source database is configured to allow incoming connections from the Datastream public IP addresses for the region specified in the connection profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticServiceIpConnectivity")]
		public StaticServiceIpConnectivity StaticServiceIpConnectivity { get; set; }
		
		/// <summary>
		/// Output only. The update time of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Forward SSH Tunnel connectivity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForwardSshTunnelConnectivity
	{
		
		/// <summary>
		/// Required. Hostname for the SSH tunnel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Input only. SSH password.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Port for the SSH tunnel, default value is 22.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Input only. SSH private key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateKey")]
		public string PrivateKey { get; set; }
		
		/// <summary>
		/// Required. Username for the SSH tunnel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Cloud Storage bucket profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GcsProfile
	{
		
		/// <summary>
		/// Required. The Cloud Storage bucket name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket")]
		public string Bucket { get; set; }
		
		/// <summary>
		/// The root path inside the Cloud Storage bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rootPath")]
		public string RootPath { get; set; }
	}
	
	/// <summary>
	/// MySQL database profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MysqlProfile
	{
		
		/// <summary>
		/// Required. Hostname for the MySQL connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Required. Input only. Password for the MySQL connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Port for the MySQL connection, default value is 3306.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// MySQL SSL configuration information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslConfig")]
		public MysqlSslConfig SslConfig { get; set; }
		
		/// <summary>
		/// Required. Username for the MySQL connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// MySQL SSL configuration information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MysqlSslConfig
	{
		
		/// <summary>
		/// Input only. PEM-encoded certificate of the CA that signed the source database server's certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCertificate")]
		public string CaCertificate { get; set; }
		
		/// <summary>
		/// Output only. Indicates whether the ca_certificate field is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCertificateSet")]
		public System.Nullable<System.Boolean> CaCertificateSet { get; set; }
		
		/// <summary>
		/// Input only. PEM-encoded certificate that will be used by the replica to authenticate against the source database server. If this field is used then the 'client_key' and the 'ca_certificate' fields are mandatory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertificate")]
		public string ClientCertificate { get; set; }
		
		/// <summary>
		/// Output only. Indicates whether the client_certificate field is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientCertificateSet")]
		public System.Nullable<System.Boolean> ClientCertificateSet { get; set; }
		
		/// <summary>
		/// Input only. PEM-encoded private key associated with the Client Certificate. If this field is used then the 'client_certificate' and the 'ca_certificate' fields are mandatory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientKey")]
		public string ClientKey { get; set; }
		
		/// <summary>
		/// Output only. Indicates whether the client_key field is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientKeySet")]
		public System.Nullable<System.Boolean> ClientKeySet { get; set; }
	}
	
	/// <summary>
	/// Oracle database profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleProfile
	{
		
		/// <summary>
		/// Connection string attributes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionAttributes")]
		public System.Collections.Generic.Dictionary<string, string> ConnectionAttributes { get; set; }
		
		/// <summary>
		/// Required. Database for the Oracle connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="databaseService")]
		public string DatabaseService { get; set; }
		
		/// <summary>
		/// Required. Hostname for the Oracle connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Oracle SSL configuration information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleSslConfig")]
		public OracleSslConfig OracleSslConfig { get; set; }
		
		/// <summary>
		/// Required. Password for the Oracle connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Port for the Oracle connection, default value is 1521.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Required. Username for the Oracle connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Oracle SSL configuration information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleSslConfig
	{
		
		/// <summary>
		/// Input only. PEM-encoded certificate of the CA that signed the source database server's certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCertificate")]
		public string CaCertificate { get; set; }
		
		/// <summary>
		/// Output only. Indicates whether the ca_certificate field has been set for this Connection-Profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="caCertificateSet")]
		public System.Nullable<System.Boolean> CaCertificateSet { get; set; }
	}
	
	/// <summary>
	/// PostgreSQL database profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PostgresqlProfile
	{
		
		/// <summary>
		/// Required. Database for the PostgreSQL connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="database")]
		public string Database { get; set; }
		
		/// <summary>
		/// Required. Hostname for the PostgreSQL connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Required. Password for the PostgreSQL connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// Port for the PostgreSQL connection, default value is 5432.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Required. Username for the PostgreSQL connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Private Connectivity
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrivateConnectivity
	{
		
		/// <summary>
		/// Required. A reference to a private connection resource. Format: `projects/{project}/locations/{location}/privateConnections/{name}`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateConnection")]
		public string PrivateConnection { get; set; }
	}
	
	/// <summary>
	/// Static IP address connectivity. Used when the source database is configured to allow incoming connections from the Datastream public IP addresses for the region specified in the connection profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StaticServiceIpConnectivity
	{
	}
	
	/// <summary>
	/// The configuration of the stream destination.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DestinationConfig
	{
		
		/// <summary>
		/// BigQuery destination configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bigqueryDestinationConfig")]
		public BigQueryDestinationConfig BigqueryDestinationConfig { get; set; }
		
		/// <summary>
		/// Required. Destination connection profile resource. Format: `projects/{project}/locations/{location}/connectionProfiles/{name}`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationConnectionProfile")]
		public string DestinationConnectionProfile { get; set; }
		
		/// <summary>
		/// Google Cloud Storage destination configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gcsDestinationConfig")]
		public GcsDestinationConfig GcsDestinationConfig { get; set; }
	}
	
	/// <summary>
	/// Google Cloud Storage destination configuration
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GcsDestinationConfig
	{
		
		/// <summary>
		/// AVRO file format configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avroFileFormat")]
		public AvroFileFormat AvroFileFormat { get; set; }
		
		/// <summary>
		/// The maximum duration for which new events are added before a file is closed and a new file is created. Values within the range of 15-60 seconds are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileRotationInterval")]
		public string FileRotationInterval { get; set; }
		
		/// <summary>
		/// The maximum file size to be saved in the bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileRotationMb")]
		public System.Nullable<System.Int32> FileRotationMb { get; set; }
		
		/// <summary>
		/// JSON file format configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jsonFileFormat")]
		public JsonFileFormat JsonFileFormat { get; set; }
		
		/// <summary>
		/// Path inside the Cloud Storage bucket to write data to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// JSON file format configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JsonFileFormat
	{
		
		/// <summary>
		/// Compression of the loaded JSON file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compression")]
		public System.Nullable<JsonFileFormatCompression> Compression { get; set; }
		
		/// <summary>
		/// The schema file format along JSON data files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schemaFileFormat")]
		public System.Nullable<JsonFileFormatSchemaFileFormat> SchemaFileFormat { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum JsonFileFormatCompression
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="JSON_COMPRESSION_UNSPECIFIED")]
		JSON_COMPRESSION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NO_COMPRESSION")]
		NO_COMPRESSION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GZIP")]
		GZIP = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum JsonFileFormatSchemaFileFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SCHEMA_FILE_FORMAT_UNSPECIFIED")]
		SCHEMA_FILE_FORMAT_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NO_SCHEMA_FILE")]
		NO_SCHEMA_FILE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AVRO_SCHEMA_FILE")]
		AVRO_SCHEMA_FILE = 2,
	}
	
	/// <summary>
	/// Request message for 'discover' ConnectionProfile request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiscoverConnectionProfileRequest
	{
		
		/// <summary>
		/// A set of reusable connection configurations to be used as a source or destination for a stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionProfile")]
		public ConnectionProfile ConnectionProfile { get; set; }
		
		/// <summary>
		/// A reference to an existing connection profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionProfileName")]
		public string ConnectionProfileName { get; set; }
		
		/// <summary>
		/// Whether to retrieve the full hierarchy of data objects (TRUE) or only the current level (FALSE).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullHierarchy")]
		public System.Nullable<System.Boolean> FullHierarchy { get; set; }
		
		/// <summary>
		/// The number of hierarchy levels below the current level to be retrieved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hierarchyDepth")]
		public System.Nullable<System.Int32> HierarchyDepth { get; set; }
		
		/// <summary>
		/// MySQL database structure
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysqlRdbms")]
		public MysqlRdbms MysqlRdbms { get; set; }
		
		/// <summary>
		/// Oracle database structure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleRdbms")]
		public OracleRdbms OracleRdbms { get; set; }
		
		/// <summary>
		/// PostgreSQL database structure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postgresqlRdbms")]
		public PostgresqlRdbms PostgresqlRdbms { get; set; }
	}
	
	/// <summary>
	/// Response from a discover request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiscoverConnectionProfileResponse
	{
		
		/// <summary>
		/// MySQL database structure
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysqlRdbms")]
		public MysqlRdbms MysqlRdbms { get; set; }
		
		/// <summary>
		/// Oracle database structure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleRdbms")]
		public OracleRdbms OracleRdbms { get; set; }
		
		/// <summary>
		/// PostgreSQL database structure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postgresqlRdbms")]
		public PostgresqlRdbms PostgresqlRdbms { get; set; }
	}
	
	/// <summary>
	/// Configuration to drop large object values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DropLargeObjects
	{
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Empty
	{
	}
	
	/// <summary>
	/// Response message for a 'FetchStaticIps' response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FetchStaticIpsResponse
	{
		
		/// <summary>
		/// A token that can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// list of static ips by account
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="staticIps")]
		public string[] StaticIps { get; set; }
	}
	
	/// <summary>
	/// Response message for listing connection profiles.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListConnectionProfilesResponse
	{
		
		/// <summary>
		/// List of connection profiles.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionProfiles")]
		public ConnectionProfile[] ConnectionProfiles { get; set; }
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// The response message for Locations.ListLocations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListLocationsResponse
	{
		
		/// <summary>
		/// A list of locations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public Location[] Locations { get; set; }
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A resource that represents a Google Cloud location.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Location
	{
		
		/// <summary>
		/// The friendly name for this location, typically a nearby city name. For example, "Tokyo".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Cross-service attributes for the location. For example {"cloud.googleapis.com/region": "us-east1"}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// The canonical id for this location. For example: `"us-east1"`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// Service-specific metadata. For example the available capacity at the given location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// Resource name for the location, which may vary between implementations. For example: `"projects/example-project/locations/us-east1"`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The response message for Operations.ListOperations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListOperationsResponse
	{
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A list of operations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public Operation[] Operations { get; set; }
	}
	
	/// <summary>
	/// This resource represents a long-running operation that is the result of a network API call.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Operation
	{
		
		/// <summary>
		/// If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="done")]
		public System.Nullable<System.Boolean> Done { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public System.Collections.Generic.Dictionary<string, object> Response { get; set; }
	}
	
	/// <summary>
	/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Status
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Response containing a list of private connection configurations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListPrivateConnectionsResponse
	{
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// List of private connectivity configurations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateConnections")]
		public PrivateConnection[] PrivateConnections { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// The PrivateConnection resource is used to establish private connectivity between Datastream and a customer's network.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrivateConnection
	{
		
		/// <summary>
		/// Output only. The create time of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Required. Display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Represent a user-facing Error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Error Error { get; set; }
		
		/// <summary>
		/// Labels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. The resource's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The state of the Private Connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<PrivateConnectionState> State { get; set; }
		
		/// <summary>
		/// Output only. The update time of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// The VPC Peering configuration is used to create VPC peering between Datastream and the consumer's VPC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpcPeeringConfig")]
		public VpcPeeringConfig VpcPeeringConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PrivateConnectionState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STATE_UNSPECIFIED")]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATED")]
		CREATED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED_TO_DELETE")]
		FAILED_TO_DELETE = 5,
	}
	
	/// <summary>
	/// The VPC Peering configuration is used to create VPC peering between Datastream and the consumer's VPC.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcPeeringConfig
	{
		
		/// <summary>
		/// Required. A free subnet for peering. (CIDR of /29)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnet")]
		public string Subnet { get; set; }
		
		/// <summary>
		/// Required. Fully qualified name of the VPC that Datastream will peer to. Format: `projects/{project}/global/{networks}/{name}`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpc")]
		public string Vpc { get; set; }
	}
	
	/// <summary>
	/// Route list response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListRoutesResponse
	{
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// List of Routes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routes")]
		public Route[] Routes { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// The route resource is the child of the private connection resource, used for defining a route for a private connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Route
	{
		
		/// <summary>
		/// Output only. The create time of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Required. Destination address for connection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationAddress")]
		public string DestinationAddress { get; set; }
		
		/// <summary>
		/// Destination port for connection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationPort")]
		public System.Nullable<System.Int32> DestinationPort { get; set; }
		
		/// <summary>
		/// Required. Display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Labels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. The resource's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The update time of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Response containing the objects for a stream.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListStreamObjectsResponse
	{
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// List of stream objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="streamObjects")]
		public StreamObject[] StreamObjects { get; set; }
	}
	
	/// <summary>
	/// A specific stream object (e.g a specific DB table).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StreamObject
	{
		
		/// <summary>
		/// Represents a backfill job on a specific stream object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backfillJob")]
		public BackfillJob BackfillJob { get; set; }
		
		/// <summary>
		/// Output only. The creation time of the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Required. Display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Output only. Active errors on the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public Error[] Errors { get; set; }
		
		/// <summary>
		/// Output only. The object resource's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Represents an identifier of an object in the data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceObject")]
		public SourceObjectIdentifier SourceObject { get; set; }
		
		/// <summary>
		/// Output only. The last update time of the object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Represents an identifier of an object in the data source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceObjectIdentifier
	{
		
		/// <summary>
		/// Mysql data source object identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysqlIdentifier")]
		public MysqlObjectIdentifier MysqlIdentifier { get; set; }
		
		/// <summary>
		/// Oracle data source object identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleIdentifier")]
		public OracleObjectIdentifier OracleIdentifier { get; set; }
		
		/// <summary>
		/// PostgreSQL data source object identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postgresqlIdentifier")]
		public PostgresqlObjectIdentifier PostgresqlIdentifier { get; set; }
	}
	
	/// <summary>
	/// Mysql data source object identifier.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MysqlObjectIdentifier
	{
		
		/// <summary>
		/// Required. The database name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="database")]
		public string Database { get; set; }
		
		/// <summary>
		/// Required. The table name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="table")]
		public string Table { get; set; }
	}
	
	/// <summary>
	/// Oracle data source object identifier.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleObjectIdentifier
	{
		
		/// <summary>
		/// Required. The schema name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
		
		/// <summary>
		/// Required. The table name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="table")]
		public string Table { get; set; }
	}
	
	/// <summary>
	/// PostgreSQL data source object identifier.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PostgresqlObjectIdentifier
	{
		
		/// <summary>
		/// Required. The schema name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
		
		/// <summary>
		/// Required. The table name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="table")]
		public string Table { get; set; }
	}
	
	/// <summary>
	/// Response message for listing streams.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListStreamsResponse
	{
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// List of streams
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="streams")]
		public Stream[] Streams { get; set; }
		
		/// <summary>
		/// Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// A resource representing streaming data from a source to a destination.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Stream
	{
		
		/// <summary>
		/// Backfill strategy to automatically backfill the Stream's objects. Specific objects can be excluded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backfillAll")]
		public BackfillAllStrategy BackfillAll { get; set; }
		
		/// <summary>
		/// Backfill strategy to disable automatic backfill for the Stream's objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backfillNone")]
		public BackfillNoneStrategy BackfillNone { get; set; }
		
		/// <summary>
		/// Output only. The creation time of the stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Immutable. A reference to a KMS encryption key. If provided, it will be used to encrypt the data. If left blank, data will be encrypted using an internal Stream-specific encryption key provisioned through KMS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerManagedEncryptionKey")]
		public string CustomerManagedEncryptionKey { get; set; }
		
		/// <summary>
		/// The configuration of the stream destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationConfig")]
		public DestinationConfig DestinationConfig { get; set; }
		
		/// <summary>
		/// Required. Display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Output only. Errors on the Stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public Error[] Errors { get; set; }
		
		/// <summary>
		/// Labels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. If the stream was recovered, the time of the last recovery. Note: This field is currently experimental.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastRecoveryTime")]
		public string LastRecoveryTime { get; set; }
		
		/// <summary>
		/// Output only. The stream's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The configuration of the stream source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceConfig")]
		public SourceConfig SourceConfig { get; set; }
		
		/// <summary>
		/// The state of the stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<StreamState> State { get; set; }
		
		/// <summary>
		/// Output only. The last update time of the stream.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// The configuration of the stream source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceConfig
	{
		
		/// <summary>
		/// MySQL source configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mysqlSourceConfig")]
		public MysqlSourceConfig MysqlSourceConfig { get; set; }
		
		/// <summary>
		/// Oracle data source configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oracleSourceConfig")]
		public OracleSourceConfig OracleSourceConfig { get; set; }
		
		/// <summary>
		/// PostgreSQL data source configuration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postgresqlSourceConfig")]
		public PostgresqlSourceConfig PostgresqlSourceConfig { get; set; }
		
		/// <summary>
		/// Required. Source connection profile resoource. Format: `projects/{project}/locations/{location}/connectionProfiles/{name}`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceConnectionProfile")]
		public string SourceConnectionProfile { get; set; }
	}
	
	/// <summary>
	/// MySQL source configuration
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MysqlSourceConfig
	{
		
		/// <summary>
		/// MySQL database structure
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="excludeObjects")]
		public MysqlRdbms ExcludeObjects { get; set; }
		
		/// <summary>
		/// MySQL database structure
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeObjects")]
		public MysqlRdbms IncludeObjects { get; set; }
		
		/// <summary>
		/// Maximum number of concurrent backfill tasks. The number should be non negative. If not set (or set to 0), the system's default value will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConcurrentBackfillTasks")]
		public System.Nullable<System.Int32> MaxConcurrentBackfillTasks { get; set; }
		
		/// <summary>
		/// Maximum number of concurrent CDC tasks. The number should be non negative. If not set (or set to 0), the system's default value will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConcurrentCdcTasks")]
		public System.Nullable<System.Int32> MaxConcurrentCdcTasks { get; set; }
	}
	
	/// <summary>
	/// Oracle data source configuration
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OracleSourceConfig
	{
		
		/// <summary>
		/// Configuration to drop large object values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dropLargeObjects")]
		public DropLargeObjects DropLargeObjects { get; set; }
		
		/// <summary>
		/// Oracle database structure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="excludeObjects")]
		public OracleRdbms ExcludeObjects { get; set; }
		
		/// <summary>
		/// Oracle database structure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeObjects")]
		public OracleRdbms IncludeObjects { get; set; }
		
		/// <summary>
		/// Maximum number of concurrent backfill tasks. The number should be non-negative. If not set (or set to 0), the system's default value is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConcurrentBackfillTasks")]
		public System.Nullable<System.Int32> MaxConcurrentBackfillTasks { get; set; }
		
		/// <summary>
		/// Maximum number of concurrent CDC tasks. The number should be non-negative. If not set (or set to 0), the system's default value is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConcurrentCdcTasks")]
		public System.Nullable<System.Int32> MaxConcurrentCdcTasks { get; set; }
		
		/// <summary>
		/// Configuration to stream large object values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="streamLargeObjects")]
		public StreamLargeObjects StreamLargeObjects { get; set; }
	}
	
	/// <summary>
	/// Configuration to stream large object values.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StreamLargeObjects
	{
	}
	
	/// <summary>
	/// PostgreSQL data source configuration
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PostgresqlSourceConfig
	{
		
		/// <summary>
		/// PostgreSQL database structure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="excludeObjects")]
		public PostgresqlRdbms ExcludeObjects { get; set; }
		
		/// <summary>
		/// PostgreSQL database structure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeObjects")]
		public PostgresqlRdbms IncludeObjects { get; set; }
		
		/// <summary>
		/// Maximum number of concurrent backfill tasks. The number should be non negative. If not set (or set to 0), the system's default value will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConcurrentBackfillTasks")]
		public System.Nullable<System.Int32> MaxConcurrentBackfillTasks { get; set; }
		
		/// <summary>
		/// Required. The name of the publication that includes the set of all tables that are defined in the stream's include_objects.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publication")]
		public string Publication { get; set; }
		
		/// <summary>
		/// Required. Immutable. The name of the logical replication slot that's configured with the pgoutput plugin.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicationSlot")]
		public string ReplicationSlot { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum StreamState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STATE_UNSPECIFIED")]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NOT_STARTED")]
		NOT_STARTED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RUNNING")]
		RUNNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PAUSED")]
		PAUSED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAINTENANCE")]
		MAINTENANCE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED_PERMANENTLY")]
		FAILED_PERMANENTLY = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STARTING")]
		STARTING = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DRAINING")]
		DRAINING = 8,
	}
	
	/// <summary>
	/// Request for looking up a specific stream object by its source object identifier.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LookupStreamObjectRequest
	{
		
		/// <summary>
		/// Represents an identifier of an object in the data source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceObjectIdentifier")]
		public SourceObjectIdentifier SourceObjectIdentifier { get; set; }
	}
	
	/// <summary>
	/// Represents the metadata of the long-running operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OperationMetadata
	{
		
		/// <summary>
		/// Output only. API version used to start the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
		
		/// <summary>
		/// Output only. The time the operation was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The time the operation finished running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Output only. Identifies whether the user has requested cancellation of the operation. Operations that have successfully been cancelled have Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestedCancellation")]
		public System.Nullable<System.Boolean> RequestedCancellation { get; set; }
		
		/// <summary>
		/// Output only. Human-readable status of the operation, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// Output only. Server-defined resource path for the target of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// Contains the current validation results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validationResult")]
		public ValidationResult ValidationResult { get; set; }
		
		/// <summary>
		/// Output only. Name of the verb executed by the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verb")]
		public string Verb { get; set; }
	}
	
	/// <summary>
	/// Contains the current validation results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidationResult
	{
		
		/// <summary>
		/// A list of validations (includes both executed as well as not executed validations).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validations")]
		public Validation[] Validations { get; set; }
	}
	
	/// <summary>
	/// A validation to perform on a stream.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Validation
	{
		
		/// <summary>
		/// A custom code identifying this validation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// A short description of the validation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Messages reflecting the validation results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public ValidationMessage[] Message { get; set; }
		
		/// <summary>
		/// Output only. Validation execution status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ValidationState> State { get; set; }
	}
	
	/// <summary>
	/// Represent user-facing validation result message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ValidationMessage
	{
		
		/// <summary>
		/// A custom code identifying this specific message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Message severity level (warning or error).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<ValidationMessageLevel> Level { get; set; }
		
		/// <summary>
		/// The result of the validation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Additional metadata related to the result.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ValidationMessageLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LEVEL_UNSPECIFIED")]
		LEVEL_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WARNING")]
		WARNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ERROR")]
		ERROR = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ValidationState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="STATE_UNSPECIFIED")]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NOT_EXECUTED")]
		NOT_EXECUTED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PASSED")]
		PASSED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="WARNING")]
		WARNING = 4,
	}
	
	/// <summary>
	/// Request message for running a stream.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RunStreamRequest
	{
		
		/// <summary>
		/// The strategy that the stream uses for CDC replication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cdcStrategy")]
		public CdcStrategy CdcStrategy { get; set; }
	}
	
	/// <summary>
	/// Request for manually initiating a backfill job for a specific stream object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartBackfillJobRequest
	{
	}
	
	/// <summary>
	/// Response for manually initiating a backfill job for a specific stream object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StartBackfillJobResponse
	{
		
		/// <summary>
		/// A specific stream object (e.g a specific DB table).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="object")]
		public StreamObject Object { get; set; }
	}
	
	/// <summary>
	/// Request for manually stopping a running backfill job for a specific stream object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StopBackfillJobRequest
	{
	}
	
	/// <summary>
	/// Response for manually stop a backfill job for a specific stream object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StopBackfillJobResponse
	{
		
		/// <summary>
		/// A specific stream object (e.g a specific DB table).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="object")]
		public StreamObject Object { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Use this method to delete a stream.
		/// Datastream_projects_locations_streams_delete v1/{name}
		/// </summary>
		/// <param name="name">Required. The name of the stream resource to delete.</param>
		/// <param name="requestId">Optional. A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Datastream_projects_locations_streams_deleteAsync(string name, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use this method to get details about a stream object.
		/// Datastream_projects_locations_streams_objects_get v1/{name}
		/// </summary>
		/// <param name="name">Required. The name of the stream object resource to get.</param>
		/// <returns>Successful response</returns>
		public async Task<StreamObject> Datastream_projects_locations_streams_objects_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StreamObject>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use this method to update the configuration of a stream.
		/// Datastream_projects_locations_streams_patch v1/{name}
		/// </summary>
		/// <param name="name">Output only. The stream's name.</param>
		/// <param name="force">Optional. Update the stream without validating it.</param>
		/// <param name="requestId">Optional. A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">Optional. Field mask is used to specify the fields to be overwritten in the stream resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then all fields will be overwritten.</param>
		/// <param name="validateOnly">Optional. Only validate the stream with the changes, without actually updating it. The default is false.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Datastream_projects_locations_streams_patchAsync(string name, bool force, string requestId, string updateMask, bool validateOnly, Stream requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&force="+force+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask))+"&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists information about the supported locations for this service.
		/// Datastream_projects_locations_list v1/{name}/locations
		/// </summary>
		/// <param name="name">The resource that owns the locations collection, if applicable.</param>
		/// <param name="filter">A filter to narrow down results to a preferred subset. The filtering language accepts strings like `"displayName=tokyo"`, and is documented in more detail in [AIP-160](https://google.aip.dev/160).</param>
		/// <param name="pageSize">The maximum number of results to return. If not set, the service selects a default.</param>
		/// <param name="pageToken">A page token received from the `next_page_token` field in the response. Send that page token to receive the subsequent page.</param>
		/// <returns>Successful response</returns>
		public async Task<ListLocationsResponse> Datastream_projects_locations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/locations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListLocationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
		/// Datastream_projects_locations_operations_list v1/{name}/operations
		/// </summary>
		/// <param name="name">The name of the operation's parent resource.</param>
		/// <param name="filter">The standard list filter.</param>
		/// <param name="pageSize">The standard list page size.</param>
		/// <param name="pageToken">The standard list page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListOperationsResponse> Datastream_projects_locations_operations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/operations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListOperationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// Datastream_projects_locations_operations_cancel v1/{name}:cancel
		/// </summary>
		/// <param name="name">The name of the operation resource to be cancelled.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Datastream_projects_locations_operations_cancelAsync(string name, CancelOperationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Empty>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// The FetchStaticIps API call exposes the static IP addresses used by Datastream.
		/// Datastream_projects_locations_fetchStaticIps v1/{name}:fetchStaticIps
		/// </summary>
		/// <param name="name">Required. The resource name for the location for which static IPs should be returned. Must be in the format `projects/*/locations/*`.</param>
		/// <param name="pageSize">Maximum number of Ips to return, will likely not be specified.</param>
		/// <param name="pageToken">A page token, received from a previous `ListStaticIps` call. will likely not be specified.</param>
		/// <returns>Successful response</returns>
		public async Task<FetchStaticIpsResponse> Datastream_projects_locations_fetchStaticIpsAsync(string name, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":fetchStaticIps&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FetchStaticIpsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use this method to start, resume or recover a stream with a non default CDC strategy. NOTE: This feature is currently experimental.
		/// Datastream_projects_locations_streams_run v1/{name}:run
		/// </summary>
		/// <param name="name">Required. Name of the stream resource to start, in the format: projects/{project_id}/locations/{location}/streams/{stream_name}</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Datastream_projects_locations_streams_runAsync(string name, RunStreamRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":run";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use this method to start a backfill job for the specified stream object.
		/// Datastream_projects_locations_streams_objects_startBackfillJob v1/{object}:startBackfillJob
		/// </summary>
		/// <param name="_object">Required. The name of the stream object resource to start a backfill job for.</param>
		/// <returns>Successful response</returns>
		public async Task<StartBackfillJobResponse> Datastream_projects_locations_streams_objects_startBackfillJobAsync(string _object, StartBackfillJobRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+":startBackfillJob";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StartBackfillJobResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use this method to stop a backfill job for the specified stream object.
		/// Datastream_projects_locations_streams_objects_stopBackfillJob v1/{object}:stopBackfillJob
		/// </summary>
		/// <param name="_object">Required. The name of the stream object resource to stop the backfill job for.</param>
		/// <returns>Successful response</returns>
		public async Task<StopBackfillJobResponse> Datastream_projects_locations_streams_objects_stopBackfillJobAsync(string _object, StopBackfillJobRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (_object==null? "" : System.Uri.EscapeDataString(_object))+":stopBackfillJob";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StopBackfillJobResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use this method to list connection profiles created in a project and location.
		/// Datastream_projects_locations_connectionProfiles_list v1/{parent}/connectionProfiles
		/// </summary>
		/// <param name="parent">Required. The parent that owns the collection of connection profiles.</param>
		/// <param name="filter">Filter request.</param>
		/// <param name="orderBy">Order by fields for the result.</param>
		/// <param name="pageSize">Maximum number of connection profiles to return. If unspecified, at most 50 connection profiles will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Page token received from a previous `ListConnectionProfiles` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListConnectionProfiles` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListConnectionProfilesResponse> Datastream_projects_locations_connectionProfiles_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/connectionProfiles&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListConnectionProfilesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use this method to create a connection profile in a project and location.
		/// Datastream_projects_locations_connectionProfiles_create v1/{parent}/connectionProfiles
		/// </summary>
		/// <param name="parent">Required. The parent that owns the collection of ConnectionProfiles.</param>
		/// <param name="connectionProfileId">Required. The connection profile identifier.</param>
		/// <param name="force">Optional. Create the connection profile without validating it.</param>
		/// <param name="requestId">Optional. A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <param name="validateOnly">Optional. Only validate the connection profile, but don't create any resources. The default is false.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Datastream_projects_locations_connectionProfiles_createAsync(string parent, string connectionProfileId, bool force, string requestId, bool validateOnly, ConnectionProfile requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/connectionProfiles&connectionProfileId=" + (connectionProfileId==null? "" : System.Uri.EscapeDataString(connectionProfileId))+"&force="+force+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use this method to discover a connection profile. The discover API call exposes the data objects and metadata belonging to the profile. Typically, a request returns children data objects of a parent data object that's optionally supplied in the request.
		/// Datastream_projects_locations_connectionProfiles_discover v1/{parent}/connectionProfiles:discover
		/// </summary>
		/// <param name="parent">Required. The parent resource of the connection profile type. Must be in the format `projects/*/locations/*`.</param>
		/// <returns>Successful response</returns>
		public async Task<DiscoverConnectionProfileResponse> Datastream_projects_locations_connectionProfiles_discoverAsync(string parent, DiscoverConnectionProfileRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/connectionProfiles:discover";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DiscoverConnectionProfileResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use this method to list the objects of a specific stream.
		/// Datastream_projects_locations_streams_objects_list v1/{parent}/objects
		/// </summary>
		/// <param name="parent">Required. The parent stream that owns the collection of objects.</param>
		/// <param name="pageSize">Maximum number of objects to return. Default is 50. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Page token received from a previous `ListStreamObjectsRequest` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListStreamObjectsRequest` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListStreamObjectsResponse> Datastream_projects_locations_streams_objects_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/objects&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListStreamObjectsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use this method to look up a stream object by its source object identifier.
		/// Datastream_projects_locations_streams_objects_lookup v1/{parent}/objects:lookup
		/// </summary>
		/// <param name="parent">Required. The parent stream that owns the collection of objects.</param>
		/// <returns>Successful response</returns>
		public async Task<StreamObject> Datastream_projects_locations_streams_objects_lookupAsync(string parent, LookupStreamObjectRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/objects:lookup";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StreamObject>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use this method to list private connectivity configurations in a project and location.
		/// Datastream_projects_locations_privateConnections_list v1/{parent}/privateConnections
		/// </summary>
		/// <param name="parent">Required. The parent that owns the collection of private connectivity configurations.</param>
		/// <param name="filter">Filter request.</param>
		/// <param name="orderBy">Order by fields for the result.</param>
		/// <param name="pageSize">Maximum number of private connectivity configurations to return. If unspecified, at most 50 private connectivity configurations that will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Page token received from a previous `ListPrivateConnections` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListPrivateConnections` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListPrivateConnectionsResponse> Datastream_projects_locations_privateConnections_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/privateConnections&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListPrivateConnectionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use this method to create a private connectivity configuration.
		/// Datastream_projects_locations_privateConnections_create v1/{parent}/privateConnections
		/// </summary>
		/// <param name="parent">Required. The parent that owns the collection of PrivateConnections.</param>
		/// <param name="force">Optional. If set to true, will skip validations.</param>
		/// <param name="privateConnectionId">Required. The private connectivity identifier.</param>
		/// <param name="requestId">Optional. A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Datastream_projects_locations_privateConnections_createAsync(string parent, bool force, string privateConnectionId, string requestId, PrivateConnection requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/privateConnections&force="+force+"&privateConnectionId=" + (privateConnectionId==null? "" : System.Uri.EscapeDataString(privateConnectionId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use this method to list routes created for a private connectivity configuration in a project and location.
		/// Datastream_projects_locations_privateConnections_routes_list v1/{parent}/routes
		/// </summary>
		/// <param name="parent">Required. The parent that owns the collection of Routess.</param>
		/// <param name="filter">Filter request.</param>
		/// <param name="orderBy">Order by fields for the result.</param>
		/// <param name="pageSize">Maximum number of Routes to return. The service may return fewer than this value. If unspecified, at most 50 Routes will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Page token received from a previous `ListRoutes` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListRoutes` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListRoutesResponse> Datastream_projects_locations_privateConnections_routes_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/routes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListRoutesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use this method to create a route for a private connectivity configuration in a project and location.
		/// Datastream_projects_locations_privateConnections_routes_create v1/{parent}/routes
		/// </summary>
		/// <param name="parent">Required. The parent that owns the collection of Routes.</param>
		/// <param name="requestId">Optional. A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <param name="routeId">Required. The Route identifier.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Datastream_projects_locations_privateConnections_routes_createAsync(string parent, string requestId, string routeId, Route requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/routes&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&routeId=" + (routeId==null? "" : System.Uri.EscapeDataString(routeId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Use this method to list streams in a project and location.
		/// Datastream_projects_locations_streams_list v1/{parent}/streams
		/// </summary>
		/// <param name="parent">Required. The parent that owns the collection of streams.</param>
		/// <param name="filter">Filter request.</param>
		/// <param name="orderBy">Order by fields for the result.</param>
		/// <param name="pageSize">Maximum number of streams to return. If unspecified, at most 50 streams will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Page token received from a previous `ListStreams` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListStreams` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListStreamsResponse> Datastream_projects_locations_streams_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/streams&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListStreamsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Use this method to create a stream.
		/// Datastream_projects_locations_streams_create v1/{parent}/streams
		/// </summary>
		/// <param name="parent">Required. The parent that owns the collection of streams.</param>
		/// <param name="force">Optional. Create the stream without validating it.</param>
		/// <param name="requestId">Optional. A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <param name="streamId">Required. The stream identifier.</param>
		/// <param name="validateOnly">Optional. Only validate the stream, but don't create any resources. The default is false.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Datastream_projects_locations_streams_createAsync(string parent, bool force, string requestId, string streamId, bool validateOnly, Stream requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/streams&force="+force+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&streamId=" + (streamId==null? "" : System.Uri.EscapeDataString(streamId))+"&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
