//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ArtifactContent
	{
		
		/// <summary>
		/// Raw content of the artifact or a valid (and accessible) URL where the content can be found.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Collection of references to other artifacts.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="references")]
		public ArtifactReference[] References { get; set; }
	}
	
	/// <summary>
	/// A reference to a different artifact. Typically used with artifact types that can have dependencies like Protobuf.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ArtifactReference
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="artifactId")]
		public string ArtifactId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groupId")]
		public string GroupId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ArtifactMetaData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contentId")]
		public long ContentId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public System.DateTimeOffset CreatedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="globalId")]
		public long GlobalId { get; set; }
		
		/// <summary>
		/// An ID of a single artifact group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupId")]
		public string GroupId { get; set; }
		
		/// <summary>
		/// The ID of a single artifact.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="modifiedBy")]
		public string ModifiedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="modifiedOn")]
		public System.DateTimeOffset ModifiedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// User-defined name-value pairs. Name and value must be strings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Properties Properties { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="references")]
		public ArtifactReference[] References { get; set; }
		
		/// <summary>
		/// Describes the state of an artifact or artifact version.  The following states
		///are possible:
		///
		///* ENABLED
		///* DISABLED
		///* DEPRECATED
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ArtifactMetaDataState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// User-defined name-value pairs. Name and value must be strings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Properties
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ArtifactMetaDataState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED = 2,
	}
	
	/// <summary>
	/// Describes the ownership of an artifact.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ArtifactOwner
	{
		
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public string Owner { get; set; }
	}
	
	/// <summary>
	/// Describes the response received when searching for artifacts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ArtifactSearchResults
	{
		
		/// <summary>
		/// The artifacts returned in the result set.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="artifacts")]
		public SearchedArtifact[] Artifacts { get; set; }
		
		/// <summary>
		/// The total number of artifacts that matched the query that produced the result set (may be 
		///more than the number of artifacts in the result set).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="count")]
		public int Count { get; set; }
	}
	
	/// <summary>
	/// Models a single artifact from the result set returned when searching for artifacts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchedArtifact
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public System.DateTimeOffset CreatedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// An ID of a single artifact group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupId")]
		public string GroupId { get; set; }
		
		/// <summary>
		/// The ID of a single artifact.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="modifiedBy")]
		public string ModifiedBy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="modifiedOn")]
		public System.Nullable<System.DateTimeOffset> ModifiedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes the state of an artifact or artifact version.  The following states
		///are possible:
		///
		///* ENABLED
		///* DISABLED
		///* DEPRECATED
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ArtifactMetaDataState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Describes the state of an artifact or artifact version.  The following states
	///are possible:
	///
	///* ENABLED
	///* DISABLED
	///* DEPRECATED
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ArtifactState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ArtifactTypeInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConfigurationProperty
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateGroupMetaData
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// User-defined name-value pairs. Name and value must be strings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Properties Properties { get; set; }
	}
	
	/// <summary>
	/// Models a download "link".  Useful for browser use-cases.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DownloadRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="downloadId")]
		public string DownloadId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="href")]
		public string Href { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EditableMetaData
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// User-defined name-value pairs. Name and value must be strings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Properties Properties { get; set; }
	}
	
	/// <summary>
	/// All error responses, whether `4xx` or `5xx` will include one of these as the response
	///body.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Error
	{
		
		/// <summary>
		/// Full details about the error.  This might contain a server stack trace, for example.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		/// <summary>
		/// The server-side error code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error_code")]
		public System.Nullable<System.Int32> Error_code { get; set; }
		
		/// <summary>
		/// The short error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The error name - typically the classname of the exception thrown by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GroupMetaData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public System.DateTimeOffset CreatedOn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// An ID of a single artifact group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="modifiedBy")]
		public string ModifiedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="modifiedOn")]
		public System.DateTimeOffset ModifiedOn { get; set; }
		
		/// <summary>
		/// User-defined name-value pairs. Name and value must be strings.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Properties Properties { get; set; }
	}
	
	/// <summary>
	/// Describes the response received when searching for groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GroupSearchResults
	{
		
		/// <summary>
		/// The total number of groups that matched the query that produced the result set (may be 
		///more than the number of groups in the result set).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="count")]
		public int Count { get; set; }
		
		/// <summary>
		/// The groups returned in the result set.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public SearchedGroup[] Groups { get; set; }
	}
	
	/// <summary>
	/// Models a single group from the result set returned when searching for groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchedGroup
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public System.DateTimeOffset CreatedOn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// An ID of a single artifact group.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="modifiedBy")]
		public string ModifiedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="modifiedOn")]
		public System.DateTimeOffset ModifiedOn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum IfExists
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAIL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RETURN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RETURN_OR_UPDATE = 3,
	}
	
	/// <summary>
	/// List of limitations on used resources, that are applied on the current instance of Registry.
	///Keys represent the resource type and are suffixed by the corresponding unit.
	///Values are integers. Only non-negative values are allowed, with the exception of -1, which means that the limit is not applied.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Limits
	{
		
		[System.Runtime.Serialization.DataMember(Name="maxArtifactDescriptionLengthChars")]
		public System.Nullable<System.Int64> MaxArtifactDescriptionLengthChars { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxArtifactLabelsCount")]
		public System.Nullable<System.Int64> MaxArtifactLabelsCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxArtifactNameLengthChars")]
		public System.Nullable<System.Int64> MaxArtifactNameLengthChars { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxArtifactPropertiesCount")]
		public System.Nullable<System.Int64> MaxArtifactPropertiesCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxArtifactsCount")]
		public System.Nullable<System.Int64> MaxArtifactsCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxLabelSizeBytes")]
		public System.Nullable<System.Int64> MaxLabelSizeBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxPropertyKeySizeBytes")]
		public System.Nullable<System.Int64> MaxPropertyKeySizeBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxPropertyValueSizeBytes")]
		public System.Nullable<System.Int64> MaxPropertyValueSizeBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxRequestsPerSecondCount")]
		public System.Nullable<System.Int64> MaxRequestsPerSecondCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxSchemaSizeBytes")]
		public System.Nullable<System.Int64> MaxSchemaSizeBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxTotalSchemasCount")]
		public System.Nullable<System.Int64> MaxTotalSchemasCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maxVersionsPerArtifactCount")]
		public System.Nullable<System.Int64> MaxVersionsPerArtifactCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LogConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="level")]
		public LogConfigurationLevel Level { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LogConfigurationLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEBUG = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRACE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WARN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEVERE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WARNING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INFO = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONFIG = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINE = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINER = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINEST = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LogLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEBUG = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRACE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WARN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEVERE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WARNING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INFO = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONFIG = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINE = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINER = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINEST = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NamedLogConfiguration
	{
	}
	
	/// <summary>
	/// The mapping between a user/principal and their role.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RoleMapping
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="principalId")]
		public string PrincipalId { get; set; }
		
		/// <summary>
		/// A friendly name for the principal.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="principalName")]
		public string PrincipalName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public RoleMappingRole Role { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RoleMappingRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READ_ONLY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEVELOPER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RoleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READ_ONLY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEVELOPER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Rule
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public string Config { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<RuleType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VALIDITY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPATIBILITY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RuleViolationCause
	{
		
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string Context { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	/// <summary>
	/// All error responses, whether `4xx` or `5xx` will include one of these as the response
	///body.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RuleViolationError
	{
	}
	
	/// <summary>
	/// Models a single artifact from the result set returned when searching for artifacts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchedVersion
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contentId")]
		public long ContentId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public System.DateTimeOffset CreatedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="globalId")]
		public long GlobalId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// User-defined name-value pairs. Name and value must be strings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Properties Properties { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="references")]
		public ArtifactReference[] References { get; set; }
		
		/// <summary>
		/// Describes the state of an artifact or artifact version.  The following states
		///are possible:
		///
		///* ENABLED
		///* DISABLED
		///* DEPRECATED
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ArtifactMetaDataState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SortBy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		createdOn = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SortOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		asc = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		desc = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SystemInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="builtOn")]
		public System.Nullable<System.DateTimeOffset> BuiltOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateConfigurationProperty
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateRole
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="role")]
		public RoleMappingRole Role { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateState
	{
		
		/// <summary>
		/// Describes the state of an artifact or artifact version.  The following states
		///are possible:
		///
		///* ENABLED
		///* DISABLED
		///* DEPRECATED
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ArtifactMetaDataState State { get; set; }
	}
	
	/// <summary>
	/// Information about a single user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UserInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="admin")]
		public System.Nullable<System.Boolean> Admin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="developer")]
		public System.Nullable<System.Boolean> Developer { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="viewer")]
		public System.Nullable<System.Boolean> Viewer { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VersionMetaData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contentId")]
		public long ContentId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public System.DateTimeOffset CreatedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="globalId")]
		public long GlobalId { get; set; }
		
		/// <summary>
		/// An ID of a single artifact group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupId")]
		public string GroupId { get; set; }
		
		/// <summary>
		/// The ID of a single artifact.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// User-defined name-value pairs. Name and value must be strings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Properties Properties { get; set; }
		
		/// <summary>
		/// Describes the state of an artifact or artifact version.  The following states
		///are possible:
		///
		///* ENABLED
		///* DISABLED
		///* DEPRECATED
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ArtifactMetaDataState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Describes the response received when searching for artifacts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VersionSearchResults
	{
		
		/// <summary>
		/// The total number of versions that matched the query (may be more than the number of versions
		///returned in the result set).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="count")]
		public int Count { get; set; }
		
		/// <summary>
		/// The collection of artifact versions returned in the result set.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="versions")]
		public SearchedVersion[] Versions { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// List artifact types
		/// Gets a list of all the configured artifact types.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// ListArtifactTypes admin/artifactTypes
		/// </summary>
		/// <returns>The list of available artifact types.</returns>
		public async Task<ArtifactTypeInfo[]> ListArtifactTypesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/artifactTypes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactTypeInfo[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all configuration properties
		/// Returns a list of all configuration properties that have been set.  The list is not paged.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// ListConfigProperties admin/config/properties
		/// </summary>
		/// <returns>On a successful response, returns a list of configuration properties.</returns>
		public async Task<ConfigurationProperty[]> ListConfigPropertiesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/config/properties";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConfigurationProperty[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset a configuration property
		/// Resets the value of a single configuration property.  This will return the property to
		/// its default value (see external documentation for supported properties and their default
		/// values).
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * Property not found or not configured (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// ResetConfigProperty admin/config/properties/{propertyName}
		/// </summary>
		public async Task ResetConfigPropertyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/config/properties/{propertyName}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get configuration property value
		/// Returns the value of a single configuration property.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * Property not found or not configured (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetConfigProperty admin/config/properties/{propertyName}
		/// </summary>
		/// <returns>The configuration property value.</returns>
		public async Task<ConfigurationProperty> GetConfigPropertyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/config/properties/{propertyName}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConfigurationProperty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a configuration property
		/// Updates the value of a single configuration property.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * Property not found or not configured (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateConfigProperty admin/config/properties/{propertyName}
		/// </summary>
		public async Task UpdateConfigPropertyAsync(UpdateConfigurationProperty requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/config/properties/{propertyName}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Export registry data
		/// Exports registry data as a ZIP archive.
		/// ExportData admin/export
		/// </summary>
		/// <param name="forBrowser">Indicates if the operation is done for a browser.  If true, the response will be a JSON payload with a property called `href`.  This `href` will be a single-use, naked download link suitable for use by a web browser to download the content.</param>
		/// <returns>Response when the export is successful.</returns>
		public async Task<DownloadRef> ExportDataAsync(bool forBrowser, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/export?forBrowser="+forBrowser;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DownloadRef>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List logging configurations
		/// List all of the configured logging levels.  These override the default
		/// logging configuration.
		/// ListLogConfigurations admin/loggers
		/// </summary>
		/// <returns>The list of logging configurations.</returns>
		public async Task<NamedLogConfiguration[]> ListLogConfigurationsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/loggers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<NamedLogConfiguration[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes logger configuration
		/// Removes the configured logger configuration (if any) for the given logger.
		/// RemoveLogConfiguration admin/loggers/{logger}
		/// </summary>
		/// <returns>The default logger configuration (now that the configuration for this logger has been removed, the 
		///default configuration is applied).</returns>
		public async Task<NamedLogConfiguration> RemoveLogConfigurationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/loggers/{logger}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<NamedLogConfiguration>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a single logger configuration
		/// Returns the configured logger configuration for the provided logger name, if no logger configuration is persisted it will return the current default log configuration in the system.
		/// GetLogConfiguration admin/loggers/{logger}
		/// </summary>
		/// <returns>The logger configuration for the named logger.</returns>
		public async Task<NamedLogConfiguration> GetLogConfigurationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/loggers/{logger}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<NamedLogConfiguration>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Set a logger's configuration
		/// Configures the logger referenced by the provided logger name with the given configuration.
		/// SetLogConfiguration admin/loggers/{logger}
		/// </summary>
		/// <param name="requestBody">The new logger configuration.</param>
		/// <returns>The new configuration for the given logger.</returns>
		public async Task<NamedLogConfiguration> SetLogConfigurationAsync(LogConfiguration requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/loggers/{logger}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<NamedLogConfiguration>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all role mappings
		/// Gets a list of all role mappings configured in the registry (if any).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// ListRoleMappings admin/roleMappings
		/// </summary>
		/// <returns>A successful response will return the list of role mappings.</returns>
		public async Task<RoleMapping[]> ListRoleMappingsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/roleMappings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RoleMapping[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new role mapping
		/// Creates a new mapping between a user/principal and a role.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// 
		/// CreateRoleMapping admin/roleMappings
		/// </summary>
		public async Task CreateRoleMappingAsync(RoleMapping requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/roleMappings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a role mapping
		/// Deletes a single role mapping, effectively denying access to a user/principal.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No role mapping for the principalId exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// DeleteRoleMapping admin/roleMappings/{principalId}
		/// </summary>
		public async Task DeleteRoleMappingAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/roleMappings/{principalId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a single role mapping
		/// Gets the details of a single role mapping (by `principalId`).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No role mapping for the `principalId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetRoleMapping admin/roleMappings/{principalId}
		/// </summary>
		/// <returns>When successful, returns the details of a role mapping.</returns>
		public async Task<RoleMapping> GetRoleMappingAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/roleMappings/{principalId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RoleMapping>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a role mapping
		/// Updates a single role mapping for one user/principal.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No role mapping for the principalId exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateRoleMapping admin/roleMappings/{principalId}
		/// </summary>
		public async Task UpdateRoleMappingAsync(UpdateRole requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/roleMappings/{principalId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all global rules
		/// Deletes all globally configured rules.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// DeleteAllGlobalRules admin/rules
		/// </summary>
		public async Task DeleteAllGlobalRulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List global rules
		/// Gets a list of all the currently configured global rules (if any).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// ListGlobalRules admin/rules
		/// </summary>
		/// <returns>The list of names of the globally configured rules.</returns>
		public async Task<RuleType[]> ListGlobalRulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RuleType[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create global rule
		/// Adds a rule to the list of globally configured rules.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * The rule type is unknown (HTTP error `400`)
		/// * The rule already exists (HTTP error `409`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// CreateGlobalRule admin/rules
		/// </summary>
		public async Task CreateGlobalRuleAsync(Rule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete global rule
		/// Deletes a single global rule.  If this is the only rule configured, this is the same
		/// as deleting **all** rules.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * Invalid rule name/type (HTTP error `400`)
		/// * No rule with name/type `rule` exists (HTTP error `404`)
		/// * Rule cannot be deleted (HTTP error `409`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// DeleteGlobalRule admin/rules/{rule}
		/// </summary>
		public async Task DeleteGlobalRuleAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get global rule configuration
		/// Returns information about the named globally configured rule.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * Invalid rule name/type (HTTP error `400`)
		/// * No rule with name/type `rule` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetGlobalRuleConfig admin/rules/{rule}
		/// </summary>
		/// <returns>The global rule's configuration.</returns>
		public async Task<Rule> GetGlobalRuleConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Rule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update global rule configuration
		/// Updates the configuration for a globally configured rule.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * Invalid rule name/type (HTTP error `400`)
		/// * No rule with name/type `rule` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateGlobalRuleConfig admin/rules/{rule}
		/// </summary>
		/// <returns>The global rule's configuration was successfully updated.</returns>
		public async Task<Rule> UpdateGlobalRuleConfigAsync(Rule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "admin/rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Rule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List groups
		/// Returns a list of all groups.  This list is paged.
		/// ListGroups groups
		/// </summary>
		/// <param name="limit">The number of groups to return.  Defaults to 20.</param>
		/// <param name="offset">The number of groups to skip before starting the result set.  Defaults to 0.</param>
		/// <param name="order">Sort order, ascending (`asc`) or descending (`desc`).</param>
		/// <param name="orderby">The field to sort by.  Can be one of:
		///
		///* `name`
		///* `createdOn`
		///</param>
		/// <returns>On a successful response, returns a bounded set of groups.</returns>
		public async Task<GroupSearchResults> ListGroupsAsync(int limit, int offset, SortOrder order, SortBy orderby, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups?limit="+limit+"&offset="+offset+"&order=" + order+"&orderby=" + orderby;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GroupSearchResults>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new group
		/// Creates a new group.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// * The group already exist (HTTP error `409`)
		/// 
		/// CreateGroup groups
		/// </summary>
		/// <returns>The group has been successfully created.</returns>
		public async Task<GroupMetaData> CreateGroupAsync(CreateGroupMetaData requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GroupMetaData>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a group by the specified ID.
		/// Deletes a group by identifier.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// * The group does not exist (HTTP error `404`)
		/// 
		/// DeleteGroupById groups/{groupId}
		/// </summary>
		public async Task DeleteGroupByIdAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a group by the specified ID.
		/// Returns a group using the specified id.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No group exists with the specified ID (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// GetGroupById groups/{groupId}
		/// </summary>
		/// <returns>The group's metadata.</returns>
		public async Task<GroupMetaData> GetGroupByIdAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GroupMetaData>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete artifacts in group
		/// Deletes all of the artifacts that exist in a given group.
		/// DeleteArtifactsInGroup groups/{groupId}/artifacts
		/// </summary>
		public async Task DeleteArtifactsInGroupAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List artifacts in group
		/// Returns a list of all artifacts in the group.  This list is paged.
		/// ListArtifactsInGroup groups/{groupId}/artifacts
		/// </summary>
		/// <param name="limit">The number of artifacts to return.  Defaults to 20.</param>
		/// <param name="offset">The number of artifacts to skip before starting the result set.  Defaults to 0.</param>
		/// <param name="order">Sort order, ascending (`asc`) or descending (`desc`).</param>
		/// <param name="orderby">The field to sort by.  Can be one of:
		///
		///* `name`
		///* `createdOn`
		///</param>
		/// <returns>On a successful response, returns a bounded set of artifacts.</returns>
		public async Task<ArtifactSearchResults> ListArtifactsInGroupAsync(int limit, int offset, SortOrder order, SortBy orderby, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts?limit="+limit+"&offset="+offset+"&order=" + order+"&orderby=" + orderby;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactSearchResults>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete artifact
		/// Deletes an artifact completely, resulting in all versions of the artifact also being
		/// deleted.  This may fail for one of the following reasons:
		/// 
		/// * No artifact with the `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// DeleteArtifact groups/{groupId}/artifacts/{artifactId}
		/// </summary>
		public async Task DeleteArtifactAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get latest artifact
		/// Returns the latest version of the artifact in its raw form.  The `Content-Type` of the
		/// response depends on the artifact type.  In most cases, this is `application/json`, but
		/// for some types it may be different (for example, `PROTOBUF`).
		/// If the latest version of the artifact is marked as `DISABLED`, the next available non-disabled version will be used.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists or all versions are `DISABLED` (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetLatestArtifact groups/{groupId}/artifacts/{artifactId}
		/// </summary>
		/// <param name="dereference">Allows the user to specify if the content should be dereferenced when being returned</param>
		/// <returns>The content of one version of one artifact.</returns>
		public async Task GetLatestArtifactAsync(bool dereference, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}?dereference="+dereference;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact metadata
		/// Gets the metadata for an artifact in the registry, based on the latest version. If the latest version of the artifact is marked as `DISABLED`, the next available non-disabled version will be used. The returned metadata includes
		/// both generated (read-only) and editable metadata (such as name and description).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists  or all versions are `DISABLED` (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// GetArtifactMetaData groups/{groupId}/artifacts/{artifactId}/meta
		/// </summary>
		/// <returns>The artifact's metadata.</returns>
		public async Task<ArtifactMetaData> GetArtifactMetaDataAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactMetaData>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update artifact metadata
		/// Updates the editable parts of the artifact's metadata.  Not all metadata fields can
		/// be updated.  For example, `createdOn` and `createdBy` are both read-only properties.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with the `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// UpdateArtifactMetaData groups/{groupId}/artifacts/{artifactId}/meta
		/// </summary>
		/// <param name="requestBody">Updated artifact metadata.</param>
		public async Task UpdateArtifactMetaDataAsync(EditableMetaData requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact owner
		/// Gets the owner of an artifact in the registry.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// GetArtifactOwner groups/{groupId}/artifacts/{artifactId}/owner
		/// </summary>
		/// <returns>The artifact's owner.</returns>
		public async Task<ArtifactOwner> GetArtifactOwnerAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/owner";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactOwner>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update artifact owner
		/// Changes the ownership of an artifact.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// UpdateArtifactOwner groups/{groupId}/artifacts/{artifactId}/owner
		/// </summary>
		public async Task UpdateArtifactOwnerAsync(ArtifactOwner requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/owner";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete artifact rules
		/// Deletes all of the rules configured for the artifact.  After this is done, the global
		/// rules apply to the artifact again.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// DeleteArtifactRules groups/{groupId}/artifacts/{artifactId}/rules
		/// </summary>
		public async Task DeleteArtifactRulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List artifact rules
		/// Returns a list of all rules configured for the artifact.  The set of rules determines
		/// how the content of an artifact can evolve over time.  If no rules are configured for
		/// an artifact, the set of globally configured rules are used.  If no global rules
		/// are defined, there are no restrictions on content evolution.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// ListArtifactRules groups/{groupId}/artifacts/{artifactId}/rules
		/// </summary>
		/// <returns>Returns the names of the rules configured for the artifact.</returns>
		public async Task<RuleType[]> ListArtifactRulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RuleType[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create artifact rule
		/// Adds a rule to the list of rules that get applied to the artifact when adding new
		/// versions.  All configured rules must pass to successfully add a new artifact version.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * Rule (named in the request body) is unknown (HTTP error `400`)
		/// * A server error occurred (HTTP error `500`)
		/// CreateArtifactRule groups/{groupId}/artifacts/{artifactId}/rules
		/// </summary>
		public async Task CreateArtifactRuleAsync(Rule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete artifact rule
		/// Deletes a rule from the artifact.  This results in the rule no longer applying for
		/// this artifact.  If this is the only rule configured for the artifact, this is the
		/// same as deleting **all** rules, and the globally configured rules now apply to
		/// this artifact.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No rule with this name/type is configured for this artifact (HTTP error `404`)
		/// * Invalid rule type (HTTP error `400`)
		/// * A server error occurred (HTTP error `500`)
		/// DeleteArtifactRule groups/{groupId}/artifacts/{artifactId}/rules/{rule}
		/// </summary>
		public async Task DeleteArtifactRuleAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact rule configuration
		/// Returns information about a single rule configured for an artifact.  This is useful
		/// when you want to know what the current configuration settings are for a specific rule.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No rule with this name/type is configured for this artifact (HTTP error `404`)
		/// * Invalid rule type (HTTP error `400`)
		/// * A server error occurred (HTTP error `500`)
		/// GetArtifactRuleConfig groups/{groupId}/artifacts/{artifactId}/rules/{rule}
		/// </summary>
		/// <returns>Information about a rule.</returns>
		public async Task<Rule> GetArtifactRuleConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Rule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update artifact rule configuration
		/// Updates the configuration of a single rule for the artifact.  The configuration data
		/// is specific to each rule type, so the configuration of the `COMPATIBILITY` rule
		/// is in a different format from the configuration of the `VALIDITY` rule.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No rule with this name/type is configured for this artifact (HTTP error `404`)
		/// * Invalid rule type (HTTP error `400`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateArtifactRuleConfig groups/{groupId}/artifacts/{artifactId}/rules/{rule}
		/// </summary>
		/// <returns>Rule configuration was updated.</returns>
		public async Task<Rule> UpdateArtifactRuleConfigAsync(Rule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Rule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update artifact state
		/// Updates the state of the artifact.  For example, you can use this to mark the latest version of an artifact as `DEPRECATED`. The operation changes the state of the latest version of the artifact, even if this version is `DISABLED`. If multiple versions exist, only the most recent is changed.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateArtifactState groups/{groupId}/artifacts/{artifactId}/state
		/// </summary>
		public async Task UpdateArtifactStateAsync(UpdateState requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List artifact versions
		/// Returns a list of all versions of the artifact.  The result set is paged.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// ListArtifactVersions groups/{groupId}/artifacts/{artifactId}/versions
		/// </summary>
		/// <param name="offset">The number of versions to skip before starting to collect the result set.  Defaults to 0.</param>
		/// <param name="limit">The number of versions to return.  Defaults to 20.</param>
		/// <returns>List of all artifact versions.</returns>
		public async Task<VersionSearchResults> ListArtifactVersionsAsync(int offset, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/versions?offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<VersionSearchResults>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete artifact version
		/// Deletes a single version of the artifact. Parameters `groupId`, `artifactId` and the unique `version`
		/// are needed. If this is the only version of the artifact, this operation is the same as
		/// deleting the entire artifact.
		/// 
		/// This feature is disabled by default and it's discouraged for normal usage. To enable it, set the `registry.rest.artifact.deletion.enabled` property to true. This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * Feature is disabled (HTTP error `405`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// DeleteArtifactVersion groups/{groupId}/artifacts/{artifactId}/versions/{version}
		/// </summary>
		public async Task DeleteArtifactVersionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/versions/{version}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact version
		/// Retrieves a single version of the artifact content.  Both the `artifactId` and the
		/// unique `version` number must be provided.  The `Content-Type` of the response depends
		/// on the artifact type.  In most cases, this is `application/json`, but for some types
		/// it may be different (for example, `PROTOBUF`).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetArtifactVersion groups/{groupId}/artifacts/{artifactId}/versions/{version}
		/// </summary>
		/// <param name="dereference">Allows the user to specify if the content should be dereferenced when being returned</param>
		/// <returns>The content of one version of one artifact.</returns>
		public async Task GetArtifactVersionAsync(bool dereference, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/versions/{version}?dereference="+dereference;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete artifact version metadata
		/// Deletes the user-editable metadata properties of the artifact version.  Any properties
		/// that are not user-editable are preserved.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// DeleteArtifactVersionMetaData groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta
		/// </summary>
		public async Task DeleteArtifactVersionMetaDataAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact version metadata
		/// Retrieves the metadata for a single version of the artifact.  The version metadata is
		/// a subset of the artifact metadata and only includes the metadata that is specific to
		/// the version (for example, this doesn't include `modifiedOn`).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetArtifactVersionMetaData groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta
		/// </summary>
		/// <returns>The artifact version's metadata.</returns>
		public async Task<VersionMetaData> GetArtifactVersionMetaDataAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<VersionMetaData>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update artifact version metadata
		/// Updates the user-editable portion of the artifact version's metadata.  Only some of
		/// the metadata fields are editable by the user.  For example, `description` is editable,
		/// but `createdOn` is not.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateArtifactVersionMetaData groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta
		/// </summary>
		public async Task UpdateArtifactVersionMetaDataAsync(EditableMetaData requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/versions/{version}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact version
		/// Retrieves a single version of the artifact content.  Both the `artifactId` and the
		/// unique `version` number must be provided.  The `Content-Type` of the response depends
		/// on the artifact type.  In most cases, this is `application/json`, but for some types
		/// it may be different (for example, `PROTOBUF`).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetArtifactVersionReferences groups/{groupId}/artifacts/{artifactId}/versions/{version}/references
		/// </summary>
		/// <returns>List of all the artifact references for this artifact.</returns>
		public async Task<ArtifactReference[]> GetArtifactVersionReferencesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/versions/{version}/references";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactReference[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update artifact version state
		/// Updates the state of a specific version of an artifact.  For example, you can use
		/// this operation to disable a specific version.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateArtifactVersionState groups/{groupId}/artifacts/{artifactId}/versions/{version}/state
		/// </summary>
		public async Task UpdateArtifactVersionStateAsync(UpdateState requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "groups/{groupId}/artifacts/{artifactId}/versions/{version}/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact content by SHA-256 hash
		/// Gets the content for an artifact version in the registry using the
		/// SHA-256 hash of the content.  This content hash may be shared by multiple artifact
		/// versions in the case where the artifact versions have identical content.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * No content with this `contentHash` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetContentByHash ids/contentHashes/{contentHash}/
		/// </summary>
		/// <returns>The content of one version of one artifact.</returns>
		public async Task GetContentByHashAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ids/contentHashes/{contentHash}/";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List artifact references by hash
		/// Returns a list containing all the artifact references using the artifact content hash.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// ReferencesByContentHash ids/contentHashes/{contentHash}/references
		/// </summary>
		/// <returns>A list containing all the references for the artifact with the given content hash.</returns>
		public async Task<ArtifactReference[]> ReferencesByContentHashAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ids/contentHashes/{contentHash}/references";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactReference[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact content by ID
		/// Gets the content for an artifact version in the registry using the unique content
		/// identifier for that content.  This content ID may be shared by multiple artifact
		/// versions in the case where the artifact versions are identical.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * No content with this `contentId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetContentById ids/contentIds/{contentId}/
		/// </summary>
		/// <returns>The content of one version of one artifact.</returns>
		public async Task GetContentByIdAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ids/contentIds/{contentId}/";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List artifact references by content ID
		/// Returns a list containing all the artifact references using the artifact content ID.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// ReferencesByContentId ids/contentIds/{contentId}/references
		/// </summary>
		/// <returns>A list containing all the references for the artifact with the given content id.</returns>
		public async Task<ArtifactReference[]> ReferencesByContentIdAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ids/contentIds/{contentId}/references";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactReference[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact by global ID
		/// Gets the content for an artifact version in the registry using its globally unique
		/// identifier.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * No artifact version with this `globalId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetContentByGlobalId ids/globalIds/{globalId}
		/// </summary>
		/// <param name="dereference">Allows the user to specify if the content should be dereferenced when being returned</param>
		/// <returns>The content of one version of one artifact.</returns>
		public async Task GetContentByGlobalIdAsync(bool dereference, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ids/globalIds/{globalId}?dereference="+dereference;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List artifact references by global ID
		/// Returns a list containing all the artifact references using the artifact global ID.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// ReferencesByGlobalId ids/globalIds/{globalId}/references
		/// </summary>
		/// <returns>A list containing all the references for the artifact with the given global id.</returns>
		public async Task<ArtifactReference[]> ReferencesByGlobalIdAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ids/globalIds/{globalId}/references";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactReference[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search for artifacts
		/// Returns a paginated list of all artifacts that match the provided filter criteria.
		/// 
		/// SearchArtifacts search/artifacts
		/// </summary>
		/// <param name="name">Filter by artifact name.</param>
		/// <param name="offset">The number of artifacts to skip before starting to collect the result set.  Defaults to 0.</param>
		/// <param name="limit">The number of artifacts to return.  Defaults to 20.</param>
		/// <param name="order">Sort order, ascending (`asc`) or descending (`desc`).</param>
		/// <param name="orderby">The field to sort by.  Can be one of:
		///
		///* `name`
		///* `createdOn`
		///</param>
		/// <param name="labels">Filter by label.  Include one or more label to only return artifacts containing all of the
		///specified labels.</param>
		/// <param name="properties">Filter by one or more name/value property.  Separate each name/value pair using a colon.  For
		///example `properties=foo:bar` will return only artifacts with a custom property named `foo`
		///and value `bar`.</param>
		/// <param name="description">Filter by description.</param>
		/// <param name="group">Filter by artifact group.</param>
		/// <param name="globalId">Filter by globalId.</param>
		/// <param name="contentId">Filter by contentId.</param>
		/// <returns>On a successful response, returns a result set of artifacts - one for each artifact
		///in the registry that matches the criteria.</returns>
		public async Task<ArtifactSearchResults> SearchArtifactsAsync(string name, int offset, int limit, SortOrder order, SortBy orderby, string[] labels, string[] properties, string description, string group, long globalId, long contentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/artifacts?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&offset="+offset+"&limit="+limit+"&order=" + order+"&orderby=" + orderby+"&"+string.Join("&", labels.Select(z => $"labels={System.Uri.EscapeDataString(z.ToString())}"))+"&"+string.Join("&", properties.Select(z => $"properties={System.Uri.EscapeDataString(z.ToString())}"))+"&description=" + (description==null? "" : System.Uri.EscapeDataString(description))+"&group=" + (group==null? "" : System.Uri.EscapeDataString(group))+"&globalId="+globalId+"&contentId="+contentId;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactSearchResults>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get system information
		/// This operation retrieves information about the running registry system, such as the version
		/// of the software and when it was built.
		/// GetSystemInfo system/info
		/// </summary>
		/// <returns>On success, returns the system information.</returns>
		public async Task<SystemInfo> GetSystemInfoAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/info";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SystemInfo>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get resource limits information
		/// This operation retrieves the list of limitations on used resources, that are applied on the current instance of Registry.
		/// GetResourceLimits system/limits
		/// </summary>
		/// <returns>On success, returns resource limits</returns>
		public async Task<Limits> GetResourceLimitsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/limits";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Limits>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get current user
		/// Returns information about the currently authenticated user.
		/// GetCurrentUserInfo users/me
		/// </summary>
		/// <returns>Response when the endpoint is successfully invoked.</returns>
		public async Task<UserInfo> GetCurrentUserInfoAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "users/me";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UserInfo>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum CreateArtifactX_Registry_Hash_Algorithm
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHA256 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MD5 = 1,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
