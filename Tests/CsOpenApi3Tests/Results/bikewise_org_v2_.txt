//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Paginated incidents matching parameters
		/// 
		/// <p>If you’d like more detailed information about bike incidents, use this endpoint. For mapping, <code>locations</code> is probably a better bet.</p>
		/// 
		/// <p><strong>Notes on location searching</strong>: <br />
		/// - <code>proximity</code> accepts an ip address, an address, zipcode, city, or latitude,longitude - i.e. <code>70.210.133.87</code>, <code>210 NW 11th Ave, Portland, OR</code>, <code>60647</code>, <code>Chicago, IL</code>, and <code>45.521728,-122.67326</code> are all acceptable<br />
		/// - <code>proximity_square</code> sets the length of the sides of the square to find matches inside of. The square is centered on the location specified by <code>proximity</code>. It defaults to 100.</p>
		/// 
		/// GET__version_incidents___format_ v2/incidents
		/// </summary>
		/// <param name="page"><p>Page of results to fetch.</p>
		///</param>
		/// <param name="per_page"><p>Number of results to return per page.</p>
		///</param>
		/// <param name="occurred_before"><p>End of period</p>
		///</param>
		/// <param name="occurred_after"><p>Start of period</p>
		///</param>
		/// <param name="incident_type"><p>Only incidents of specific type</p>
		///</param>
		/// <param name="proximity"><p>Center of location for proximity search</p>
		///</param>
		/// <param name="proximity_square"><p>Size of the proximity search</p>
		///</param>
		/// <param name="query"><p>Full text search of incidents</p>
		///</param>
		/// <returns>No response was specified</returns>
		public async Task GET__version_incidents___format_Async(int page, int per_page, int occurred_before, int occurred_after, GET__version_incidents___format_Incident_type incident_type, string proximity, int proximity_square, string query, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/incidents?page="+page+"&per_page="+per_page+"&occurred_before="+occurred_before+"&occurred_after="+occurred_after+"&incident_type=" + incident_type+"&proximity=" + (proximity==null? "" : System.Uri.EscapeDataString(proximity))+"&proximity_square="+proximity_square+"&query=" + (query==null? "" : System.Uri.EscapeDataString(query));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// GET__version_incidents__id___format_ v2/incidents/{id}
		/// </summary>
		/// <param name="id"><p>Incident ID</p>
		///</param>
		/// <returns>No response was specified</returns>
		public async Task GET__version_incidents__id___format_Async(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/incidents/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unpaginated geojson response
		/// <p><strong>This endpoint behaves exactly like</strong> <code>incidents</code>, but returns a valid geojson <code>FeatureCollection</code> that looks like this:</p>
		/// 
		/// <pre><code>{
		/// type: "FeatureCollection",
		/// features: [
		/// {
		/// type: "Feature",
		/// properties: {
		/// id: 4474199,
		/// type: "Theft",
		/// occurred_at: 1428536937
		/// },
		/// geometry: {
		/// type: "Point",
		/// coordinates: [ -122.6244177, 45.5164386 ]
		/// }
		/// }
		/// }
		/// </code></pre>
		/// 
		/// <p>It doesn’t paginate. If you pass the <code>all</code> parameter it returns all matches (which can be big, &gt; 4mb), otherwise it returns the 100 most recent.</p>
		/// 
		/// <p><strong>Go forth and make maps!</strong></p>
		/// 
		/// GET__version_locations___format_ v2/locations
		/// </summary>
		/// <param name="occurred_before"><p>End of period</p>
		///</param>
		/// <param name="occurred_after"><p>Start of period</p>
		///</param>
		/// <param name="incident_type"><p>Only incidents of specific type</p>
		///</param>
		/// <param name="proximity"><p>Center of location for proximity search</p>
		///</param>
		/// <param name="proximity_square"><p>Size of the proximity search</p>
		///</param>
		/// <param name="query"><p>Full text search of incidents</p>
		///</param>
		/// <param name="limit"><p>Max number of results to return. Defaults to 100</p>
		///</param>
		/// <param name="all"><p>Give ‘em all to me. Will ignore limit</p>
		///</param>
		/// <returns>No response was specified</returns>
		public async Task GET__version_locations___format_Async(int occurred_before, int occurred_after, GET__version_incidents___format_Incident_type incident_type, string proximity, int proximity_square, string query, int limit, bool all, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/locations?occurred_before="+occurred_before+"&occurred_after="+occurred_after+"&incident_type=" + incident_type+"&proximity=" + (proximity==null? "" : System.Uri.EscapeDataString(proximity))+"&proximity_square="+proximity_square+"&query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&limit="+limit+"&all="+all;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unpaginated geojson response with simplestyled markers
		/// <p>This behaves exactly like the root <code>locations</code> endpoint, but returns <a href="https://github.com/mapbox/simplestyle-spec">simplestyled markers</a> (<a href="https://www.mapbox.com/guides/markers/#simple-style">mapbox styled markers</a>)</p>
		/// 
		/// <p><strong>Go forth and make maps!</strong></p>
		/// 
		/// GET__version_locations_markers___format_ v2/locations/markers
		/// </summary>
		/// <param name="occurred_before"><p>End of period</p>
		///</param>
		/// <param name="occurred_after"><p>Start of period</p>
		///</param>
		/// <param name="incident_type"><p>Only incidents of specific type</p>
		///</param>
		/// <param name="proximity"><p>Center of location for proximity search</p>
		///</param>
		/// <param name="proximity_square"><p>Size of the proximity search</p>
		///</param>
		/// <param name="query"><p>Full text search of incidents</p>
		///</param>
		/// <param name="limit"><p>Max number of results to return. Defaults to 100</p>
		///</param>
		/// <param name="all"><p>Give ‘em all to me. Will ignore limit</p>
		///</param>
		/// <returns>No response was specified</returns>
		public async Task GET__version_locations_markers___format_Async(int occurred_before, int occurred_after, GET__version_incidents___format_Incident_type incident_type, string proximity, int proximity_square, string query, int limit, bool all, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/locations/markers?occurred_before="+occurred_before+"&occurred_after="+occurred_after+"&incident_type=" + incident_type+"&proximity=" + (proximity==null? "" : System.Uri.EscapeDataString(proximity))+"&proximity_square="+proximity_square+"&query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&limit="+limit+"&all="+all;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum GET__version_incidents___format_Incident_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		crash = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hazard = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		theft = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unconfirmed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		infrastructure_issue = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		chop_shop = 5,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
