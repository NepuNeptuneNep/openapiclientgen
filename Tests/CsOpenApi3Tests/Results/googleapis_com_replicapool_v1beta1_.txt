//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A Compute Engine network accessConfig. Identical to the accessConfig on corresponding Compute Engine resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AccessConfig
	{
		
		/// <summary>
		/// Name of this access configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// An external IP address associated with this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natIp")]
		public string NatIp { get; set; }
		
		/// <summary>
		/// Type of this access configuration file. Currently only ONE_TO_ONE_NAT is supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// An action that gets executed during initialization of the replicas.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Action
	{
		
		/// <summary>
		/// A list of commands to run, one per line. If any command fails, the whole action is considered a failure and no further actions are run. This also marks the virtual machine or replica as a failure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commands")]
		public string[] Commands { get; set; }
		
		/// <summary>
		/// A list of environment variables to use for the commands in this action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="envVariables")]
		public EnvVariable[] EnvVariables { get; set; }
		
		/// <summary>
		/// If an action's commands on a particular replica do not finish in the specified timeoutMilliSeconds, the replica is considered to be in a FAILING state. No efforts are made to stop any processes that were spawned or created as the result of running the action's commands. The default is the max allowed value, 1 hour (i.e. 3600000 milliseconds).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeoutMilliSeconds")]
		public System.Nullable<System.Int32> TimeoutMilliSeconds { get; set; }
	}
	
	/// <summary>
	/// An environment variable to set for an action.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EnvVariable
	{
		
		/// <summary>
		/// Deprecated, do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hidden")]
		public System.Nullable<System.Boolean> Hidden { get; set; }
		
		/// <summary>
		/// The name of the environment variable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the variable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Specifies how to attach a disk to a Replica.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DiskAttachment
	{
		
		/// <summary>
		/// The device name of this disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceName")]
		public string DeviceName { get; set; }
		
		/// <summary>
		/// A zero-based index to assign to this disk, where 0 is reserved for the boot disk. If not specified, this is assigned by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="index")]
		public System.Nullable<System.UInt32> Index { get; set; }
	}
	
	/// <summary>
	/// A pre-existing persistent disk that will be attached to every Replica in the Pool in READ_ONLY mode.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExistingDisk
	{
		
		/// <summary>
		/// Specifies how to attach a disk to a Replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attachment")]
		public DiskAttachment Attachment { get; set; }
		
		/// <summary>
		/// The name of the Persistent Disk resource. The Persistent Disk resource must be in the same zone as the Pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HealthCheck
	{
		
		/// <summary>
		/// How often (in seconds) to make HTTP requests for this healthcheck. The default value is 5 seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checkIntervalSec")]
		public System.Nullable<System.Int32> CheckIntervalSec { get; set; }
		
		/// <summary>
		/// The description for this health check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The number of consecutive health check requests that need to succeed before the replica is considered healthy again. The default value is 2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthyThreshold")]
		public System.Nullable<System.Int32> HealthyThreshold { get; set; }
		
		/// <summary>
		/// The value of the host header in the HTTP health check request. If left empty (default value), the localhost IP 127.0.0.1 will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The name of this health check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The localhost request path to send this health check, in the format /path/to/use. For example, /healthcheck.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The TCP port for the health check requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// How long (in seconds) to wait before a timeout failure for this healthcheck. The default value is 5 seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeoutSec")]
		public System.Nullable<System.Int32> TimeoutSec { get; set; }
		
		/// <summary>
		/// The number of consecutive health check requests that need to fail in order to consider the replica unhealthy. The default value is 2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unhealthyThreshold")]
		public System.Nullable<System.Int32> UnhealthyThreshold { get; set; }
	}
	
	/// <summary>
	/// A label to apply to this replica pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Label
	{
		
		/// <summary>
		/// The key for this label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The value of this label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A Compute Engine metadata entry. Identical to the metadata on the corresponding Compute Engine resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Metadata
	{
		
		/// <summary>
		/// The fingerprint of the metadata. Required for updating the metadata entries for this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerPrint")]
		public string FingerPrint { get; set; }
		
		/// <summary>
		/// A list of metadata items.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public MetadataItem[] Items { get; set; }
	}
	
	/// <summary>
	/// A Compute Engine metadata item, defined as a key:value pair. Identical to the metadata on the corresponding Compute Engine resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MetadataItem
	{
		
		/// <summary>
		/// A metadata key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// A metadata value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A Compute Engine NetworkInterface resource. Identical to the NetworkInterface on the corresponding Compute Engine resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NetworkInterface
	{
		
		/// <summary>
		/// An array of configurations for this interface. This specifies how this interface is configured to interact with other network services.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessConfigs")]
		public AccessConfig[] AccessConfigs { get; set; }
		
		/// <summary>
		/// Name the Network resource to which this interface applies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// An optional IPV4 internal network address to assign to the instance for this network interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkIp")]
		public string NetworkIp { get; set; }
	}
	
	/// <summary>
	/// A Persistent Disk resource that will be created and attached to each Replica in the Pool. Each Replica will have a unique persistent disk that is created and attached to that Replica in READ_WRITE mode.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NewDisk
	{
		
		/// <summary>
		/// Specifies how to attach a disk to a Replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attachment")]
		public DiskAttachment Attachment { get; set; }
		
		/// <summary>
		/// If true, then this disk will be deleted when the instance is deleted. The default value is true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoDelete")]
		public System.Nullable<System.Boolean> AutoDelete { get; set; }
		
		/// <summary>
		/// If true, indicates that this is the root persistent disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="boot")]
		public System.Nullable<System.Boolean> Boot { get; set; }
		
		/// <summary>
		/// Initialization parameters for creating a new disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="initializeParams")]
		public NewDiskInitializeParams InitializeParams { get; set; }
	}
	
	/// <summary>
	/// Initialization parameters for creating a new disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NewDiskInitializeParams
	{
		
		/// <summary>
		/// The size of the created disk in gigabytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGb")]
		public string DiskSizeGb { get; set; }
		
		/// <summary>
		/// Name of the disk type resource describing which disk type to use to create the disk. For example 'pd-ssd' or 'pd-standard'. Default is 'pd-standard'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskType")]
		public string DiskType { get; set; }
		
		/// <summary>
		/// The name or fully-qualified URL of a source image to use to create this disk. If you provide a name of the source image, Replica Pool will look for an image with that name in your project. If you are specifying an image provided by Compute Engine, you will need to provide the full URL with the correct project, such as:
		///http://www.googleapis.com/compute/v1/projects/debian-cloud/ global/images/debian-wheezy-7-vYYYYMMDD
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceImage")]
		public string SourceImage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Pool
	{
		
		/// <summary>
		/// Whether replicas in this pool should be restarted if they experience a failure. The default value is true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoRestart")]
		public System.Nullable<System.Boolean> AutoRestart { get; set; }
		
		/// <summary>
		/// The base instance name to use for the replicas in this pool. This must match the regex [a-z]([-a-z0-9]*[a-z0-9])?. If specified, the instances in this replica pool will be named in the format <base-instance-name>-<ID>. The <ID> postfix will be a four character alphanumeric identifier generated by the service.
		///
		///If this is not specified by the user, a random base instance name is generated by the service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseInstanceName")]
		public string BaseInstanceName { get; set; }
		
		/// <summary>
		/// [Output Only] The current number of replicas in the pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentNumReplicas")]
		public System.Nullable<System.Int32> CurrentNumReplicas { get; set; }
		
		/// <summary>
		/// An optional description of the replica pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Deprecated. Please use template[].healthChecks instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthChecks")]
		public HealthCheck[] HealthChecks { get; set; }
		
		/// <summary>
		/// The initial number of replicas this pool should have. You must provide a value greater than or equal to 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="initialNumReplicas")]
		public System.Nullable<System.Int32> InitialNumReplicas { get; set; }
		
		/// <summary>
		/// A list of labels to attach to this replica pool and all created virtual machines in this replica pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Label[] Labels { get; set; }
		
		/// <summary>
		/// The name of the replica pool. Must follow the regex [a-z]([-a-z0-9]*[a-z0-9])? and be 1-28 characters long.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Deprecated! Use initial_num_replicas instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numReplicas")]
		public System.Nullable<System.Int32> NumReplicas { get; set; }
		
		/// <summary>
		/// The list of resource views that should be updated with all the replicas that are managed by this pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceViews")]
		public string[] ResourceViews { get; set; }
		
		/// <summary>
		/// [Output Only] A self-link to the replica pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Deprecated, please use target_pools instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPool")]
		public string TargetPool { get; set; }
		
		/// <summary>
		/// A list of target pools to update with the replicas that are managed by this pool. If specified, the replicas in this replica pool will be added to the specified target pools for load balancing purposes. The replica pool must live in the same region as the specified target pools. These values must be the target pool resource names, and not fully qualified URLs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPools")]
		public string[] TargetPools { get; set; }
		
		/// <summary>
		/// The template used for creating replicas in the pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="template")]
		public Template Template { get; set; }
		
		/// <summary>
		/// Deprecated! Do not set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// The template used for creating replicas in the pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Template
	{
		
		/// <summary>
		/// An action that gets executed during initialization of the replicas.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Action Action { get; set; }
		
		/// <summary>
		/// A list of HTTP Health Checks to configure for this replica pool and all virtual machines in this replica pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthChecks")]
		public HealthCheck[] HealthChecks { get; set; }
		
		/// <summary>
		/// A free-form string describing the version of this template. You can provide any versioning string you would like. For example, version1 or template-v1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		/// <summary>
		/// Parameters for creating a Compute Engine Instance resource. Most fields are identical to the corresponding Compute Engine resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmParams")]
		public VmParams VmParams { get; set; }
	}
	
	/// <summary>
	/// Parameters for creating a Compute Engine Instance resource. Most fields are identical to the corresponding Compute Engine resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VmParams
	{
		
		/// <summary>
		/// Deprecated. Please use baseInstanceName instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseInstanceName")]
		public string BaseInstanceName { get; set; }
		
		/// <summary>
		/// Enables IP Forwarding, which allows this instance to receive packets destined for a different IP address, and send packets with a different source IP. See IP Forwarding for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canIpForward")]
		public System.Nullable<System.Boolean> CanIpForward { get; set; }
		
		/// <summary>
		/// An optional textual description of the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// A list of existing Persistent Disk resources to attach to each replica in the pool. Each disk will be attached in read-only mode to every replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disksToAttach")]
		public ExistingDisk[] DisksToAttach { get; set; }
		
		/// <summary>
		/// A list of Disk resources to create and attach to each Replica in the Pool. Currently, you can only define one disk and it must be a root persistent disk. Note that Replica Pool will create a root persistent disk for each replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disksToCreate")]
		public NewDisk[] DisksToCreate { get; set; }
		
		/// <summary>
		/// The machine type for this instance. The resource name (e.g. n1-standard-1).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
		
		/// <summary>
		/// A Compute Engine metadata entry. Identical to the metadata on the corresponding Compute Engine resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public Metadata Metadata { get; set; }
		
		/// <summary>
		/// A list of network interfaces for the instance. Currently only one interface is supported by Google Compute Engine, ONE_TO_ONE_NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaces")]
		public NetworkInterface[] NetworkInterfaces { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="onHostMaintenance")]
		public string OnHostMaintenance { get; set; }
		
		/// <summary>
		/// A list of Service Accounts to enable for this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccounts")]
		public ServiceAccount[] ServiceAccounts { get; set; }
		
		/// <summary>
		/// A Compute Engine Instance tag, identical to the tags on the corresponding Compute Engine Instance resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag Tags { get; set; }
	}
	
	/// <summary>
	/// A Compute Engine service account, identical to the Compute Engine resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceAccount
	{
		
		/// <summary>
		/// The service account email address, for example: 123845678986@project.gserviceaccount.com
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The list of OAuth2 scopes to obtain for the service account, for example: https://www.googleapis.com/auth/devstorage.full_control
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
	}
	
	/// <summary>
	/// A Compute Engine Instance tag, identical to the tags on the corresponding Compute Engine Instance resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Tag
	{
		
		/// <summary>
		/// The fingerprint of the tag. Required for updating the list of tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerPrint")]
		public string FingerPrint { get; set; }
		
		/// <summary>
		/// Items contained in this tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public string[] Items { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PoolsDeleteRequest
	{
		
		/// <summary>
		/// If there are instances you would like to keep, you can specify them here. These instances won't be deleted, but the associated replica objects will be removed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="abandonInstances")]
		public string[] AbandonInstances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PoolsListResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Pool[] Resources { get; set; }
	}
	
	/// <summary>
	/// An individual Replica within a Pool. Replicas are automatically created by the replica pool, using the template provided by the user. You cannot directly create replicas.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Replica
	{
		
		/// <summary>
		/// [Output Only] The name of the Replica object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] The self-link of the Replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The current status of a Replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ReplicaStatus Status { get; set; }
	}
	
	/// <summary>
	/// The current status of a Replica.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReplicaStatus
	{
		
		/// <summary>
		/// [Output Only] Human-readable details about the current state of the replica
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string Details { get; set; }
		
		/// <summary>
		/// [Output Only] The state of the Replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// [Output Only] The template used to build the replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="templateVersion")]
		public string TemplateVersion { get; set; }
		
		/// <summary>
		/// [Output Only] Link to the virtual machine that this Replica represents.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmLink")]
		public string VmLink { get; set; }
		
		/// <summary>
		/// [Output Only] The time that this Replica got to the RUNNING state, in RFC 3339 format. If the start time is unknown, UNKNOWN is returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmStartTime")]
		public string VmStartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReplicasDeleteRequest
	{
		
		/// <summary>
		/// Whether the instance resource represented by this replica should be deleted or abandoned. If abandoned, the replica will be deleted but the virtual machine instance will remain. By default, this is set to false and the instance will be deleted along with the replica.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="abandonInstance")]
		public System.Nullable<System.Boolean> AbandonInstance { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReplicasListResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Replica[] Resources { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// List all replica pools.
		/// Replicapool_pools_list {projectName}/zones/{zone}/pools
		/// </summary>
		/// <param name="projectName">The project ID for this request.</param>
		/// <param name="zone">The zone for this replica pool.</param>
		/// <param name="maxResults">Maximum count of results to be returned. Acceptable values are 0 to 100, inclusive. (Default: 50)
		/// Minimum: 0
		/// Maximum: 1000
		// </param>
		/// <param name="pageToken">Set this to the nextPageToken value returned by a previous list request to obtain the next page of results from the previous list request.</param>
		/// <returns>Successful response</returns>
		public async Task Replicapool_pools_listAsync(string projectName, string zone, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = ""+ (projectName==null? "" : System.Uri.EscapeDataString(projectName))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/pools&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Inserts a new replica pool.
		/// Replicapool_pools_insert {projectName}/zones/{zone}/pools
		/// </summary>
		/// <param name="projectName">The project ID for this replica pool.</param>
		/// <param name="zone">The zone for this replica pool.</param>
		/// <returns>Successful response</returns>
		public async Task Replicapool_pools_insertAsync(string projectName, string zone, Pool requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = ""+ (projectName==null? "" : System.Uri.EscapeDataString(projectName))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/pools";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about a single replica pool.
		/// Replicapool_pools_get {projectName}/zones/{zone}/pools/{poolName}
		/// </summary>
		/// <param name="projectName">The project ID for this replica pool.</param>
		/// <param name="zone">The zone for this replica pool.</param>
		/// <param name="poolName">The name of the replica pool for this request.</param>
		/// <returns>Successful response</returns>
		public async Task Replicapool_pools_getAsync(string projectName, string zone, string poolName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = ""+ (projectName==null? "" : System.Uri.EscapeDataString(projectName))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/pools/"+ (poolName==null? "" : System.Uri.EscapeDataString(poolName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a replica pool.
		/// Replicapool_pools_delete {projectName}/zones/{zone}/pools/{poolName}
		/// </summary>
		/// <param name="projectName">The project ID for this replica pool.</param>
		/// <param name="zone">The zone for this replica pool.</param>
		/// <param name="poolName">The name of the replica pool for this request.</param>
		/// <returns>Successful response</returns>
		public async Task Replicapool_pools_deleteAsync(string projectName, string zone, string poolName, PoolsDeleteRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = ""+ (projectName==null? "" : System.Uri.EscapeDataString(projectName))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/pools/"+ (poolName==null? "" : System.Uri.EscapeDataString(poolName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all replicas in a pool.
		/// Replicapool_replicas_list {projectName}/zones/{zone}/pools/{poolName}/replicas
		/// </summary>
		/// <param name="projectName">The project ID for this request.</param>
		/// <param name="zone">The zone where the replica pool lives.</param>
		/// <param name="poolName">The replica pool name for this request.</param>
		/// <param name="maxResults">Maximum count of results to be returned. Acceptable values are 0 to 100, inclusive. (Default: 50)
		/// Minimum: 0
		/// Maximum: 1000
		// </param>
		/// <param name="pageToken">Set this to the nextPageToken value returned by a previous list request to obtain the next page of results from the previous list request.</param>
		/// <returns>Successful response</returns>
		public async Task Replicapool_replicas_listAsync(string projectName, string zone, string poolName, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = ""+ (projectName==null? "" : System.Uri.EscapeDataString(projectName))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/pools/"+ (poolName==null? "" : System.Uri.EscapeDataString(poolName))+"/replicas&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets information about a specific replica.
		/// Replicapool_replicas_get {projectName}/zones/{zone}/pools/{poolName}/replicas/{replicaName}
		/// </summary>
		/// <param name="projectName">The project ID for this request.</param>
		/// <param name="zone">The zone where the replica lives.</param>
		/// <param name="poolName">The replica pool name for this request.</param>
		/// <param name="replicaName">The name of the replica for this request.</param>
		/// <returns>Successful response</returns>
		public async Task Replicapool_replicas_getAsync(string projectName, string zone, string poolName, string replicaName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = ""+ (projectName==null? "" : System.Uri.EscapeDataString(projectName))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/pools/"+ (poolName==null? "" : System.Uri.EscapeDataString(poolName))+"/replicas/"+ (replicaName==null? "" : System.Uri.EscapeDataString(replicaName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a replica from the pool.
		/// Replicapool_replicas_delete {projectName}/zones/{zone}/pools/{poolName}/replicas/{replicaName}
		/// </summary>
		/// <param name="projectName">The project ID for this request.</param>
		/// <param name="zone">The zone where the replica lives.</param>
		/// <param name="poolName">The replica pool name for this request.</param>
		/// <param name="replicaName">The name of the replica for this request.</param>
		/// <returns>Successful response</returns>
		public async Task Replicapool_replicas_deleteAsync(string projectName, string zone, string poolName, string replicaName, ReplicasDeleteRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = ""+ (projectName==null? "" : System.Uri.EscapeDataString(projectName))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/pools/"+ (poolName==null? "" : System.Uri.EscapeDataString(poolName))+"/replicas/"+ (replicaName==null? "" : System.Uri.EscapeDataString(replicaName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Restarts a replica in a pool.
		/// Replicapool_replicas_restart {projectName}/zones/{zone}/pools/{poolName}/replicas/{replicaName}/restart
		/// </summary>
		/// <param name="projectName">The project ID for this request.</param>
		/// <param name="zone">The zone where the replica lives.</param>
		/// <param name="poolName">The replica pool name for this request.</param>
		/// <param name="replicaName">The name of the replica for this request.</param>
		/// <returns>Successful response</returns>
		public async Task Replicapool_replicas_restartAsync(string projectName, string zone, string poolName, string replicaName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = ""+ (projectName==null? "" : System.Uri.EscapeDataString(projectName))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/pools/"+ (poolName==null? "" : System.Uri.EscapeDataString(poolName))+"/replicas/"+ (replicaName==null? "" : System.Uri.EscapeDataString(replicaName))+"/restart";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resize a pool. This is an asynchronous operation, and multiple overlapping resize requests can be made. Replica Pools will use the information from the last resize request.
		/// Replicapool_pools_resize {projectName}/zones/{zone}/pools/{poolName}/resize
		/// </summary>
		/// <param name="projectName">The project ID for this replica pool.</param>
		/// <param name="zone">The zone for this replica pool.</param>
		/// <param name="poolName">The name of the replica pool for this request.</param>
		/// <param name="numReplicas">The desired number of replicas to resize to. If this number is larger than the existing number of replicas, new replicas will be added. If the number is smaller, then existing replicas will be deleted.</param>
		/// <returns>Successful response</returns>
		public async Task Replicapool_pools_resizeAsync(string projectName, string zone, string poolName, int numReplicas, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = ""+ (projectName==null? "" : System.Uri.EscapeDataString(projectName))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/pools/"+ (poolName==null? "" : System.Uri.EscapeDataString(poolName))+"/resize&numReplicas="+numReplicas;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the template used by the pool.
		/// Replicapool_pools_updatetemplate {projectName}/zones/{zone}/pools/{poolName}/updateTemplate
		/// </summary>
		/// <param name="projectName">The project ID for this replica pool.</param>
		/// <param name="zone">The zone for this replica pool.</param>
		/// <param name="poolName">The name of the replica pool for this request.</param>
		/// <returns>Successful response</returns>
		public async Task Replicapool_pools_updatetemplateAsync(string projectName, string zone, string poolName, Template requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = ""+ (projectName==null? "" : System.Uri.EscapeDataString(projectName))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/pools/"+ (poolName==null? "" : System.Uri.EscapeDataString(poolName))+"/updateTemplate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
