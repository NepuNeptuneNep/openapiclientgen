//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Represents a user of Mastodon and their associated profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Account
	{
		
		/// <summary>
		/// The Webfinger account URI. Equal to `username` for local users, or `username@domain` for
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acct")]
		public string Acct { get; set; }
		
		/// <summary>
		/// An image icon that is shown next to statuses and in the profile. The format is URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avatar")]
		public string Avatar { get; set; }
		
		/// <summary>
		/// A static version of the avatar. Equal to `avatar` if its value is a static image; different if `avatar` is an animated GIF. The format is URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avatar_static")]
		public string Avatar_static { get; set; }
		
		/// <summary>
		/// A presentational flag. Indicates that the account may perform automated actions, may not be monitored, or identifies as a robot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bot")]
		public System.Nullable<System.Boolean> Bot { get; set; }
		
		/// <summary>
		/// When the account was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Whether the account has opted into discovery features such as the profile directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="discoverable")]
		public System.Nullable<System.Boolean> Discoverable { get; set; }
		
		/// <summary>
		/// The profile's display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="display_name")]
		public string Display_name { get; set; }
		
		/// <summary>
		/// Custom emoji entities to be used when rendering the profile. If none, an empty array will be returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emojis")]
		public Emoji[] Emojis { get; set; }
		
		/// <summary>
		/// Additional metadata attached to a profile as name-value pairs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public Field[] Fields { get; set; }
		
		/// <summary>
		/// The reported followers of this profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="followers_count")]
		public System.Nullable<System.Int32> Followers_count { get; set; }
		
		/// <summary>
		/// The reported follows of this profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="following_count")]
		public System.Nullable<System.Int32> Following_count { get; set; }
		
		/// <summary>
		/// An image banner that is shown above the profile and in profile cards. The format is URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="header")]
		public string Header { get; set; }
		
		/// <summary>
		/// A static version of the header. Equal to `header` if its value is a static image; different if `header` is an animated GIF. The format is URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="header_static")]
		public string Header_static { get; set; }
		
		/// <summary>
		/// The account id `header`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// When the most recent status was posted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_status_at")]
		public System.Nullable<System.DateTimeOffset> Last_status_at { get; set; }
		
		/// <summary>
		/// Whether the account manually approves follow requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public System.Nullable<System.Boolean> Locked { get; set; }
		
		/// <summary>
		/// Represents a user of Mastodon and their associated profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="moved")]
		public Account Moved { get; set; }
		
		/// <summary>
		/// When a timed mute will expire, if applicable. ISO 8601 Datetime.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mute_expires_at")]
		public System.Nullable<System.DateTimeOffset> Mute_expires_at { get; set; }
		
		/// <summary>
		/// The profile's bio / description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// Represents display or publishing preferences of user's own account. Returned as an additional entity when verifying and updated credentials, as an attribute of Account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public Source Source { get; set; }
		
		/// <summary>
		/// How many statuses are attached to this account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses_count")]
		public System.Nullable<System.Int32> Statuses_count { get; set; }
		
		/// <summary>
		/// An extra entity returned when an account is suspended.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suspended")]
		public System.Nullable<System.Boolean> Suspended { get; set; }
		
		/// <summary>
		/// The location of the user's profile page. (HTTPS URL)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The username of the account, not including domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Represents a custom emoji.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Emoji
	{
		
		/// <summary>
		/// Used for sorting custom emoji in the picker.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// The name of the custom emoji.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="shortcode")]
		public string Shortcode { get; set; }
		
		/// <summary>
		/// A link to a static copy of the custom emoji. The format is URL.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="static_url")]
		public string Static_url { get; set; }
		
		/// <summary>
		/// A link to the custom emoji. The format is URL.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Whether this Emoji should be visible in the picker or unlisted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="visible_in_picker")]
		public bool Visible_in_picker { get; set; }
	}
	
	/// <summary>
	/// Represents a profile field as a name-value pair with optional verification.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Field
	{
		
		/// <summary>
		/// The key of a given field's key-value pair.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value associated with the `name` key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
		
		/// <summary>
		/// Timestamp of when the server verified a URL value for a rel="me‚Äù link. If `value` is a verified URL. Otherwise, null
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verified_at")]
		public System.Nullable<System.DateTimeOffset> Verified_at { get; set; }
	}
	
	/// <summary>
	/// Represents display or publishing preferences of user's own account. Returned as an additional entity when verifying and updated credentials, as an attribute of Account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Source
	{
		
		/// <summary>
		/// Metadata about the account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public Field[] Fields { get; set; }
		
		/// <summary>
		/// The number of pending follow requests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="follow_requests_count")]
		public System.Nullable<System.Int32> Follow_requests_count { get; set; }
		
		/// <summary>
		/// The default posting language for new statuses, ISO 639-1 language two-letter code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Profile bio
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// The default post privacy to be used for new statuses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privacy")]
		public System.Nullable<SourcePrivacy> Privacy { get; set; }
		
		/// <summary>
		/// Whether new statuses should be marked sensitive by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sensitive")]
		public System.Nullable<System.Boolean> Sensitive { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum SourcePrivacy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unlisted")]
		unlisted = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="direct")]
		direct = 3,
	}
	
	/// <summary>
	/// Represents a weekly bucket of instance activity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Activity
	{
		
		/// <summary>
		/// User logins since the week began, String (cast from an integer).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logins")]
		public string Logins { get; set; }
		
		/// <summary>
		/// User registrations since the week began, String (cast from an integer).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registrations")]
		public string Registrations { get; set; }
		
		/// <summary>
		/// Statuses created since the week began, String (cast from an integer).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public string Statuses { get; set; }
		
		/// <summary>
		/// Midnight at the first day of the week.  (UNIX Timestamp).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="week")]
		public string Week { get; set; }
	}
	
	/// <summary>
	/// Admin-level information about a given account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AdminAccount
	{
		
		/// <summary>
		/// Represents a user of Mastodon and their associated profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account")]
		public Account Account { get; set; }
		
		/// <summary>
		/// Whether the account is currently approved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="approved")]
		public System.Nullable<System.Boolean> Approved { get; set; }
		
		/// <summary>
		/// Whether the account has confirmed their email address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confirmed")]
		public System.Nullable<System.Boolean> Confirmed { get; set; }
		
		/// <summary>
		/// When the account was first discovered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The ID of the application that created this account. Cast from an integer, but not guaranteed to be a number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_by_application_id")]
		public string Created_by_application_id { get; set; }
		
		/// <summary>
		/// Whether the account is currently disabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// The email address associated with the account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The ID of the account in the database. Cast from an integer, but not guaranteed to be a number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Invite request text ???
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invite_request")]
		public string Invite_request { get; set; }
		
		/// <summary>
		/// The ID of the account that invited this user. Cast from an integer, but not guaranteed to be a number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invited_by_account_id")]
		public string Invited_by_account_id { get; set; }
		
		/// <summary>
		/// The IP address last used to login to this account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// The locale of the account. ISO 639 Part 1 two-letter language code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locale")]
		public string Locale { get; set; }
		
		/// <summary>
		/// The current role of the account. Enumerable oneOf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
		
		/// <summary>
		/// Whether the account is currently silenced.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="silenced")]
		public System.Nullable<System.Boolean> Silenced { get; set; }
		
		/// <summary>
		/// Whether the account is currently suspended.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suspended")]
		public System.Nullable<System.Boolean> Suspended { get; set; }
		
		/// <summary>
		/// The username of the account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Admin-level information about a filed report.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AdminReport
	{
		
		/// <summary>
		/// Represents a user of Mastodon and their associated profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account")]
		public Account Account { get; set; }
		
		/// <summary>
		/// The action taken to resolve this report. Enumerable oneOf.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action_taken")]
		public string Action_taken { get; set; }
		
		/// <summary>
		/// Represents a user of Mastodon and their associated profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assigned_account")]
		public Account Assigned_account { get; set; }
		
		/// <summary>
		/// An optional reason for reporting.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// The time the report was filed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The ID of the report in the database. Cast from an integer, but not guaranteed to be a number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Statuses attached to the report, for context.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public Status[] Statuses { get; set; }
		
		/// <summary>
		/// Represents a user of Mastodon and their associated profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target_account")]
		public Account Target_account { get; set; }
		
		/// <summary>
		/// The time of last action on this report.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	/// <summary>
	/// Represents a status posted by an account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Status
	{
		
		/// <summary>
		/// Represents a user of Mastodon and their associated profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account")]
		public Account Account { get; set; }
		
		/// <summary>
		/// Represents an application that interfaces with the REST API to access accounts or post statuses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="application")]
		public Application Application { get; set; }
		
		/// <summary>
		/// Have you bookmarked this status?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bookmarked")]
		public System.Nullable<System.Boolean> Bookmarked { get; set; }
		
		/// <summary>
		/// Represents a rich preview card that is generated using OpenGraph tags from a URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="card")]
		public Card Card { get; set; }
		
		/// <summary>
		/// HTML-encoded status content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// The date when this status was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Custom emoji to be used when rendering status content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emojis")]
		public Emoji[] Emojis { get; set; }
		
		/// <summary>
		/// Have you favourited this status?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="favourited")]
		public System.Nullable<System.Boolean> Favourited { get; set; }
		
		/// <summary>
		/// How many favourites this status has received.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="favourites_count")]
		public System.Nullable<System.Int32> Favourites_count { get; set; }
		
		/// <summary>
		/// ID of the status in the database. Cast from an integer but not guaranteed to be a number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// ID of the account being replied to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in_reply_to_account_id")]
		public string In_reply_to_account_id { get; set; }
		
		/// <summary>
		/// ID of the status being replied. Cast from an integer but not guaranteed to be a number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in_reply_to_id")]
		public string In_reply_to_id { get; set; }
		
		/// <summary>
		/// Primary language of this status. ISO 639 Part 1 two-letter language code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Media that is attached to this status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="media_attachments")]
		public Attachment[] Media_attachments { get; set; }
		
		/// <summary>
		/// Mentions of users within the status content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mentions")]
		public Mention[] Mentions { get; set; }
		
		/// <summary>
		/// Have you muted notifications for this status's conversation?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="muted")]
		public System.Nullable<System.Boolean> Muted { get; set; }
		
		/// <summary>
		/// Have you pinned this status? Only appears if the status is pinnable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pinned")]
		public System.Nullable<System.Boolean> Pinned { get; set; }
		
		/// <summary>
		/// Represents a poll attached to a status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poll")]
		public Poll Poll { get; set; }
		
		/// <summary>
		/// Represents a status posted by an account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reblog")]
		public Status Reblog { get; set; }
		
		/// <summary>
		/// Have you boosted this status?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reblogged")]
		public System.Nullable<System.Boolean> Reblogged { get; set; }
		
		/// <summary>
		/// How many boosts this status has received.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reblogs_count")]
		public System.Nullable<System.Int32> Reblogs_count { get; set; }
		
		/// <summary>
		/// How many replies this status has received.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replies_count")]
		public System.Nullable<System.Int32> Replies_count { get; set; }
		
		/// <summary>
		/// Is this status marked as sensitive content?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sensitive")]
		public System.Nullable<System.Boolean> Sensitive { get; set; }
		
		/// <summary>
		/// Subject or summary line, below which status content is collapsed until expanded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spoiler_text")]
		public string Spoiler_text { get; set; }
		
		/// <summary>
		/// Hashtags used within the status content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tag[] Tags { get; set; }
		
		/// <summary>
		/// Plain-text source of a status. Returned instead of `content` when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// URI of the status used for federation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// A link to the status's HTML representation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Visibility of this status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public System.Nullable<StatusVisibility> Visibility { get; set; }
	}
	
	/// <summary>
	/// Represents a file or media attachment that can be added to a status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Attachment
	{
		
		/// <summary>
		/// A hash computed by the [BlurHash algorithm](https://github.com/woltapp/blurhash), for generating colorful preview thumbnails when media has not been downloaded yet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blurhash")]
		public string Blurhash { get; set; }
		
		/// <summary>
		/// Alternate text that describes what is in the media attachment, to be used for the visually impaired or when media attachments do not load.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The ID of the attachment in the database. Cast from an integer but not guaranteed to be a number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Metadata returned by Paperclip.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public string Meta { get; set; }
		
		/// <summary>
		/// The location of a scaled-down preview of the attachment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="preview_url")]
		public string Preview_url { get; set; }
		
		/// <summary>
		/// The location of the full-size original attachment on the remote website. String or null if the attachment is local.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remote_url")]
		public string Remote_url { get; set; }
		
		/// <summary>
		/// A shorter URL for the attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text_url")]
		public string Text_url { get; set; }
		
		/// <summary>
		/// The type of the attachment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public AttachmentType Type { get; set; }
		
		/// <summary>
		/// The location of the original full-size attachment.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum AttachmentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unknown")]
		unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="image")]
		image = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="gifv")]
		gifv = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="video")]
		video = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="audio")]
		audio = 4,
	}
	
	/// <summary>
	/// Represents a mention of a user within the content of a status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Mention
	{
		
		/// <summary>
		/// The webfinger acct URI of the mentioned user. Equivalent to `username` for local users, or `username@domain` for remote users.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="acct")]
		public string Acct { get; set; }
		
		/// <summary>
		/// The account id of the mentioned user. Cast from an integer, but not guaranteed to be a number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The location of the mentioned user's profile.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The username of the mentioned user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Represents a hashtag used within the content of a status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tag
	{
		
		/// <summary>
		/// Usage statistics for given days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="history")]
		public History[] History { get; set; }
		
		/// <summary>
		/// The value of the hashtag after the `#` sign.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A link to the hashtag on the instance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents daily usage history of a hashtag.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class History
	{
		
		/// <summary>
		/// the total of accounts using the tag within that day. Cast from an integer.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accounts")]
		public string Accounts { get; set; }
		
		/// <summary>
		/// UNIX timestamp on midnight of the given day.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="day")]
		public string Day { get; set; }
		
		/// <summary>
		/// the counted usage of the tag within that day. Cast from an integer.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uses")]
		public string Uses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum StatusVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unlisted")]
		unlisted = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="direct")]
		direct = 3,
	}
	
	/// <summary>
	/// Represents an announcement set by an administrator.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Announcement
	{
		
		/// <summary>
		/// Whether the announcement has a start/end time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="all_day")]
		public bool All_day { get; set; }
		
		/// <summary>
		/// When the announcement was created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// When the future announcement will end. ISO 8601 Datetime.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ends_at")]
		public string Ends_at { get; set; }
		
		/// <summary>
		/// The announcement id. Cast from an integer, but not guaranteed to be a number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Whether the announcement is currently active.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="published")]
		public bool Published { get; set; }
		
		/// <summary>
		/// Whether the announcement has been read by the user.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="read")]
		public bool Read { get; set; }
		
		/// <summary>
		/// When the future announcement was scheduled. ISO 8601 Datetime.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduled_at")]
		public string Scheduled_at { get; set; }
		
		/// <summary>
		/// When the future announcement will start. ISO 8601 Datetime.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="starts_at")]
		public string Starts_at { get; set; }
		
		/// <summary>
		/// The content of the announcement.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// When the announcement was last updated. ISO 8601 Datetime.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
	}
	
	/// <summary>
	/// Represents an emoji reaction to an Announcement.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnnouncementReaction
	{
		
		/// <summary>
		/// The total number of users who have added this reaction.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// Whether the authorized user has added this reaction to the announcement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="me")]
		public System.Nullable<System.Boolean> Me { get; set; }
		
		/// <summary>
		/// The emoji used for the reaction. Either a unicode emoji, or a custom emoji's shortcode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A link to a non-animated version of the custom emoji (URL).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="static_url")]
		public string Static_url { get; set; }
		
		/// <summary>
		/// A link to the custom emoji (URL).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents an application that interfaces with the REST API to access accounts or post statuses.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Application
	{
		
		/// <summary>
		/// Client ID key, to be used for obtaining OAuth tokens
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_id")]
		public string Client_id { get; set; }
		
		/// <summary>
		/// Client secret key, to be used for obtaining OAuth tokens
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="client_secret")]
		public string Client_secret { get; set; }
		
		/// <summary>
		/// The name of your application.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Used for Push Streaming API. Returned with [POST /api/v1/apps](https://docs.joinmastodon.org/methods/apps/#create-an-application). Equivalent to [PushSubscription#server_key](https://docs.joinmastodon.org/entities/pushsubscription/#server_key)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vapid_key")]
		public string Vapid_key { get; set; }
		
		/// <summary>
		/// The website associated with your application. Must be URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="website")]
		public string Website { get; set; }
	}
	
	/// <summary>
	/// Represents a rich preview card that is generated using OpenGraph tags from a URL.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Card
	{
		
		/// <summary>
		/// The author of the original resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author_name")]
		public string Author_name { get; set; }
		
		/// <summary>
		/// A link to the author of the original resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author_url")]
		public string Author_url { get; set; }
		
		/// <summary>
		/// A hash computed by the [BlurHash algorithm](https://github.com/woltapp/blurhash), for generating colorful preview thumbnails when media has not been downloaded yet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blurhash")]
		public string Blurhash { get; set; }
		
		/// <summary>
		/// Description of preview.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Height of preview, in pixels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// HTML to be used for generating the preview card.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
		
		/// <summary>
		/// Preview thumbnail (URL).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public string Image { get; set; }
		
		/// <summary>
		/// The provider of the original resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider_name")]
		public string Provider_name { get; set; }
		
		/// <summary>
		/// A link to the provider of the original resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider_url")]
		public string Provider_url { get; set; }
		
		/// <summary>
		/// Title of linked resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// The type of the preview card. String (Enumerable, oneOf).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CardType Type { get; set; }
		
		/// <summary>
		/// Location of linked resource.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Width of preview, in pixels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum CardType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="link")]
		link = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="photo")]
		photo = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="video")]
		video = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="rich")]
		rich = 3,
	}
	
	/// <summary>
	/// Represents the tree around a given status. Used for reconstructing threads of statuses.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Context
	{
		
		/// <summary>
		/// Parents in the thread.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ancestors")]
		public Status[] Ancestors { get; set; }
		
		/// <summary>
		/// Children in the thread.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="descendants")]
		public Status[] Descendants { get; set; }
	}
	
	/// <summary>
	/// Represents a conversation with "direct message" visibility.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Conversation
	{
		
		/// <summary>
		/// Participants in the conversation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accounts")]
		public Account[] Accounts { get; set; }
		
		/// <summary>
		/// Local database ID of the conversation. Cast from an integer, but not guaranteed to be a number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Represents a status posted by an account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_status")]
		public Status Last_status { get; set; }
		
		/// <summary>
		/// Is the conversation currently marked as unread?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="unread")]
		public bool Unread { get; set; }
	}
	
	/// <summary>
	/// Represents an error message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Error
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public string Error1 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error_description")]
		public string Error_description { get; set; }
	}
	
	/// <summary>
	/// Represents a hashtag that is featured on a profile.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FeaturedTag
	{
		
		/// <summary>
		/// The internal ID of the featured tag in the database. Cast from integer but not guaranteed to be a number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The timestamp of the last authored status containing this hashtag. ISO 8601 Datetime.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_status_at")]
		public System.Nullable<System.DateTimeOffset> Last_status_at { get; set; }
		
		/// <summary>
		/// The name of the hashtag being featured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The number of authored statuses containing this hashtag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses_count")]
		public System.Nullable<System.Int32> Statuses_count { get; set; }
		
		/// <summary>
		/// A link to all statuses by a user that contain this hashtag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Represents a user-defined filter for determining which statuses should not be shown to the user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Filter
	{
		
		/// <summary>
		/// The contexts in which the filter should be applied.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="context")]
		public string[] Context { get; set; }
		
		/// <summary>
		/// When the filter should no longer be applied. ISO 8601 Datetime, or null if the filter does not expire
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public string Expires_at { get; set; }
		
		/// <summary>
		/// The ID of the filter in the database. Cast from an integer, but not guaranteed to be a number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Should matching entities in home and notifications be dropped by the server?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="irreversible")]
		public System.Nullable<System.Boolean> Irreversible { get; set; }
		
		/// <summary>
		/// The text to be filtered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phrase")]
		public string Phrase { get; set; }
		
		/// <summary>
		/// Should the filter consider word boundaries?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="whole_word")]
		public System.Nullable<System.Boolean> Whole_word { get; set; }
	}
	
	/// <summary>
	/// Represents a proof from an external identity provider.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IdentityProof
	{
		
		/// <summary>
		/// The account owner's profile URL on the identity provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile_url")]
		public string Profile_url { get; set; }
		
		/// <summary>
		/// A link to a statement of identity proof, hosted by the identity provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proof_url")]
		public string Proof_url { get; set; }
		
		/// <summary>
		/// The name of the identity provider.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider")]
		public string Provider { get; set; }
		
		/// <summary>
		/// The account owner's username on the identity provider's service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provider_username")]
		public string Provider_username { get; set; }
		
		/// <summary>
		/// When the identity proof was last updated. ISO 8601 Datetime.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public string Updated_at { get; set; }
	}
	
	/// <summary>
	/// Represents the software instance of Mastodon running on this domain.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Instance
	{
		
		/// <summary>
		/// Whether registrations require moderator approval.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="approval_required")]
		public bool Approval_required { get; set; }
		
		/// <summary>
		/// Represents a user of Mastodon and their associated profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contact_account")]
		public Account Contact_account { get; set; }
		
		/// <summary>
		/// Admin-defined description of the Mastodon site.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// An email that may be contacted for any inquiries.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Whether invites are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="invites_enabled")]
		public bool Invites_enabled { get; set; }
		
		/// <summary>
		/// Primary languages of the website and its staff. ISO 639 Part 1-5 language codes.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="languages")]
		public string[] Languages { get; set; }
		
		/// <summary>
		/// Whether registrations are enabled.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="registrations")]
		public bool Registrations { get; set; }
		
		/// <summary>
		/// A shorter description defined by the admin.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="short_description")]
		public string Short_description { get; set; }
		
		/// <summary>
		/// Statistics about how much information the instance contains.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stats")]
		public string Stats { get; set; }
		
		/// <summary>
		/// Banner image for the website.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbnail")]
		public string Thumbnail { get; set; }
		
		/// <summary>
		/// The title of the website.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// The domain name of the instance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// URLs of interest for clients apps.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="urls")]
		public string Urls { get; set; }
		
		/// <summary>
		/// The version of Mastodon installed on the instance.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Represents a list of some users that the authenticated user follows.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class List
	{
		
		/// <summary>
		/// The internal database ID of the list. Cast from an integer, but not guaranteed to be a number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The user-defined title of the list.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="replies_policy")]
		public ListReplies_policy Replies_policy { get; set; }
		
		/// <summary>
		/// The user-defined title of the list.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ListReplies_policy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="followed")]
		followed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="list")]
		list = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="none")]
		none = 2,
	}
	
	/// <summary>
	/// Represents the last read position within a user's timelines.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Marker
	{
		
		/// <summary>
		/// Information about the user's position in the home timeline.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="home")]
		public string Home { get; set; }
		
		/// <summary>
		/// The ID of the most recently viewed entity. Cast from integer but not guaranteed to be a number
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_read_id")]
		public string Last_read_id { get; set; }
		
		/// <summary>
		/// Information about the user's position in their notifications.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notifications")]
		public string Notifications { get; set; }
		
		/// <summary>
		/// The timestamp of when the marker was set. ISO 8601 Datetime.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
		
		/// <summary>
		/// Used for locking to prevent write conflicts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<System.Int32> Version { get; set; }
	}
	
	/// <summary>
	/// Represents a notification of an event relevant to the user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Notification
	{
		
		/// <summary>
		/// Represents a user of Mastodon and their associated profile.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="account")]
		public Account Account { get; set; }
		
		/// <summary>
		/// The timestamp of the notification. ISO 8601 Datetime.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.DateTimeOffset Created_at { get; set; }
		
		/// <summary>
		/// The id of the notification in the database. Cast from an integer, but not guaranteed to be a number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Represents a status posted by an account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Status Status { get; set; }
		
		/// <summary>
		/// The type of event that resulted in the notification.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public NotificationType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum NotificationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="follow")]
		follow = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="follow_request")]
		follow_request = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="mention")]
		mention = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="reblog")]
		reblog = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="favourite")]
		favourite = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="poll")]
		poll = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status")]
		status = 6,
	}
	
	/// <summary>
	/// Represents a poll attached to a status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Poll
	{
		
		/// <summary>
		/// Custom emoji to be used for rendering poll options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emojis")]
		public Emoji[] Emojis { get; set; }
		
		/// <summary>
		/// Is the poll currently expired?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expired")]
		public System.Nullable<System.Boolean> Expired { get; set; }
		
		/// <summary>
		/// When the poll ends. ISO 8601 Datetime, or null if the poll does not end.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public System.Nullable<System.DateTimeOffset> Expires_at { get; set; }
		
		/// <summary>
		/// The ID of the poll in the database. Cast from an integer, but not guaranteed to be a number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Does the poll allow multiple-choice answers?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multiple")]
		public System.Nullable<System.Boolean> Multiple { get; set; }
		
		/// <summary>
		/// Possible answers for the poll.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="options")]
		public string[] Options { get; set; }
		
		/// <summary>
		/// When called with a user token, which options has the authorized user chosen? Contains an array of index values for `options`. Array of Number, or null if no current user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="own_votes")]
		public int[] Own_votes { get; set; }
		
		/// <summary>
		/// When called with a user token, has the authorized user voted? Boolean, or null if no current user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voted")]
		public System.Nullable<System.Boolean> Voted { get; set; }
		
		/// <summary>
		/// How many unique accounts have voted on a multiple-choice poll. Number, or null if `multiple` is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voters_count")]
		public System.Nullable<System.Int32> Voters_count { get; set; }
		
		/// <summary>
		/// How many votes have been received.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="votes_count")]
		public System.Nullable<System.Int32> Votes_count { get; set; }
	}
	
	/// <summary>
	/// Represents a user's preferences.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Preferences
	{
		
		/// <summary>
		/// Default language for new posts. Equivalent to [Source#language](https://docs.joinmastodon.org/entities/source/#language). ISO 639-1 language two-letter code, or null
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="posting:default:language")]
		public string Posting_default_language { get; set; }
		
		/// <summary>
		/// Default sensitivity flag for new posts. Equivalent to [Source#sensitive](https://docs.joinmastodon.org/entities/source/#sensitive).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="posting:default:sensitive")]
		public System.Nullable<System.Boolean> Posting_default_sensitive { get; set; }
		
		/// <summary>
		/// Default visibility for new posts. Equivalent to [Source#privacy](https://docs.joinmastodon.org/entities/source/#privacy).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="posting:default:visibility")]
		public System.Nullable<PreferencesPosting_default_visibility> Posting_default_visibility { get; set; }
		
		/// <summary>
		/// Whether media attachments should be automatically displayed or blurred/hidden.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reading:expand:media")]
		public System.Nullable<PreferencesReading_expand_media> Reading_expand_media { get; set; }
		
		/// <summary>
		/// Whether CWs should be expanded by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reading:expand:spoilers")]
		public System.Nullable<System.Boolean> Reading_expand_spoilers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PreferencesPosting_default_visibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unlisted")]
		unlisted = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="direct")]
		direct = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum PreferencesReading_expand_media
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="show_all")]
		show_all = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hide_all")]
		hide_all = 2,
	}
	
	/// <summary>
	/// Represents a subscription to the push streaming server.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PushSubscription
	{
		
		/// <summary>
		/// Which alerts should be delivered to the `endpoint`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="alerts")]
		public string Alerts { get; set; }
		
		/// <summary>
		/// Where push alerts will be sent to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		/// <summary>
		/// The ID of the push subscription in the database. Cast from an integer, but not guaranteed to be a number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The streaming server's VAPID key.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_key")]
		public string Server_key { get; set; }
	}
	
	/// <summary>
	/// Represents the relationship between accounts, such as following / blocking / muting / etc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Relationship
	{
		
		/// <summary>
		/// Is this user blocking you?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked_by")]
		public bool Blocked_by { get; set; }
		
		/// <summary>
		/// Are you blocking this user?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocking")]
		public bool Blocking { get; set; }
		
		/// <summary>
		/// Are you blocking this user's domain?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain_blocking")]
		public bool Domain_blocking { get; set; }
		
		/// <summary>
		/// Are you featuring this user on your profile?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endorsed")]
		public bool Endorsed { get; set; }
		
		/// <summary>
		/// Are you followed by this user?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="followed_by")]
		public bool Followed_by { get; set; }
		
		/// <summary>
		/// Are you following this user?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="following")]
		public bool Following { get; set; }
		
		/// <summary>
		/// The account id. Cast from an integer, but not guaranteed to be a number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Are you muting this user?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="muting")]
		public bool Muting { get; set; }
		
		/// <summary>
		/// Are you muting notifications from this user?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="muting_notifications")]
		public bool Muting_notifications { get; set; }
		
		/// <summary>
		/// This user's profile bio
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="note")]
		public string Note { get; set; }
		
		/// <summary>
		/// Have you enabled notifications for this user?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifying")]
		public bool Notifying { get; set; }
		
		/// <summary>
		/// Do you have a pending follow request for this user?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="requested")]
		public bool Requested { get; set; }
		
		/// <summary>
		/// Are you receiving this user's boosts in your home timeline?
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="showing_reblogs")]
		public bool Showing_reblogs { get; set; }
	}
	
	/// <summary>
	/// Reports filed against users and/or statuses, to be taken action on by moderators.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Report
	{
		
		[System.Runtime.Serialization.DataMember(Name="action_taken")]
		public System.Nullable<System.Boolean> Action_taken { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="action_taken_at")]
		public System.Nullable<System.DateTimeOffset> Action_taken_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="category")]
		public System.Nullable<ReportCategory> Category { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forwarded")]
		public System.Nullable<System.Boolean> Forwarded { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rule_ids")]
		public int[] Rule_ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status_ids")]
		public int[] Status_ids { get; set; }
		
		/// <summary>
		/// Represents a user of Mastodon and their associated profile.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target_account")]
		public Account Target_account { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ReportCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="other")]
		other = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="spam")]
		spam = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="violation")]
		violation = 2,
	}
	
	/// <summary>
	/// Represents the results of a search.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Results
	{
		
		/// <summary>
		/// Accounts which match the given query.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accounts")]
		public Account[] Accounts { get; set; }
		
		/// <summary>
		/// Hashtags which match the given query.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hashtags")]
		public Tag[] Hashtags { get; set; }
		
		/// <summary>
		/// Statuses which match the given query.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public Status[] Statuses { get; set; }
	}
	
	/// <summary>
	/// Represents a status that will be published at a future scheduled date.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScheduledStatus
	{
		
		/// <summary>
		/// ID of the scheduled status in the database. Cast from an integer, but not guaranteed to be a number.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Array of attachements
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="media_attachments")]
		public Attachment[] Media_attachments { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="params")]
		public StatusParams Params { get; set; }
		
		/// <summary>
		/// ID of the status in the database. ISO 8601 Datetime.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="scheduled_at")]
		public System.DateTimeOffset Scheduled_at { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatusParams
	{
		
		/// <summary>
		/// application_id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="application_id")]
		public string Application_id { get; set; }
		
		/// <summary>
		/// in_reply_to_id
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in_reply_to_id")]
		public string In_reply_to_id { get; set; }
		
		/// <summary>
		/// media_ids
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="media_ids")]
		public string[] Media_ids { get; set; }
		
		/// <summary>
		/// scheduled_at
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduled_at")]
		public System.Nullable<System.DateTimeOffset> Scheduled_at { get; set; }
		
		/// <summary>
		/// sensitive
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sensitive")]
		public System.Nullable<System.Boolean> Sensitive { get; set; }
		
		/// <summary>
		/// spoiler_text
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spoiler_text")]
		public string Spoiler_text { get; set; }
		
		/// <summary>
		/// text
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// visibility
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
	}
	
	/// <summary>
	/// Represents an OAuth token used for authenticating with the API and performing actions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Token
	{
		
		/// <summary>
		/// An OAuth token to be used for authorization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="access_token")]
		public string Access_token { get; set; }
		
		/// <summary>
		/// When the token was generated. UNIX Timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.Int32> Created_at { get; set; }
		
		/// <summary>
		/// The OAuth scopes granted by this token, space-separated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scope")]
		public string Scope { get; set; }
		
		/// <summary>
		/// The OAuth token type. Mastodon uses `Bearer` tokens.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token_type")]
		public string Token_type { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// OEmbed as JSON
		/// ApiOembedGetByUrlAndMaxwidthAndMaxheight api/oembed
		/// </summary>
		/// <param name="url">URL of a status</param>
		/// <param name="maxwidth">width of the iframe. Defaults to 400</param>
		/// <param name="maxheight">height of the iframe. Defaults to null</param>
		/// <returns>Success</returns>
		public async Task<Card> ApiOembedGetByUrlAndMaxwidthAndMaxheightAsync(string url, int maxwidth, int maxheight, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/oembed?url=" + (url==null? "" : System.Uri.EscapeDataString(url))+"&maxwidth="+maxwidth+"&maxheight="+maxheight;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Card>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View identity proof
		/// ApiProofsGetByProviderAndUsername api/proofs
		/// </summary>
		/// <param name="provider">The identity provider to be looked up. Currently only supports keybase (case-sensitive)</param>
		/// <param name="username">The username on the selected identity provider</param>
		/// <returns>Success</returns>
		public async Task<IdentityProof> ApiProofsGetByProviderAndUsernameAsync(string provider, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/proofs?provider=" + (provider==null? "" : System.Uri.EscapeDataString(provider))+"&username=" + (username==null? "" : System.Uri.EscapeDataString(username));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityProof>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Sets a private note on a user.
		/// ApiV1AccountsRelationshipsGetById api/v1/accounts/relationships
		/// </summary>
		/// <param name="id">Array of account IDs to check</param>
		/// <returns>Success.</returns>
		public async Task<Relationship[]> ApiV1AccountsRelationshipsGetByIdAsync(string[] id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/relationships?"+string.Join("&", id.Select(z => $"id={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Relationship[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Search for matching accounts by username or display name.
		/// ApiV1AccountsSearchGetByQAndLimitAndResolveAndFollowing api/v1/accounts/search
		/// </summary>
		/// <param name="q">What to search for</param>
		/// <param name="limit">Maximum number of results. Defaults to 40.</param>
		/// <param name="resolve">Attempt WebFinger lookup. Defaults to false. Use this when `q` is an exact address.</param>
		/// <param name="following">Only who the user is following. Defaults to false.</param>
		/// <returns>Accounts matching `q` in username or display name</returns>
		public async Task<Account[]> ApiV1AccountsSearchGetByQAndLimitAndResolveAndFollowingAsync(string q, int limit, string resolve, bool following, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/search?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&limit="+limit+"&resolve=" + (resolve==null? "" : System.Uri.EscapeDataString(resolve))+"&following="+following;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Test to make sure that the user token works.
		/// ApiV1AccountsVerify_credentialsGet api/v1/accounts/verify_credentials
		/// </summary>
		/// <returns>Note the extra `source` property, which is not visible on accounts other than your own. Also note that plain-text is used within `source` and HTML is used for their corresponding properties such as `note` and `fields`.</returns>
		public async Task<Account> ApiV1AccountsVerify_credentialsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/verify_credentials";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// ApiV1Accounts_idGet api/v1/accounts/{id}
		/// </summary>
		/// <returns>Account record will be returned. Note that `acct` of local users does not include the domain name.</returns>
		public async Task<Account> ApiV1Accounts_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Block the given account. Clients should filter statuses from this account if received (e.g. due to a boost in the Home timeline).
		/// ApiV1Accounts_idBlockPost api/v1/accounts/{id}/block
		/// </summary>
		/// <returns>Successfully blocked, or account was already blocked</returns>
		public async Task<Relationship> ApiV1Accounts_idBlockPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/block";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Relationship>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Tags featured by this account.
		/// ApiV1Accounts_idFeatured_tagsGet api/v1/accounts/{id}/featured_tags
		/// </summary>
		/// <returns>Success</returns>
		public async Task<FeaturedTag[]> ApiV1Accounts_idFeatured_tagsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/featured_tags";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FeaturedTag[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Accounts which follow the given account, if network is not hidden by the account owner.
		/// ApiV1Accounts_idFollowersGetByMax_idAndSince_idAndLimit api/v1/accounts/{id}/followers
		/// </summary>
		/// <param name="max_id">Internal parameter. Use HTTP `Link` header for pagination.</param>
		/// <param name="since_id">Internal parameter. Use HTTP `Link` header for pagination.</param>
		/// <param name="limit">Maximum number of results to return. Defaults to 40.</param>
		/// <returns>Success</returns>
		public async Task<Account[]> ApiV1Accounts_idFollowersGetByMax_idAndSince_idAndLimitAsync(string max_id, string since_id, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/followers?max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id))+"&limit="+limit;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Accounts which the given account is following, if network is not hidden by the account owner.
		/// ApiV1Accounts_idFollowingGetByMax_idAndSince_idAndLimit api/v1/accounts/{id}/following
		/// </summary>
		/// <param name="max_id">Internal parameter. Use HTTP `Link` header for pagination.</param>
		/// <param name="since_id">Internal parameter. Use HTTP `Link` header for pagination.</param>
		/// <param name="limit">Maximum number of results to return. Defaults to 40.</param>
		/// <returns>Success</returns>
		public async Task<Account[]> ApiV1Accounts_idFollowingGetByMax_idAndSince_idAndLimitAsync(string max_id, string since_id, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/following?max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id))+"&limit="+limit;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Array of IdentityProof
		/// ApiV1Accounts_idIdentity_proofsGet api/v1/accounts/{id}/identity_proofs
		/// </summary>
		/// <returns>Success</returns>
		public async Task<IdentityProof[]> ApiV1Accounts_idIdentity_proofsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/identity_proofs";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IdentityProof[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// User lists that you have added this account to.
		/// ApiV1Accounts_idListsGet api/v1/accounts/{id}/lists
		/// </summary>
		/// <returns>Success</returns>
		public async Task<List[]> ApiV1Accounts_idListsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/lists";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<List[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add the given account to the user's featured profiles. (Featured profiles are currently shown on the user's own public profile.)
		/// ApiV1Accounts_idPinPost api/v1/accounts/{id}/pin
		/// </summary>
		/// <returns>Successfully unmuted, or account was already unmuted.</returns>
		public async Task<Relationship> ApiV1Accounts_idPinPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/pin";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Relationship>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Statuses posted to the given account.
		/// ApiV1Accounts_idStatusesGet api/v1/accounts/{id}/statuses
		/// </summary>
		/// <returns>Statuses posted to the given account. Public (for public statuses only), or user token + read:statuses (for private statuses the user is authorized to see)</returns>
		public async Task<Status[]> ApiV1Accounts_idStatusesGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/statuses";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Block the given account. Clients should filter statuses from this account if received (e.g. due to a boost in the Home timeline).
		/// ApiV1Accounts_idUnblockPost api/v1/accounts/{id}/unblock
		/// </summary>
		/// <returns>Successfully unblocked, or account was already not blocked</returns>
		public async Task<Relationship> ApiV1Accounts_idUnblockPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/unblock";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Relationship>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Unfollow the given account.
		/// ApiV1Accounts_idUnfollowPost api/v1/accounts/{id}/unfollow
		/// </summary>
		/// <returns>Successfully unfollowed, or account was already not followed</returns>
		public async Task<Relationship> ApiV1Accounts_idUnfollowPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/unfollow";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Relationship>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Unmute the given account.
		/// ApiV1Accounts_idUnmutePost api/v1/accounts/{id}/unmute
		/// </summary>
		/// <returns>Successfully unmuted, or account was already unmuted.</returns>
		public async Task<Relationship> ApiV1Accounts_idUnmutePostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/unmute";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Relationship>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove the given account from the user's featured profiles.
		/// ApiV1Accounts_idUnpinPost api/v1/accounts/{id}/unpin
		/// </summary>
		/// <returns>Successfully unmuted, or account was already unmuted.</returns>
		public async Task<Relationship> ApiV1Accounts_idUnpinPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/accounts/{id}/unpin";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Relationship>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View accounts matching certain criteria for filtering, up to 100 at a time. Pagination may be done with the HTTP Link header in the response.
		/// ApiV1AdminAccountsGetByLocalAndRemoteAndBy_domainAndActiveAndPendingAndDisabledAndSilencedAndSuspendedAndStaffAndUsernameAndDisplay_nameAndEmailAndIp api/v1/admin/accounts
		/// </summary>
		/// <param name="local">Filter for local accounts?</param>
		/// <param name="remote">Filter for remote accounts?</param>
		/// <param name="by_domain">Filter by the given domain</param>
		/// <param name="active">Filter for currently active accounts?</param>
		/// <param name="pending">Filter for currently pending accounts?</param>
		/// <param name="disabled">Filter for currently disabled accounts?</param>
		/// <param name="silenced">Filter for currently silenced accounts?</param>
		/// <param name="suspended">Filter for currently suspended accounts?</param>
		/// <param name="staff">Filter for staff accounts?</param>
		/// <param name="username">Username to search for</param>
		/// <param name="display_name">Display name to search for</param>
		/// <param name="email">Lookup a user with this email</param>
		/// <param name="ip">Lookup a user with this IP</param>
		/// <returns>Success</returns>
		public async Task<AdminAccount[]> ApiV1AdminAccountsGetByLocalAndRemoteAndBy_domainAndActiveAndPendingAndDisabledAndSilencedAndSuspendedAndStaffAndUsernameAndDisplay_nameAndEmailAndIpAsync(bool local, bool remote, string by_domain, bool active, bool pending, bool disabled, bool silenced, bool suspended, bool staff, string username, string display_name, string email, string ip, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/accounts?local="+local+"&remote="+remote+"&by_domain=" + (by_domain==null? "" : System.Uri.EscapeDataString(by_domain))+"&active="+active+"&pending="+pending+"&disabled="+disabled+"&silenced="+silenced+"&suspended="+suspended+"&staff="+staff+"&username=" + (username==null? "" : System.Uri.EscapeDataString(username))+"&display_name=" + (display_name==null? "" : System.Uri.EscapeDataString(display_name))+"&email=" + (email==null? "" : System.Uri.EscapeDataString(email))+"&ip=" + (ip==null? "" : System.Uri.EscapeDataString(ip));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AdminAccount[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View admin-level information about the given account.
		/// ApiV1AdminAccounts_idGet api/v1/admin/accounts/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AdminAccount> ApiV1AdminAccounts_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/accounts/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AdminAccount>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Perform an action against an account and log this action in the moderation history.
		/// ApiV1AdminAccounts_idActionPost api/v1/admin/accounts/{id}/action
		/// </summary>
		/// <returns>Success</returns>
		public async Task ApiV1AdminAccounts_idActionPostAsync(ApiV1AdminAccounts_idActionPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/accounts/{id}/action";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Approve the given local account if it is currently pending approval.
		/// ApiV1AdminAccounts_idApprovePost api/v1/admin/accounts/{id}/approve
		/// </summary>
		/// <returns>Success</returns>
		public async Task ApiV1AdminAccounts_idApprovePostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/accounts/{id}/approve";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Re-enable a local account whose login is currently disabled.
		/// ApiV1AdminAccounts_idEnablePost api/v1/admin/accounts/{id}/enable
		/// </summary>
		/// <returns>Success</returns>
		public async Task ApiV1AdminAccounts_idEnablePostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/accounts/{id}/enable";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reject the given local account if it is currently pending approval.
		/// ApiV1AdminAccounts_idRejectPost api/v1/admin/accounts/{id}/reject
		/// </summary>
		/// <returns>Success</returns>
		public async Task ApiV1AdminAccounts_idRejectPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/accounts/{id}/reject";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Unsilence a currently silenced account.
		/// ApiV1AdminAccounts_idUnsilencePost api/v1/admin/accounts/{id}/unsilence
		/// </summary>
		/// <returns>Success</returns>
		public async Task ApiV1AdminAccounts_idUnsilencePostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/accounts/{id}/unsilence";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Unsuspend a currently suspended account.
		/// ApiV1AdminAccounts_idUnsuspendPost api/v1/admin/accounts/{id}/unsuspend
		/// </summary>
		/// <returns>Success</returns>
		public async Task ApiV1AdminAccounts_idUnsuspendPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/accounts/{id}/unsuspend";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View all reports. Pagination may be done with HTTP Link header in the response.
		/// ApiV1AdminReportsGetByResolvedAndAccount_idAndTarget_account_id api/v1/admin/reports
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AdminReport[]> ApiV1AdminReportsGetByResolvedAndAccount_idAndTarget_account_idAsync(bool resolved, string account_id, string target_account_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/reports?resolved="+resolved+"&account_id=" + (account_id==null? "" : System.Uri.EscapeDataString(account_id))+"&target_account_id=" + (target_account_id==null? "" : System.Uri.EscapeDataString(target_account_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AdminReport[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View information about the report with the given ID.
		/// ApiV1AdminReports_idGet api/v1/admin/reports/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AdminReport> ApiV1AdminReports_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/reports/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AdminReport>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Claim the handling of this report to yourself.
		/// ApiV1AdminReports_idAssign_to_selfPost api/v1/admin/reports/{id}/assign_to_self
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AdminReport> ApiV1AdminReports_idAssign_to_selfPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/reports/{id}/assign_to_self";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AdminReport>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Mark a report as resolved with no further action taken.
		/// ApiV1AdminReports_idReopenPost api/v1/admin/reports/{id}/reopen
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AdminReport> ApiV1AdminReports_idReopenPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/reports/{id}/reopen";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AdminReport>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Mark a report as resolved with no further action taken.
		/// ApiV1AdminReports_idResolvePost api/v1/admin/reports/{id}/resolve
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AdminReport> ApiV1AdminReports_idResolvePostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/reports/{id}/resolve";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AdminReport>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Unassign a report so that someone else can claim it.
		/// ApiV1AdminReports_idUnassignPost api/v1/admin/reports/{id}/unassign
		/// </summary>
		/// <returns>Success</returns>
		public async Task<AdminReport> ApiV1AdminReports_idUnassignPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/admin/reports/{id}/unassign";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AdminReport>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// See all currently active announcements set by admins.
		/// ApiV1AnnouncementsGetByWith_dismissed api/v1/announcements
		/// </summary>
		/// <param name="with_dismissed">If true, response will include announcements dismissed by the user. Defaults to false.</param>
		/// <returns>Success</returns>
		public async Task<Announcement[]> ApiV1AnnouncementsGetByWith_dismissedAsync(bool with_dismissed, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/announcements?with_dismissed="+with_dismissed;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Announcement[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Allows a user to mark the announcement as read.
		/// ApiV1Announcements_idDismissPost api/v1/announcements/{id}/dismiss
		/// </summary>
		/// <returns>Success</returns>
		public async Task<string> ApiV1Announcements_idDismissPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/announcements/{id}/dismiss";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Undo a react emoji to an announcement.
		/// ApiV1Announcements_idReactions_nameDelete api/v1/announcements/{id}/reactions/{name}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<string> ApiV1Announcements_idReactions_nameDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/announcements/{id}/reactions/{name}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Allows a user to mark the announcement as read.
		/// ApiV1Announcements_idReactions_namePut api/v1/announcements/{id}/reactions/{name}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<string> ApiV1Announcements_idReactions_namePutAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/announcements/{id}/reactions/{name}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Confirm that the app's OAuth2 credentials work.
		/// ApiV1AppsVerify_credentialsGet api/v1/apps/verify_credentials
		/// </summary>
		/// <returns>If the Authorization header was provided with a valid token, you should see your app returned as an Application entity.</returns>
		public async Task<Application> ApiV1AppsVerify_credentialsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/apps/verify_credentials";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Application>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get blocked users.
		/// ApiV1BlocksGetByLimitAndMax_idAndSince_id api/v1/blocks
		/// </summary>
		/// <returns>success</returns>
		public async Task<Account[]> ApiV1BlocksGetByLimitAndMax_idAndSince_idAsync(int limit, string max_id, string since_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/blocks?limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Statuses the user has bookmarked.
		/// ApiV1BookmarksGetByLimitAndMax_idAndSince_idAndMin_id api/v1/bookmarks
		/// </summary>
		/// <returns>success</returns>
		public async Task<Status[]> ApiV1BookmarksGetByLimitAndMax_idAndSince_idAndMin_idAsync(int limit, string max_id, string since_id, string min_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/bookmarks?limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id))+"&min_id=" + (min_id==null? "" : System.Uri.EscapeDataString(min_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Show conversation.
		/// ApiV1ConversationsGetByLimitAndMax_idAndSince_idAndMin_id api/v1/conversations
		/// </summary>
		/// <param name="limit">Max number of results to return. Defaults to 20.</param>
		/// <param name="max_id">Return results older than ID</param>
		/// <param name="since_id">Return results newer than ID</param>
		/// <param name="min_id">Return results immediately newer than ID</param>
		/// <returns>Success.</returns>
		public async Task<Conversation[]> ApiV1ConversationsGetByLimitAndMax_idAndSince_idAndMin_idAsync(int limit, string max_id, string since_id, string min_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/conversations?limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id))+"&min_id=" + (min_id==null? "" : System.Uri.EscapeDataString(min_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Conversation[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove converstation
		/// ApiV1Conversations_idDelete api/v1/conversations/{id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<string> ApiV1Conversations_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/conversations/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove converstation
		/// ApiV1Conversations_idReadPost api/v1/conversations/{id}/read
		/// </summary>
		/// <returns>The value of unread has been changed to false..</returns>
		public async Task<Conversation> ApiV1Conversations_idReadPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/conversations/{id}/read";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Conversation>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Returns custom emojis that are available on the server.
		/// ApiV1Custom_emojisGet api/v1/custom_emojis
		/// </summary>
		/// <returns>List of Emojis</returns>
		public async Task<Emoji[]> ApiV1Custom_emojisGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/custom_emojis";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Emoji[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// List accounts visible in the directory.
		/// ApiV1DirectoryGetByLimitAndOffsetAndOrderAndLocal api/v1/directory
		/// </summary>
		/// <param name="limit">How many accounts to load. Default 40.</param>
		/// <param name="offset">How many accounts to skip before returning results. Default 0.</param>
		/// <param name="order">the `active` to sort by most recently posted statuses (default) or `new` to sort by most recently created profiles.</param>
		/// <param name="local">Only return local accounts.</param>
		/// <returns>List of accounts</returns>
		public async Task<Account[]> ApiV1DirectoryGetByLimitAndOffsetAndOrderAndLocalAsync(int limit, int offset, ApiV1DirectoryGetByLimitAndOffsetAndOrderAndLocalOrder order, bool local, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/directory?limit="+limit+"&offset="+offset+"&order=" + order+"&local="+local;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove a domain block, if it exists in the user's array of blocked domains.
		/// ApiV1Domain_blocksDeleteByDomain api/v1/domain_blocks
		/// </summary>
		/// <param name="domain">Domain to unblock.</param>
		/// <returns>success</returns>
		public async Task<string> ApiV1Domain_blocksDeleteByDomainAsync(string domain, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/domain_blocks?domain=" + (domain==null? "" : System.Uri.EscapeDataString(domain));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View domains the user has blocked.
		/// ApiV1Domain_blocksGetByLimitAndMax_idAndSince_id api/v1/domain_blocks
		/// </summary>
		/// <returns>success</returns>
		public async Task<string[]> ApiV1Domain_blocksGetByLimitAndMax_idAndSince_idAsync(int limit, string max_id, string since_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/domain_blocks?limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Accounts that the user is currently featuring on their profile.
		/// ApiV1EndorsementsGetByLimitAndMax_idAndSince_id api/v1/endorsements
		/// </summary>
		/// <param name="limit">Maximum number of results to return. Defaults to 40. Paginate using the HTTP Link header.</param>
		/// <param name="max_id">Internal parameter. Use HTTP Link header from response for pagination</param>
		/// <param name="since_id">Internal parameter. Use HTTP Link header from response for pagination.</param>
		/// <returns>Success. Because endorsement ids are private, you must parse the HTTP Link header to find next and previous pages.</returns>
		public async Task<Account[]> ApiV1EndorsementsGetByLimitAndMax_idAndSince_idAsync(int limit, string max_id, string since_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/endorsements?limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Statuses the user has favourited.
		/// ApiV1FavouritesGetByLimitAndMax_idAndMin_id api/v1/favourites
		/// </summary>
		/// <returns>success</returns>
		public async Task<Status[]> ApiV1FavouritesGetByLimitAndMax_idAndMin_idAsync(string limit, string max_id, string min_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/favourites?limit=" + (limit==null? "" : System.Uri.EscapeDataString(limit))+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&min_id=" + (min_id==null? "" : System.Uri.EscapeDataString(min_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View your featured tags.
		/// ApiV1Featured_tagsGet api/v1/featured_tags
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<FeaturedTag[]> ApiV1Featured_tagsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/featured_tags";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FeaturedTag[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a feature a tag.
		/// ApiV1Featured_tagsPost api/v1/featured_tags
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<FeaturedTag> ApiV1Featured_tagsPostAsync(ApiV1Featured_tagsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/featured_tags";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FeaturedTag>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Shows your 10 most-used tags, with usage history for the past week.
		/// ApiV1Featured_tagsSuggestionsGet api/v1/featured_tags/suggestions
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<FeaturedTag[]> ApiV1Featured_tagsSuggestionsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/featured_tags/suggestions";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FeaturedTag[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Unfeature a tag
		/// ApiV1Featured_tags_idDelete api/v1/featured_tags/{id}
		/// </summary>
		/// <returns>An empty object will be returned if the featured tag was successfully deleted.</returns>
		public async Task<string> ApiV1Featured_tags_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/featured_tags/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// ApiV1FiltersGet api/v1/filters
		/// </summary>
		/// <returns>Excerpts of various filters in different contexts.</returns>
		public async Task<Filter[]> ApiV1FiltersGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/filters";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Filter[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a filter.
		/// ApiV1Filters_idDelete api/v1/filters/{id}
		/// </summary>
		/// <returns>The filter has been deleted successfully, so an empty object will be returned.</returns>
		public async Task ApiV1Filters_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/filters/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get one filter.
		/// ApiV1Filters_idGet api/v1/filters/{id}
		/// </summary>
		/// <returns>Filter returned successfully.</returns>
		public async Task<Filter> ApiV1Filters_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/filters/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Filter>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Pending Follows
		/// ApiV1Follow_requestsGetByLimit api/v1/follow_requests
		/// </summary>
		/// <param name="limit">Maximum number of results to return. Defaults to 40. Paginate using the HTTP Link header.</param>
		/// <returns>Accounts that are requesting a follow.</returns>
		public async Task<Account[]> ApiV1Follow_requestsGetByLimitAsync(int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/follow_requests?limit="+limit;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Accept Follow
		/// ApiV1Follow_requests_idAuthorizePost api/v1/follow_requests/{id}/authorize
		/// </summary>
		/// <returns>Your Relationship with this account should be updated so that you are followed_by this account.</returns>
		public async Task<Relationship> ApiV1Follow_requests_idAuthorizePostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/follow_requests/{id}/authorize";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Relationship>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Accept Follow
		/// ApiV1Follow_requests_idRejectPost api/v1/follow_requests/{id}/reject
		/// </summary>
		/// <returns>Your Relationship with this Account should be unchanged.</returns>
		public async Task<Relationship> ApiV1Follow_requests_idRejectPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/follow_requests/{id}/reject";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Relationship>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Information about the server.
		/// ApiV1InstanceGet api/v1/instance
		/// </summary>
		/// <returns>Result</returns>
		public async Task<Instance> ApiV1InstanceGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/instance";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Instance>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Instance activity over the last 3 months, binned weekly.
		/// ApiV1InstanceActivityGet api/v1/instance/activity
		/// </summary>
		/// <returns>Domains that this instance is aware of.</returns>
		public async Task<Activity[]> ApiV1InstanceActivityGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/instance/activity";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Activity[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Information about the server.
		/// ApiV1InstancePeersGet api/v1/instance/peers
		/// </summary>
		/// <returns>Domains that this instance is aware of.</returns>
		public async Task<string[]> ApiV1InstancePeersGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/instance/peers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete a list
		/// ApiV1ListsDelete api/v1/lists
		/// </summary>
		/// <returns>A list was deleted successfully</returns>
		public async Task<string> ApiV1ListsDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/lists";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Fetch all lists that the user owns.
		/// ApiV1ListsGet api/v1/lists
		/// </summary>
		/// <returns>Use id as a parameter for related API calls.</returns>
		public async Task<List[]> ApiV1ListsGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/lists";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<List[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Create a new list.
		/// ApiV1ListsPost api/v1/lists
		/// </summary>
		/// <returns>A list was created successfully</returns>
		public async Task<List> ApiV1ListsPostAsync(ApiV1ListsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/lists";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<List>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Change the title of a list, or which replies to show.
		/// ApiV1ListsPut api/v1/lists
		/// </summary>
		/// <returns>A list was updated successfully</returns>
		public async Task<List> ApiV1ListsPutAsync(ApiV1ListsPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/lists";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<List>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove converstation
		/// ApiV1Lists_idGet api/v1/lists/{id}
		/// </summary>
		/// <returns>The value of unread has been changed to false..</returns>
		public async Task<List> ApiV1Lists_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/lists/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<List>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove accounts from the given list.
		/// ApiV1Lists_idAccountsDeleteByAccount_ids api/v1/lists/{id}/accounts
		/// </summary>
		/// <param name="account_ids">Array of account IDs to add to the list.</param>
		/// <returns>Account was successfully removed from the list, or it was already not in the list.</returns>
		public async Task<string> ApiV1Lists_idAccountsDeleteByAccount_idsAsync(string[] account_ids, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/lists/{id}/accounts?"+string.Join("&", account_ids.Select(z => $"account_ids={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View accounts in List
		/// ApiV1Lists_idAccountsGetByLimitAndMax_idAndSince_id api/v1/lists/{id}/accounts
		/// </summary>
		/// <param name="limit">Maximum number of results. Defaults to 40. Max 40. Set to 0 in order to get all accounts without pagination. Pagination is done with the HTTP Link header.</param>
		/// <param name="max_id">Return results older than ID</param>
		/// <param name="since_id">Return results newer than ID</param>
		/// <returns>Success</returns>
		public async Task<Account[]> ApiV1Lists_idAccountsGetByLimitAndMax_idAndSince_idAsync(int limit, string max_id, string since_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/lists/{id}/accounts?limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add accounts to the given list. Note that the user must be following these accounts.
		/// ApiV1Lists_idAccountsPost api/v1/lists/{id}/accounts
		/// </summary>
		/// <returns>Success</returns>
		public async Task<string> ApiV1Lists_idAccountsPostAsync(ApiV1Lists_idAccountsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/lists/{id}/accounts";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get saved timeline position
		/// ApiV1MarkersGetByTimeline api/v1/markers
		/// </summary>
		/// <param name="timeline">Array of markers to fetch. String enum anyOf home, notifications. If not provided, an empty object will be returned.</param>
		/// <returns>Account was successfully removed from the list, or it was already not in the list.</returns>
		public async Task<string> ApiV1MarkersGetByTimelineAsync(string[] timeline, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/markers?"+string.Join("&", timeline.Select(z => $"timeline={System.Uri.EscapeDataString(z.ToString())}"));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get saved timeline position
		/// ApiV1MarkersPost api/v1/markers
		/// </summary>
		/// <returns>Account was successfully removed from the list, or it was already not in the list.</returns>
		public async Task<string> ApiV1MarkersPostAsync(string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/markers";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Get an attachement.
		/// ApiV1Media_idGet api/v1/media/{id}
		/// </summary>
		/// <returns>Attachment created successfully. Note that the Attachment will be created even if the file is not understood correctly.</returns>
		public async Task<Attachment> ApiV1Media_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/media/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Attachment>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Accounts the user has muted.
		/// ApiV1MutesGetByLimitAndMax_idAndSince_id api/v1/mutes
		/// </summary>
		/// <returns>success</returns>
		public async Task<Account[]> ApiV1MutesGetByLimitAndMax_idAndSince_idAsync(string limit, string max_id, string since_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/mutes?limit=" + (limit==null? "" : System.Uri.EscapeDataString(limit))+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Notifications concerning the user. This API returns Link headers containing links to the next/previous page. However, the links can also be constructed dynamically using query params and id values.
		/// ApiV1NotificationsGetByLimitAndMax_idAndSince_idAndMin_idAndExclude_typesAndAccount_id api/v1/notifications
		/// </summary>
		/// <param name="limit">Max number of results to return. Defaults to 20.</param>
		/// <param name="max_id">Return results older than ID</param>
		/// <param name="since_id">Return results newer than ID</param>
		/// <param name="min_id">Return results immediately newer than ID</param>
		/// <param name="exclude_types">Array of types to exclude (follow, favourite, reblog, mention, poll, follow_request)</param>
		/// <param name="account_id">Return only notifications received from this account</param>
		/// <returns>Success</returns>
		public async Task<Notification[]> ApiV1NotificationsGetByLimitAndMax_idAndSince_idAndMin_idAndExclude_typesAndAccount_idAsync(int limit, string max_id, string since_id, string min_id, string[] exclude_types, string account_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/notifications?limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id))+"&min_id=" + (min_id==null? "" : System.Uri.EscapeDataString(min_id))+"&"+string.Join("&", exclude_types.Select(z => $"exclude_types={System.Uri.EscapeDataString(z.ToString())}"))+"&account_id=" + (account_id==null? "" : System.Uri.EscapeDataString(account_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Notification[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Clear all notifications from the server.
		/// ApiV1NotificationsClearPost api/v1/notifications/clear
		/// </summary>
		/// <returns>Success</returns>
		public async Task<string> ApiV1NotificationsClearPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/notifications/clear";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View information about a notification with a given ID.
		/// ApiV1Notifications_idGet api/v1/notifications/{id}
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Notification> ApiV1Notifications_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/notifications/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Notification>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Clear a single notification from the server.
		/// ApiV1Notifications_idDismissPost api/v1/notifications/{id}/dismiss
		/// </summary>
		/// <returns>Notification with given ID successfully dismissed</returns>
		public async Task<Notification> ApiV1Notifications_idDismissPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/notifications/{id}/dismiss";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Notification>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View a poll.
		/// ApiV1Polls_idGet api/v1/polls/{id}
		/// </summary>
		/// <returns>Get one poll.</returns>
		public async Task<Poll> ApiV1Polls_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/polls/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Poll>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Vote on a poll.
		/// ApiV1Polls_idPost api/v1/polls/{id}
		/// </summary>
		/// <returns>Get one poll.</returns>
		public async Task<Poll> ApiV1Polls_idPostAsync(ApiV1Polls_idPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/polls/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Poll>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Shows your 10 most-used tags, with usage history for the past week.
		/// ApiV1PreferencesGet api/v1/preferences
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<Preferences> ApiV1PreferencesGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/preferences";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Preferences>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead.
		/// ApiV1PushSubscriptionDelete api/v1/push/subscription
		/// </summary>
		/// <returns>Updating a PushSubscription to only receive mention alerts</returns>
		public async Task<string> ApiV1PushSubscriptionDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/push/subscription";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View the PushSubscription currently associated with this access token.
		/// ApiV1PushSubscriptionGet api/v1/push/subscription
		/// </summary>
		/// <returns>Get one PushSubscription</returns>
		public async Task<PushSubscription> ApiV1PushSubscriptionGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/push/subscription";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PushSubscription>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a Web Push API subscription to receive notifications. Each access token can have one push subscription. If you create a new subscription, the old subscription is deleted.
		/// ApiV1PushSubscriptionPost api/v1/push/subscription
		/// </summary>
		/// <returns>PushSubscription created</returns>
		public async Task<PushSubscription> ApiV1PushSubscriptionPostAsync(ApiV1PushSubscriptionPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/push/subscription";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PushSubscription>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead.
		/// ApiV1PushSubscriptionPut api/v1/push/subscription
		/// </summary>
		/// <returns>Updating a PushSubscription to only receive mention alerts</returns>
		public async Task<PushSubscription> ApiV1PushSubscriptionPutAsync(ApiV1PushSubscriptionPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/push/subscription";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PushSubscription>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// File a report.
		/// ApiV1ReportsPost api/v1/reports
		/// </summary>
		/// <returns>Successfully reported.</returns>
		public async Task<Report> ApiV1ReportsPostAsync(ApiV1ReportsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/reports";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Report>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View scheduled statuses
		/// ApiV1Scheduled_statusesGetByLimitAndMax_idAndSince_idAndMin_id api/v1/scheduled_statuses
		/// </summary>
		/// <param name="limit">Max number of results to return. Defaults to 20.</param>
		/// <param name="max_id">Return results older than ID</param>
		/// <param name="since_id">Return results newer than ID</param>
		/// <param name="min_id">Return results immediately newer than ID</param>
		/// <returns>Get scheduled statuses.</returns>
		public async Task<ScheduledStatus[]> ApiV1Scheduled_statusesGetByLimitAndMax_idAndSince_idAndMin_idAsync(int limit, string max_id, string since_id, string min_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/scheduled_statuses?limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id))+"&min_id=" + (min_id==null? "" : System.Uri.EscapeDataString(min_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScheduledStatus[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Cancel a scheduled status
		/// ApiV1Scheduled_statuses_idDelete api/v1/scheduled_statuses/{id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<string> ApiV1Scheduled_statuses_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/scheduled_statuses/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View a single scheduled status
		/// ApiV1Scheduled_statuses_idGet api/v1/scheduled_statuses/{id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<ScheduledStatus> ApiV1Scheduled_statuses_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/scheduled_statuses/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScheduledStatus>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View a single scheduled status
		/// ApiV1Scheduled_statuses_idPut api/v1/scheduled_statuses/{id}
		/// </summary>
		/// <returns>Success.</returns>
		public async Task<ScheduledStatus> ApiV1Scheduled_statuses_idPutAsync(ApiV1Scheduled_statuses_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/scheduled_statuses/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScheduledStatus>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// ApiV1StatusesPost api/v1/statuses
		/// </summary>
		/// <returns>Status will be posted with chosen parameters. If scheduled_at is provided, then a ScheduledStatus will be returned instead.</returns>
		public async Task<Status> ApiV1StatusesPostAsync(ApiV1StatusesPostPostBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// ApiV1Statuses_idDelete api/v1/statuses/{id}
		/// </summary>
		/// <returns>Status will be posted with chosen parameters. If scheduled_at is provided, then a ScheduledStatus will be returned instead.</returns>
		public async Task<Status> ApiV1Statuses_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// ApiV1Statuses_idGet api/v1/statuses/{id}
		/// </summary>
		/// <returns>Status will be posted with chosen parameters. If scheduled_at is provided, then a ScheduledStatus will be returned instead.</returns>
		public async Task<Status> ApiV1Statuses_idGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Privately bookmark a status.
		/// ApiV1Statuses_idBookmarkPost api/v1/statuses/{id}/bookmark
		/// </summary>
		/// <returns>Status bookmarked</returns>
		public async Task<Status> ApiV1Statuses_idBookmarkPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/bookmark";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// ApiV1Statuses_idContextGet api/v1/statuses/{id}/context
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Context> ApiV1Statuses_idContextGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/context";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Context>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Add a status to your favourites list.
		/// ApiV1Statuses_idFavouritePost api/v1/statuses/{id}/favourite
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Status> ApiV1Statuses_idFavouritePostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/favourite";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View who favourited a given status.
		/// ApiV1Statuses_idFavourited_byGet api/v1/statuses/{id}/favourited_by
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Account> ApiV1Statuses_idFavourited_byGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/favourited_by";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Do not receive notifications for the thread that this status is part of. Must be a thread in which you are a participant.
		/// ApiV1Statuses_idMutePost api/v1/statuses/{id}/mute
		/// </summary>
		/// <returns>Status's conversation muted, or was already muted</returns>
		public async Task<Status> ApiV1Statuses_idMutePostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/mute";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Feature one of your own public statuses at the top of your profile.
		/// ApiV1Statuses_idPinPost api/v1/statuses/{id}/pin
		/// </summary>
		/// <returns>Status pinned. Note the status is not a reblog and its authoring account is your own.</returns>
		public async Task<Status> ApiV1Statuses_idPinPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/pin";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Reshare a status.
		/// ApiV1Statuses_idReblogPost api/v1/statuses/{id}/reblog
		/// </summary>
		/// <returns>Status has been reblogged. Note that the top-level id has changed. The id of the boosted status is now inside the reblog property. The top-level id is the id of the reblog itself. Also note that reblogs cannot be pinned.</returns>
		public async Task<Status> ApiV1Statuses_idReblogPostAsync(ApiV1Statuses_idReblogPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/reblog";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			using var requestWriter = new System.IO.StringWriter();
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View who boosted a given status.
		/// ApiV1Statuses_idReblogged_byGet api/v1/statuses/{id}/reblogged_by
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Account> ApiV1Statuses_idReblogged_byGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/reblogged_by";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove a status from your private bookmarks.
		/// ApiV1Statuses_idUnbookmarkPost api/v1/statuses/{id}/unbookmark
		/// </summary>
		/// <returns>Status unbookmarked</returns>
		public async Task<Status> ApiV1Statuses_idUnbookmarkPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/unbookmark";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Remove a status from your favourites list.
		/// ApiV1Statuses_idUnfavouritePost api/v1/statuses/{id}/unfavourite
		/// </summary>
		/// <returns>Success</returns>
		public async Task<Status> ApiV1Statuses_idUnfavouritePostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/unfavourite";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Status's conversation unmuted, or was already unmuted
		/// ApiV1Statuses_idUnmutePost api/v1/statuses/{id}/unmute
		/// </summary>
		/// <returns>Status's conversation muted, or was already muted</returns>
		public async Task<Status> ApiV1Statuses_idUnmutePostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/unmute";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Unfeature a status from the top of your profile.
		/// ApiV1Statuses_idUnpinPost api/v1/statuses/{id}/unpin
		/// </summary>
		/// <returns>Status unpinned, or was already not pinned</returns>
		public async Task<Status> ApiV1Statuses_idUnpinPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/unpin";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Undo a reshare of a status.
		/// ApiV1Statuses_idUnreblogPost api/v1/statuses/{id}/unreblog
		/// </summary>
		/// <returns>Status no longer reblogged</returns>
		public async Task<Status> ApiV1Statuses_idUnreblogPostAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/statuses/{id}/unreblog";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri);
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Accounts the user has had past positive interactions with, but is not yet following.
		/// ApiV1SuggestionsGetByLimit api/v1/suggestions
		/// </summary>
		/// <param name="limit">Maximum number of results to return. Defaults to 40.</param>
		/// <returns>Success.</returns>
		public async Task<Account> ApiV1SuggestionsGetByLimitAsync(int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/suggestions?limit="+limit;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Delete user suggestion
		/// ApiV1Suggestions_idDelete api/v1/suggestions/{id}
		/// </summary>
		/// <returns>Successfully removed</returns>
		public async Task<string> ApiV1Suggestions_idDeleteAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/suggestions/{id}";
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				return jsonReader.ReadAsString();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View statuses from followed users.
		/// ApiV1TimelinesHomeGetByLocalAndLimitAndMax_idAndSince_idAndMin_id api/v1/timelines/home
		/// </summary>
		/// <param name="local">Show only local statuses? Defaults to false.</param>
		/// <param name="limit">Max number of results to return. Defaults to 20.</param>
		/// <param name="max_id">Return results older than ID</param>
		/// <param name="since_id">Return results newer than ID</param>
		/// <param name="min_id">Return results immediately newer than ID</param>
		/// <returns>Get statuses for home.</returns>
		public async Task<Status[]> ApiV1TimelinesHomeGetByLocalAndLimitAndMax_idAndSince_idAndMin_idAsync(bool local, int limit, string max_id, string since_id, string min_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/timelines/home?local="+local+"&limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id))+"&min_id=" + (min_id==null? "" : System.Uri.EscapeDataString(min_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View statuses in the given list timeline.
		/// ApiV1TimelinesList_list_idGetByLimitAndMax_idAndSince_idAndMin_id api/v1/timelines/list/{list_id}
		/// </summary>
		/// <param name="limit">Max number of results to return. Defaults to 20.</param>
		/// <param name="max_id">Return results older than ID</param>
		/// <param name="since_id">Return results newer than ID</param>
		/// <param name="min_id">Return results immediately newer than ID</param>
		/// <returns>Statuses in this list will be returned..</returns>
		public async Task<Status[]> ApiV1TimelinesList_list_idGetByLimitAndMax_idAndSince_idAndMin_idAsync(int limit, string max_id, string since_id, string min_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/timelines/list/{list_id}?limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id))+"&min_id=" + (min_id==null? "" : System.Uri.EscapeDataString(min_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Public timeline
		/// ApiV1TimelinesPublicGetByLocalAndRemoteAndOnly_mediaAndLimitAndMax_idAndSince_idAndMin_id api/v1/timelines/public
		/// </summary>
		/// <param name="local">Show only local statuses? Defaults to false.</param>
		/// <param name="remote">Show only local statuses? Defaults to false.</param>
		/// <param name="only_media">Show only statuses with media attached? Defaults to false..</param>
		/// <param name="limit">Max number of results to return. Defaults to 20.</param>
		/// <param name="max_id">Return results older than ID</param>
		/// <param name="since_id">Return results newer than ID</param>
		/// <param name="min_id">Return results immediately newer than ID</param>
		/// <returns>get statuses.</returns>
		public async Task<Status[]> ApiV1TimelinesPublicGetByLocalAndRemoteAndOnly_mediaAndLimitAndMax_idAndSince_idAndMin_idAsync(bool local, bool remote, bool only_media, int limit, string max_id, string since_id, string min_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/timelines/public?local="+local+"&remote="+remote+"&only_media="+only_media+"&limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id))+"&min_id=" + (min_id==null? "" : System.Uri.EscapeDataString(min_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// View public statuses containing the given hashtag.
		/// ApiV1TimelinesTag_hashtagGetByLocalAndRemoteAndOnly_mediaAndLimitAndMax_idAndSince_idAndMin_id api/v1/timelines/tag/{hashtag}
		/// </summary>
		/// <param name="local">Show only local statuses? Defaults to false.</param>
		/// <param name="remote">Show only local statuses? Defaults to false.</param>
		/// <param name="only_media">Show only statuses with media attached? Defaults to false..</param>
		/// <param name="limit">Max number of results to return. Defaults to 20.</param>
		/// <param name="max_id">Return results older than ID</param>
		/// <param name="since_id">Return results newer than ID</param>
		/// <param name="min_id">Return results immediately newer than ID</param>
		/// <returns>Get statuses.</returns>
		public async Task<Status[]> ApiV1TimelinesTag_hashtagGetByLocalAndRemoteAndOnly_mediaAndLimitAndMax_idAndSince_idAndMin_idAsync(bool local, bool remote, bool only_media, int limit, string max_id, string since_id, string min_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/timelines/tag/{hashtag}?local="+local+"&remote="+remote+"&only_media="+only_media+"&limit="+limit+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&since_id=" + (since_id==null? "" : System.Uri.EscapeDataString(since_id))+"&min_id=" + (min_id==null? "" : System.Uri.EscapeDataString(min_id));
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Status[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Tags that are being used more frequently within the past week.
		/// ApiV1TrendsGetByLimit api/v1/trends
		/// </summary>
		/// <param name="limit">Max number of results to return. Defaults to 10.</param>
		/// <returns>Domains that this instance is aware of.</returns>
		public async Task<Tag[]> ApiV1TrendsGetByLimitAsync(int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/trends?limit="+limit;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Tag[]>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Search results
		/// ApiV2SearchGetByQAndLimitAndResolveAndFollowingAndAccount_idAndMax_idAndMin_idAndTypeAndExclude_unreviewedAndOffset api/v2/search
		/// </summary>
		/// <param name="q">What to search for</param>
		/// <param name="limit">Maximum number of results. Defaults to 40.</param>
		/// <param name="resolve">Attempt WebFinger lookup.</param>
		/// <param name="following">Only who the user is following. Defaults to false.</param>
		/// <param name="account_id">If provided, statuses returned will be authored only by this account</param>
		/// <param name="max_id">Return results older than this id</param>
		/// <param name="min_id">Return results immediately newer than this id</param>
		/// <param name="type">Enum(accounts, hashtags, statuses)</param>
		/// <param name="exclude_unreviewed">Filter out unreviewed tags? Defaults to false. Use true when trying to find trending tags.</param>
		/// <param name="offset">Offset in search results. Used for pagination. Defaults to 0.</param>
		/// <returns>Result</returns>
		public async Task<ApiV2SearchGetByQAndLimitAndResolveAndFollowingAndAccount_idAndMax_idAndMin_idAndTypeAndExclude_unreviewedAndOffsetReturn> ApiV2SearchGetByQAndLimitAndResolveAndFollowingAndAccount_idAndMax_idAndMin_idAndTypeAndExclude_unreviewedAndOffsetAsync(string q, int limit, string resolve, bool following, string account_id, string max_id, string min_id, ApiV2SearchGetByQAndLimitAndResolveAndFollowingAndAccount_idAndMax_idAndMin_idAndTypeAndExclude_unreviewedAndOffsetType type, bool exclude_unreviewed, int offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/search?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&limit="+limit+"&resolve=" + (resolve==null? "" : System.Uri.EscapeDataString(resolve))+"&following="+following+"&account_id=" + (account_id==null? "" : System.Uri.EscapeDataString(account_id))+"&max_id=" + (max_id==null? "" : System.Uri.EscapeDataString(max_id))+"&min_id=" + (min_id==null? "" : System.Uri.EscapeDataString(min_id))+"&type=" + type+"&exclude_unreviewed="+exclude_unreviewed+"&offset="+offset;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var streamContent = await responseMessage.Content.ReadAsStreamAsync();
				using JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(streamContent));
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ApiV2SearchGetByQAndLimitAndResolveAndFollowingAndAccount_idAndMax_idAndMin_idAndTypeAndExclude_unreviewedAndOffsetReturn>(jsonReader);
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
		
		/// <summary>
		/// Displays an authorization form to the user. If approved, it will create and return an authorization code, then redirect to the desired redirect_uri, or show the authorization code if urn:ietf:wg:oauth:2.0:oob was requested. The authorization code can be used while requesting a token to obtain access to user-level methods.
		/// OauthAuthorizeGetByResponse_typeAndClient_idAndRedirect_uriAndScopeAndForce_login oauth/authorize
		/// </summary>
		/// <param name="response_type">Should be set equal to code.</param>
		/// <param name="client_id">Client ID, obtained during app registration.</param>
		/// <param name="redirect_uri">Set a URI to redirect the user to. If this parameter is set to urn:ietf:wg:oauth:2.0:oob then the authorization code will be shown instead. Must match one of the redirect URIs declared during app registration.</param>
		/// <param name="scope">List of requested OAuth scopes, separated by spaces (or by pluses, if using query parameters). Must be a subset of scopes declared during app registration. If not provided, defaults to read.</param>
		/// <param name="force_login">Added in 2.6.0. Forces the user to re-login, which is necessary for authorizing with multiple accounts from the same instance.</param>
		/// <returns>The authorization code will be returned as a query parameter named code.</returns>
		public async Task OauthAuthorizeGetByResponse_typeAndClient_idAndRedirect_uriAndScopeAndForce_loginAsync(string response_type, string client_id, string redirect_uri, string scope, bool force_login, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "oauth/authorize?response_type=" + (response_type==null? "" : System.Uri.EscapeDataString(response_type))+"&client_id=" + (client_id==null? "" : System.Uri.EscapeDataString(client_id))+"&redirect_uri=" + (redirect_uri==null? "" : System.Uri.EscapeDataString(redirect_uri))+"&scope=" + (scope==null? "" : System.Uri.EscapeDataString(scope))+"&force_login="+force_login;
			using var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri);
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
		}
	}
	
	public class ApiV1AdminAccounts_idActionPostPostBody
	{
		
		/// <summary>
		/// ID of an associated report that caused this action to be taken
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="report_id")]
		public string Report_id { get; set; }
		
		/// <summary>
		/// Whether an email should be sent to the user with the above information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="send_email_notification")]
		public System.Nullable<System.Boolean> Send_email_notification { get; set; }
		
		/// <summary>
		/// Additional text for clarification of why this action was taken
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// Type of action to be taken. Enumerable oneOf: none disable silence suspend
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ApiV1AdminAccounts_idActionPostPostBodyType> Type { get; set; }
		
		/// <summary>
		/// ID of a preset warning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning_preset_id")]
		public string Warning_preset_id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ApiV1AdminAccounts_idActionPostPostBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="none")]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="disable")]
		disable = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="silence")]
		silence = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="suspend")]
		suspend = 3,
	}
	
	public enum ApiV1DirectoryGetByLimitAndOffsetAndOrderAndLocalOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="active")]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="new")]
		_new = 1,
	}
	
	public class ApiV1Featured_tagsPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class ApiV1ListsPostPostBody
	{
		
		/// <summary>
		/// Enumerable oneOf followed list none. Defaults to list.
		/// </summary>
		[System.ComponentModel.DefaultValue(ListReplies_policy.list)]
		[System.Runtime.Serialization.DataMember(Name="replies_policy")]
		public ListReplies_policy Replies_policy { get; set; } = ListReplies_policy.list;
		
		/// <summary>
		/// The title of the list to be created.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class ApiV1ListsPutPutBody
	{
		
		/// <summary>
		/// Enumerable oneOf followed list none. Defaults to list.
		/// </summary>
		[System.ComponentModel.DefaultValue(ListReplies_policy.list)]
		[System.Runtime.Serialization.DataMember(Name="replies_policy")]
		public ListReplies_policy Replies_policy { get; set; } = ListReplies_policy.list;
		
		/// <summary>
		/// The title of the list to be created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	public class ApiV1Lists_idAccountsPostPostBody
	{
		
		/// <summary>
		/// Array of account IDs to add to the list.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="account_ids")]
		public string[] Account_ids { get; set; }
	}
	
	public class ApiV1Polls_idPostPostBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="choices")]
		public string[] Choices { get; set; }
	}
	
	public class ApiV1PushSubscriptionPostPostBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subscription")]
		public string Subscription { get; set; }
	}
	
	public class ApiV1PushSubscriptionPutPutBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
	}
	
	public class ApiV1ReportsPostPostBody
	{
		
		/// <summary>
		/// ID of the account to report
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="account_id")]
		public string Account_id { get; set; }
		
		/// <summary>
		/// Reason for the report (default max 1000 characters)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// If the account is remote, should the report be forwarded to the remote admin?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forward")]
		public System.Nullable<System.Boolean> Forward { get; set; }
		
		/// <summary>
		/// Array of Statuses to attach to the report, for context
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status_ids")]
		public string[] Status_ids { get; set; }
	}
	
	public class ApiV1Scheduled_statuses_idPutPutBody
	{
		
		/// <summary>
		/// ISO 8601 Datetime at which the status will be published. Must be at least 5 minutes into the future.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduled_at")]
		public System.Nullable<System.DateTimeOffset> Scheduled_at { get; set; }
	}
	
	public class ApiV1StatusesPostPostBody
	{
		
		/// <summary>
		/// ID of the status being replied to, if status is a reply
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in_reply_to_id")]
		public string In_reply_to_id { get; set; }
		
		/// <summary>
		/// ISO 639 language code for this status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Array of Attachment ids to be attached as media. If provided, `status` becomes optional, and `poll` cannot be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="media_ids")]
		public string[] Media_ids { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="poll")]
		public string[] Poll { get; set; }
		
		/// <summary>
		/// ISO 8601 Datetime at which to schedule a status. Providing this paramter will cause ScheduledStatus to be returned instead of Status. Must be at least 5 minutes in the future.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduled_at")]
		public string Scheduled_at { get; set; }
		
		/// <summary>
		/// Mark status and attached media as sensitive?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sensitive")]
		public System.Nullable<System.Boolean> Sensitive { get; set; }
		
		/// <summary>
		/// Text to be shown as a warning or subject before the actual content. Statuses are generally collapsed behind this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spoiler_text")]
		public string Spoiler_text { get; set; }
		
		/// <summary>
		/// Text content of the status. If `media_ids` is provided, this becomes optional. Attaching a `poll` is optional while `status` is provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		/// <summary>
		/// Visibility of the posted status. Enumerable oneOf public, unlisted, private, direct.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public System.Nullable<ApiV1StatusesPostPostBodyVisibility> Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ApiV1StatusesPostPostBodyVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unlisted")]
		unlisted = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="direct")]
		direct = 3,
	}
	
	public class ApiV1Statuses_idReblogPostPostBody
	{
		
		/// <summary>
		/// any visibility except limited or direct (i.e. public, unlisted, private). Defaults to public. Currently unused in UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public string Visibility { get; set; }
	}
	
	public enum ApiV2SearchGetByQAndLimitAndResolveAndFollowingAndAccount_idAndMax_idAndMin_idAndTypeAndExclude_unreviewedAndOffsetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="accounts")]
		accounts = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hashtags")]
		hashtags = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="statuses")]
		statuses = 2,
	}
	
	public class ApiV2SearchGetByQAndLimitAndResolveAndFollowingAndAccount_idAndMax_idAndMin_idAndTypeAndExclude_unreviewedAndOffsetReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="accounts")]
		public Account[] Accounts { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hashtags")]
		public Status[] Hashtags { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public Tag[] Statuses { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
