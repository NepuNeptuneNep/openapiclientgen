//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Phone_number_enum_address_requirement
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="none")]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="any")]
		any = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="local")]
		local = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="foreign")]
		foreign = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Recording_enum_recording_mode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="do-not-record")]
		doMinusnotMinusrecord = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="record-from-ringing")]
		recordMinusfromMinusringing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="record-from-answer")]
		recordMinusfromMinusanswer = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="record-from-ringing-dual")]
		recordMinusfromMinusringingMinusdual = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="record-from-answer-dual")]
		recordMinusfromMinusanswerMinusdual = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Recording_enum_recording_trim
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="trim-silence")]
		trimMinussilence = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="do-not-trim")]
		doMinusnotMinustrim = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Trunk_enum_transfer_caller_id
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="from-transferee")]
		fromMinustransferee = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="from-transferor")]
		fromMinustransferor = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Trunk_enum_transfer_setting
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="disable-all")]
		disableMinusall = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="enable-all")]
		enableMinusall = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sip-only")]
		sipMinusonly = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Trunkingv1trunk
	{
		
		/// <summary>
		/// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the Trunk resource.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^AC[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^AC[0-9a-fA-F]{32}$")]
		public string Account_sid { get; set; }
		
		/// <summary>
		/// The types of authentication mapped to the domain. Can be: `IP_ACL` and `CREDENTIAL_LIST`. If both are mapped, the values are returned in a comma delimited list. If empty, the domain will not receive any traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auth_type")]
		public string Auth_type { get; set; }
		
		/// <summary>
		/// Reserved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auth_type_set")]
		public string[] Auth_type_set { get; set; }
		
		/// <summary>
		/// Whether Caller ID Name (CNAM) lookup is enabled for the trunk. If enabled, all inbound calls to the SIP Trunk from the United States and Canada automatically perform a CNAM Lookup and display Caller ID data on your phone. See [CNAM Lookups](https://www.twilio.com/docs/sip-trunking#CNAM) for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cnam_lookup_enabled")]
		public System.Nullable<System.Boolean> Cnam_lookup_enabled { get; set; }
		
		/// <summary>
		/// The date and time in GMT when the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_created")]
		public System.Nullable<System.DateTimeOffset> Date_created { get; set; }
		
		/// <summary>
		/// The date and time in GMT when the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_updated")]
		public System.Nullable<System.DateTimeOffset> Date_updated { get; set; }
		
		/// <summary>
		/// The HTTP method we use to call the `disaster_recovery_url`. Can be: `GET` or `POST`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disaster_recovery_method")]
		public System.Nullable<Trunkingv1trunkDisaster_recovery_method> Disaster_recovery_method { get; set; }
		
		/// <summary>
		/// The URL we call using the `disaster_recovery_method` if an error occurs while sending SIP traffic towards the configured Origination URL. We retrieve TwiML from this URL and execute the instructions like any other normal TwiML call. See [Disaster Recovery](https://www.twilio.com/docs/sip-trunking#disaster-recovery) for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disaster_recovery_url")]
		public string Disaster_recovery_url { get; set; }
		
		/// <summary>
		/// The unique address you reserve on Twilio to which you route your SIP traffic. Domain names can contain letters, digits, and `-` and must end with `pstn.twilio.com`. See [Termination Settings](https://www.twilio.com/docs/sip-trunking#termination) for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain_name")]
		public string Domain_name { get; set; }
		
		/// <summary>
		/// The string that you assigned to describe the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friendly_name")]
		public string Friendly_name { get; set; }
		
		/// <summary>
		/// The URLs of related resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string Links { get; set; }
		
		/// <summary>
		/// The recording settings for the trunk. Can be: `do-not-record`, `record-from-ringing`, `record-from-answer`. If set to `record-from-ringing` or `record-from-answer`, all calls going through the trunk will be recorded. The only way to change recording parameters is on a sub-resource of a Trunk after it has been created. e.g.`/Trunks/[Trunk_SID]/Recording -XPOST -d'Mode=record-from-answer'`. See [Recording](https://www.twilio.com/docs/sip-trunking#recording) for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recording")]
		public object Recording { get; set; }
		
		/// <summary>
		/// Whether Secure Trunking is enabled for the trunk. If enabled, all calls going through the trunk will be secure using SRTP for media and TLS for signaling. If disabled, then RTP will be used for media. See [Secure Trunking](https://www.twilio.com/docs/sip-trunking#securetrunking) for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secure")]
		public System.Nullable<System.Boolean> Secure { get; set; }
		
		/// <summary>
		/// The unique string that we created to identify the Trunk resource.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^TK[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^TK[0-9a-fA-F]{32}$")]
		public string Sid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="transfer_caller_id")]
		public System.Nullable<Trunkingv1trunkTransfer_caller_id> Transfer_caller_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="transfer_mode")]
		public System.Nullable<Trunkingv1trunkTransfer_mode> Transfer_mode { get; set; }
		
		/// <summary>
		/// The absolute URL of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Trunkingv1trunkDisaster_recovery_method
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HEAD")]
		HEAD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="GET")]
		GET = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="POST")]
		POST = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PATCH")]
		PATCH = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PUT")]
		PUT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETE")]
		DELETE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Trunkingv1trunkTransfer_caller_id
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="from-transferee")]
		fromMinustransferee = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="from-transferor")]
		fromMinustransferor = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Trunkingv1trunkTransfer_mode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="disable-all")]
		disableMinusall = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="enable-all")]
		enableMinusall = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sip-only")]
		sipMinusonly = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Trunkingv1trunkcredential_list
	{
		
		/// <summary>
		/// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the CredentialList resource.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^AC[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^AC[0-9a-fA-F]{32}$")]
		public string Account_sid { get; set; }
		
		/// <summary>
		/// The date and time in GMT when the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_created")]
		public System.Nullable<System.DateTimeOffset> Date_created { get; set; }
		
		/// <summary>
		/// The date and time in GMT when the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_updated")]
		public System.Nullable<System.DateTimeOffset> Date_updated { get; set; }
		
		/// <summary>
		/// The string that you assigned to describe the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friendly_name")]
		public string Friendly_name { get; set; }
		
		/// <summary>
		/// The unique string that we created to identify the CredentialList resource.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^CL[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^CL[0-9a-fA-F]{32}$")]
		public string Sid { get; set; }
		
		/// <summary>
		/// The SID of the Trunk the credential list in associated with.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^TK[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trunk_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^TK[0-9a-fA-F]{32}$")]
		public string Trunk_sid { get; set; }
		
		/// <summary>
		/// The absolute URL of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Trunkingv1trunkip_access_control_list
	{
		
		/// <summary>
		/// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the IpAccessControlList resource.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^AC[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^AC[0-9a-fA-F]{32}$")]
		public string Account_sid { get; set; }
		
		/// <summary>
		/// The date and time in GMT when the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_created")]
		public System.Nullable<System.DateTimeOffset> Date_created { get; set; }
		
		/// <summary>
		/// The date and time in GMT when the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_updated")]
		public System.Nullable<System.DateTimeOffset> Date_updated { get; set; }
		
		/// <summary>
		/// The string that you assigned to describe the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friendly_name")]
		public string Friendly_name { get; set; }
		
		/// <summary>
		/// The unique string that we created to identify the IpAccessControlList resource.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^AL[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^AL[0-9a-fA-F]{32}$")]
		public string Sid { get; set; }
		
		/// <summary>
		/// The SID of the Trunk the resource is associated with.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^TK[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trunk_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^TK[0-9a-fA-F]{32}$")]
		public string Trunk_sid { get; set; }
		
		/// <summary>
		/// The absolute URL of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Trunkingv1trunkorigination_url
	{
		
		/// <summary>
		/// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the OriginationUrl resource.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^AC[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^AC[0-9a-fA-F]{32}$")]
		public string Account_sid { get; set; }
		
		/// <summary>
		/// The date and time in GMT when the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_created")]
		public System.Nullable<System.DateTimeOffset> Date_created { get; set; }
		
		/// <summary>
		/// The date and time in GMT when the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_updated")]
		public System.Nullable<System.DateTimeOffset> Date_updated { get; set; }
		
		/// <summary>
		/// Whether the URL is enabled. The default is `true`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// The string that you assigned to describe the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friendly_name")]
		public string Friendly_name { get; set; }
		
		/// <summary>
		/// The relative importance of the URI. Can be an integer from 0 to 65535, inclusive, and the default is 10. The lowest number represents the most important URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// The unique string that we created to identify the OriginationUrl resource.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^OU[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^OU[0-9a-fA-F]{32}$")]
		public string Sid { get; set; }
		
		/// <summary>
		/// The SIP address you want Twilio to route your Origination calls to. This must be a `sip:` schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sip_url")]
		public string Sip_url { get; set; }
		
		/// <summary>
		/// The SID of the Trunk that owns the Origination URL.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^TK[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trunk_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^TK[0-9a-fA-F]{32}$")]
		public string Trunk_sid { get; set; }
		
		/// <summary>
		/// The absolute URL of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The value that determines the relative share of the load the URI should receive compared to other URIs with the same priority. Can be an integer from 1 to 65535, inclusive, and the default is 10. URLs with higher values receive more load than those with lower ones with the same priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public System.Nullable<System.Int32> Weight { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Trunkingv1trunkphone_number
	{
		
		/// <summary>
		/// The SID of the [Account](https://www.twilio.com/docs/iam/api/account) that created the PhoneNumber resource.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^AC[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^AC[0-9a-fA-F]{32}$")]
		public string Account_sid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="address_requirements")]
		public Phone_number_enum_address_requirement Address_requirements { get; set; }
		
		/// <summary>
		/// The API version used to start a new TwiML session.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="api_version")]
		public string Api_version { get; set; }
		
		/// <summary>
		/// Whether the phone number is new to the Twilio platform. Can be: `true` or `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="beta")]
		public System.Nullable<System.Boolean> Beta { get; set; }
		
		/// <summary>
		/// The set of Boolean properties that indicate whether a phone number can receive calls or messages.  Capabilities are  `Voice`, `SMS`, and `MMS` and each capability can be: `true` or `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capabilities")]
		public string Capabilities { get; set; }
		
		/// <summary>
		/// The date and time in GMT when the resource was created specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_created")]
		public System.Nullable<System.DateTimeOffset> Date_created { get; set; }
		
		/// <summary>
		/// The date and time in GMT when the resource was last updated specified in [RFC 2822](https://www.ietf.org/rfc/rfc2822.txt) format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="date_updated")]
		public System.Nullable<System.DateTimeOffset> Date_updated { get; set; }
		
		/// <summary>
		/// The string that you assigned to describe the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friendly_name")]
		public string Friendly_name { get; set; }
		
		/// <summary>
		/// The URLs of related resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public string Links { get; set; }
		
		/// <summary>
		/// The phone number in [E.164](https://www.twilio.com/docs/glossary/what-e164) format, which consists of a + followed by the country code and subscriber number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phone_number")]
		public string Phone_number { get; set; }
		
		/// <summary>
		/// The unique string that we created to identify the PhoneNumber resource.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^PN[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^PN[0-9a-fA-F]{32}$")]
		public string Sid { get; set; }
		
		/// <summary>
		/// The SID of the application that handles SMS messages sent to the phone number. If an `sms_application_sid` is present, we ignore all `sms_*_url` values and use those of the application.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^AP[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sms_application_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^AP[0-9a-fA-F]{32}$")]
		public string Sms_application_sid { get; set; }
		
		/// <summary>
		/// The HTTP method we use to call `sms_fallback_url`. Can be: `GET` or `POST`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sms_fallback_method")]
		public Trunkingv1trunkDisaster_recovery_method Sms_fallback_method { get; set; }
		
		/// <summary>
		/// The URL that we call using the `sms_fallback_method` when an error occurs while retrieving or executing the TwiML from `sms_url`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sms_fallback_url")]
		public string Sms_fallback_url { get; set; }
		
		/// <summary>
		/// The HTTP method we use to call `sms_url`. Can be: `GET` or `POST`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sms_method")]
		public Trunkingv1trunkDisaster_recovery_method Sms_method { get; set; }
		
		/// <summary>
		/// The URL we call using the `sms_method` when the phone number receives an incoming SMS message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sms_url")]
		public string Sms_url { get; set; }
		
		/// <summary>
		/// The URL we call using the `status_callback_method` to send status information to your application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status_callback")]
		public string Status_callback { get; set; }
		
		/// <summary>
		/// The HTTP method we use to call `status_callback`. Can be: `GET` or `POST`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status_callback_method")]
		public Trunkingv1trunkDisaster_recovery_method Status_callback_method { get; set; }
		
		/// <summary>
		/// The SID of the Trunk that handles calls to the phone number. If a `trunk_sid` is present, we ignore all of the voice URLs and voice applications and use those set on the Trunk. Setting a `trunk_sid` will automatically delete your `voice_application_sid` and vice versa.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^TK[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trunk_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^TK[0-9a-fA-F]{32}$")]
		public string Trunk_sid { get; set; }
		
		/// <summary>
		/// The absolute URL of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The SID of the application that handles calls to the phone number. If a `voice_application_sid` is present, we ignore all of the voice URLs and use those set on the application. Setting a `voice_application_sid` will automatically delete your `trunk_sid` and vice versa.
		/// Max length: 34
		/// Min length: 34
		/// Pattern: ^AP[0-9a-fA-F]{32}$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voice_application_sid")]
		[System.ComponentModel.DataAnnotations.MinLength(34)]
		[System.ComponentModel.DataAnnotations.MaxLength(34)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^AP[0-9a-fA-F]{32}$")]
		public string Voice_application_sid { get; set; }
		
		/// <summary>
		/// Whether we look up the caller's caller-ID name from the CNAM database ($0.01 per look up). Can be: `true` or `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voice_caller_id_lookup")]
		public System.Nullable<System.Boolean> Voice_caller_id_lookup { get; set; }
		
		/// <summary>
		/// The HTTP method that we use to call `voice_fallback_url`. Can be: `GET` or `POST`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voice_fallback_method")]
		public Trunkingv1trunkDisaster_recovery_method Voice_fallback_method { get; set; }
		
		/// <summary>
		/// The URL that we call using the `voice_fallback_method` when an error occurs retrieving or executing the TwiML requested by `url`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voice_fallback_url")]
		public string Voice_fallback_url { get; set; }
		
		/// <summary>
		/// The HTTP method we use to call `voice_url`. Can be: `GET` or `POST`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voice_method")]
		public Trunkingv1trunkDisaster_recovery_method Voice_method { get; set; }
		
		/// <summary>
		/// The URL we call using the `voice_method` when the phone number receives a call. The `voice_url` is not be used if a `voice_application_sid` or a `trunk_sid` is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voice_url")]
		public string Voice_url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Trunkingv1trunkrecording
	{
		
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<Trunkingv1trunkrecordingMode> Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trim")]
		public System.Nullable<Trunkingv1trunkrecordingTrim> Trim { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Trunkingv1trunkrecordingMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="do-not-record")]
		doMinusnotMinusrecord = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="record-from-ringing")]
		recordMinusfromMinusringing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="record-from-answer")]
		recordMinusfromMinusanswer = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="record-from-ringing-dual")]
		recordMinusfromMinusringingMinusdual = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="record-from-answer-dual")]
		recordMinusfromMinusanswerMinusdual = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Trunkingv1trunkrecordingTrim
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="trim-silence")]
		trimMinussilence = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="do-not-trim")]
		doMinusnotMinustrim = 1,
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// ListTrunk v1/Trunks
		/// </summary>
		/// <param name="PageSize">How many resources to return in each list page. The default is 50, and the maximum is 1000.</param>
		/// <param name="Page">The page index. This value is simply for client state.</param>
		/// <param name="PageToken">The page token. This is provided by the API.</param>
		/// <returns>OK</returns>
		public async Task<ListTrunkReturn> ListTrunkAsync(int PageSize, int Page, string PageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks?PageSize="+PageSize+"&Page="+Page+"&PageToken=" + (PageToken==null? "" : System.Uri.EscapeDataString(PageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTrunkReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// DeleteTrunk v1/Trunks/{Sid}
		/// </summary>
		/// <param name="Sid">The unique string that we created to identify the Trunk resource to delete.</param>
		public async Task DeleteTrunkAsync(string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// FetchTrunk v1/Trunks/{Sid}
		/// </summary>
		/// <param name="Sid">The unique string that we created to identify the Trunk resource to fetch.</param>
		/// <returns>OK</returns>
		public async Task<Trunkingv1trunk> FetchTrunkAsync(string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Trunkingv1trunk>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// ListCredentialList v1/Trunks/{TrunkSid}/CredentialLists
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to read the credential lists.</param>
		/// <param name="PageSize">How many resources to return in each list page. The default is 50, and the maximum is 1000.</param>
		/// <param name="Page">The page index. This value is simply for client state.</param>
		/// <param name="PageToken">The page token. This is provided by the API.</param>
		/// <returns>OK</returns>
		public async Task<ListCredentialListReturn> ListCredentialListAsync(string TrunkSid, int PageSize, int Page, string PageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/CredentialLists&PageSize="+PageSize+"&Page="+Page+"&PageToken=" + (PageToken==null? "" : System.Uri.EscapeDataString(PageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListCredentialListReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// DeleteCredentialList v1/Trunks/{TrunkSid}/CredentialLists/{Sid}
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to delete the credential list.</param>
		/// <param name="Sid">The unique string that we created to identify the CredentialList resource to delete.</param>
		public async Task DeleteCredentialListAsync(string TrunkSid, string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/CredentialLists/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// FetchCredentialList v1/Trunks/{TrunkSid}/CredentialLists/{Sid}
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to fetch the credential list.</param>
		/// <param name="Sid">The unique string that we created to identify the CredentialList resource to fetch.</param>
		/// <returns>OK</returns>
		public async Task<Trunkingv1trunkcredential_list> FetchCredentialListAsync(string TrunkSid, string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/CredentialLists/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Trunkingv1trunkcredential_list>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all IP Access Control Lists for a Trunk
		/// ListIpAccessControlList v1/Trunks/{TrunkSid}/IpAccessControlLists
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to read the IP Access Control Lists.</param>
		/// <param name="PageSize">How many resources to return in each list page. The default is 50, and the maximum is 1000.</param>
		/// <param name="Page">The page index. This value is simply for client state.</param>
		/// <param name="PageToken">The page token. This is provided by the API.</param>
		/// <returns>OK</returns>
		public async Task<ListIpAccessControlListReturn> ListIpAccessControlListAsync(string TrunkSid, int PageSize, int Page, string PageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/IpAccessControlLists&PageSize="+PageSize+"&Page="+Page+"&PageToken=" + (PageToken==null? "" : System.Uri.EscapeDataString(PageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListIpAccessControlListReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove an associated IP Access Control List from a Trunk
		/// DeleteIpAccessControlList v1/Trunks/{TrunkSid}/IpAccessControlLists/{Sid}
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to delete the IP Access Control List.</param>
		/// <param name="Sid">The unique string that we created to identify the IpAccessControlList resource to delete.</param>
		public async Task DeleteIpAccessControlListAsync(string TrunkSid, string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/IpAccessControlLists/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// FetchIpAccessControlList v1/Trunks/{TrunkSid}/IpAccessControlLists/{Sid}
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to fetch the IP Access Control List.</param>
		/// <param name="Sid">The unique string that we created to identify the IpAccessControlList resource to fetch.</param>
		/// <returns>OK</returns>
		public async Task<Trunkingv1trunkip_access_control_list> FetchIpAccessControlListAsync(string TrunkSid, string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/IpAccessControlLists/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Trunkingv1trunkip_access_control_list>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// ListOriginationUrl v1/Trunks/{TrunkSid}/OriginationUrls
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to read the OriginationUrl.</param>
		/// <param name="PageSize">How many resources to return in each list page. The default is 50, and the maximum is 1000.</param>
		/// <param name="Page">The page index. This value is simply for client state.</param>
		/// <param name="PageToken">The page token. This is provided by the API.</param>
		/// <returns>OK</returns>
		public async Task<ListOriginationUrlReturn> ListOriginationUrlAsync(string TrunkSid, int PageSize, int Page, string PageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/OriginationUrls&PageSize="+PageSize+"&Page="+Page+"&PageToken=" + (PageToken==null? "" : System.Uri.EscapeDataString(PageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListOriginationUrlReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// DeleteOriginationUrl v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to delete the OriginationUrl.</param>
		/// <param name="Sid">The unique string that we created to identify the OriginationUrl resource to delete.</param>
		public async Task DeleteOriginationUrlAsync(string TrunkSid, string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/OriginationUrls/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// FetchOriginationUrl v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to fetch the OriginationUrl.</param>
		/// <param name="Sid">The unique string that we created to identify the OriginationUrl resource to fetch.</param>
		/// <returns>OK</returns>
		public async Task<Trunkingv1trunkorigination_url> FetchOriginationUrlAsync(string TrunkSid, string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/OriginationUrls/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Trunkingv1trunkorigination_url>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// ListPhoneNumber v1/Trunks/{TrunkSid}/PhoneNumbers
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to read the PhoneNumber resources.</param>
		/// <param name="PageSize">How many resources to return in each list page. The default is 50, and the maximum is 1000.</param>
		/// <param name="Page">The page index. This value is simply for client state.</param>
		/// <param name="PageToken">The page token. This is provided by the API.</param>
		/// <returns>OK</returns>
		public async Task<ListPhoneNumberReturn> ListPhoneNumberAsync(string TrunkSid, int PageSize, int Page, string PageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/PhoneNumbers&PageSize="+PageSize+"&Page="+Page+"&PageToken=" + (PageToken==null? "" : System.Uri.EscapeDataString(PageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListPhoneNumberReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// DeletePhoneNumber v1/Trunks/{TrunkSid}/PhoneNumbers/{Sid}
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to delete the PhoneNumber resource.</param>
		/// <param name="Sid">The unique string that we created to identify the PhoneNumber resource to delete.</param>
		public async Task DeletePhoneNumberAsync(string TrunkSid, string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/PhoneNumbers/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// FetchPhoneNumber v1/Trunks/{TrunkSid}/PhoneNumbers/{Sid}
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to fetch the PhoneNumber resource.</param>
		/// <param name="Sid">The unique string that we created to identify the PhoneNumber resource to fetch.</param>
		/// <returns>OK</returns>
		public async Task<Trunkingv1trunkphone_number> FetchPhoneNumberAsync(string TrunkSid, string Sid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/PhoneNumbers/"+ (Sid==null? "" : System.Uri.EscapeDataString(Sid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Trunkingv1trunkphone_number>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// FetchRecording v1/Trunks/{TrunkSid}/Recording
		/// </summary>
		/// <param name="TrunkSid">The SID of the Trunk from which to fetch the recording settings.</param>
		/// <returns>OK</returns>
		public async Task<Trunkingv1trunkrecording> FetchRecordingAsync(string TrunkSid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/Trunks/"+ (TrunkSid==null? "" : System.Uri.EscapeDataString(TrunkSid))+"/Recording";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Trunkingv1trunkrecording>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class ListTrunkReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ListTrunkReturnMeta Meta { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="trunks")]
		public Trunkingv1trunk[] Trunks { get; set; }
	}
	
	public class ListTrunkReturnMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="first_page_url")]
		public string First_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_page_url")]
		public string Next_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public System.Nullable<System.Int32> Page_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_page_url")]
		public string Previous_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ListCredentialListReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="credential_lists")]
		public Trunkingv1trunkcredential_list[] Credential_lists { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ListCredentialListReturnMeta Meta { get; set; }
	}
	
	public class ListCredentialListReturnMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="first_page_url")]
		public string First_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_page_url")]
		public string Next_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public System.Nullable<System.Int32> Page_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_page_url")]
		public string Previous_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ListIpAccessControlListReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="ip_access_control_lists")]
		public Trunkingv1trunkip_access_control_list[] Ip_access_control_lists { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ListIpAccessControlListReturnMeta Meta { get; set; }
	}
	
	public class ListIpAccessControlListReturnMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="first_page_url")]
		public string First_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_page_url")]
		public string Next_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public System.Nullable<System.Int32> Page_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_page_url")]
		public string Previous_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ListOriginationUrlReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ListOriginationUrlReturnMeta Meta { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="origination_urls")]
		public Trunkingv1trunkorigination_url[] Origination_urls { get; set; }
	}
	
	public class ListOriginationUrlReturnMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="first_page_url")]
		public string First_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_page_url")]
		public string Next_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public System.Nullable<System.Int32> Page_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_page_url")]
		public string Previous_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	public class ListPhoneNumberReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ListPhoneNumberReturnMeta Meta { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="phone_numbers")]
		public Trunkingv1trunkphone_number[] Phone_numbers { get; set; }
	}
	
	public class ListPhoneNumberReturnMeta
	{
		
		[System.Runtime.Serialization.DataMember(Name="first_page_url")]
		public string First_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="next_page_url")]
		public string Next_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="page_size")]
		public System.Nullable<System.Int32> Page_size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="previous_page_url")]
		public string Previous_page_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
