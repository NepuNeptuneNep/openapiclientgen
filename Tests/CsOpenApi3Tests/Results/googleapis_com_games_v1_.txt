//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// An achievement definition object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AchievementDefinition
	{
		
		/// <summary>
		/// The type of the achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="achievementType")]
		public System.Nullable<AchievementDefinitionAchievementType> AchievementType { get; set; }
		
		/// <summary>
		/// The description of the achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Experience points which will be earned when unlocking this achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="experiencePoints")]
		public string ExperiencePoints { get; set; }
		
		/// <summary>
		/// The total steps for an incremental achievement as a string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formattedTotalSteps")]
		public string FormattedTotalSteps { get; set; }
		
		/// <summary>
		/// The ID of the achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The initial state of the achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="initialState")]
		public System.Nullable<AchievementDefinitionInitialState> InitialState { get; set; }
		
		/// <summary>
		/// Indicates whether the revealed icon image being returned is a default image, or is provided by the game.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isRevealedIconUrlDefault")]
		public System.Nullable<System.Boolean> IsRevealedIconUrlDefault { get; set; }
		
		/// <summary>
		/// Indicates whether the unlocked icon image being returned is a default image, or is game-provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isUnlockedIconUrlDefault")]
		public System.Nullable<System.Boolean> IsUnlockedIconUrlDefault { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#achievementDefinition`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The name of the achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The image URL for the revealed achievement icon.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="revealedIconUrl")]
		public string RevealedIconUrl { get; set; }
		
		/// <summary>
		/// The total steps for an incremental achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalSteps")]
		public System.Nullable<System.Int32> TotalSteps { get; set; }
		
		/// <summary>
		/// The image URL for the unlocked achievement icon.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unlockedIconUrl")]
		public string UnlockedIconUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AchievementDefinitionAchievementType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCREMENTAL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AchievementDefinitionInitialState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIDDEN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVEALED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNLOCKED = 2,
	}
	
	/// <summary>
	/// A list of achievement definition objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AchievementDefinitionsListResponse
	{
		
		/// <summary>
		/// The achievement definitions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public AchievementDefinition[] Items { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#achievementDefinitionsListResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token corresponding to the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// An achievement increment response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AchievementIncrementResponse
	{
		
		/// <summary>
		/// The current steps recorded for this incremental achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentSteps")]
		public System.Nullable<System.Int32> CurrentSteps { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#achievementIncrementResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Whether the current steps for the achievement has reached the number of steps required to unlock.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newlyUnlocked")]
		public System.Nullable<System.Boolean> NewlyUnlocked { get; set; }
	}
	
	/// <summary>
	/// An achievement reveal response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AchievementRevealResponse
	{
		
		/// <summary>
		/// The current state of the achievement for which a reveal was attempted. This might be `UNLOCKED` if the achievement was already unlocked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentState")]
		public System.Nullable<AchievementRevealResponseCurrentState> CurrentState { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#achievementRevealResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AchievementRevealResponseCurrentState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVEALED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNLOCKED = 1,
	}
	
	/// <summary>
	/// An achievement set steps at least response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AchievementSetStepsAtLeastResponse
	{
		
		/// <summary>
		/// The current steps recorded for this incremental achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentSteps")]
		public System.Nullable<System.Int32> CurrentSteps { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#achievementSetStepsAtLeastResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Whether the current steps for the achievement has reached the number of steps required to unlock.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newlyUnlocked")]
		public System.Nullable<System.Boolean> NewlyUnlocked { get; set; }
	}
	
	/// <summary>
	/// An achievement unlock response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AchievementUnlockResponse
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#achievementUnlockResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Whether this achievement was newly unlocked (that is, whether the unlock request for the achievement was the first for the player).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newlyUnlocked")]
		public System.Nullable<System.Boolean> NewlyUnlocked { get; set; }
	}
	
	/// <summary>
	/// A list of achievement update requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AchievementUpdateMultipleRequest
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#achievementUpdateMultipleRequest`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The individual achievement update requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updates")]
		public AchievementUpdateRequest[] Updates { get; set; }
	}
	
	/// <summary>
	/// A request to update an achievement.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AchievementUpdateRequest
	{
		
		/// <summary>
		/// The achievement this update is being applied to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="achievementId")]
		public string AchievementId { get; set; }
		
		/// <summary>
		/// The payload to request to increment an achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="incrementPayload")]
		public GamesAchievementIncrement IncrementPayload { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#achievementUpdateRequest`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The payload to request to increment an achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="setStepsAtLeastPayload")]
		public GamesAchievementSetStepsAtLeast SetStepsAtLeastPayload { get; set; }
		
		/// <summary>
		/// The type of update being applied.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateType")]
		public System.Nullable<AchievementUpdateRequestUpdateType> UpdateType { get; set; }
	}
	
	/// <summary>
	/// The payload to request to increment an achievement.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GamesAchievementIncrement
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#GamesAchievementIncrement`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The requestId associated with an increment to an achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestId")]
		public string RequestId { get; set; }
		
		/// <summary>
		/// The number of steps to be incremented.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="steps")]
		public System.Nullable<System.Int32> Steps { get; set; }
	}
	
	/// <summary>
	/// The payload to request to increment an achievement.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GamesAchievementSetStepsAtLeast
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#GamesAchievementSetStepsAtLeast`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The minimum number of steps for the achievement to be set to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="steps")]
		public System.Nullable<System.Int32> Steps { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AchievementUpdateRequestUpdateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVEAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNLOCK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCREMENT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SET_STEPS_AT_LEAST = 3,
	}
	
	/// <summary>
	/// Response message for UpdateMultipleAchievements rpc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AchievementUpdateMultipleResponse
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#achievementUpdateMultipleResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The updated state of the achievements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updatedAchievements")]
		public AchievementUpdateResponse[] UpdatedAchievements { get; set; }
	}
	
	/// <summary>
	/// An updated achievement.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AchievementUpdateResponse
	{
		
		/// <summary>
		/// The achievement this update is was applied to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="achievementId")]
		public string AchievementId { get; set; }
		
		/// <summary>
		/// The current state of the achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentState")]
		public AchievementDefinitionInitialState CurrentState { get; set; }
		
		/// <summary>
		/// The current steps recorded for this achievement if it is incremental.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentSteps")]
		public System.Nullable<System.Int32> CurrentSteps { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#achievementUpdateResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Whether this achievement was newly unlocked (that is, whether the unlock request for the achievement was the first for the player).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newlyUnlocked")]
		public System.Nullable<System.Boolean> NewlyUnlocked { get; set; }
		
		/// <summary>
		/// Whether the requested updates actually affected the achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateOccurred")]
		public System.Nullable<System.Boolean> UpdateOccurred { get; set; }
	}
	
	/// <summary>
	/// The Application resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Application
	{
		
		/// <summary>
		/// The number of achievements visible to the currently authenticated player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="achievement_count")]
		public System.Nullable<System.Int32> Achievement_count { get; set; }
		
		/// <summary>
		/// The assets of the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assets")]
		public ImageAsset[] Assets { get; set; }
		
		/// <summary>
		/// The author of the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author")]
		public string Author { get; set; }
		
		/// <summary>
		/// An application category object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public ApplicationCategory Category { get; set; }
		
		/// <summary>
		/// The description of the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// A list of features that have been enabled for the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabledFeatures")]
		public string[] EnabledFeatures { get; set; }
		
		/// <summary>
		/// The ID of the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The instances of the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public Instance[] Instances { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#application`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The last updated timestamp of the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedTimestamp")]
		public string LastUpdatedTimestamp { get; set; }
		
		/// <summary>
		/// The number of leaderboards visible to the currently authenticated player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="leaderboard_count")]
		public System.Nullable<System.Int32> Leaderboard_count { get; set; }
		
		/// <summary>
		/// The name of the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A hint to the client UI for what color to use as an app-themed color. The color is given as an RGB triplet (e.g. "E0E0E0").
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="themeColor")]
		public string ThemeColor { get; set; }
	}
	
	/// <summary>
	/// An image asset object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageAsset
	{
		
		/// <summary>
		/// The height of the asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#imageAsset`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The name of the asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The URL of the asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The width of the asset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	/// <summary>
	/// An application category object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApplicationCategory
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#applicationCategory`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The primary category.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primary")]
		public string Primary { get; set; }
		
		/// <summary>
		/// The secondary category.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondary")]
		public string Secondary { get; set; }
	}
	
	/// <summary>
	/// The Instance resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Instance
	{
		
		/// <summary>
		/// URI which shows where a user can acquire this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acquisitionUri")]
		public string AcquisitionUri { get; set; }
		
		/// <summary>
		/// The Android instance details resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="androidInstance")]
		public InstanceAndroidDetails AndroidInstance { get; set; }
		
		/// <summary>
		/// The iOS details resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iosInstance")]
		public InstanceIosDetails IosInstance { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#instance`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Localized display name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The platform type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platformType")]
		public System.Nullable<InstancePlatformType> PlatformType { get; set; }
		
		/// <summary>
		/// Flag to show if this game instance supports realtime play.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="realtimePlay")]
		public System.Nullable<System.Boolean> RealtimePlay { get; set; }
		
		/// <summary>
		/// Flag to show if this game instance supports turn based play.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="turnBasedPlay")]
		public System.Nullable<System.Boolean> TurnBasedPlay { get; set; }
		
		/// <summary>
		/// The Web details resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="webInstance")]
		public InstanceWebDetails WebInstance { get; set; }
	}
	
	/// <summary>
	/// The Android instance details resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceAndroidDetails
	{
		
		/// <summary>
		/// Flag indicating whether the anti-piracy check is enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enablePiracyCheck")]
		public System.Nullable<System.Boolean> EnablePiracyCheck { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#instanceAndroidDetails`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Android package name which maps to Google Play URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="packageName")]
		public string PackageName { get; set; }
		
		/// <summary>
		/// Indicates that this instance is the default for new installations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferred")]
		public System.Nullable<System.Boolean> Preferred { get; set; }
	}
	
	/// <summary>
	/// The iOS details resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceIosDetails
	{
		
		/// <summary>
		/// Bundle identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bundleIdentifier")]
		public string BundleIdentifier { get; set; }
		
		/// <summary>
		/// iTunes App ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="itunesAppId")]
		public string ItunesAppId { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#instanceIosDetails`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Indicates that this instance is the default for new installations on iPad devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferredForIpad")]
		public System.Nullable<System.Boolean> PreferredForIpad { get; set; }
		
		/// <summary>
		/// Indicates that this instance is the default for new installations on iPhone devices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferredForIphone")]
		public System.Nullable<System.Boolean> PreferredForIphone { get; set; }
		
		/// <summary>
		/// Flag to indicate if this instance supports iPad.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportIpad")]
		public System.Nullable<System.Boolean> SupportIpad { get; set; }
		
		/// <summary>
		/// Flag to indicate if this instance supports iPhone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportIphone")]
		public System.Nullable<System.Boolean> SupportIphone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstancePlatformType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANDROID = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IOS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEB_APP = 2,
	}
	
	/// <summary>
	/// The Web details resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceWebDetails
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#instanceWebDetails`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Launch URL for the game.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="launchUrl")]
		public string LaunchUrl { get; set; }
		
		/// <summary>
		/// Indicates that this instance is the default for new installations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preferred")]
		public System.Nullable<System.Boolean> Preferred { get; set; }
	}
	
	/// <summary>
	/// Primary scoped player identifier for an application.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApplicationPlayerId
	{
		
		/// <summary>
		/// The application that this player identifier is for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applicationId")]
		public string ApplicationId { get; set; }
		
		/// <summary>
		/// The player identifier for the application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playerId")]
		public string PlayerId { get; set; }
	}
	
	/// <summary>
	/// A third party application verification response resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApplicationVerifyResponse
	{
		
		/// <summary>
		/// An alternate ID that was once used for the player that was issued the auth token used in this request. (This field is not normally populated.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alternate_player_id")]
		public string Alternate_player_id { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#applicationVerifyResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The ID of the player that was issued the auth token used in this request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player_id")]
		public string Player_id { get; set; }
	}
	
	/// <summary>
	/// Data related to individual game categories.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Category
	{
		
		/// <summary>
		/// The category name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category1 { get; set; }
		
		/// <summary>
		/// Experience points earned in this category.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="experiencePoints")]
		public string ExperiencePoints { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#category`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	/// <summary>
	/// A third party list metagame categories response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CategoryListResponse
	{
		
		/// <summary>
		/// The list of categories with usage data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Category[] Items { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#categoryListResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token corresponding to the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Container for a URL end point of the requested type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EndPoint
	{
		
		/// <summary>
		/// A URL suitable for loading in a web browser for the requested endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// A batch update failure resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventBatchRecordFailure
	{
		
		/// <summary>
		/// The cause for the update failure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failureCause")]
		public System.Nullable<EventBatchRecordFailureFailureCause> FailureCause { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#eventBatchRecordFailure`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// An event period time range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="range")]
		public EventPeriodRange Range { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventBatchRecordFailureFailureCause
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOO_LARGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIME_PERIOD_EXPIRED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIME_PERIOD_SHORT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIME_PERIOD_LONG = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALREADY_UPDATED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECORD_RATE_HIGH = 5,
	}
	
	/// <summary>
	/// An event period time range.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventPeriodRange
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#eventPeriodRange`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The time when this update period ends, in millis, since 1970 UTC (Unix Epoch).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="periodEndMillis")]
		public string PeriodEndMillis { get; set; }
		
		/// <summary>
		/// The time when this update period begins, in millis, since 1970 UTC (Unix Epoch).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="periodStartMillis")]
		public string PeriodStartMillis { get; set; }
	}
	
	/// <summary>
	/// An event child relationship resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventChild
	{
		
		/// <summary>
		/// The ID of the child event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childId")]
		public string ChildId { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#eventChild`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	/// <summary>
	/// An event definition resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventDefinition
	{
		
		/// <summary>
		/// A list of events that are a child of this event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="childEvents")]
		public EventChild[] ChildEvents { get; set; }
		
		/// <summary>
		/// Description of what this event represents.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The name to display for the event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The ID of the event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The base URL for the image that represents the event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageUrl")]
		public string ImageUrl { get; set; }
		
		/// <summary>
		/// Indicates whether the icon image being returned is a default image, or is game-provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isDefaultImageUrl")]
		public System.Nullable<System.Boolean> IsDefaultImageUrl { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#eventDefinition`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The visibility of event being tracked in this definition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibility")]
		public System.Nullable<EventDefinitionVisibility> Visibility { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventDefinitionVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVEALED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIDDEN = 1,
	}
	
	/// <summary>
	/// A ListDefinitions response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventDefinitionListResponse
	{
		
		/// <summary>
		/// The event definitions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public EventDefinition[] Items { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#eventDefinitionListResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The pagination token for the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// An event period update resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventPeriodUpdate
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#eventPeriodUpdate`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// An event period time range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timePeriod")]
		public EventPeriodRange TimePeriod { get; set; }
		
		/// <summary>
		/// The updates being made for this time period.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updates")]
		public EventUpdateRequest[] Updates { get; set; }
	}
	
	/// <summary>
	/// An event period update resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventUpdateRequest
	{
		
		/// <summary>
		/// The ID of the event being modified in this update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="definitionId")]
		public string DefinitionId { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#eventUpdateRequest`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The number of times this event occurred in this time period.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateCount")]
		public string UpdateCount { get; set; }
	}
	
	/// <summary>
	/// An event update failure resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventRecordFailure
	{
		
		/// <summary>
		/// The ID of the event that was not updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventId")]
		public string EventId { get; set; }
		
		/// <summary>
		/// The cause for the update failure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failureCause")]
		public System.Nullable<EventRecordFailureFailureCause> FailureCause { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#eventRecordFailure`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum EventRecordFailureFailureCause
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_FOUND = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_UPDATE_VALUE = 1,
	}
	
	/// <summary>
	/// An event period update resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventRecordRequest
	{
		
		/// <summary>
		/// The current time when this update was sent, in milliseconds, since 1970 UTC (Unix Epoch).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentTimeMillis")]
		public string CurrentTimeMillis { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#eventRecordRequest`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The request ID used to identify this attempt to record events.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestId")]
		public string RequestId { get; set; }
		
		/// <summary>
		/// A list of the time period updates being made in this request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timePeriods")]
		public EventPeriodUpdate[] TimePeriods { get; set; }
	}
	
	/// <summary>
	/// An event period update resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventUpdateResponse
	{
		
		/// <summary>
		/// Any batch-wide failures which occurred applying updates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="batchFailures")]
		public EventBatchRecordFailure[] BatchFailures { get; set; }
		
		/// <summary>
		/// Any failures updating a particular event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventFailures")]
		public EventRecordFailure[] EventFailures { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#eventUpdateResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The current status of any updated events
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playerEvents")]
		public PlayerEvent[] PlayerEvents { get; set; }
	}
	
	/// <summary>
	/// An event status resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerEvent
	{
		
		/// <summary>
		/// The ID of the event definition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="definitionId")]
		public string DefinitionId { get; set; }
		
		/// <summary>
		/// The current number of times this event has occurred, as a string. The formatting of this string depends on the configuration of your event in the Play Games Developer Console.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formattedNumEvents")]
		public string FormattedNumEvents { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerEvent`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The current number of times this event has occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numEvents")]
		public string NumEvents { get; set; }
		
		/// <summary>
		/// The ID of the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playerId")]
		public string PlayerId { get; set; }
	}
	
	/// <summary>
	/// Response message for GetMultipleApplicationPlayerIds rpc.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetMultipleApplicationPlayerIdsResponse
	{
		
		/// <summary>
		/// Output only. The requested applications along with the scoped ids for tha player, if that player has an id for the application. If not, the application is not included in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playerIds")]
		public ApplicationPlayerId[] PlayerIds { get; set; }
	}
	
	/// <summary>
	/// The Leaderboard resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Leaderboard
	{
		
		/// <summary>
		/// The icon for the leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iconUrl")]
		public string IconUrl { get; set; }
		
		/// <summary>
		/// The leaderboard ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Indicates whether the icon image being returned is a default image, or is game-provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isIconUrlDefault")]
		public System.Nullable<System.Boolean> IsIconUrlDefault { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#leaderboard`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The name of the leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// How scores are ordered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="order")]
		public System.Nullable<LeaderboardOrder> Order { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LeaderboardOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LARGER_IS_BETTER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SMALLER_IS_BETTER = 1,
	}
	
	/// <summary>
	/// The Leaderboard Entry resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LeaderboardEntry
	{
		
		/// <summary>
		/// The localized string for the numerical value of this score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formattedScore")]
		public string FormattedScore { get; set; }
		
		/// <summary>
		/// The localized string for the rank of this score for this leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formattedScoreRank")]
		public string FormattedScoreRank { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#leaderboardEntry`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// A Player resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player")]
		public Player Player { get; set; }
		
		/// <summary>
		/// The rank of this score for this leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scoreRank")]
		public string ScoreRank { get; set; }
		
		/// <summary>
		/// Additional information about the score. Values must contain no more than 64 URI-safe characters as defined by section 2.3 of RFC 3986.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scoreTag")]
		public string ScoreTag { get; set; }
		
		/// <summary>
		/// The numerical value of this score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scoreValue")]
		public string ScoreValue { get; set; }
		
		/// <summary>
		/// The time span of this high score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSpan")]
		public System.Nullable<LeaderboardEntryTimeSpan> TimeSpan { get; set; }
		
		/// <summary>
		/// The timestamp at which this score was recorded, in milliseconds since the epoch in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="writeTimestampMillis")]
		public string WriteTimestampMillis { get; set; }
	}
	
	/// <summary>
	/// A Player resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Player
	{
		
		/// <summary>
		/// The base URL for the image that represents the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avatarImageUrl")]
		public string AvatarImageUrl { get; set; }
		
		/// <summary>
		/// The url to the landscape mode player banner image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bannerUrlLandscape")]
		public string BannerUrlLandscape { get; set; }
		
		/// <summary>
		/// The url to the portrait mode player banner image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bannerUrlPortrait")]
		public string BannerUrlPortrait { get; set; }
		
		/// <summary>
		/// The name to display for the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// 1P/3P metadata about the player's experience.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="experienceInfo")]
		public PlayerExperienceInfo ExperienceInfo { get; set; }
		
		/// <summary>
		/// The friend status of the given player, relative to the requester. This is unset if the player is not sharing their friends list with the game.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friendStatus")]
		public System.Nullable<PlayerFriendStatus> FriendStatus { get; set; }
		
		/// <summary>
		/// Per-application unique player identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gamePlayerId")]
		public string GamePlayerId { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#player`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// A representation of the individual components of the name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public PlayerName Name { get; set; }
		
		/// <summary>
		/// The player ID that was used for this player the first time they signed into the game in question. This is only populated for calls to player.get for the requesting player, only if the player ID has subsequently changed, and only to clients that support remapping player IDs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="originalPlayerId")]
		public string OriginalPlayerId { get; set; }
		
		/// <summary>
		/// The ID of the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playerId")]
		public string PlayerId { get; set; }
		
		/// <summary>
		/// Profile settings
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileSettings")]
		public ProfileSettings ProfileSettings { get; set; }
		
		/// <summary>
		/// The player's title rewarded for their game activities.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// 1P/3P metadata about the player's experience.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerExperienceInfo
	{
		
		/// <summary>
		/// The current number of experience points for the player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentExperiencePoints")]
		public string CurrentExperiencePoints { get; set; }
		
		/// <summary>
		/// 1P/3P metadata about a user's level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentLevel")]
		public PlayerLevel CurrentLevel { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerExperienceInfo`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The timestamp when the player was leveled up, in millis since Unix epoch UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastLevelUpTimestampMillis")]
		public string LastLevelUpTimestampMillis { get; set; }
		
		/// <summary>
		/// 1P/3P metadata about a user's level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextLevel")]
		public PlayerLevel NextLevel { get; set; }
	}
	
	/// <summary>
	/// 1P/3P metadata about a user's level.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerLevel
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerLevel`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The level for the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="level")]
		public System.Nullable<System.Int32> Level { get; set; }
		
		/// <summary>
		/// The maximum experience points for this level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxExperiencePoints")]
		public string MaxExperiencePoints { get; set; }
		
		/// <summary>
		/// The minimum experience points for this level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minExperiencePoints")]
		public string MinExperiencePoints { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PlayerFriendStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_RELATIONSHIP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FRIEND = 1,
	}
	
	public class PlayerName
	{
		
		/// <summary>
		/// The family name of this player. In some places, this is known as the last name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="familyName")]
		public string FamilyName { get; set; }
		
		/// <summary>
		/// The given name of this player. In some places, this is known as the first name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="givenName")]
		public string GivenName { get; set; }
	}
	
	/// <summary>
	/// Profile settings
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProfileSettings
	{
		
		[System.Runtime.Serialization.DataMember(Name="friendsListVisibility")]
		public System.Nullable<ProfileSettingsFriendsListVisibility> FriendsListVisibility { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#profileSettings`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Whether the player's profile is visible to the currently signed in player.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profileVisible")]
		public System.Nullable<System.Boolean> ProfileVisible { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ProfileSettingsFriendsListVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VISIBLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REQUEST_REQUIRED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNAVAILABLE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LeaderboardEntryTimeSpan
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_TIME = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEEKLY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DAILY = 2,
	}
	
	/// <summary>
	/// A list of leaderboard objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LeaderboardListResponse
	{
		
		/// <summary>
		/// The leaderboards.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Leaderboard[] Items { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#leaderboardListResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token corresponding to the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A score rank in a leaderboard.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LeaderboardScoreRank
	{
		
		/// <summary>
		/// The number of scores in the leaderboard as a string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formattedNumScores")]
		public string FormattedNumScores { get; set; }
		
		/// <summary>
		/// The rank in the leaderboard as a string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formattedRank")]
		public string FormattedRank { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#leaderboardScoreRank`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The number of scores in the leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numScores")]
		public string NumScores { get; set; }
		
		/// <summary>
		/// The rank in the leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rank")]
		public string Rank { get; set; }
	}
	
	/// <summary>
	/// A ListScores response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LeaderboardScores
	{
		
		/// <summary>
		/// The scores in the leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public LeaderboardEntry[] Items { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#leaderboardScores`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The pagination token for the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The total number of scores in the leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numScores")]
		public string NumScores { get; set; }
		
		/// <summary>
		/// The Leaderboard Entry resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playerScore")]
		public LeaderboardEntry PlayerScore { get; set; }
		
		/// <summary>
		/// The pagination token for the previous page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prevPageToken")]
		public string PrevPageToken { get; set; }
	}
	
	/// <summary>
	/// Request to link an in-game account with a PGS principal (encoded in the session id).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LinkPersonaRequest
	{
		
		/// <summary>
		/// Required. Cardinality constraint to observe when linking a persona to a player in the scope of a game.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cardinalityConstraint")]
		public System.Nullable<LinkPersonaRequestCardinalityConstraint> CardinalityConstraint { get; set; }
		
		/// <summary>
		/// Required. Resolution policy to apply when the linking of a persona to a player would result in violating the specified cardinality constraint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conflictingLinksResolutionPolicy")]
		public System.Nullable<LinkPersonaRequestConflictingLinksResolutionPolicy> ConflictingLinksResolutionPolicy { get; set; }
		
		/// <summary>
		/// Input only. Optional expiration time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expireTime")]
		public string ExpireTime { get; set; }
		
		/// <summary>
		/// Required. Stable identifier of the in-game account. Please refrain from re-using the same persona for different games.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persona")]
		public string Persona { get; set; }
		
		/// <summary>
		/// Required. Opaque server-generated string that encodes all the necessary information to identify the PGS player / Google user and application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sessionId")]
		public string SessionId { get; set; }
		
		/// <summary>
		/// Required. Value of the token to create. Opaque to Play Games and assumed to be non-stable (encrypted with key rotation).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
		
		/// <summary>
		/// Input only. Optional time-to-live.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public string Ttl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LinkPersonaRequestCardinalityConstraint
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONE_PERSONA_TO_ONE_PLAYER = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LinkPersonaRequestConflictingLinksResolutionPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KEEP_EXISTING_LINKS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATE_NEW_LINK = 1,
	}
	
	/// <summary>
	/// Outcome of a persona linking attempt.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LinkPersonaResponse
	{
		
		/// <summary>
		/// Output only. State of a persona linking attempt.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<LinkPersonaResponseState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LinkPersonaResponseState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINK_CREATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PERSONA_OR_PLAYER_ALREADY_LINKED = 1,
	}
	
	/// <summary>
	/// The metagame config resource
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MetagameConfig
	{
		
		/// <summary>
		/// Current version of the metagame configuration data. When this data is updated, the version number will be increased by one.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public System.Nullable<System.Int32> CurrentVersion { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#metagameConfig`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The list of player levels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="playerLevels")]
		public PlayerLevel[] PlayerLevels { get; set; }
	}
	
	/// <summary>
	/// An achievement object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerAchievement
	{
		
		/// <summary>
		/// The state of the achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="achievementState")]
		public AchievementDefinitionInitialState AchievementState { get; set; }
		
		/// <summary>
		/// The current steps for an incremental achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentSteps")]
		public System.Nullable<System.Int32> CurrentSteps { get; set; }
		
		/// <summary>
		/// Experience points earned for the achievement. This field is absent for achievements that have not yet been unlocked and 0 for achievements that have been unlocked by testers but that are unpublished.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="experiencePoints")]
		public string ExperiencePoints { get; set; }
		
		/// <summary>
		/// The current steps for an incremental achievement as a string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formattedCurrentStepsString")]
		public string FormattedCurrentStepsString { get; set; }
		
		/// <summary>
		/// The ID of the achievement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerAchievement`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The timestamp of the last modification to this achievement's state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpdatedTimestamp")]
		public string LastUpdatedTimestamp { get; set; }
	}
	
	/// <summary>
	/// A list of achievement objects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerAchievementListResponse
	{
		
		/// <summary>
		/// The achievements.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public PlayerAchievement[] Items { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerAchievementListResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token corresponding to the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A ListByPlayer response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerEventListResponse
	{
		
		/// <summary>
		/// The player events.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public PlayerEvent[] Items { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerEventListResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The pagination token for the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A player leaderboard score object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerLeaderboardScore
	{
		
		/// <summary>
		/// A score rank in a leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="friendsRank")]
		public LeaderboardScoreRank FriendsRank { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerLeaderboardScore`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The ID of the leaderboard this score is in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="leaderboard_id")]
		public string Leaderboard_id { get; set; }
		
		/// <summary>
		/// A score rank in a leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicRank")]
		public LeaderboardScoreRank PublicRank { get; set; }
		
		/// <summary>
		/// The formatted value of this score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scoreString")]
		public string ScoreString { get; set; }
		
		/// <summary>
		/// Additional information about the score. Values must contain no more than 64 URI-safe characters as defined by section 2.3 of RFC 3986.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scoreTag")]
		public string ScoreTag { get; set; }
		
		/// <summary>
		/// The numerical value of this score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scoreValue")]
		public string ScoreValue { get; set; }
		
		/// <summary>
		/// A score rank in a leaderboard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="socialRank")]
		public LeaderboardScoreRank SocialRank { get; set; }
		
		/// <summary>
		/// The time span of this score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSpan")]
		public LeaderboardEntryTimeSpan TimeSpan { get; set; }
		
		/// <summary>
		/// The timestamp at which this score was recorded, in milliseconds since the epoch in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="writeTimestamp")]
		public string WriteTimestamp { get; set; }
	}
	
	/// <summary>
	/// A list of player leaderboard scores.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerLeaderboardScoreListResponse
	{
		
		/// <summary>
		/// The leaderboard scores.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public PlayerLeaderboardScore[] Items { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerLeaderboardScoreListResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The pagination token for the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A Player resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="player")]
		public Player Player { get; set; }
	}
	
	/// <summary>
	/// A third party player list response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerListResponse
	{
		
		/// <summary>
		/// The players.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Player[] Items { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerListResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token corresponding to the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A player score.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerScore
	{
		
		/// <summary>
		/// The formatted score for this player score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formattedScore")]
		public string FormattedScore { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerScore`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The numerical value for this player score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public string Score { get; set; }
		
		/// <summary>
		/// Additional information about this score. Values will contain no more than 64 URI-safe characters as defined by section 2.3 of RFC 3986.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scoreTag")]
		public string ScoreTag { get; set; }
		
		/// <summary>
		/// The time span for this player score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeSpan")]
		public LeaderboardEntryTimeSpan TimeSpan { get; set; }
	}
	
	/// <summary>
	/// A list of score submission statuses.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerScoreListResponse
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerScoreListResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The score submissions statuses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="submittedScores")]
		public PlayerScoreResponse[] SubmittedScores { get; set; }
	}
	
	/// <summary>
	/// A list of leaderboard entry resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerScoreResponse
	{
		
		/// <summary>
		/// The time spans where the submitted score is better than the existing score for that time span.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="beatenScoreTimeSpans")]
		public LeaderboardEntryTimeSpan[] BeatenScoreTimeSpans { get; set; }
		
		/// <summary>
		/// The formatted value of the submitted score.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formattedScore")]
		public string FormattedScore { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerScoreResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The leaderboard ID that this score was submitted to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="leaderboardId")]
		public string LeaderboardId { get; set; }
		
		/// <summary>
		/// Additional information about this score. Values will contain no more than 64 URI-safe characters as defined by section 2.3 of RFC 3986.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scoreTag")]
		public string ScoreTag { get; set; }
		
		/// <summary>
		/// The scores in time spans that have not been beaten. As an example, the submitted score may be better than the player's `DAILY` score, but not better than the player's scores for the `WEEKLY` or `ALL_TIME` time spans.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unbeatenScores")]
		public PlayerScore[] UnbeatenScores { get; set; }
	}
	
	/// <summary>
	/// A list of score submission requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PlayerScoreSubmissionList
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#playerScoreSubmissionList`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The score submissions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scores")]
		public ScoreSubmission[] Scores { get; set; }
	}
	
	/// <summary>
	/// A request to submit a score to leaderboards.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScoreSubmission
	{
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#scoreSubmission`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The leaderboard this score is being submitted to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="leaderboardId")]
		public string LeaderboardId { get; set; }
		
		/// <summary>
		/// The new score being submitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="score")]
		public string Score { get; set; }
		
		/// <summary>
		/// Additional information about this score. Values will contain no more than 64 URI-safe characters as defined by section 2.3 of RFC 3986.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scoreTag")]
		public string ScoreTag { get; set; }
		
		/// <summary>
		/// Signature Values will contain URI-safe characters as defined by section 2.3 of RFC 3986.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
	}
	
	/// <summary>
	/// Recall token data returned from RetrievePlayerTokens RPC
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RecallToken
	{
		
		/// <summary>
		/// Optional. Optional expiration time of the token
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expireTime")]
		public string ExpireTime { get; set; }
		
		/// <summary>
		/// Required. Whether the persona identified by the token is linked to multiple PGS Players
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multiPlayerPersona")]
		public System.Nullable<System.Boolean> MultiPlayerPersona { get; set; }
		
		/// <summary>
		/// Required. Value of the Recall token as it is provided by the client via LinkPersona RPC
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
	}
	
	/// <summary>
	/// Request to remove all Recall tokens associated with a persona for an app.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResetPersonaRequest
	{
		
		/// <summary>
		/// Value of the 'persona' field as it was provided by the client in LinkPersona RPC
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persona")]
		public string Persona { get; set; }
	}
	
	/// <summary>
	/// Response for the ResetPersona RPC
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResetPersonaResponse
	{
		
		/// <summary>
		/// Required. Whether any tokens were unlinked as a result of this request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unlinked")]
		public System.Nullable<System.Boolean> Unlinked { get; set; }
	}
	
	/// <summary>
	/// Response for the RetrievePlayerTokens RPC
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RetrievePlayerTokensResponse
	{
		
		/// <summary>
		/// Required. Recall tokens associated with the requested PGS Player principal
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokens")]
		public RecallToken[] Tokens { get; set; }
	}
	
	/// <summary>
	/// A third party checking a revision response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RevisionCheckResponse
	{
		
		/// <summary>
		/// The version of the API this client revision should use when calling API methods.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#revisionCheckResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The result of the revision check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="revisionStatus")]
		public System.Nullable<RevisionCheckResponseRevisionStatus> RevisionStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RevisionCheckResponseRevisionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 2,
	}
	
	/// <summary>
	/// Scoped player identifiers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScopedPlayerIds
	{
		
		/// <summary>
		/// Identifier of the player across all games of the given developer. Every player has the same developer_player_key in all games of one developer. Developer player key changes for the game if the game is transferred to another developer. Note that game_player_id will stay unchanged.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="developerPlayerKey")]
		public string DeveloperPlayerKey { get; set; }
		
		/// <summary>
		/// Game-scoped player identifier. This is the same id that is returned in GetPlayer game_player_id field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gamePlayerId")]
		public string GamePlayerId { get; set; }
	}
	
	/// <summary>
	/// An snapshot object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Snapshot
	{
		
		/// <summary>
		/// An image of a snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coverImage")]
		public SnapshotImage CoverImage { get; set; }
		
		/// <summary>
		/// The description of this snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The ID of the file underlying this snapshot in the Drive API. Only present if the snapshot is a view on a Drive file and the file is owned by the caller.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="driveId")]
		public string DriveId { get; set; }
		
		/// <summary>
		/// The duration associated with this snapshot, in millis.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationMillis")]
		public string DurationMillis { get; set; }
		
		/// <summary>
		/// The ID of the snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#snapshot`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The timestamp (in millis since Unix epoch) of the last modification to this snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastModifiedMillis")]
		public string LastModifiedMillis { get; set; }
		
		/// <summary>
		/// The progress value (64-bit integer set by developer) associated with this snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progressValue")]
		public string ProgressValue { get; set; }
		
		/// <summary>
		/// The title of this snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
		
		/// <summary>
		/// The type of this snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<SnapshotType> Type { get; set; }
		
		/// <summary>
		/// The unique name provided when the snapshot was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uniqueName")]
		public string UniqueName { get; set; }
	}
	
	/// <summary>
	/// An image of a snapshot.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotImage
	{
		
		/// <summary>
		/// The height of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#snapshotImage`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// The MIME type of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mime_type")]
		public string Mime_type { get; set; }
		
		/// <summary>
		/// The URL of the image. This URL may be invalidated at any time and should not be cached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// The width of the image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SnapshotType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SAVE_GAME = 0,
	}
	
	/// <summary>
	/// A third party list snapshots response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotListResponse
	{
		
		/// <summary>
		/// The snapshots.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Snapshot[] Items { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#snapshotListResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Token corresponding to the next page of results. If there are no more results, the token is omitted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A third party stats resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatsResponse
	{
		
		/// <summary>
		/// Average session length in minutes of the player. E.g., 1, 30, 60, ... . Not populated if there is not enough information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avg_session_length_minutes")]
		public System.Nullable<System.Single> Avg_session_length_minutes { get; set; }
		
		/// <summary>
		/// The probability of the player not returning to play the game in the next day. E.g., 0, 0.1, 0.5, ..., 1.0. Not populated if there is not enough information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="churn_probability")]
		public System.Nullable<System.Single> Churn_probability { get; set; }
		
		/// <summary>
		/// Number of days since the player last played this game. E.g., 0, 1, 5, 10, ... . Not populated if there is not enough information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="days_since_last_played")]
		public System.Nullable<System.Int32> Days_since_last_played { get; set; }
		
		/// <summary>
		/// The probability of the player going to spend beyond a threshold amount of money. E.g., 0, 0.25, 0.50, 0.75. Not populated if there is not enough information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="high_spender_probability")]
		public System.Nullable<System.Single> High_spender_probability { get; set; }
		
		/// <summary>
		/// Uniquely identifies the type of this resource. Value is always the fixed string `games#statsResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; }
		
		/// <summary>
		/// Number of in-app purchases made by the player in this game. E.g., 0, 1, 5, 10, ... . Not populated if there is not enough information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="num_purchases")]
		public System.Nullable<System.Int32> Num_purchases { get; set; }
		
		/// <summary>
		/// The approximate number of sessions of the player within the last 28 days, where a session begins when the player is connected to Play Games Services and ends when they are disconnected. E.g., 0, 1, 5, 10, ... . Not populated if there is not enough information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="num_sessions")]
		public System.Nullable<System.Int32> Num_sessions { get; set; }
		
		/// <summary>
		/// The approximation of the sessions percentile of the player within the last 30 days, where a session begins when the player is connected to Play Games Services and ends when they are disconnected. E.g., 0, 0.25, 0.5, 0.75. Not populated if there is not enough information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="num_sessions_percentile")]
		public System.Nullable<System.Single> Num_sessions_percentile { get; set; }
		
		/// <summary>
		/// The approximate spend percentile of the player in this game. E.g., 0, 0.25, 0.5, 0.75. Not populated if there is not enough information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spend_percentile")]
		public System.Nullable<System.Single> Spend_percentile { get; set; }
		
		/// <summary>
		/// The probability of the player going to spend the game in the next seven days. E.g., 0, 0.25, 0.50, 0.75. Not populated if there is not enough information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spend_probability")]
		public System.Nullable<System.Single> Spend_probability { get; set; }
		
		/// <summary>
		/// The predicted amount of money that the player going to spend in the next 28 days. E.g., 1, 30, 60, ... . Not populated if there is not enough information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_spend_next_28_days")]
		public System.Nullable<System.Single> Total_spend_next_28_days { get; set; }
	}
	
	/// <summary>
	/// Request to remove a Recall token linking PGS principal and an in-game account
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnlinkPersonaRequest
	{
		
		/// <summary>
		/// Value of the 'persona' field as it was provided by the client in LinkPersona RPC
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persona")]
		public string Persona { get; set; }
		
		/// <summary>
		/// Required. Opaque server-generated string that encodes all the necessary information to identify the PGS player / Google user and application.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sessionId")]
		public string SessionId { get; set; }
		
		/// <summary>
		/// Value of the Recall token as it was provided by the client in LinkPersona RPC
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
	}
	
	/// <summary>
	/// Response for the UnlinkPersona RPC
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnlinkPersonaResponse
	{
		
		/// <summary>
		/// Required. Whether a Recall token specified by the request was deleted. Can be 'false' when there were no Recall tokens satisfied the criteria from the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unlinked")]
		public System.Nullable<System.Boolean> Unlinked { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists all the achievement definitions for your application.
		/// Games_achievementDefinitions_list games/v1/achievements
		/// </summary>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of achievement resources to return in the response, used for paging. For any response, the actual number of achievement resources returned may be less than the specified `maxResults`.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <returns>Successful response</returns>
		public async Task<AchievementDefinitionsListResponse> Games_achievementDefinitions_listAsync(string language, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/achievements?language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AchievementDefinitionsListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates multiple achievements for the currently authenticated player.
		/// Games_achievements_updateMultiple games/v1/achievements/updateMultiple
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<AchievementUpdateMultipleResponse> Games_achievements_updateMultipleAsync(AchievementUpdateMultipleRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/achievements/updateMultiple";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AchievementUpdateMultipleResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Increments the steps of the achievement with the given ID for the currently authenticated player.
		/// Games_achievements_increment games/v1/achievements/{achievementId}/increment
		/// </summary>
		/// <param name="achievementId">The ID of the achievement used by this method.</param>
		/// <param name="stepsToIncrement">Required. The number of steps to increment.</param>
		/// <param name="requestId">A randomly generated numeric ID for each request specified by the caller. This number is used at the server to ensure that the request is handled correctly across retries.</param>
		/// <returns>Successful response</returns>
		public async Task<AchievementIncrementResponse> Games_achievements_incrementAsync(string achievementId, int stepsToIncrement, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/achievements/"+ (achievementId==null? "" : System.Uri.EscapeDataString(achievementId))+"/increment&stepsToIncrement="+stepsToIncrement+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AchievementIncrementResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the state of the achievement with the given ID to `REVEALED` for the currently authenticated player.
		/// Games_achievements_reveal games/v1/achievements/{achievementId}/reveal
		/// </summary>
		/// <param name="achievementId">The ID of the achievement used by this method.</param>
		/// <returns>Successful response</returns>
		public async Task<AchievementRevealResponse> Games_achievements_revealAsync(string achievementId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/achievements/"+ (achievementId==null? "" : System.Uri.EscapeDataString(achievementId))+"/reveal";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AchievementRevealResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the steps for the currently authenticated player towards unlocking an achievement. If the steps parameter is less than the current number of steps that the player already gained for the achievement, the achievement is not modified.
		/// Games_achievements_setStepsAtLeast games/v1/achievements/{achievementId}/setStepsAtLeast
		/// </summary>
		/// <param name="achievementId">The ID of the achievement used by this method.</param>
		/// <param name="steps">Required. The minimum value to set the steps to.</param>
		/// <returns>Successful response</returns>
		public async Task<AchievementSetStepsAtLeastResponse> Games_achievements_setStepsAtLeastAsync(string achievementId, int steps, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/achievements/"+ (achievementId==null? "" : System.Uri.EscapeDataString(achievementId))+"/setStepsAtLeast&steps="+steps;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AchievementSetStepsAtLeastResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unlocks this achievement for the currently authenticated player.
		/// Games_achievements_unlock games/v1/achievements/{achievementId}/unlock
		/// </summary>
		/// <param name="achievementId">The ID of the achievement used by this method.</param>
		/// <returns>Successful response</returns>
		public async Task<AchievementUnlockResponse> Games_achievements_unlockAsync(string achievementId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/achievements/"+ (achievementId==null? "" : System.Uri.EscapeDataString(achievementId))+"/unlock";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AchievementUnlockResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a URL for the requested end point type.
		/// Games_applications_getEndPoint games/v1/applications/getEndPoint
		/// </summary>
		/// <param name="applicationId">The application ID from the Google Play developer console.</param>
		/// <param name="endPointType">Type of endpoint being requested.</param>
		/// <returns>Successful response</returns>
		public async Task<EndPoint> Games_applications_getEndPointAsync(string applicationId, Games_applications_getEndPointEndPointType endPointType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/applications/getEndPoint?applicationId=" + (applicationId==null? "" : System.Uri.EscapeDataString(applicationId))+"&endPointType=" + endPointType;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EndPoint>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Indicate that the currently authenticated user is playing your application.
		/// Games_applications_played games/v1/applications/played
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task Games_applications_playedAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/applications/played";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the metadata of the application with the given ID. If the requested application is not available for the specified `platformType`, the returned response will not include any instance data.
		/// Games_applications_get games/v1/applications/{applicationId}
		/// </summary>
		/// <param name="applicationId">The application ID from the Google Play developer console.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="platformType">Restrict application details returned to the specific platform.</param>
		/// <returns>Successful response</returns>
		public async Task<Application> Games_applications_getAsync(string applicationId, string language, InstancePlatformType platformType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/applications/"+ (applicationId==null? "" : System.Uri.EscapeDataString(applicationId))+"&language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&platformType=" + platformType;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Application>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Verifies the auth token provided with this request is for the application with the specified ID, and returns the ID of the player it was granted for.
		/// Games_applications_verify games/v1/applications/{applicationId}/verify
		/// </summary>
		/// <param name="applicationId">The application ID from the Google Play developer console.</param>
		/// <returns>Successful response</returns>
		public async Task<ApplicationVerifyResponse> Games_applications_verifyAsync(string applicationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/applications/"+ (applicationId==null? "" : System.Uri.EscapeDataString(applicationId))+"/verify";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ApplicationVerifyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of the event definitions in this application.
		/// Games_events_listDefinitions games/v1/eventDefinitions
		/// </summary>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of event definitions to return in the response, used for paging. For any response, the actual number of event definitions to return may be less than the specified `maxResults`.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <returns>Successful response</returns>
		public async Task<EventDefinitionListResponse> Games_events_listDefinitionsAsync(string language, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/eventDefinitions?language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventDefinitionListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list showing the current progress on events in this application for the currently authenticated user.
		/// Games_events_listByPlayer games/v1/events
		/// </summary>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of events to return in the response, used for paging. For any response, the actual number of events to return may be less than the specified maxResults.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <returns>Successful response</returns>
		public async Task<PlayerEventListResponse> Games_events_listByPlayerAsync(string language, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/events?language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PlayerEventListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Records a batch of changes to the number of times events have occurred for the currently authenticated user of this application.
		/// Games_events_record games/v1/events
		/// </summary>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <returns>Successful response</returns>
		public async Task<EventUpdateResponse> Games_events_recordAsync(string language, EventRecordRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/events?language=" + (language==null? "" : System.Uri.EscapeDataString(language));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventUpdateResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all the leaderboard metadata for your application.
		/// Games_leaderboards_list games/v1/leaderboards
		/// </summary>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of leaderboards to return in the response. For any response, the actual number of leaderboards returned may be less than the specified `maxResults`.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <returns>Successful response</returns>
		public async Task<LeaderboardListResponse> Games_leaderboards_listAsync(string language, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/leaderboards?language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LeaderboardListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Submits multiple scores to leaderboards.
		/// Games_scores_submitMultiple games/v1/leaderboards/scores
		/// </summary>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <returns>Successful response</returns>
		public async Task<PlayerScoreListResponse> Games_scores_submitMultipleAsync(string language, PlayerScoreSubmissionList requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/leaderboards/scores?language=" + (language==null? "" : System.Uri.EscapeDataString(language));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PlayerScoreListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the metadata of the leaderboard with the given ID.
		/// Games_leaderboards_get games/v1/leaderboards/{leaderboardId}
		/// </summary>
		/// <param name="leaderboardId">The ID of the leaderboard.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <returns>Successful response</returns>
		public async Task<Leaderboard> Games_leaderboards_getAsync(string leaderboardId, string language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/leaderboards/"+ (leaderboardId==null? "" : System.Uri.EscapeDataString(leaderboardId))+"&language=" + (language==null? "" : System.Uri.EscapeDataString(language));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Leaderboard>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Submits a score to the specified leaderboard.
		/// Games_scores_submit games/v1/leaderboards/{leaderboardId}/scores
		/// </summary>
		/// <param name="leaderboardId">The ID of the leaderboard.</param>
		/// <param name="score">Required. The score you're submitting. The submitted score is ignored if it is worse than a previously submitted score, where worse depends on the leaderboard sort order. The meaning of the score value depends on the leaderboard format type. For fixed-point, the score represents the raw value. For time, the score represents elapsed time in milliseconds. For currency, the score represents a value in micro units.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="scoreTag">Additional information about the score you're submitting. Values must contain no more than 64 URI-safe characters as defined by section 2.3 of RFC 3986.</param>
		/// <returns>Successful response</returns>
		public async Task<PlayerScoreResponse> Games_scores_submitAsync(string leaderboardId, string score, string language, string scoreTag, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/leaderboards/"+ (leaderboardId==null? "" : System.Uri.EscapeDataString(leaderboardId))+"/scores&score=" + (score==null? "" : System.Uri.EscapeDataString(score))+"&language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&scoreTag=" + (scoreTag==null? "" : System.Uri.EscapeDataString(scoreTag));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PlayerScoreResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the scores in a leaderboard, starting from the top.
		/// Games_scores_list games/v1/leaderboards/{leaderboardId}/scores/{collection}
		/// </summary>
		/// <param name="leaderboardId">The ID of the leaderboard.</param>
		/// <param name="collection">The collection of scores you're requesting.</param>
		/// <param name="timeSpan">Required. The time span for the scores and ranks you're requesting.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of leaderboard scores to return in the response. For any response, the actual number of leaderboard scores returned may be less than the specified `maxResults`.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <returns>Successful response</returns>
		public async Task<LeaderboardScores> Games_scores_listAsync(string leaderboardId, Games_scores_listCollection collection, LeaderboardEntryTimeSpan timeSpan, string language, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/leaderboards/"+ (leaderboardId==null? "" : System.Uri.EscapeDataString(leaderboardId))+"/scores/"+collection+"&timeSpan=" + timeSpan+"&language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LeaderboardScores>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the scores in a leaderboard around (and including) a player's score.
		/// Games_scores_listWindow games/v1/leaderboards/{leaderboardId}/window/{collection}
		/// </summary>
		/// <param name="leaderboardId">The ID of the leaderboard.</param>
		/// <param name="collection">The collection of scores you're requesting.</param>
		/// <param name="timeSpan">Required. The time span for the scores and ranks you're requesting.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of leaderboard scores to return in the response. For any response, the actual number of leaderboard scores returned may be less than the specified `maxResults`.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <param name="resultsAbove">The preferred number of scores to return above the player's score. More scores may be returned if the player is at the bottom of the leaderboard; fewer may be returned if the player is at the top. Must be less than or equal to maxResults.</param>
		/// <param name="returnTopIfAbsent">True if the top scores should be returned when the player is not in the leaderboard. Defaults to true.</param>
		/// <returns>Successful response</returns>
		public async Task<LeaderboardScores> Games_scores_listWindowAsync(string leaderboardId, Games_scores_listCollection collection, LeaderboardEntryTimeSpan timeSpan, string language, int maxResults, string pageToken, int resultsAbove, bool returnTopIfAbsent, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/leaderboards/"+ (leaderboardId==null? "" : System.Uri.EscapeDataString(leaderboardId))+"/window/"+collection+"&timeSpan=" + timeSpan+"&language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&resultsAbove="+resultsAbove+"&returnTopIfAbsent="+returnTopIfAbsent;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LeaderboardScores>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return the metagame configuration data for the calling application.
		/// Games_metagame_getMetagameConfig games/v1/metagameConfig
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<MetagameConfig> Games_metagame_getMetagameConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/metagameConfig";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MetagameConfig>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the application player ids for the currently authenticated player across all requested games by the same developer as the calling application. This will only return ids for players that actually have an id (scoped or otherwise) with that game.
		/// Games_players_getMultipleApplicationPlayerIds games/v1/players/me/multipleApplicationPlayerIds
		/// </summary>
		/// <param name="applicationIds">Required. The application IDs from the Google Play developer console for the games to return scoped ids for.</param>
		/// <returns>Successful response</returns>
		public async Task<GetMultipleApplicationPlayerIdsResponse> Games_players_getMultipleApplicationPlayerIdsAsync(string[] applicationIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/players/me/multipleApplicationPlayerIds?"+string.Join("&", applicationIds.Select(z => $"applicationIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetMultipleApplicationPlayerIdsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the collection of players for the currently authenticated user.
		/// Games_players_list games/v1/players/me/players/{collection}
		/// </summary>
		/// <param name="collection">Collection of players being retrieved</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of player resources to return in the response, used for paging. For any response, the actual number of player resources returned may be less than the specified `maxResults`.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <returns>Successful response</returns>
		public async Task<PlayerListResponse> Games_players_listAsync(Games_players_listCollection collection, string language, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/players/me/players/"+collection+"?language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PlayerListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves scoped player identifiers for currently authenticated user.
		/// Games_players_getScopedPlayerIds games/v1/players/me/scopedIds
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<ScopedPlayerIds> Games_players_getScopedPlayerIdsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/players/me/scopedIds";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ScopedPlayerIds>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the Player resource with the given ID. To retrieve the player for the currently authenticated user, set `playerId` to `me`.
		/// Games_players_get games/v1/players/{playerId}
		/// </summary>
		/// <param name="playerId">A player ID. A value of `me` may be used in place of the authenticated player's ID.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="playerIdConsistencyToken">Consistency token of the player id. The call returns a 'not found' result when the token is present and invalid. Empty value is ignored. See also GlobalPlayerIdConsistencyTokenProto</param>
		/// <returns>Successful response</returns>
		public async Task<Player> Games_players_getAsync(string playerId, string language, string playerIdConsistencyToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/players/"+ (playerId==null? "" : System.Uri.EscapeDataString(playerId))+"&language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&playerIdConsistencyToken=" + (playerIdConsistencyToken==null? "" : System.Uri.EscapeDataString(playerIdConsistencyToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Player>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the progress for all your application's achievements for the currently authenticated player.
		/// Games_achievements_list games/v1/players/{playerId}/achievements
		/// </summary>
		/// <param name="playerId">A player ID. A value of `me` may be used in place of the authenticated player's ID.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of achievement resources to return in the response, used for paging. For any response, the actual number of achievement resources returned may be less than the specified `maxResults`.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <param name="state">Tells the server to return only achievements with the specified state. If this parameter isn't specified, all achievements are returned.</param>
		/// <returns>Successful response</returns>
		public async Task<PlayerAchievementListResponse> Games_achievements_listAsync(string playerId, string language, int maxResults, string pageToken, Games_achievements_listState state, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/players/"+ (playerId==null? "" : System.Uri.EscapeDataString(playerId))+"/achievements&language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&state=" + state;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PlayerAchievementListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List play data aggregated per category for the player corresponding to `playerId`.
		/// Games_metagame_listCategoriesByPlayer games/v1/players/{playerId}/categories/{collection}
		/// </summary>
		/// <param name="playerId">A player ID. A value of `me` may be used in place of the authenticated player's ID.</param>
		/// <param name="collection">The collection of categories for which data will be returned.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of category resources to return in the response, used for paging. For any response, the actual number of category resources returned may be less than the specified `maxResults`.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <returns>Successful response</returns>
		public async Task<CategoryListResponse> Games_metagame_listCategoriesByPlayerAsync(string playerId, Games_metagame_listCategoriesByPlayerCollection collection, string language, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/players/"+ (playerId==null? "" : System.Uri.EscapeDataString(playerId))+"/categories/"+collection+"&language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CategoryListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get high scores, and optionally ranks, in leaderboards for the currently authenticated player. For a specific time span, `leaderboardId` can be set to `ALL` to retrieve data for all leaderboards in a given time span. `NOTE: You cannot ask for 'ALL' leaderboards and 'ALL' timeSpans in the same request; only one parameter may be set to 'ALL'.
		/// Games_scores_get games/v1/players/{playerId}/leaderboards/{leaderboardId}/scores/{timeSpan}
		/// </summary>
		/// <param name="playerId">A player ID. A value of `me` may be used in place of the authenticated player's ID.</param>
		/// <param name="leaderboardId">The ID of the leaderboard. Can be set to 'ALL' to retrieve data for all leaderboards for this application.</param>
		/// <param name="timeSpan">The time span for the scores and ranks you're requesting.</param>
		/// <param name="includeRankType">The types of ranks to return. If the parameter is omitted, no ranks will be returned.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of leaderboard scores to return in the response. For any response, the actual number of leaderboard scores returned may be less than the specified `maxResults`.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <returns>Successful response</returns>
		public async Task<PlayerLeaderboardScoreListResponse> Games_scores_getAsync(string playerId, string leaderboardId, Games_scores_getTimeSpan timeSpan, Games_scores_getIncludeRankType includeRankType, string language, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/players/"+ (playerId==null? "" : System.Uri.EscapeDataString(playerId))+"/leaderboards/"+ (leaderboardId==null? "" : System.Uri.EscapeDataString(leaderboardId))+"/scores/"+timeSpan+"&includeRankType=" + includeRankType+"&language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PlayerLeaderboardScoreListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of snapshots created by your application for the player corresponding to the player ID.
		/// Games_snapshots_list games/v1/players/{playerId}/snapshots
		/// </summary>
		/// <param name="playerId">A player ID. A value of `me` may be used in place of the authenticated player's ID.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <param name="maxResults">The maximum number of snapshot resources to return in the response, used for paging. For any response, the actual number of snapshot resources returned may be less than the specified `maxResults`.</param>
		/// <param name="pageToken">The token returned by the previous request.</param>
		/// <returns>Successful response</returns>
		public async Task<SnapshotListResponse> Games_snapshots_listAsync(string playerId, string language, int maxResults, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/players/"+ (playerId==null? "" : System.Uri.EscapeDataString(playerId))+"/snapshots&language=" + (language==null? "" : System.Uri.EscapeDataString(language))+"&maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SnapshotListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all Recall tokens associated with the PGS Player principal encoded in the provided recall session id. The API is only available for users that have active PGS Player profile.
		/// Games_recall_retrieveTokens games/v1/recall/tokens/{sessionId}
		/// </summary>
		/// <param name="sessionId">Required. Opaque server-generated string that encodes all the necessary information to identify the PGS player / Google user and application.</param>
		/// <returns>Successful response</returns>
		public async Task<RetrievePlayerTokensResponse> Games_recall_retrieveTokensAsync(string sessionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/recall/tokens/"+ (sessionId==null? "" : System.Uri.EscapeDataString(sessionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetrievePlayerTokensResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Associate the PGS Player principal encoded in the provided recall session id with an in-game account
		/// Games_recall_linkPersona games/v1/recall:linkPersona
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<LinkPersonaResponse> Games_recall_linkPersonaAsync(LinkPersonaRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/recall:linkPersona";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LinkPersonaResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete all Recall tokens linking the given persona to any player (with or without a profile).
		/// Games_recall_resetPersona games/v1/recall:resetPersona
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<ResetPersonaResponse> Games_recall_resetPersonaAsync(ResetPersonaRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/recall:resetPersona";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResetPersonaResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a Recall token linking the PGS Player principal identified by the Recall session and an in-game account identified either by the 'persona' or by the token value.
		/// Games_recall_unlinkPersona games/v1/recall:unlinkPersona
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<UnlinkPersonaResponse> Games_recall_unlinkPersonaAsync(UnlinkPersonaRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/recall:unlinkPersona";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UnlinkPersonaResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Checks whether the games client is out of date.
		/// Games_revisions_check games/v1/revisions/check
		/// </summary>
		/// <param name="clientRevision">Required. The revision of the client SDK used by your application. Format: `[PLATFORM_TYPE]:[VERSION_NUMBER]`. Possible values of `PLATFORM_TYPE` are: * `ANDROID` - Client is running the Android SDK. * `IOS` - Client is running the iOS SDK. * `WEB_APP` - Client is running as a Web App.</param>
		/// <returns>Successful response</returns>
		public async Task<RevisionCheckResponse> Games_revisions_checkAsync(string clientRevision, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/revisions/check?clientRevision=" + (clientRevision==null? "" : System.Uri.EscapeDataString(clientRevision));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RevisionCheckResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the metadata for a given snapshot ID.
		/// Games_snapshots_get games/v1/snapshots/{snapshotId}
		/// </summary>
		/// <param name="snapshotId">The ID of the snapshot.</param>
		/// <param name="language">The preferred language to use for strings returned by this method.</param>
		/// <returns>Successful response</returns>
		public async Task<Snapshot> Games_snapshots_getAsync(string snapshotId, string language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/snapshots/"+ (snapshotId==null? "" : System.Uri.EscapeDataString(snapshotId))+"&language=" + (language==null? "" : System.Uri.EscapeDataString(language));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Snapshot>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns engagement and spend statistics in this application for the currently authenticated user.
		/// Games_stats_get games/v1/stats
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<StatsResponse> Games_stats_getAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "games/v1/stats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StatsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Games_applications_getEndPointEndPointType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROFILE_CREATION = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROFILE_SETTINGS = 1,
	}
	
	public enum Games_scores_listCollection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOCIAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FRIENDS = 2,
	}
	
	public enum Games_players_listCollection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECTED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VISIBLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FRIENDS_ALL = 2,
	}
	
	public enum Games_achievements_listState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIDDEN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVEALED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNLOCKED = 3,
	}
	
	public enum Games_metagame_listCategoriesByPlayerCollection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
	}
	
	public enum Games_scores_getTimeSpan
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_TIME = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEEKLY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DAILY = 3,
	}
	
	public enum Games_scores_getIncludeRankType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOCIAL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FRIENDS = 3,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
