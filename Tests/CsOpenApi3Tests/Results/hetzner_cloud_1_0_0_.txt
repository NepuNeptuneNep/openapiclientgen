//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get all Actions
		/// Returns all Action objects. You can `sort` the results by using the sort URI parameter, and filter them with the `status` parameter.
		/// ActionsGetByIdAndSortAndStatus actions
		/// </summary>
		/// <param name="id">Can be used multiple times, the response will contain only Actions with specified IDs</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times, the response will contain only Actions with specified statuses</param>
		/// <returns>The `actions` key contains a list of Actions</returns>
		public async Task<ActionsGetByIdAndSortAndStatusReturn> ActionsGetByIdAndSortAndStatusAsync(int id, ActionsGetByIdAndSortAndStatusSort sort, ActionsGetByIdAndSortAndStatusStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "actions?id="+id+"&sort=" + sort+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ActionsGetByIdAndSortAndStatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an Action
		/// Returns a specific Action object.
		/// Actions_idGet actions/{id}
		/// </summary>
		/// <param name="id">ID of the Resource</param>
		/// <returns>The `action` key in the reply has this structure</returns>
		public async Task<Actions_idGetReturn> Actions_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "actions/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Actions_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Certificates
		/// Returns all Certificate objects.
		/// CertificatesGetBySortAndNameAndLabel_selectorAndType certificates
		/// </summary>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="name">Can be used to filter resources by their name. The response will only contain the resources matching the specified name</param>
		/// <param name="label_selector">Can be used to filter resources by labels. The response will only contain resources matching the label selector.</param>
		/// <param name="type">Can be used multiple times. The response will only contain Certificates matching the type.</param>
		/// <returns>The `certificates` key contains an array of Certificate objects</returns>
		public async Task<CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturn> CertificatesGetBySortAndNameAndLabel_selectorAndTypeAsync(CertificatesGetBySortAndNameAndLabel_selectorAndTypeSort sort, string name, string label_selector, CertificatesGetBySortAndNameAndLabel_selectorAndTypeType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificates?sort=" + sort+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector))+"&type=" + type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a Certificate
		/// Creates a new Certificate.
		/// 
		/// The default type **uploaded** allows for uploading your existing `certificate` and `private_key` in PEM format. You have to monitor its expiration date and handle renewal yourself.
		/// 
		/// In contrast, type **managed** requests a new Certificate from *Let's Encrypt* for the specified `domain_names`. Only domains managed by *Hetzner DNS* are supported. We handle renewal and timely alert the project owner via email if problems occur.
		/// 
		/// For type `managed` Certificates the `action` key of the response contains the Action that allows for tracking the issuance process. For type `uploaded` Certificates the `action` is always null.
		/// 
		/// CertificatesPost certificates
		/// </summary>
		public async Task CertificatesPostAsync(CertificatesPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificates";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a Certificate
		/// Deletes a Certificate.
		/// Certificates_idDelete certificates/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		public async Task Certificates_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificates/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Certificate
		/// Gets a specific Certificate object.
		/// Certificates_idGet certificates/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		/// <returns>The `certificate` key contains a Certificate object</returns>
		public async Task<Certificates_idGetReturn> Certificates_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificates/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Certificates_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Certificate
		/// Updates the Certificate properties.
		/// 
		/// Note that when updating labels, the Certificate’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// 
		/// Note: if the Certificate object changes during the request, the response will be a “conflict” error.
		/// 
		/// Certificates_idPut certificates/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		/// <returns>The `certificate` key contains the Certificate that was just updated</returns>
		public async Task<Certificates_idPutReturn> Certificates_idPutAsync(int id, Certificates_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificates/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Certificates_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all Actions for a Certificate
		/// Returns all Action objects for a Certificate. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter.
		/// 
		/// Only type `managed` Certificates can have Actions. For type `uploaded` Certificates the `actions` key will always contain an empty array.
		/// 
		/// Certificates_idActionsGetBySortAndStatus certificates/{id}/actions
		/// </summary>
		/// <param name="id">ID of the Resource</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times, the response will contain only Actions with specified statuses</param>
		/// <returns>The `actions` key contains a list of Actions</returns>
		public async Task<Certificates_idActionsGetBySortAndStatusReturn> Certificates_idActionsGetBySortAndStatusAsync(int id, Certificates_idActionsGetBySortAndStatusSort sort, ActionsGetByIdAndSortAndStatusStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificates/"+id+"/actions?sort=" + sort+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Certificates_idActionsGetBySortAndStatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retry Issuance or Renewal
		/// Retry a failed Certificate issuance or renewal.
		/// 
		/// Only applicable if the type of the Certificate is `managed` and the issuance or renewal status is `failed`.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                                                    | Description                                                               |
		/// |---------------------------------------------------------|---------------------------------------------------------------------------|
		/// | `caa_record_does_not_allow_ca`                          | CAA record does not allow certificate authority                           |
		/// | `ca_dns_validation_failed`                              | Certificate Authority: DNS validation failed                              |
		/// | `ca_too_many_authorizations_failed_recently`            | Certificate Authority: Too many authorizations failed recently            |
		/// | `ca_too_many_certificates_issued_for_registered_domain` | Certificate Authority: Too many certificates issued for registered domain |
		/// | `ca_too_many_duplicate_certificates`                    | Certificate Authority: Too many duplicate certificates                    |
		/// | `could_not_verify_domain_delegated_to_zone`             | Could not verify domain delegated to zone                                 |
		/// | `dns_zone_not_found`                                    | DNS zone not found                                                        |
		/// | `dns_zone_is_secondary_zone`                            | DNS zone is a secondary zone                                              |
		/// 
		/// Certificates_idActionsRetryPost certificates/{id}/actions/retry
		/// </summary>
		/// <param name="id">ID of the Certificate</param>
		public async Task Certificates_idActionsRetryPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificates/"+id+"/actions/retry";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an Action for a Certificate
		/// Returns a specific Action for a Certificate. Only type `managed` Certificates have Actions.
		/// Certificates_idActions_action_idGet certificates/{id}/actions/{action_id}
		/// </summary>
		/// <param name="id">ID of the Certificate</param>
		/// <param name="action_id">ID of the Action</param>
		/// <returns>The `action` key contains the Certificate Action</returns>
		public async Task<Certificates_idActions_action_idGetReturn> Certificates_idActions_action_idGetAsync(int id, int action_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "certificates/"+id+"/actions/"+action_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Certificates_idActions_action_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Datacenters
		/// Returns all Datacenter objects.
		/// DatacentersGetByName datacenters
		/// </summary>
		/// <param name="name">Can be used to filter Datacenters by their name. The response will only contain the Datacenter matching the specified name. When the name does not match the Datacenter name format, an `invalid_input` error is returned.</param>
		/// <returns>The reply contains the `datacenters` and `recommendation` keys</returns>
		public async Task<DatacentersGetByNameReturn> DatacentersGetByNameAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "datacenters?name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DatacentersGetByNameReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Datacenter
		/// Returns a specific Datacenter object.
		/// Datacenters_idGet datacenters/{id}
		/// </summary>
		/// <param name="id">ID of Datacenter</param>
		/// <returns>The `datacenter` key in the reply contains a Datacenter object with this structure</returns>
		public async Task<Datacenters_idGetReturn> Datacenters_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "datacenters/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Datacenters_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Firewalls
		/// Returns all Firewall objects.
		/// FirewallsGetBySortAndNameAndLabel_selector firewalls
		/// </summary>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="name">Can be used to filter resources by their name. The response will only contain the resources matching the specified name</param>
		/// <param name="label_selector">Can be used to filter resources by labels. The response will only contain resources matching the label selector.</param>
		/// <returns>The `firewalls` key contains an array of Firewall objects</returns>
		public async Task<FirewallsGetBySortAndNameAndLabel_selectorReturn> FirewallsGetBySortAndNameAndLabel_selectorAsync(FirewallsGetBySortAndNameAndLabel_selectorSort sort, string name, string label_selector, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "firewalls?sort=" + sort+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallsGetBySortAndNameAndLabel_selectorReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a Firewall
		/// Creates a new Firewall.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                          | Description                                                   |
		/// |------------------------------ |-------------------------------------------------------------- |
		/// | `server_already_added`        | Server added more than one time to resource                   |
		/// | `incompatible_network_type`   | The Network type is incompatible for the given resource       |
		/// | `firewall_resource_not_found` | The resource the Firewall should be attached to was not found |
		/// 
		/// FirewallsPost firewalls
		/// </summary>
		public async Task FirewallsPostAsync(FirewallsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "firewalls";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a Firewall
		/// Deletes a Firewall.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                 | Description                               |
		/// |--------------------- |-------------------------------------------|
		/// | `resource_in_use`    | Firewall must not be in use to be deleted |
		/// 
		/// Firewalls_idDelete firewalls/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		public async Task Firewalls_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "firewalls/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Firewall
		/// Gets a specific Firewall object.
		/// Firewalls_idGet firewalls/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		/// <returns>The `firewall` key contains a Firewall object</returns>
		public async Task<Firewalls_idGetReturn> Firewalls_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "firewalls/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Firewalls_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Firewall
		/// Updates the Firewall.
		/// 
		/// Note that when updating labels, the Firewall's current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// 
		/// Note: if the Firewall object changes during the request, the response will be a “conflict” error.
		/// 
		/// Firewalls_idPut firewalls/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		/// <returns>The `firewall` key contains the Firewall that was just updated</returns>
		public async Task<Firewalls_idPutReturn> Firewalls_idPutAsync(int id, Firewalls_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "firewalls/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Firewalls_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all Actions for a Firewall
		/// Returns all Action objects for a Firewall. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter.
		/// Firewalls_idActionsGetBySortAndStatus firewalls/{id}/actions
		/// </summary>
		/// <param name="id">ID of the Resource</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times, the response will contain only Actions with specified statuses</param>
		/// <returns>The `actions` key contains a list of Actions</returns>
		public async Task<Firewalls_idActionsGetBySortAndStatusReturn> Firewalls_idActionsGetBySortAndStatusAsync(int id, Firewalls_idActionsGetBySortAndStatusSort sort, ActionsGetByIdAndSortAndStatusStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "firewalls/"+id+"/actions?sort=" + sort+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Firewalls_idActionsGetBySortAndStatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Apply to Resources
		/// Applies one Firewall to multiple resources.
		/// 
		/// Currently servers (public network interface) and label selectors are supported.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                          | Description                                                   |
		/// |-------------------------------|---------------------------------------------------------------|
		/// | `firewall_already_applied`    | Firewall was already applied on resource                      |
		/// | `incompatible_network_type`   | The Network type is incompatible for the given resource       |
		/// | `firewall_resource_not_found` | The resource the Firewall should be attached to was not found |
		/// 
		/// Firewalls_idActionsApply_to_resourcesPost firewalls/{id}/actions/apply_to_resources
		/// </summary>
		/// <param name="id">ID of the Firewall</param>
		public async Task Firewalls_idActionsApply_to_resourcesPostAsync(int id, Firewalls_idActionsApply_to_resourcesPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "firewalls/"+id+"/actions/apply_to_resources";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove from Resources
		/// Removes one Firewall from multiple resources.
		/// 
		/// Currently only Servers (and their public network interfaces) are supported.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                                  | Description                                                            |
		/// |---------------------------------------|------------------------------------------------------------------------|
		/// | `firewall_already_removed`            | Firewall was already removed from the resource                         |
		/// | `firewall_resource_not_found`         | The resource the Firewall should be attached to was not found          |
		/// | `firewall_managed_by_label_selector`  | Firewall was applied via label selector and cannot be removed manually |
		/// 
		/// Firewalls_idActionsRemove_from_resourcesPost firewalls/{id}/actions/remove_from_resources
		/// </summary>
		/// <param name="id">ID of the Firewall</param>
		public async Task Firewalls_idActionsRemove_from_resourcesPostAsync(int id, Firewalls_idActionsRemove_from_resourcesPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "firewalls/"+id+"/actions/remove_from_resources";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set Rules
		/// Sets the rules of a Firewall.
		/// 
		/// All existing rules will be overwritten. Pass an empty `rules` array to remove all rules.
		/// The maximum amount of rules that can be defined is 50.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                          | Description                                                   |
		/// |-------------------------------|---------------------------------------------------------------|
		/// | `firewall_resource_not_found` | The resource the Firewall should be attached to was not found |
		/// 
		/// Firewalls_idActionsSet_rulesPost firewalls/{id}/actions/set_rules
		/// </summary>
		/// <param name="id">ID of the Firewall</param>
		public async Task Firewalls_idActionsSet_rulesPostAsync(int id, Firewalls_idActionsSet_rulesPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "firewalls/"+id+"/actions/set_rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get an Action for a Firewall
		/// Returns a specific Action for a Firewall.
		/// Firewalls_idActions_action_idGet firewalls/{id}/actions/{action_id}
		/// </summary>
		/// <param name="id">ID of the Firewall</param>
		/// <param name="action_id">ID of the Action</param>
		/// <returns>The `action` key contains the Firewall Action</returns>
		public async Task<Firewalls_idActions_action_idGetReturn> Firewalls_idActions_action_idGetAsync(int id, int action_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "firewalls/"+id+"/actions/"+action_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Firewalls_idActions_action_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Floating IPs
		/// Returns all Floating IP objects.
		/// Floating_ipsGetByNameAndLabel_selectorAndSort floating_ips
		/// </summary>
		/// <param name="name">Can be used to filter Floating IPs by their name. The response will only contain the Floating IP matching the specified name.</param>
		/// <param name="label_selector">Can be used to filter Floating IPs by labels. The response will only contain Floating IPs matching the label selector.</param>
		/// <param name="sort">Can be used multiple times. Choices id id:asc id:desc created created:asc created:desc</param>
		/// <returns>The `floating_ips` key in the reply contains an array of Floating IP objects with this structure</returns>
		public async Task<Floating_ipsGetByNameAndLabel_selectorAndSortReturn> Floating_ipsGetByNameAndLabel_selectorAndSortAsync(string name, string label_selector, Floating_ipsGetByNameAndLabel_selectorAndSortSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector))+"&sort=" + sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Floating_ipsGetByNameAndLabel_selectorAndSortReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a Floating IP
		/// Creates a new Floating IP assigned to a Server. If you want to create a Floating IP that is not bound to a Server, you need to provide the `home_location` key instead of `server`. This can be either the ID or the name of the Location this IP shall be created in. Note that a Floating IP can be assigned to a Server in any Location later on. For optimal routing it is advised to use the Floating IP in the same Location it was created in.
		/// Floating_ipsPost floating_ips
		/// </summary>
		/// <param name="requestBody">The `type` argument is required while `home_location` and `server` are mutually exclusive.</param>
		public async Task Floating_ipsPostAsync(Floating_ipsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a Floating IP
		/// Deletes a Floating IP. If it is currently assigned to a Server it will automatically get unassigned.
		/// Floating_ips_idDelete floating_ips/{id}
		/// </summary>
		/// <param name="id">ID of the Floating IP</param>
		public async Task Floating_ips_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Floating IP
		/// Returns a specific Floating IP object.
		/// Floating_ips_idGet floating_ips/{id}
		/// </summary>
		/// <param name="id">ID of the Floating IP</param>
		/// <returns>The `floating_ip` key in the reply contains a Floating IP object with this structure</returns>
		public async Task<Floating_ips_idGetReturn> Floating_ips_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Floating_ips_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Floating IP
		/// Updates the description or labels of a Floating IP.
		/// Also note that when updating labels, the Floating IP’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// Floating_ips_idPut floating_ips/{id}
		/// </summary>
		/// <param name="id">ID of the Floating IP</param>
		/// <returns>The `floating_ip` key in the reply contains the modified Floating IP object with the new description</returns>
		public async Task<Floating_ips_idPutReturn> Floating_ips_idPutAsync(int id, Floating_ips_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Floating_ips_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all Actions for a Floating IP
		/// Returns all Action objects for a Floating IP. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter.
		/// Floating_ips_idActionsGetBySortAndStatus floating_ips/{id}/actions
		/// </summary>
		/// <param name="id">ID of the Floating IP</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times, the response will contain only Actions with specified statuses</param>
		/// <returns>The `actions` key contains a list of Actions</returns>
		public async Task<Floating_ips_idActionsGetBySortAndStatusReturn> Floating_ips_idActionsGetBySortAndStatusAsync(int id, Floating_ips_idActionsGetBySortAndStatusSort sort, ActionsGetByIdAndSortAndStatusStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips/"+id+"/actions?sort=" + sort+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Floating_ips_idActionsGetBySortAndStatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Assign a Floating IP to a Server
		/// Assigns a Floating IP to a Server.
		/// Floating_ips_idActionsAssignPost floating_ips/{id}/actions/assign
		/// </summary>
		/// <param name="id">ID of the Floating IP</param>
		public async Task Floating_ips_idActionsAssignPostAsync(int id, Floating_ips_idActionsAssignPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips/"+id+"/actions/assign";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change reverse DNS entry for a Floating IP
		/// Changes the hostname that will appear when getting the hostname belonging to this Floating IP.
		/// Floating_ips_idActionsChange_dns_ptrPost floating_ips/{id}/actions/change_dns_ptr
		/// </summary>
		/// <param name="id">ID of the Floating IP</param>
		/// <param name="requestBody">Select the IP address for which to change the DNS entry by passing `ip`. For a Floating IP of type `ipv4` this must exactly match the IP address of the Floating IP. For a Floating IP of type `ipv6` this must be a single IP within the IPv6 /64 range that belongs to this Floating IP. You can add up to 100 IPv6 reverse DNS entries.
		///
		///The target hostname is set by passing `dns_ptr`.
		///</param>
		public async Task Floating_ips_idActionsChange_dns_ptrPostAsync(int id, Floating_ips_idActionsChange_dns_ptrPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips/"+id+"/actions/change_dns_ptr";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change Floating IP Protection
		/// Changes the protection configuration of the Floating IP.
		/// Floating_ips_idActionsChange_protectionPost floating_ips/{id}/actions/change_protection
		/// </summary>
		/// <param name="id">ID of the Floating IP</param>
		public async Task Floating_ips_idActionsChange_protectionPostAsync(int id, Floating_ips_idActionsChange_protectionPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips/"+id+"/actions/change_protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Unassign a Floating IP
		/// Unassigns a Floating IP, resulting in it being unreachable. You may assign it to a Server again at a later time.
		/// Floating_ips_idActionsUnassignPost floating_ips/{id}/actions/unassign
		/// </summary>
		/// <param name="id">ID of the Floating IP</param>
		public async Task Floating_ips_idActionsUnassignPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips/"+id+"/actions/unassign";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an Action for a Floating IP
		/// Returns a specific Action object for a Floating IP.
		/// Floating_ips_idActions_action_idGet floating_ips/{id}/actions/{action_id}
		/// </summary>
		/// <param name="id">ID of the Floating IP</param>
		/// <param name="action_id">ID of the Action</param>
		/// <returns>The `action` key in the reply has this structure</returns>
		public async Task<Floating_ips_idActions_action_idGetReturn> Floating_ips_idActions_action_idGetAsync(int id, int action_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "floating_ips/"+id+"/actions/"+action_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Floating_ips_idActions_action_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Images
		/// Returns all Image objects. You can select specific Image types only and sort the results by using URI parameters.
		/// ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitecture images
		/// </summary>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="type">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times. The response will only contain Images matching the status.</param>
		/// <param name="bound_to">Can be used multiple times. Server ID linked to the Image. Only available for Images of type `backup`</param>
		/// <param name="include_deprecated">Can be used multiple times.</param>
		/// <param name="name">Can be used to filter resources by their name. The response will only contain the resources matching the specified name</param>
		/// <param name="label_selector">Can be used to filter resources by labels. The response will only contain resources matching the label selector.</param>
		/// <param name="architecture">Return only Images with the given architecture.</param>
		/// <returns>The `images` key in the reply contains an array of Image objects with this structure</returns>
		public async Task<ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturn> ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureAsync(ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureSort sort, ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureType type, ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureStatus status, string bound_to, bool include_deprecated, string name, string label_selector, string architecture, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images?sort=" + sort+"&type=" + type+"&status=" + status+"&bound_to=" + (bound_to==null? "" : System.Uri.EscapeDataString(bound_to))+"&include_deprecated="+include_deprecated+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector))+"&architecture=" + (architecture==null? "" : System.Uri.EscapeDataString(architecture));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an Image
		/// Deletes an Image. Only Images of type `snapshot` and `backup` can be deleted.
		/// Images_idDelete images/{id}
		/// </summary>
		/// <param name="id">ID of the Image</param>
		public async Task Images_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an Image
		/// Returns a specific Image object.
		/// Images_idGet images/{id}
		/// </summary>
		/// <param name="id">ID of the Image</param>
		/// <returns>The `image` key in the reply contains an Image object with this structure</returns>
		public async Task<Images_idGetReturn> Images_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Images_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an Image
		/// Updates the Image. You may change the description, convert a Backup Image to a Snapshot Image or change the Image labels. Only Images of type `snapshot` and `backup` can be updated.
		/// 
		/// Note that when updating labels, the current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// 
		/// Images_idPut images/{id}
		/// </summary>
		/// <param name="id">ID of the Image</param>
		/// <returns>The image key in the reply contains the modified Image object</returns>
		public async Task<Images_idPutReturn> Images_idPutAsync(int id, Images_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Images_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all Actions for an Image
		/// Returns all Action objects for an Image. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter.
		/// Images_idActionsGetBySortAndStatus images/{id}/actions
		/// </summary>
		/// <param name="id">ID of the Image</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times, the response will contain only Actions with specified statuses</param>
		/// <returns>The `actions` key contains a list of Actions</returns>
		public async Task<Images_idActionsGetBySortAndStatusReturn> Images_idActionsGetBySortAndStatusAsync(int id, Images_idActionsGetBySortAndStatusSort sort, ActionsGetByIdAndSortAndStatusStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+id+"/actions?sort=" + sort+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Images_idActionsGetBySortAndStatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Change Image Protection
		/// Changes the protection configuration of the Image. Can only be used on snapshots.
		/// Images_idActionsChange_protectionPost images/{id}/actions/change_protection
		/// </summary>
		/// <param name="id">ID of the Image</param>
		public async Task Images_idActionsChange_protectionPostAsync(int id, Images_idActionsChange_protectionPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+id+"/actions/change_protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get an Action for an Image
		/// Returns a specific Action for an Image.
		/// Images_idActions_action_idGet images/{id}/actions/{action_id}
		/// </summary>
		/// <param name="id">ID of the Image</param>
		/// <param name="action_id">ID of the Action</param>
		/// <returns>The `action` key contains the Image Action</returns>
		public async Task<Images_idActions_action_idGetReturn> Images_idActions_action_idGetAsync(int id, int action_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+id+"/actions/"+action_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Images_idActions_action_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all ISOs
		/// Returns all available ISO objects.
		/// IsosGetByNameAndArchitectureAndInclude_architecture_wildcard isos
		/// </summary>
		/// <param name="name">Can be used to filter ISOs by their name. The response will only contain the ISO matching the specified name.</param>
		/// <param name="architecture">Return only ISOs with the given architecture.</param>
		/// <param name="include_architecture_wildcard">Include Images with wildcard architecture (architecture is null). Works only if architecture filter is specified.</param>
		/// <returns>The `isos` key in the reply contains an array of iso objects with this structure</returns>
		public async Task<IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturn> IsosGetByNameAndArchitectureAndInclude_architecture_wildcardAsync(string name, string architecture, bool include_architecture_wildcard, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "isos?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&architecture=" + (architecture==null? "" : System.Uri.EscapeDataString(architecture))+"&include_architecture_wildcard="+include_architecture_wildcard;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an ISO
		/// Returns a specific ISO object.
		/// Isos_idGet isos/{id}
		/// </summary>
		/// <param name="id">ID of the ISO</param>
		/// <returns>The `iso` key in the reply contains an array of ISO objects with this structure</returns>
		public async Task<Isos_idGetReturn> Isos_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "isos/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Isos_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Load Balancer Types
		/// Gets all Load Balancer type objects.
		/// Load_balancer_typesGetByName load_balancer_types
		/// </summary>
		/// <param name="name">Can be used to filter Load Balancer types by their name. The response will only contain the Load Balancer type matching the specified name.</param>
		/// <returns>The `load_balancer_types` key in the reply contains an array of Load Balancer type objects with this structure</returns>
		public async Task<Load_balancer_typesGetByNameReturn> Load_balancer_typesGetByNameAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancer_types?name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Load_balancer_typesGetByNameReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Load Balancer Type
		/// Gets a specific Load Balancer type object.
		/// Load_balancer_types_idGet load_balancer_types/{id}
		/// </summary>
		/// <param name="id">ID of Load Balancer type</param>
		/// <returns>The `load_balancer_type` key in the reply contains a Load Balancer type object with this structure</returns>
		public async Task<Load_balancer_types_idGetReturn> Load_balancer_types_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancer_types/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Load_balancer_types_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Load Balancers
		/// Gets all existing Load Balancers that you have available.
		/// Load_balancersGetBySortAndNameAndLabel_selector load_balancers
		/// </summary>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="name">Can be used to filter resources by their name. The response will only contain the resources matching the specified name</param>
		/// <param name="label_selector">Can be used to filter resources by labels. The response will only contain resources matching the label selector.</param>
		/// <returns>The `load_balancers` key contains a list of Load Balancers</returns>
		public async Task<Load_balancersGetBySortAndNameAndLabel_selectorReturn> Load_balancersGetBySortAndNameAndLabel_selectorAsync(Load_balancersGetBySortAndNameAndLabel_selectorSort sort, string name, string label_selector, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers?sort=" + sort+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Load_balancersGetBySortAndNameAndLabel_selectorReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a Load Balancer
		/// Creates a Load Balancer.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                                    | Description                                                                                           |
		/// |-----------------------------------------|-------------------------------------------------------------------------------------------------------|
		/// | `cloud_resource_ip_not_allowed`         | The IP you are trying to add as a target belongs to a Hetzner Cloud resource                          |
		/// | `ip_not_owned`                          | The IP is not owned by the owner of the project of the Load Balancer                                  |
		/// | `load_balancer_not_attached_to_network` | The Load Balancer is not attached to a network                                                        |
		/// | `robot_unavailable`                     | Robot was not available. The caller may retry the operation after a short delay.                      |
		/// | `server_not_attached_to_network`        | The server you are trying to add as a target is not attached to the same network as the Load Balancer |
		/// | `source_port_already_used`              | The source port you are trying to add is already in use                                               |
		/// | `target_already_defined`                | The Load Balancer target you are trying to define is already defined                                  |
		/// 
		/// Load_balancersPost load_balancers
		/// </summary>
		public async Task Load_balancersPostAsync(Load_balancersPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a Load Balancer
		/// Deletes a Load Balancer.
		/// Load_balancers_idDelete load_balancers/{id}
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Load Balancer
		/// Gets a specific Load Balancer object.
		/// Load_balancers_idGet load_balancers/{id}
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		/// <returns>The `load_balancer` key contains the Load Balancer</returns>
		public async Task<Load_balancers_idGetReturn> Load_balancers_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Load_balancers_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Load Balancer
		/// Updates a Load Balancer. You can update a Load Balancer’s name and a Load Balancer’s labels.
		/// 
		/// Note that when updating labels, the Load Balancer’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// 
		/// Note: if the Load Balancer object changes during the request, the response will be a “conflict” error.
		/// 
		/// Load_balancers_idPut load_balancers/{id}
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		/// <returns>The `load_balancer` key contains the updated Load Balancer</returns>
		public async Task<Load_balancers_idPutReturn> Load_balancers_idPutAsync(int id, Load_balancers_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Load_balancers_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all Actions for a Load Balancer
		/// Returns all Action objects for a Load Balancer. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter.
		/// Load_balancers_idActionsGetBySortAndStatus load_balancers/{id}/actions
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times, the response will contain only Actions with specified statuses</param>
		/// <returns>The `actions` key contains a list of Actions</returns>
		public async Task<Load_balancers_idActionsGetBySortAndStatusReturn> Load_balancers_idActionsGetBySortAndStatusAsync(int id, Load_balancers_idActionsGetBySortAndStatusSort sort, ActionsGetByIdAndSortAndStatusStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions?sort=" + sort+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Load_balancers_idActionsGetBySortAndStatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add Service
		/// Adds a service to a Load Balancer.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                       | Description                                             |
		/// |----------------------------|---------------------------------------------------------|
		/// | `source_port_already_used` | The source port you are trying to add is already in use |
		/// 
		/// Load_balancers_idActionsAdd_servicePost load_balancers/{id}/actions/add_service
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsAdd_servicePostAsync(int id, Load_balancers_idActionsAdd_servicePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/add_service";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add Target
		/// Adds a target to a Load Balancer.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                                    | Description                                                                                           |
		/// |-----------------------------------------|-------------------------------------------------------------------------------------------------------|
		/// | `cloud_resource_ip_not_allowed`         | The IP you are trying to add as a target belongs to a Hetzner Cloud resource                          |
		/// | `ip_not_owned`                          | The IP you are trying to add as a target is not owned by the Project owner                            |
		/// | `load_balancer_not_attached_to_network` | The Load Balancer is not attached to a network                                                        |
		/// | `robot_unavailable`                     | Robot was not available. The caller may retry the operation after a short delay.                      |
		/// | `server_not_attached_to_network`        | The server you are trying to add as a target is not attached to the same network as the Load Balancer |
		/// | `target_already_defined`                | The Load Balancer target you are trying to define is already defined                                  |
		/// 
		/// Load_balancers_idActionsAdd_targetPost load_balancers/{id}/actions/add_target
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsAdd_targetPostAsync(int id, Load_balancers_idActionsAdd_targetPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/add_target";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Attach a Load Balancer to a Network
		/// Attach a Load Balancer to a Network.
		/// 
		/// **Call specific error codes**
		/// 
		/// | Code                             | Description                                                           |
		/// |----------------------------------|-----------------------------------------------------------------------|
		/// | `load_balancer_already_attached` | The Load Balancer is already attached to a network                    |
		/// | `ip_not_available`               | The provided Network IP is not available                              |
		/// | `no_subnet_available`            | No Subnet or IP is available for the Load Balancer within the network |
		/// 
		/// Load_balancers_idActionsAttach_to_networkPost load_balancers/{id}/actions/attach_to_network
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsAttach_to_networkPostAsync(int id, Load_balancers_idActionsAttach_to_networkPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/attach_to_network";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change Algorithm
		/// Change the algorithm that determines to which target new requests are sent.
		/// Load_balancers_idActionsChange_algorithmPost load_balancers/{id}/actions/change_algorithm
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsChange_algorithmPostAsync(int id, Load_balancers_idActionsChange_algorithmPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/change_algorithm";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change reverse DNS entry for this Load Balancer
		/// Changes the hostname that will appear when getting the hostname belonging to the public IPs (IPv4 and IPv6) of this Load Balancer.
		/// 
		/// Floating IPs assigned to the Server are not affected by this.
		/// 
		/// Load_balancers_idActionsChange_dns_ptrPost load_balancers/{id}/actions/change_dns_ptr
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		/// <param name="requestBody">Select the IP address for which to change the DNS entry by passing `ip`. It can be either IPv4 or IPv6. The target hostname is set by passing `dns_ptr`.</param>
		public async Task Load_balancers_idActionsChange_dns_ptrPostAsync(int id, Load_balancers_idActionsChange_dns_ptrPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/change_dns_ptr";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change Load Balancer Protection
		/// Changes the protection configuration of a Load Balancer.
		/// Load_balancers_idActionsChange_protectionPost load_balancers/{id}/actions/change_protection
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsChange_protectionPostAsync(int id, Load_balancers_idActionsChange_protectionPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/change_protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change the Type of a Load Balancer
		/// Changes the type (Max Services, Max Targets and Max Connections) of a Load Balancer.
		/// 
		/// **Call specific error codes**
		/// 
		/// | Code                         | Description                                                     |
		/// |------------------------------|-----------------------------------------------------------------|
		/// | `invalid_load_balancer_type` | The Load Balancer type does not fit for the given Load Balancer |
		/// 
		/// Load_balancers_idActionsChange_typePost load_balancers/{id}/actions/change_type
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsChange_typePostAsync(int id, Load_balancers_idActionsChange_typePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/change_type";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete Service
		/// Delete a service of a Load Balancer.
		/// Load_balancers_idActionsDelete_servicePost load_balancers/{id}/actions/delete_service
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsDelete_servicePostAsync(int id, Load_balancers_idActionsDelete_servicePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/delete_service";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Detach a Load Balancer from a Network
		/// Detaches a Load Balancer from a network.
		/// Load_balancers_idActionsDetach_from_networkPost load_balancers/{id}/actions/detach_from_network
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsDetach_from_networkPostAsync(int id, Load_balancers_idActionsDetach_from_networkPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/detach_from_network";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Disable the public interface of a Load Balancer
		/// Disable the public interface of a Load Balancer. The Load Balancer will be not accessible from the internet via its public IPs.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                                      | Description                                                                    |
		/// |-------------------------------------------|--------------------------------------------------------------------------------|
		/// | `load_balancer_not_attached_to_network`   |  The Load Balancer is not attached to a network                                |
		/// | `targets_without_use_private_ip`          | The Load Balancer has targets that use the public IP instead of the private IP |
		/// 
		/// Load_balancers_idActionsDisable_public_interfacePost load_balancers/{id}/actions/disable_public_interface
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsDisable_public_interfacePostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/disable_public_interface";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable the public interface of a Load Balancer
		/// Enable the public interface of a Load Balancer. The Load Balancer will be accessible from the internet via its public IPs.
		/// Load_balancers_idActionsEnable_public_interfacePost load_balancers/{id}/actions/enable_public_interface
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsEnable_public_interfacePostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/enable_public_interface";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Remove Target
		/// Removes a target from a Load Balancer.
		/// Load_balancers_idActionsRemove_targetPost load_balancers/{id}/actions/remove_target
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsRemove_targetPostAsync(int id, Load_balancers_idActionsRemove_targetPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/remove_target";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Update Service
		/// Updates a Load Balancer Service.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                       | Description                                             |
		/// |----------------------------|---------------------------------------------------------|
		/// | `source_port_already_used` | The source port you are trying to add is already in use |
		/// 
		/// Load_balancers_idActionsUpdate_servicePost load_balancers/{id}/actions/update_service
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		public async Task Load_balancers_idActionsUpdate_servicePostAsync(int id, Load_balancers_idActionsUpdate_servicePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/update_service";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get an Action for a Load Balancer
		/// Returns a specific Action for a Load Balancer.
		/// Load_balancers_idActions_action_idGet load_balancers/{id}/actions/{action_id}
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		/// <param name="action_id">ID of the Action</param>
		/// <returns>The `action` key contains the Load Balancer Action</returns>
		public async Task<Load_balancers_idActions_action_idGetReturn> Load_balancers_idActions_action_idGetAsync(int id, int action_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/actions/"+action_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Load_balancers_idActions_action_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Metrics for a LoadBalancer
		/// You must specify the type of metric to get: `open_connections`, `connections_per_second`, `requests_per_second` or `bandwidth`. You can also specify more than one type by comma separation, e.g. `requests_per_second,bandwidth`.
		/// 
		/// Depending on the type you will get different time series data:
		/// 
		/// |Type | Timeseries | Unit | Description |
		/// |---- |------------|------|-------------|
		/// | open_connections | open_connections | number | Open connections |
		/// | connections_per_second | connections_per_second | connections/s | Connections per second |
		/// | requests_per_second | requests_per_second | requests/s | Requests per second |
		/// | bandwidth | bandwidth.in | bytes/s | Ingress bandwidth |
		/// || bandwidth.out | bytes/s | Egress bandwidth |
		/// 
		/// Metrics are available for the last 30 days only.
		/// 
		/// If you do not provide the step argument we will automatically adjust it so that 200 samples are returned.
		/// 
		/// We limit the number of samples to a maximum of 500 and will adjust the step parameter accordingly.
		/// 
		/// Load_balancers_idMetricsGetByTypeAndStartAndEndAndStep load_balancers/{id}/metrics
		/// </summary>
		/// <param name="id">ID of the Load Balancer</param>
		/// <param name="type">Type of metrics to get</param>
		/// <param name="start">Start of period to get Metrics for (in ISO-8601 format)</param>
		/// <param name="end">End of period to get Metrics for (in ISO-8601 format)</param>
		/// <param name="step">Resolution of results in seconds</param>
		/// <returns>The `metrics` key in the reply contains a metrics object with this structure</returns>
		public async Task<Load_balancers_idMetricsGetByTypeAndStartAndEndAndStepReturn> Load_balancers_idMetricsGetByTypeAndStartAndEndAndStepAsync(int id, Load_balancers_idMetricsGetByTypeAndStartAndEndAndStepType type, string start, string end, string step, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "load_balancers/"+id+"/metrics?type=" + type+"&start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&end=" + (end==null? "" : System.Uri.EscapeDataString(end))+"&step=" + (step==null? "" : System.Uri.EscapeDataString(step));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Load_balancers_idMetricsGetByTypeAndStartAndEndAndStepReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Locations
		/// Returns all Location objects.
		/// LocationsGetByName locations
		/// </summary>
		/// <param name="name">Can be used to filter Locations by their name. The response will only contain the Location matching the specified name.</param>
		/// <returns>The `locations` key in the reply contains an array of Location objects with this structure</returns>
		public async Task<LocationsGetByNameReturn> LocationsGetByNameAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations?name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LocationsGetByNameReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Location
		/// Returns a specific Location object.
		/// Locations_idGet locations/{id}
		/// </summary>
		/// <param name="id">ID of Location</param>
		/// <returns>The `location` key in the reply contains a Location object with this structure</returns>
		public async Task<Locations_idGetReturn> Locations_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Locations_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Networks
		/// Gets all existing networks that you have available.
		/// NetworksGetByNameAndLabel_selector networks
		/// </summary>
		/// <param name="name">Can be used to filter networks by their name. The response will only contain the networks matching the specified name.</param>
		/// <param name="label_selector">Can be used to filter networks by labels. The response will only contain networks with a matching label selector pattern.</param>
		/// <returns>The `networks` key contains a list of networks</returns>
		public async Task<NetworksGetByNameAndLabel_selectorReturn> NetworksGetByNameAndLabel_selectorAsync(string name, string label_selector, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworksGetByNameAndLabel_selectorReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a Network
		/// Creates a network with the specified `ip_range`.
		/// 
		/// You may specify one or more `subnets`. You can also add more Subnets later by using the [add subnet action](https://docs.hetzner.cloud/#network-actions-add-a-subnet-to-a-network). If you do not specify an `ip_range` in the subnet we will automatically pick the first available /24 range for you.
		/// 
		/// You may specify one or more routes in `routes`. You can also add more routes later by using the [add route action](https://docs.hetzner.cloud/#network-actions-add-a-route-to-a-network).
		/// 
		/// NetworksPost networks
		/// </summary>
		public async Task NetworksPostAsync(NetworksPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a Network
		/// Deletes a network. If there are Servers attached they will be detached in the background.
		/// 
		/// Note: if the network object changes during the request, the response will be a “conflict” error.
		/// 
		/// Networks_idDelete networks/{id}
		/// </summary>
		/// <param name="id">ID of the network</param>
		public async Task Networks_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Network
		/// Gets a specific network object.
		/// Networks_idGet networks/{id}
		/// </summary>
		/// <param name="id">ID of the network</param>
		/// <returns>The `network` key contains the network</returns>
		public async Task<Networks_idGetReturn> Networks_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Networks_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Network
		/// Updates the network properties.
		/// 
		/// Note that when updating labels, the network’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// 
		/// Note: if the network object changes during the request, the response will be a “conflict” error.
		/// 
		/// Networks_idPut networks/{id}
		/// </summary>
		/// <param name="id">ID of the network</param>
		/// <returns>The `network` key contains the updated network</returns>
		public async Task<Networks_idPutReturn> Networks_idPutAsync(int id, Networks_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Networks_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all Actions for a Network
		/// Returns all Action objects for a Network. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter.
		/// Networks_idActionsGetBySortAndStatus networks/{id}/actions
		/// </summary>
		/// <param name="id">ID of the Network</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times, the response will contain only Actions with specified statuses</param>
		/// <returns>The `actions` key contains a list of Actions</returns>
		public async Task<Networks_idActionsGetBySortAndStatusReturn> Networks_idActionsGetBySortAndStatusAsync(int id, Networks_idActionsGetBySortAndStatusSort sort, ActionsGetByIdAndSortAndStatusStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id+"/actions?sort=" + sort+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Networks_idActionsGetBySortAndStatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a route to a Network
		/// Adds a route entry to a Network.
		/// 
		/// Note: if the Network object changes during the request, the response will be a “conflict” error.
		/// 
		/// Networks_idActionsAdd_routePost networks/{id}/actions/add_route
		/// </summary>
		/// <param name="id">ID of the Network</param>
		public async Task Networks_idActionsAdd_routePostAsync(int id, Networks_idActionsAdd_routePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id+"/actions/add_route";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add a subnet to a Network
		/// Adds a new subnet object to the Network. If you do not specify an `ip_range` for the subnet we will automatically pick the first available /24 range for you if possible.
		/// 
		/// Note: if the parent Network object changes during the request, the response will be a “conflict” error.
		/// 
		/// Networks_idActionsAdd_subnetPost networks/{id}/actions/add_subnet
		/// </summary>
		/// <param name="id">ID of the Network</param>
		public async Task Networks_idActionsAdd_subnetPostAsync(int id, Networks_idActionsAdd_subnetPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id+"/actions/add_subnet";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change IP range of a Network
		/// Changes the IP range of a Network. IP ranges can only be extended and never shrunk. You can only add IPs at the end of an existing IP range. This means that the IP part of your existing range must stay the same and you can only change its netmask.
		/// 
		/// For example if you have a range `10.0.0.0/16` you want to extend then your new range must also start with the IP `10.0.0.0`. Your CIDR netmask `/16` may change to a number that is smaller than `16` thereby increasing the IP range. So valid entries would be `10.0.0.0/15`, `10.0.0.0/14`, `10.0.0.0/13` and so on.
		/// 
		/// After changing the IP range you will have to adjust the routes on your connected Servers by either rebooting them or manually changing the routes to your private Network interface.
		/// 
		/// Note: if the Network object changes during the request, the response will be a “conflict” error.
		/// 
		/// Networks_idActionsChange_ip_rangePost networks/{id}/actions/change_ip_range
		/// </summary>
		/// <param name="id">ID of the Network</param>
		public async Task Networks_idActionsChange_ip_rangePostAsync(int id, Networks_idActionsChange_ip_rangePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id+"/actions/change_ip_range";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change Network Protection
		/// Changes the protection configuration of a Network.
		/// 
		/// Note: if the Network object changes during the request, the response will be a “conflict” error.
		/// 
		/// Networks_idActionsChange_protectionPost networks/{id}/actions/change_protection
		/// </summary>
		/// <param name="id">ID of the Network</param>
		public async Task Networks_idActionsChange_protectionPostAsync(int id, Networks_idActionsChange_protectionPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id+"/actions/change_protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a route from a Network
		/// Delete a route entry from a Network.
		/// 
		/// Note: if the Network object changes during the request, the response will be a “conflict” error.
		/// 
		/// Networks_idActionsDelete_routePost networks/{id}/actions/delete_route
		/// </summary>
		/// <param name="id">ID of the Network</param>
		public async Task Networks_idActionsDelete_routePostAsync(int id, Networks_idActionsDelete_routePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id+"/actions/delete_route";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a subnet from a Network
		/// Deletes a single subnet entry from a Network. You cannot delete subnets which still have Servers attached. If you have Servers attached you first need to detach all Servers that use IPs from this subnet before you can delete the subnet.
		/// 
		/// Note: if the Network object changes during the request, the response will be a “conflict” error.
		/// 
		/// Networks_idActionsDelete_subnetPost networks/{id}/actions/delete_subnet
		/// </summary>
		/// <param name="id">ID of the Network</param>
		public async Task Networks_idActionsDelete_subnetPostAsync(int id, Networks_idActionsDelete_subnetPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id+"/actions/delete_subnet";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get an Action for a Network
		/// Returns a specific Action for a Network.
		/// Networks_idActions_action_idGet networks/{id}/actions/{action_id}
		/// </summary>
		/// <param name="id">ID of the Network</param>
		/// <param name="action_id">ID of the Action</param>
		/// <returns>The `action` key contains the Network Action</returns>
		public async Task<Networks_idActions_action_idGetReturn> Networks_idActions_action_idGetAsync(int id, int action_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "networks/"+id+"/actions/"+action_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Networks_idActions_action_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all PlacementGroups
		/// Returns all PlacementGroup objects.
		/// Placement_groupsGetBySortAndNameAndLabel_selectorAndType placement_groups
		/// </summary>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="name">Can be used to filter resources by their name. The response will only contain the resources matching the specified name</param>
		/// <param name="label_selector">Can be used to filter resources by labels. The response will only contain resources matching the label selector.</param>
		/// <param name="type">Can be used multiple times. The response will only contain PlacementGroups matching the type.</param>
		/// <returns>The `placement_groups` key contains an array of PlacementGroup objects</returns>
		public async Task<Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeReturn> Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeAsync(Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeSort sort, string name, string label_selector, Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "placement_groups?sort=" + sort+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector))+"&type=" + type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a PlacementGroup
		/// Creates a new PlacementGroup.
		/// 
		/// Placement_groupsPost placement_groups
		/// </summary>
		public async Task Placement_groupsPostAsync(Placement_groupsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "placement_groups";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a PlacementGroup
		/// Deletes a PlacementGroup.
		/// Placement_groups_idDelete placement_groups/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		public async Task Placement_groups_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "placement_groups/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a PlacementGroup
		/// Gets a specific PlacementGroup object.
		/// Placement_groups_idGet placement_groups/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		/// <returns>The `placement_group` key contains a PlacementGroup object</returns>
		public async Task<Placement_groups_idGetReturn> Placement_groups_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "placement_groups/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Placement_groups_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a PlacementGroup
		/// Updates the PlacementGroup properties.
		/// 
		/// Note that when updating labels, the PlacementGroup’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// 
		/// Note: if the PlacementGroup object changes during the request, the response will be a “conflict” error.
		/// 
		/// Placement_groups_idPut placement_groups/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		/// <returns>The `certificate` key contains the PlacementGroup that was just updated</returns>
		public async Task<Placement_groups_idPutReturn> Placement_groups_idPutAsync(int id, Placement_groups_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "placement_groups/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Placement_groups_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all prices
		/// Returns prices for all resources available on the platform. VAT and currency of the Project owner are used for calculations.
		/// 
		/// Both net and gross prices are included in the response.
		/// 
		/// PricingGet pricing
		/// </summary>
		/// <returns>The `pricing` key in the reply contains an pricing object with this structure</returns>
		public async Task<PricingGetReturn> PricingGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PricingGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Primary IPs
		/// Returns all Primary IP objects.
		/// Primary_ipsGetByNameAndLabel_selectorAndIpAndSort primary_ips
		/// </summary>
		/// <param name="name">Can be used to filter resources by their name. The response will only contain the resources matching the specified name</param>
		/// <param name="label_selector">Can be used to filter resources by labels. The response will only contain resources matching the label selector.</param>
		/// <param name="ip">Can be used to filter resources by their ip. The response will only contain the resources matching the specified ip.</param>
		/// <param name="sort">Can be used multiple times. Choices id id:asc id:desc created created:asc created:desc</param>
		/// <returns>The `primary_ips` key contains an array of Primary IP objects</returns>
		public async Task<Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturn> Primary_ipsGetByNameAndLabel_selectorAndIpAndSortAsync(string name, string label_selector, string ip, Primary_ipsGetByNameAndLabel_selectorAndIpAndSortSort sort, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "primary_ips?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector))+"&ip=" + (ip==null? "" : System.Uri.EscapeDataString(ip))+"&sort=" + sort;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a Primary IP
		/// Creates a new Primary IP, optionally assigned to a Server.
		/// 
		/// If you want to create a Primary IP that is not assigned to a Server, you need to provide the `datacenter` key instead of `assignee_id`. This can be either the ID or the name of the Datacenter this Primary IP shall be created in.
		/// 
		/// Note that a Primary IP can only be assigned to a Server in the same Datacenter later on.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                          | Description                                                   |
		/// |------------------------------ |-------------------------------------------------------------- |
		/// | `server_not_stopped`          | The specified server is running, but needs to be powered off  |
		/// | `server_has_ipv4`             | The server already has an ipv4 address                        |
		/// | `server_has_ipv6`             | The server already has an ipv6 address                        |
		/// 
		/// Primary_ipsPost primary_ips
		/// </summary>
		/// <param name="requestBody">The `type` argument is required while `datacenter` and `assignee_id` are mutually exclusive.</param>
		public async Task Primary_ipsPostAsync(Primary_ipsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "primary_ips";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a Primary IP
		/// Deletes a Primary IP.
		/// 
		/// The Primary IP may be assigned to a Server. In this case it is unassigned automatically. The Server must be powered off (status `off`) in order for this operation to succeed.
		/// 
		/// Primary_ips_idDelete primary_ips/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		public async Task Primary_ips_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "primary_ips/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Primary IP
		/// Returns a specific Primary IP object.
		/// Primary_ips_idGet primary_ips/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		/// <returns>The `primary_ip` key contains a Primary IP object</returns>
		public async Task<Primary_ips_idGetReturn> Primary_ips_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "primary_ips/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Primary_ips_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Primary IP
		/// Updates the Primary IP.
		/// 
		/// Note that when updating labels, the Primary IP's current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// 
		/// If the Primary IP object changes during the request, the response will be a “conflict” error.
		/// 
		/// Primary_ips_idPut primary_ips/{id}
		/// </summary>
		/// <param name="id">ID of the resource</param>
		/// <returns>The `primary_ip` key contains the Primary IP that was just updated</returns>
		public async Task<Primary_ips_idPutReturn> Primary_ips_idPutAsync(int id, Primary_ips_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "primary_ips/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Primary_ips_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Assign a Primary IP to a resource
		/// Assigns a Primary IP to a Server.
		/// 
		/// A Server can only have one Primary IP of type `ipv4` and one of type `ipv6` assigned. If you need more IPs use Floating IPs.
		/// 
		/// The Server must be powered off (status `off`) in order for this operation to succeed.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                          | Description                                                   |
		/// |------------------------------ |-------------------------------------------------------------- |
		/// | `server_not_stopped`          | The server is running, but needs to be powered off            |
		/// | `primary_ip_already_assigned` | Primary ip is already assigned to a different server          |
		/// | `server_has_ipv4`             | The server already has an ipv4 address                        |
		/// | `server_has_ipv6`             | The server already has an ipv6 address                        |
		/// 
		/// Primary_ips_idActionsAssignPost primary_ips/{id}/actions/assign
		/// </summary>
		/// <param name="id">ID of the Primary IP</param>
		public async Task Primary_ips_idActionsAssignPostAsync(int id, Primary_ips_idActionsAssignPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "primary_ips/"+id+"/actions/assign";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change reverse DNS entry for a Primary IP
		/// Changes the hostname that will appear when getting the hostname belonging to this Primary IP.
		/// Primary_ips_idActionsChange_dns_ptrPost primary_ips/{id}/actions/change_dns_ptr
		/// </summary>
		/// <param name="id">ID of the Primary IP</param>
		/// <param name="requestBody">Select the IP address for which to change the DNS entry by passing `ip`. For a Primary IP of type `ipv4` this must exactly match the IP address of the Primary IP. For a Primary IP of type `ipv6` this must be a single IP within the IPv6 /64 range that belongs to this Primary IP. You can add up to 100 IPv6 reverse DNS entries.
		///
		///The target hostname is set by passing `dns_ptr`.
		///</param>
		public async Task Primary_ips_idActionsChange_dns_ptrPostAsync(int id, Primary_ips_idActionsChange_dns_ptrPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "primary_ips/"+id+"/actions/change_dns_ptr";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change Primary IP Protection
		/// Changes the protection configuration of a Primary IP.
		/// 
		/// A Primary IP can only be delete protected if its `auto_delete` property is set to `false`.
		/// 
		/// Primary_ips_idActionsChange_protectionPost primary_ips/{id}/actions/change_protection
		/// </summary>
		/// <param name="id">ID of the Primary IP</param>
		public async Task Primary_ips_idActionsChange_protectionPostAsync(int id, Primary_ips_idActionsChange_protectionPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "primary_ips/"+id+"/actions/change_protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Unassign a Primary IP from a resource
		/// Unassigns a Primary IP from a Server.
		/// 
		/// The Server must be powered off (status `off`) in order for this operation to succeed.
		/// 
		/// Note that only Servers that have at least one network interface (public or private) attached can be powered on.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                              | Description                                                   |
		/// |---------------------------------- |-------------------------------------------------------------- |
		/// | `server_not_stopped`              | The server is running, but needs to be powered off            |
		/// | `server_is_load_balancer_target`  | The server ipv4 address is a loadbalancer target              |
		/// 
		/// Primary_ips_idActionsUnassignPost primary_ips/{id}/actions/unassign
		/// </summary>
		/// <param name="id">ID of the Primary IP</param>
		public async Task Primary_ips_idActionsUnassignPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "primary_ips/"+id+"/actions/unassign";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Server Types
		/// Gets all Server type objects.
		/// Server_typesGetByName server_types
		/// </summary>
		/// <param name="name">Can be used to filter Server types by their name. The response will only contain the Server type matching the specified name.</param>
		/// <returns>The `server_types` key in the reply contains an array of Server type objects with this structure</returns>
		public async Task<Server_typesGetByNameReturn> Server_typesGetByNameAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "server_types?name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Server_typesGetByNameReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Server Type
		/// Gets a specific Server type object.
		/// Server_types_idGet server_types/{id}
		/// </summary>
		/// <param name="id">ID of Server Type</param>
		/// <returns>The `server_type` key in the reply contains a Server type object with this structure</returns>
		public async Task<Server_types_idGetReturn> Server_types_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "server_types/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Server_types_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all Servers
		/// Returns all existing Server objects
		/// ServersGetByNameAndLabel_selectorAndSortAndStatus servers
		/// </summary>
		/// <param name="name">Can be used to filter resources by their name. The response will only contain the resources matching the specified name</param>
		/// <param name="label_selector">Can be used to filter resources by labels. The response will only contain resources matching the label selector.</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times. The response will only contain Server matching the status</param>
		/// <returns>A paged array of servers</returns>
		public async Task<ServersGetByNameAndLabel_selectorAndSortAndStatusReturn> ServersGetByNameAndLabel_selectorAndSortAndStatusAsync(string name, string label_selector, ServersGetByNameAndLabel_selectorAndSortAndStatusSort sort, ServersGetByNameAndLabel_selectorAndSortAndStatusStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector))+"&sort=" + sort+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ServersGetByNameAndLabel_selectorAndSortAndStatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a Server
		/// Creates a new Server. Returns preliminary information about the Server as well as an Action that covers progress of creation.
		/// ServersPost servers
		/// </summary>
		/// <param name="requestBody">Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes).
		///
		///For `server_type` you can either use the ID as listed in `/server_types` or its name.
		///
		///For `image` you can either use the ID as listed in `/images` or its name.
		///
		///If you want to create the Server in a Location, you must set `location` to the ID or name as listed in `/locations`. This is the recommended way. You can be even more specific by setting `datacenter` to the ID or name as listed in `/datacenters`. However we only recommend this if you want to assign a specific Primary IP to the Server which is located in the specified Datacenter.
		///
		///Some properties like `start_after_create` or `automount` will trigger Actions after the Server is created. Those Actions are listed in the `next_actions` field in the response.
		///
		///For accessing your Server we strongly recommend to use SSH keys by passing the respective key IDs in `ssh_keys`. If you do not specify any `ssh_keys` we will generate a root password for you and return it in the response.
		///
		///Please note that provided user-data is stored in our systems. While we take measures to protect it we highly recommend that you don’t use it to store passwords or other sensitive information.
		///
		///#### Call specific error codes
		///
		///| Code                             | Description                                                |
		///|----------------------------------|------------------------------------------------------------|
		///| `placement_error`                | An error during the placement occurred                     |
		///| `primary_ip_assigned`            | The specified Primary IP is already assigned to a server   |
		///| `primary_ip_datacenter_mismatch` | The specified Primary IP is in a different datacenter      |
		///| `primary_ip_version_mismatch`    | The specified Primary IP has the wrong IP Version          |
		///</param>
		public async Task ServersPostAsync(ServersPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a Server
		/// Deletes a Server. This immediately removes the Server from your account, and it is no longer accessible.
		/// Servers_idDelete servers/{id}
		/// </summary>
		/// <param name="id">ID of the Server</param>
		/// <returns>The `action` key in the reply contains an Action object with this structure</returns>
		public async Task<Servers_idDeleteReturn> Servers_idDeleteAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Servers_idDeleteReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Server
		/// Returns a specific Server object. The Server must exist inside the Project
		/// Servers_idGet servers/{id}
		/// </summary>
		/// <param name="id">ID of the Server</param>
		/// <returns>The `server` key in the reply contains a Server object with this structure</returns>
		public async Task<Servers_idGetReturn> Servers_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Servers_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Server
		/// Updates a Server. You can update a Server’s name and a Server’s labels.
		/// Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes).
		/// Also note that when updating labels, the Server’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// Servers_idPut servers/{id}
		/// </summary>
		/// <param name="id">ID of the Server</param>
		/// <returns>The `server` key in the reply contains the updated Server</returns>
		public async Task<Servers_idPutReturn> Servers_idPutAsync(int id, Servers_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Servers_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all Actions for a Server
		/// Returns all Action objects for a Server. You can `sort` the results by using the sort URI parameter, and filter them with the `status` parameter.
		/// Servers_idActionsGetBySortAndStatus servers/{id}/actions
		/// </summary>
		/// <param name="id">ID of the Resource</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times, the response will contain only Actions with specified statuses</param>
		/// <returns>The `actions` key contains a list of Actions</returns>
		public async Task<Servers_idActionsGetBySortAndStatusReturn> Servers_idActionsGetBySortAndStatusAsync(int id, Servers_idActionsGetBySortAndStatusSort sort, ActionsGetByIdAndSortAndStatusStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions?sort=" + sort+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Servers_idActionsGetBySortAndStatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a Server to a Placement Group
		/// Adds a Server to a Placement Group.
		/// 
		/// Server must be powered off for this command to succeed.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                          | Description                                                          |
		/// |-------------------------------|----------------------------------------------------------------------|
		/// | `server_not_stopped`          | The action requires a stopped server                                 |
		/// 
		/// Servers_idActionsAdd_to_placement_groupPost servers/{id}/actions/add_to_placement_group
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsAdd_to_placement_groupPostAsync(int id, Servers_idActionsAdd_to_placement_groupPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/add_to_placement_group";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Attach an ISO to a Server
		/// Attaches an ISO to a Server. The Server will immediately see it as a new disk. An already attached ISO will automatically be detached before the new ISO is attached.
		/// 
		/// Servers with attached ISOs have a modified boot order: They will try to boot from the ISO first before falling back to hard disk.
		/// 
		/// Servers_idActionsAttach_isoPost servers/{id}/actions/attach_iso
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsAttach_isoPostAsync(int id, Servers_idActionsAttach_isoPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/attach_iso";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Attach a Server to a Network
		/// Attaches a Server to a network. This will complement the fixed public Server interface by adding an additional ethernet interface to the Server which is connected to the specified network.
		/// 
		/// The Server will get an IP auto assigned from a subnet of type `server` in the same `network_zone`.
		/// 
		/// Using the `alias_ips` attribute you can also define one or more additional IPs to the Servers. Please note that you will have to configure these IPs by hand on your Server since only the primary IP will be given out by DHCP.
		/// 
		/// **Call specific error codes**
		/// 
		/// | Code                             | Description                                                           |
		/// |----------------------------------|-----------------------------------------------------------------------|
		/// | `server_already_attached`        | The server is already attached to the network                         |
		/// | `ip_not_available`               | The provided Network IP is not available                              |
		/// | `no_subnet_available`            | No Subnet or IP is available for the Server within the network        |
		/// | `networks_overlap`               | The network IP range overlaps with one of the server networks         |
		/// 
		/// Servers_idActionsAttach_to_networkPost servers/{id}/actions/attach_to_network
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsAttach_to_networkPostAsync(int id, Servers_idActionsAttach_to_networkPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/attach_to_network";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change alias IPs of a Network
		/// Changes the alias IPs of an already attached Network. Note that the existing aliases for the specified Network will be replaced with these provided in the request body. So if you want to add an alias IP, you have to provide the existing ones from the Network plus the new alias IP in the request body.
		/// Servers_idActionsChange_alias_ipsPost servers/{id}/actions/change_alias_ips
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsChange_alias_ipsPostAsync(int id, Servers_idActionsChange_alias_ipsPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/change_alias_ips";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change reverse DNS entry for this Server
		/// Changes the hostname that will appear when getting the hostname belonging to the primary IPs (IPv4 and IPv6) of this Server.
		/// 
		/// Floating IPs assigned to the Server are not affected by this.
		/// 
		/// Servers_idActionsChange_dns_ptrPost servers/{id}/actions/change_dns_ptr
		/// </summary>
		/// <param name="id">ID of the Server</param>
		/// <param name="requestBody">Select the IP address for which to change the DNS entry by passing `ip`. It can be either IPv4 or IPv6. The target hostname is set by passing `dns_ptr`.</param>
		public async Task Servers_idActionsChange_dns_ptrPostAsync(int id, Servers_idActionsChange_dns_ptrPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/change_dns_ptr";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change Server Protection
		/// Changes the protection configuration of the Server.
		/// Servers_idActionsChange_protectionPost servers/{id}/actions/change_protection
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsChange_protectionPostAsync(int id, Servers_idActionsChange_protectionPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/change_protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change the Type of a Server
		/// Changes the type (Cores, RAM and disk sizes) of a Server.
		/// 
		/// Server must be powered off for this command to succeed.
		/// 
		/// This copies the content of its disk, and starts it again.
		/// 
		/// You can only migrate to Server types with the same `storage_type` and equal or bigger disks. Shrinking disks is not possible as it might destroy data.
		/// 
		/// If the disk gets upgraded, the Server type can not be downgraded any more. If you plan to downgrade the Server type, set `upgrade_disk` to `false`.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                          | Description                                                          |
		/// |-------------------------------|----------------------------------------------------------------------|
		/// | `invalid_server_type`         | The server type does not fit for the given server or is deprecated   |
		/// | `server_not_stopped`          | The action requires a stopped server                                 |
		/// 
		/// Servers_idActionsChange_typePost servers/{id}/actions/change_type
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsChange_typePostAsync(int id, Servers_idActionsChange_typePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/change_type";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Create Image from a Server
		/// Creates an Image (snapshot) from a Server by copying the contents of its disks. This creates a snapshot of the current state of the disk and copies it into an Image. If the Server is currently running you must make sure that its disk content is consistent. Otherwise, the created Image may not be readable.
		/// 
		/// To make sure disk content is consistent, we recommend to shut down the Server prior to creating an Image.
		/// 
		/// You can either create a `backup` Image that is bound to the Server and therefore will be deleted when the Server is deleted, or you can create an `snapshot` Image which is completely independent of the Server it was created from and will survive Server deletion. Backup Images are only available when the backup option is enabled for the Server. Snapshot Images are billed on a per GB basis.
		/// 
		/// Servers_idActionsCreate_imagePost servers/{id}/actions/create_image
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsCreate_imagePostAsync(int id, Servers_idActionsCreate_imagePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/create_image";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Detach a Server from a Network
		/// Detaches a Server from a network. The interface for this network will vanish.
		/// Servers_idActionsDetach_from_networkPost servers/{id}/actions/detach_from_network
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsDetach_from_networkPostAsync(int id, Servers_idActionsDetach_from_networkPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/detach_from_network";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Detach an ISO from a Server
		/// Detaches an ISO from a Server. In case no ISO Image is attached to the Server, the status of the returned Action is immediately set to `success`
		/// Servers_idActionsDetach_isoPost servers/{id}/actions/detach_iso
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsDetach_isoPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/detach_iso";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable Backups for a Server
		/// Disables the automatic backup option and deletes all existing Backups for a Server. No more additional charges for backups will be made.
		/// 
		/// Caution: This immediately removes all existing backups for the Server!
		/// 
		/// Servers_idActionsDisable_backupPost servers/{id}/actions/disable_backup
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsDisable_backupPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/disable_backup";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable Rescue Mode for a Server
		/// Disables the Hetzner Rescue System for a Server. This makes a Server start from its disks on next reboot.
		/// 
		/// Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.
		/// 
		/// Disabling rescue mode will not reboot your Server — you will have to do this yourself.
		/// 
		/// Servers_idActionsDisable_rescuePost servers/{id}/actions/disable_rescue
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsDisable_rescuePostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/disable_rescue";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable and Configure Backups for a Server
		/// Enables and configures the automatic daily backup option for the Server. Enabling automatic backups will increase the price of the Server by 20%. In return, you will get seven slots where Images of type backup can be stored.
		/// 
		/// Backups are automatically created daily.
		/// 
		/// Servers_idActionsEnable_backupPost servers/{id}/actions/enable_backup
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsEnable_backupPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/enable_backup";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable Rescue Mode for a Server
		/// Enable the Hetzner Rescue System for this Server. The next time a Server with enabled rescue mode boots it will start a special minimal Linux distribution designed for repair and reinstall.
		/// 
		/// In case a Server cannot boot on its own you can use this to access a Server’s disks.
		/// 
		/// Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.
		/// 
		/// Enabling rescue mode will not [reboot](https://docs.hetzner.cloud/#server-actions-soft-reboot-a-server) your Server — you will have to do this yourself.
		/// 
		/// Servers_idActionsEnable_rescuePost servers/{id}/actions/enable_rescue
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsEnable_rescuePostAsync(int id, Servers_idActionsEnable_rescuePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/enable_rescue";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Power off a Server
		/// Cuts power to the Server. This forcefully stops it without giving the Server operating system time to gracefully stop. May lead to data loss, equivalent to pulling the power cord. Power off should only be used when shutdown does not work.
		/// Servers_idActionsPoweroffPost servers/{id}/actions/poweroff
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsPoweroffPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/poweroff";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Power on a Server
		/// Starts a Server by turning its power on.
		/// Servers_idActionsPoweronPost servers/{id}/actions/poweron
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsPoweronPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/poweron";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Soft-reboot a Server
		/// Reboots a Server gracefully by sending an ACPI request. The Server operating system must support ACPI and react to the request, otherwise the Server will not reboot.
		/// Servers_idActionsRebootPost servers/{id}/actions/reboot
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsRebootPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/reboot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Rebuild a Server from an Image
		/// Rebuilds a Server overwriting its disk with the content of an Image, thereby **destroying all data** on the target Server
		/// 
		/// The Image can either be one you have created earlier (`backup` or `snapshot` Image) or it can be a completely fresh `system` Image provided by us. You can get a list of all available Images with `GET /images`.
		/// 
		/// Your Server will automatically be powered off before the rebuild command executes.
		/// 
		/// Servers_idActionsRebuildPost servers/{id}/actions/rebuild
		/// </summary>
		/// <param name="id">ID of the Server</param>
		/// <param name="requestBody">To select which Image to rebuild from you can either pass an ID or a name as the `image` argument. Passing a name only works for `system` Images since the other Image types do not have a name set.</param>
		public async Task Servers_idActionsRebuildPostAsync(int id, Servers_idActionsRebuildPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/rebuild";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Remove from Placement Group
		/// Removes a Server from a Placement Group.
		/// 
		/// Servers_idActionsRemove_from_placement_groupPost servers/{id}/actions/remove_from_placement_group
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsRemove_from_placement_groupPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/remove_from_placement_group";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Request Console for a Server
		/// Requests credentials for remote access via VNC over websocket to keyboard, monitor, and mouse for a Server. The provided URL is valid for 1 minute, after this period a new url needs to be created to connect to the Server. How long the connection is open after the initial connect is not subject to this timeout.
		/// Servers_idActionsRequest_consolePost servers/{id}/actions/request_console
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsRequest_consolePostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/request_console";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset a Server
		/// Cuts power to a Server and starts it again. This forcefully stops it without giving the Server operating system time to gracefully stop. This may lead to data loss, it’s equivalent to pulling the power cord and plugging it in again. Reset should only be used when reboot does not work.
		/// Servers_idActionsResetPost servers/{id}/actions/reset
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsResetPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/reset";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset root Password of a Server
		/// Resets the root password. Only works for Linux systems that are running the qemu guest agent. Server must be powered on (status `running`) in order for this operation to succeed.
		/// 
		/// This will generate a new password for this Server and return it.
		/// 
		/// If this does not succeed you can use the rescue system to netboot the Server and manually change your Server password by hand.
		/// 
		/// Servers_idActionsReset_passwordPost servers/{id}/actions/reset_password
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsReset_passwordPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/reset_password";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Shutdown a Server
		/// Shuts down a Server gracefully by sending an ACPI shutdown request. The Server operating system must support ACPI and react to the request, otherwise the Server will not shut down.
		/// Servers_idActionsShutdownPost servers/{id}/actions/shutdown
		/// </summary>
		/// <param name="id">ID of the Server</param>
		public async Task Servers_idActionsShutdownPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/shutdown";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get an Action for a Server
		/// Returns a specific Action object for a Server.
		/// Servers_idActions_action_idGet servers/{id}/actions/{action_id}
		/// </summary>
		/// <param name="id">ID of the Server</param>
		/// <param name="action_id">ID of the Action</param>
		/// <returns>The `action` key in the reply has this structure</returns>
		public async Task<Servers_idActions_action_idGetReturn> Servers_idActions_action_idGetAsync(int id, int action_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/actions/"+action_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Servers_idActions_action_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Metrics for a Server
		/// Get Metrics for specified Server.
		/// 
		/// You must specify the type of metric to get: cpu, disk or network. You can also specify more than one type by comma separation, e.g. cpu,disk.
		/// 
		/// Depending on the type you will get different time series data
		/// 
		/// | Type    | Timeseries              | Unit      | Description                                          |
		/// |---------|-------------------------|-----------|------------------------------------------------------|
		/// | cpu     | cpu                     | percent   | Percent CPU usage                                    |
		/// | disk    | disk.0.iops.read        | iop/s     | Number of read IO operations per second              |
		/// |         | disk.0.iops.write       | iop/s     | Number of write IO operations per second             |
		/// |         | disk.0.bandwidth.read   | bytes/s   | Bytes read per second                                |
		/// |         | disk.0.bandwidth.write  | bytes/s   | Bytes written per second                             |
		/// | network | network.0.pps.in        | packets/s | Public Network interface packets per second received |
		/// |         | network.0.pps.out       | packets/s | Public Network interface packets per second sent     |
		/// |         | network.0.bandwidth.in  | bytes/s   | Public Network interface bytes/s received            |
		/// |         | network.0.bandwidth.out | bytes/s   | Public Network interface bytes/s sent                |
		/// 
		/// Metrics are available for the last 30 days only.
		/// 
		/// If you do not provide the step argument we will automatically adjust it so that a maximum of 200 samples are returned.
		/// 
		/// We limit the number of samples returned to a maximum of 500 and will adjust the step parameter accordingly.
		/// 
		/// Servers_idMetricsGetByTypeAndStartAndEndAndStep servers/{id}/metrics
		/// </summary>
		/// <param name="id">ID of the Server</param>
		/// <param name="type">Type of metrics to get</param>
		/// <param name="start">Start of period to get Metrics for (in ISO-8601 format)</param>
		/// <param name="end">End of period to get Metrics for (in ISO-8601 format)</param>
		/// <param name="step">Resolution of results in seconds</param>
		/// <returns>The `metrics` key in the reply contains a metrics object with this structure</returns>
		public async Task<Servers_idMetricsGetByTypeAndStartAndEndAndStepReturn> Servers_idMetricsGetByTypeAndStartAndEndAndStepAsync(int id, Servers_idMetricsGetByTypeAndStartAndEndAndStepType type, string start, string end, string step, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "servers/"+id+"/metrics?type=" + type+"&start=" + (start==null? "" : System.Uri.EscapeDataString(start))+"&end=" + (end==null? "" : System.Uri.EscapeDataString(end))+"&step=" + (step==null? "" : System.Uri.EscapeDataString(step));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Servers_idMetricsGetByTypeAndStartAndEndAndStepReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all SSH keys
		/// Returns all SSH key objects.
		/// Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selector ssh_keys
		/// </summary>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="name">Can be used to filter resources by their name. The response will only contain the resources matching the specified name</param>
		/// <param name="fingerprint">Can be used to filter SSH keys by their fingerprint. The response will only contain the SSH key matching the specified fingerprint.</param>
		/// <param name="label_selector">Can be used to filter resources by labels. The response will only contain resources matching the label selector.</param>
		/// <returns>The `ssh_keys` key in the reply contains an array of SSH key objects with this structure</returns>
		public async Task<Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorReturn> Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorAsync(Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorSort sort, string name, string fingerprint, string label_selector, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ssh_keys?sort=" + sort+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&fingerprint=" + (fingerprint==null? "" : System.Uri.EscapeDataString(fingerprint))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an SSH key
		/// Creates a new SSH key with the given `name` and `public_key`. Once an SSH key is created, it can be used in other calls such as creating Servers.
		/// Ssh_keysPost ssh_keys
		/// </summary>
		public async Task Ssh_keysPostAsync(Ssh_keysPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ssh_keys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete an SSH key
		/// Deletes an SSH key. It cannot be used anymore.
		/// Ssh_keys_idDelete ssh_keys/{id}
		/// </summary>
		/// <param name="id">ID of the SSH key</param>
		public async Task Ssh_keys_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ssh_keys/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a SSH key
		/// Returns a specific SSH key object.
		/// Ssh_keys_idGet ssh_keys/{id}
		/// </summary>
		/// <param name="id">ID of the SSH key</param>
		/// <returns>The `ssh_key` key in the reply contains an SSH key object with this structure</returns>
		public async Task<Ssh_keys_idGetReturn> Ssh_keys_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ssh_keys/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Ssh_keys_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an SSH key
		/// Updates an SSH key. You can update an SSH key name and an SSH key labels.
		/// 
		/// Please note that when updating labels, the SSH key current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// 
		/// Ssh_keys_idPut ssh_keys/{id}
		/// </summary>
		/// <param name="id">ID of the SSH key</param>
		/// <returns>The `ssh_key` key in the reply contains the modified SSH key object with the new description</returns>
		public async Task<Ssh_keys_idPutReturn> Ssh_keys_idPutAsync(string id, Ssh_keys_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ssh_keys/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Ssh_keys_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all Volumes
		/// Gets all existing Volumes that you have available.
		/// VolumesGetByStatusAndSortAndNameAndLabel_selector volumes
		/// </summary>
		/// <param name="status">Can be used multiple times. The response will only contain Volumes matching the status.</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="name">Can be used to filter resources by their name. The response will only contain the resources matching the specified name</param>
		/// <param name="label_selector">Can be used to filter resources by labels. The response will only contain resources matching the label selector.</param>
		/// <returns>The `volumes` key contains a list of volumes</returns>
		public async Task<VolumesGetByStatusAndSortAndNameAndLabel_selectorReturn> VolumesGetByStatusAndSortAndNameAndLabel_selectorAsync(ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureStatus status, VolumesGetByStatusAndSortAndNameAndLabel_selectorSort sort, string name, string label_selector, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes?status=" + status+"&sort=" + sort+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&label_selector=" + (label_selector==null? "" : System.Uri.EscapeDataString(label_selector));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VolumesGetByStatusAndSortAndNameAndLabel_selectorReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a Volume
		/// Creates a new Volume attached to a Server. If you want to create a Volume that is not attached to a Server, you need to provide the `location` key instead of `server`. This can be either the ID or the name of the Location this Volume will be created in. Note that a Volume can be attached to a Server only in the same Location as the Volume itself.
		/// 
		/// Specifying the Server during Volume creation will automatically attach the Volume to that Server after it has been initialized. In that case, the `next_actions` key in the response is an array which contains a single `attach_volume` action.
		/// 
		/// The minimum Volume size is 10GB and the maximum size is 10TB (10240GB).
		/// 
		/// A volume’s name can consist of alphanumeric characters, dashes, underscores, and dots, but has to start and end with an alphanumeric character. The total length is limited to 64 characters. Volume names must be unique per Project.
		/// 
		/// #### Call specific error codes
		/// 
		/// | Code                                | Description                                         |
		/// |-------------------------------------|-----------------------------------------------------|
		/// | `no_space_left_in_location`         | There is no volume space left in the given location |
		/// 
		/// VolumesPost volumes
		/// </summary>
		public async Task VolumesPostAsync(VolumesPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a Volume
		/// Deletes a volume. All Volume data is irreversibly destroyed. The Volume must not be attached to a Server and it must not have delete protection enabled.
		/// Volumes_idDelete volumes/{id}
		/// </summary>
		/// <param name="id">ID of the Volume</param>
		public async Task Volumes_idDeleteAsync(string id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a Volume
		/// Gets a specific Volume object.
		/// Volumes_idGet volumes/{id}
		/// </summary>
		/// <param name="id">ID of the Volume</param>
		/// <returns>The `volume` key contains the volume</returns>
		public async Task<Volumes_idGetReturn> Volumes_idGetAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/"+id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Volumes_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a Volume
		/// Updates the Volume properties.
		/// 
		/// Note that when updating labels, the volume’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
		/// 
		/// Volumes_idPut volumes/{id}
		/// </summary>
		/// <param name="id">ID of the Volume to update</param>
		/// <returns>The `volume` key contains the updated volume</returns>
		public async Task<Volumes_idPutReturn> Volumes_idPutAsync(string id, Volumes_idPutPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/"+ (id==null? "" : System.Uri.EscapeDataString(id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Volumes_idPutReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get all Actions for a Volume
		/// Returns all Action objects for a Volume. You can `sort` the results by using the sort URI parameter, and filter them with the `status` parameter.
		/// Volumes_idActionsGetBySortAndStatus volumes/{id}/actions
		/// </summary>
		/// <param name="id">ID of the Volume</param>
		/// <param name="sort">Can be used multiple times.</param>
		/// <param name="status">Can be used multiple times, the response will contain only Actions with specified statuses</param>
		/// <returns>The `actions` key contains a list of Actions</returns>
		public async Task<Volumes_idActionsGetBySortAndStatusReturn> Volumes_idActionsGetBySortAndStatusAsync(int id, Volumes_idActionsGetBySortAndStatusSort sort, ActionsGetByIdAndSortAndStatusStatus status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/"+id+"/actions?sort=" + sort+"&status=" + status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Volumes_idActionsGetBySortAndStatusReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Attach Volume to a Server
		/// Attaches a Volume to a Server. Works only if the Server is in the same Location as the Volume.
		/// Volumes_idActionsAttachPost volumes/{id}/actions/attach
		/// </summary>
		/// <param name="id">ID of the Volume</param>
		public async Task Volumes_idActionsAttachPostAsync(int id, Volumes_idActionsAttachPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/"+id+"/actions/attach";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Change Volume Protection
		/// Changes the protection configuration of a Volume.
		/// Volumes_idActionsChange_protectionPost volumes/{id}/actions/change_protection
		/// </summary>
		/// <param name="id">ID of the Volume</param>
		public async Task Volumes_idActionsChange_protectionPostAsync(int id, Volumes_idActionsChange_protectionPostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/"+id+"/actions/change_protection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Detach Volume
		/// Detaches a Volume from the Server it’s attached to. You may attach it to a Server again at a later time.
		/// Volumes_idActionsDetachPost volumes/{id}/actions/detach
		/// </summary>
		/// <param name="id">ID of the Volume</param>
		public async Task Volumes_idActionsDetachPostAsync(int id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/"+id+"/actions/detach";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resize Volume
		/// Changes the size of a Volume. Note that downsizing a Volume is not possible.
		/// Volumes_idActionsResizePost volumes/{id}/actions/resize
		/// </summary>
		/// <param name="id">ID of the Volume</param>
		public async Task Volumes_idActionsResizePostAsync(int id, Volumes_idActionsResizePostPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/"+id+"/actions/resize";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get an Action for a Volume
		/// Returns a specific Action for a Volume.
		/// Volumes_idActions_action_idGet volumes/{id}/actions/{action_id}
		/// </summary>
		/// <param name="id">ID of the Volume</param>
		/// <param name="action_id">ID of the Action</param>
		/// <returns>The `action` key contains the Volume Action</returns>
		public async Task<Volumes_idActions_action_idGetReturn> Volumes_idActions_action_idGetAsync(int id, int action_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "volumes/"+id+"/actions/"+action_id;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Volumes_idActions_action_idGetReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum ActionsGetByIdAndSortAndStatusSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command")]
		command = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:asc")]
		commandasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:desc")]
		commanddesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status")]
		status = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:asc")]
		statusasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:desc")]
		statusdesc = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress")]
		progress = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:asc")]
		progressasc = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:desc")]
		progressdesc = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started")]
		started = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:asc")]
		startedasc = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:desc")]
		starteddesc = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished")]
		finished = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:asc")]
		finishedasc = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:desc")]
		finisheddesc = 17,
	}
	
	public enum ActionsGetByIdAndSortAndStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="running")]
		running = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="success")]
		success = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="error")]
		error = 2,
	}
	
	public class ActionsGetByIdAndSortAndStatusReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public ActionsGetByIdAndSortAndStatusReturnActions[] ActionsGetByIdAndSortAndStatusReturnActions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ActionsGetByIdAndSortAndStatusReturnMeta Meta { get; set; }
	}
	
	public class ActionsGetByIdAndSortAndStatusReturnActions
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public ActionsGetByIdAndSortAndStatusReturnActionsError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public ActionsGetByIdAndSortAndStatusReturnActionsResources[] ActionsGetByIdAndSortAndStatusReturnActionsResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class ActionsGetByIdAndSortAndStatusReturnActionsError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ActionsGetByIdAndSortAndStatusReturnActionsResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ActionsGetByIdAndSortAndStatusReturnActionsStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="success")]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="running")]
		running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="error")]
		error = 2,
	}
	
	public class ActionsGetByIdAndSortAndStatusReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public ActionsGetByIdAndSortAndStatusReturnMetaPagination Pagination { get; set; }
	}
	
	public class ActionsGetByIdAndSortAndStatusReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Actions_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Actions_idGetReturnAction Action { get; set; }
	}
	
	public class Actions_idGetReturnAction
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Actions_idGetReturnActionError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Actions_idGetReturnActionResources[] Actions_idGetReturnActionResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Actions_idGetReturnActionError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Actions_idGetReturnActionResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public enum CertificatesGetBySortAndNameAndLabel_selectorAndTypeSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name")]
		name = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:asc")]
		nameasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:desc")]
		namedesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created")]
		created = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:asc")]
		createdasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:desc")]
		createddesc = 8,
	}
	
	public enum CertificatesGetBySortAndNameAndLabel_selectorAndTypeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="uploaded")]
		uploaded = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="managed")]
		managed = 1,
	}
	
	public class CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificates")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificates[] CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnMeta Meta { get; set; }
	}
	
	public class CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificates
	{
		
		/// <summary>
		/// Certificate and chain in PEM format, in order so that each record directly certifies the one preceding
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Domains and subdomains covered by the Certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain_names")]
		public string[] Domain_names { get; set; }
		
		/// <summary>
		/// SHA256 fingerprint of the Certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Point in time when the Certificate stops being valid (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="not_valid_after")]
		public string Not_valid_after { get; set; }
		
		/// <summary>
		/// Point in time when the Certificate becomes valid (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="not_valid_before")]
		public string Not_valid_before { get; set; }
		
		/// <summary>
		/// Current status of a type `managed` Certificate, always *null* for type `uploaded` Certificates
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatus Status { get; set; }
		
		/// <summary>
		/// Type of the Certificate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
		
		/// <summary>
		/// Resources currently using the Certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="used_by")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesUsed_by[] CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesUsed_by { get; set; }
	}
	
	public class CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatus
	{
		
		/// <summary>
		/// If issuance or renewal reports `failed`, this property contains information about what happened
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatusError Error { get; set; }
		
		/// <summary>
		/// Status of the issuance process of the Certificate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issuance")]
		public System.Nullable<CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatusIssuance> Issuance { get; set; }
		
		/// <summary>
		/// Status of the renewal process of the Certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="renewal")]
		public System.Nullable<CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatusRenewal> Renewal { get; set; }
	}
	
	public class CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatusError
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatusIssuance
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pending")]
		pending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="completed")]
		completed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="failed")]
		failed = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatusRenewal
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="scheduled")]
		scheduled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pending")]
		pending = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="failed")]
		failed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unavailable")]
		unavailable = 3,
	}
	
	public class CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesUsed_by
	{
		
		/// <summary>
		/// ID of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnMetaPagination Pagination { get; set; }
	}
	
	public class CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class CertificatesPostPostBody
	{
		
		/// <summary>
		/// Certificate and chain in PEM format, in order so that each record directly certifies the one preceding. Required for type `uploaded` Certificates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
		
		/// <summary>
		/// Domains and subdomains that should be contained in the Certificate issued by *Let's Encrypt*. Required for type `managed` Certificates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain_names")]
		public string[] Domain_names { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// Name of the Certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Certificate key in PEM format. Required for type `uploaded` Certificates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="private_key")]
		public string Private_key { get; set; }
		
		/// <summary>
		/// Choose between uploading a Certificate in PEM format or requesting a managed *Let's Encrypt* Certificate. If omitted defaults to `uploaded`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
	}
	
	public class Certificates_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public Certificates_idGetReturnCertificate Certificate { get; set; }
	}
	
	public class Certificates_idGetReturnCertificate
	{
		
		/// <summary>
		/// Certificate and chain in PEM format, in order so that each record directly certifies the one preceding
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Domains and subdomains covered by the Certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain_names")]
		public string[] Domain_names { get; set; }
		
		/// <summary>
		/// SHA256 fingerprint of the Certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Point in time when the Certificate stops being valid (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="not_valid_after")]
		public string Not_valid_after { get; set; }
		
		/// <summary>
		/// Point in time when the Certificate becomes valid (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="not_valid_before")]
		public string Not_valid_before { get; set; }
		
		/// <summary>
		/// Current status of a type `managed` Certificate, always *null* for type `uploaded` Certificates
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Certificates_idGetReturnCertificateStatus Status { get; set; }
		
		/// <summary>
		/// Type of the Certificate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
		
		/// <summary>
		/// Resources currently using the Certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="used_by")]
		public Certificates_idGetReturnCertificateUsed_by[] Certificates_idGetReturnCertificateUsed_by { get; set; }
	}
	
	public class Certificates_idGetReturnCertificateStatus
	{
		
		/// <summary>
		/// If issuance or renewal reports `failed`, this property contains information about what happened
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Certificates_idGetReturnCertificateStatusError Error { get; set; }
		
		/// <summary>
		/// Status of the issuance process of the Certificate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issuance")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatusIssuance Issuance { get; set; }
		
		/// <summary>
		/// Status of the renewal process of the Certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="renewal")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatusRenewal Renewal { get; set; }
	}
	
	public class Certificates_idGetReturnCertificateStatusError
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Certificates_idGetReturnCertificateUsed_by
	{
		
		/// <summary>
		/// ID of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Certificates_idPutPutBody
	{
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// New Certificate name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Certificates_idPutReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public Certificates_idPutReturnCertificate Certificate { get; set; }
	}
	
	public class Certificates_idPutReturnCertificate
	{
		
		/// <summary>
		/// Certificate and chain in PEM format, in order so that each record directly certifies the one preceding
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Domains and subdomains covered by the Certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain_names")]
		public string[] Domain_names { get; set; }
		
		/// <summary>
		/// SHA256 fingerprint of the Certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Point in time when the Certificate stops being valid (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="not_valid_after")]
		public string Not_valid_after { get; set; }
		
		/// <summary>
		/// Point in time when the Certificate becomes valid (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="not_valid_before")]
		public string Not_valid_before { get; set; }
		
		/// <summary>
		/// Current status of a type `managed` Certificate, always *null* for type `uploaded` Certificates
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Certificates_idPutReturnCertificateStatus Status { get; set; }
		
		/// <summary>
		/// Type of the Certificate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
		
		/// <summary>
		/// Resources currently using the Certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="used_by")]
		public Certificates_idPutReturnCertificateUsed_by[] Certificates_idPutReturnCertificateUsed_by { get; set; }
	}
	
	public class Certificates_idPutReturnCertificateStatus
	{
		
		/// <summary>
		/// If issuance or renewal reports `failed`, this property contains information about what happened
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Certificates_idPutReturnCertificateStatusError Error { get; set; }
		
		/// <summary>
		/// Status of the issuance process of the Certificate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issuance")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatusIssuance Issuance { get; set; }
		
		/// <summary>
		/// Status of the renewal process of the Certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="renewal")]
		public CertificatesGetBySortAndNameAndLabel_selectorAndTypeReturnCertificatesStatusRenewal Renewal { get; set; }
	}
	
	public class Certificates_idPutReturnCertificateStatusError
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Certificates_idPutReturnCertificateUsed_by
	{
		
		/// <summary>
		/// ID of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public enum Certificates_idActionsGetBySortAndStatusSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command")]
		command = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:asc")]
		commandasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:desc")]
		commanddesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status")]
		status = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:asc")]
		statusasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:desc")]
		statusdesc = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress")]
		progress = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:asc")]
		progressasc = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:desc")]
		progressdesc = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started")]
		started = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:asc")]
		startedasc = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:desc")]
		starteddesc = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished")]
		finished = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:asc")]
		finishedasc = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:desc")]
		finisheddesc = 17,
	}
	
	public class Certificates_idActionsGetBySortAndStatusReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public Certificates_idActionsGetBySortAndStatusReturnActions[] Certificates_idActionsGetBySortAndStatusReturnActions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Certificates_idActionsGetBySortAndStatusReturnMeta Meta { get; set; }
	}
	
	public class Certificates_idActionsGetBySortAndStatusReturnActions
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Certificates_idActionsGetBySortAndStatusReturnActionsError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Certificates_idActionsGetBySortAndStatusReturnActionsResources[] Certificates_idActionsGetBySortAndStatusReturnActionsResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Certificates_idActionsGetBySortAndStatusReturnActionsError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Certificates_idActionsGetBySortAndStatusReturnActionsResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Certificates_idActionsGetBySortAndStatusReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Certificates_idActionsGetBySortAndStatusReturnMetaPagination Pagination { get; set; }
	}
	
	public class Certificates_idActionsGetBySortAndStatusReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Certificates_idActions_action_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Certificates_idActions_action_idGetReturnAction Action { get; set; }
	}
	
	public class Certificates_idActions_action_idGetReturnAction
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Certificates_idActions_action_idGetReturnActionError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Certificates_idActions_action_idGetReturnActionResources[] Certificates_idActions_action_idGetReturnActionResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Certificates_idActions_action_idGetReturnActionError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Certificates_idActions_action_idGetReturnActionResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class DatacentersGetByNameReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenters")]
		public DatacentersGetByNameReturnDatacenters[] DatacentersGetByNameReturnDatacenters { get; set; }
		
		/// <summary>
		/// The Datacenter which is recommended to be used to create new Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recommendation")]
		public double Recommendation { get; set; }
	}
	
	public class DatacentersGetByNameReturnDatacenters
	{
		
		/// <summary>
		/// Description of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public DatacentersGetByNameReturnDatacentersLocation Location { get; set; }
		
		/// <summary>
		/// Unique identifier of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Server types the Datacenter can handle
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_types")]
		public DatacentersGetByNameReturnDatacentersServer_types Server_types { get; set; }
	}
	
	public class DatacentersGetByNameReturnDatacentersLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class DatacentersGetByNameReturnDatacentersServer_types
	{
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available")]
		public double[] Available { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available_for_migration")]
		public double[] Available_for_migration { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported in the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="supported")]
		public double[] Supported { get; set; }
	}
	
	public class Datacenters_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public Datacenters_idGetReturnDatacenter Datacenter { get; set; }
	}
	
	public class Datacenters_idGetReturnDatacenter
	{
		
		/// <summary>
		/// Description of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Datacenters_idGetReturnDatacenterLocation Location { get; set; }
		
		/// <summary>
		/// Unique identifier of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Server types the Datacenter can handle
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_types")]
		public Datacenters_idGetReturnDatacenterServer_types Server_types { get; set; }
	}
	
	public class Datacenters_idGetReturnDatacenterLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Datacenters_idGetReturnDatacenterServer_types
	{
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available")]
		public double[] Available { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available_for_migration")]
		public double[] Available_for_migration { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported in the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="supported")]
		public double[] Supported { get; set; }
	}
	
	public enum FirewallsGetBySortAndNameAndLabel_selectorSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name")]
		name = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:asc")]
		nameasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:desc")]
		namedesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created")]
		created = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:asc")]
		createdasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:desc")]
		createddesc = 8,
	}
	
	public class FirewallsGetBySortAndNameAndLabel_selectorReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="firewalls")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewalls[] FirewallsGetBySortAndNameAndLabel_selectorReturnFirewalls { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnMeta Meta { get; set; }
	}
	
	public class FirewallsGetBySortAndNameAndLabel_selectorReturnFirewalls
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="applied_to")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_to[] FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_to { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRules[] FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRules { get; set; }
	}
	
	public class FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_to
	{
		
		[System.Runtime.Serialization.DataMember(Name="applied_to_resources")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resources[] FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resources { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toLabel_selector Label_selector { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="server")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toServer Server { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toType Type { get; set; }
	}
	
	public class FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resources
	{
		
		[System.Runtime.Serialization.DataMember(Name="server")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesServer Server { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesType> Type { get; set; }
	}
	
	public class FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesServer
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="server")]
		server = 0,
	}
	
	public class FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toServer
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="server")]
		server = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="label_selector")]
		label_selector = 1,
	}
	
	public class FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRules
	{
		
		/// <summary>
		/// Description of the Rule
		/// Max length: 255
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string Description { get; set; }
		
		/// <summary>
		/// List of permitted IPv4/IPv6 addresses in CIDR notation. Use `0.0.0.0/0` to allow all IPv4 addresses and `::/0` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination_ips")]
		public string[] Destination_ips { get; set; }
		
		/// <summary>
		/// Select traffic direction on which rule should be applied. Use `source_ips` for direction `in` and `destination_ips` for direction `out`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRulesDirection Direction { get; set; }
		
		/// <summary>
		/// Port or port range to which traffic will be allowed, only applicable for protocols TCP and UDP. A port range can be specified by separating two ports with a dash, e.g `1024-5000`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// Type of traffic to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// List of permitted IPv4/IPv6 addresses in CIDR notation. Use `0.0.0.0/0` to allow all IPv4 addresses and `::/0` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_ips")]
		public string[] Source_ips { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRulesDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="in")]
		_in = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="out")]
		_out = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRulesProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tcp")]
		tcp = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="udp")]
		udp = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="icmp")]
		icmp = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="esp")]
		esp = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="gre")]
		gre = 4,
	}
	
	public class FirewallsGetBySortAndNameAndLabel_selectorReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnMetaPagination Pagination { get; set; }
	}
	
	public class FirewallsGetBySortAndNameAndLabel_selectorReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class FirewallsPostPostBody
	{
		
		/// <summary>
		/// Resources the Firewall should be applied to after creation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apply_to")]
		public FirewallsPostPostBodyApply_to[] FirewallsPostPostBodyApply_to { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// Name of the Firewall
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Array of rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public FirewallsPostPostBodyRules[] FirewallsPostPostBodyRules { get; set; }
	}
	
	public class FirewallsPostPostBodyApply_to
	{
		
		/// <summary>
		/// Configuration for type LabelSelector, required if type is `label_selector`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public FirewallsPostPostBodyApply_toLabel_selector Label_selector { get; set; }
		
		/// <summary>
		/// Configuration for type Server, required if type is `server`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public FirewallsPostPostBodyApply_toServer Server { get; set; }
		
		/// <summary>
		/// Type of the resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toType Type { get; set; }
	}
	
	public class FirewallsPostPostBodyApply_toLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class FirewallsPostPostBodyApply_toServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class FirewallsPostPostBodyRules
	{
		
		/// <summary>
		/// Description of the Rule
		/// Max length: 255
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string Description { get; set; }
		
		/// <summary>
		/// List of permitted IPv4/IPv6 addresses in CIDR notation. Use `0.0.0.0/0` to allow all IPv4 addresses and `::/0` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination_ips")]
		public string[] Destination_ips { get; set; }
		
		/// <summary>
		/// Select traffic direction on which rule should be applied. Use `source_ips` for direction `in` and `destination_ips` for direction `out`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public FirewallsPostPostBodyRulesDirection Direction { get; set; }
		
		/// <summary>
		/// Port or port range to which traffic will be allowed, only applicable for protocols TCP and UDP. A port range can be specified by separating two ports with a dash, e.g `1024-5000`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// Type of traffic to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// List of permitted IPv4/IPv6 addresses in CIDR notation. Use `0.0.0.0/0` to allow all IPv4 addresses and `::/0` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_ips")]
		public string[] Source_ips { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum FirewallsPostPostBodyRulesDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="in")]
		_in = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="out")]
		_out = 1,
	}
	
	public class Firewalls_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="firewall")]
		public Firewalls_idGetReturnFirewall Firewall { get; set; }
	}
	
	public class Firewalls_idGetReturnFirewall
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="applied_to")]
		public Firewalls_idGetReturnFirewallApplied_to[] Firewalls_idGetReturnFirewallApplied_to { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public Firewalls_idGetReturnFirewallRules[] Firewalls_idGetReturnFirewallRules { get; set; }
	}
	
	public class Firewalls_idGetReturnFirewallApplied_to
	{
		
		[System.Runtime.Serialization.DataMember(Name="applied_to_resources")]
		public Firewalls_idGetReturnFirewallApplied_toApplied_to_resources[] Firewalls_idGetReturnFirewallApplied_toApplied_to_resources { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public Firewalls_idGetReturnFirewallApplied_toLabel_selector Label_selector { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Firewalls_idGetReturnFirewallApplied_toServer Server { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toType Type { get; set; }
	}
	
	public class Firewalls_idGetReturnFirewallApplied_toApplied_to_resources
	{
		
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Firewalls_idGetReturnFirewallApplied_toApplied_to_resourcesServer Server { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesType Type { get; set; }
	}
	
	public class Firewalls_idGetReturnFirewallApplied_toApplied_to_resourcesServer
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Firewalls_idGetReturnFirewallApplied_toLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class Firewalls_idGetReturnFirewallApplied_toServer
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Firewalls_idGetReturnFirewallRules
	{
		
		/// <summary>
		/// Description of the Rule
		/// Max length: 255
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string Description { get; set; }
		
		/// <summary>
		/// List of permitted IPv4/IPv6 addresses in CIDR notation. Use `0.0.0.0/0` to allow all IPv4 addresses and `::/0` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination_ips")]
		public string[] Destination_ips { get; set; }
		
		/// <summary>
		/// Select traffic direction on which rule should be applied. Use `source_ips` for direction `in` and `destination_ips` for direction `out`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public Firewalls_idGetReturnFirewallRulesDirection Direction { get; set; }
		
		/// <summary>
		/// Port or port range to which traffic will be allowed, only applicable for protocols TCP and UDP. A port range can be specified by separating two ports with a dash, e.g `1024-5000`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// Type of traffic to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// List of permitted IPv4/IPv6 addresses in CIDR notation. Use `0.0.0.0/0` to allow all IPv4 addresses and `::/0` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_ips")]
		public string[] Source_ips { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Firewalls_idGetReturnFirewallRulesDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="in")]
		_in = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="out")]
		_out = 1,
	}
	
	public class Firewalls_idPutPutBody
	{
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// New Firewall name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Firewalls_idPutReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="firewall")]
		public Firewalls_idPutReturnFirewall Firewall { get; set; }
	}
	
	public class Firewalls_idPutReturnFirewall
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="applied_to")]
		public Firewalls_idPutReturnFirewallApplied_to[] Firewalls_idPutReturnFirewallApplied_to { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public Firewalls_idPutReturnFirewallRules[] Firewalls_idPutReturnFirewallRules { get; set; }
	}
	
	public class Firewalls_idPutReturnFirewallApplied_to
	{
		
		[System.Runtime.Serialization.DataMember(Name="applied_to_resources")]
		public Firewalls_idPutReturnFirewallApplied_toApplied_to_resources[] Firewalls_idPutReturnFirewallApplied_toApplied_to_resources { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public Firewalls_idPutReturnFirewallApplied_toLabel_selector Label_selector { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Firewalls_idPutReturnFirewallApplied_toServer Server { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toType Type { get; set; }
	}
	
	public class Firewalls_idPutReturnFirewallApplied_toApplied_to_resources
	{
		
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Firewalls_idPutReturnFirewallApplied_toApplied_to_resourcesServer Server { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesType Type { get; set; }
	}
	
	public class Firewalls_idPutReturnFirewallApplied_toApplied_to_resourcesServer
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Firewalls_idPutReturnFirewallApplied_toLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class Firewalls_idPutReturnFirewallApplied_toServer
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Firewalls_idPutReturnFirewallRules
	{
		
		/// <summary>
		/// Description of the Rule
		/// Max length: 255
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string Description { get; set; }
		
		/// <summary>
		/// List of permitted IPv4/IPv6 addresses in CIDR notation. Use `0.0.0.0/0` to allow all IPv4 addresses and `::/0` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination_ips")]
		public string[] Destination_ips { get; set; }
		
		/// <summary>
		/// Select traffic direction on which rule should be applied. Use `source_ips` for direction `in` and `destination_ips` for direction `out`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public Firewalls_idPutReturnFirewallRulesDirection Direction { get; set; }
		
		/// <summary>
		/// Port or port range to which traffic will be allowed, only applicable for protocols TCP and UDP. A port range can be specified by separating two ports with a dash, e.g `1024-5000`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// Type of traffic to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// List of permitted IPv4/IPv6 addresses in CIDR notation. Use `0.0.0.0/0` to allow all IPv4 addresses and `::/0` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_ips")]
		public string[] Source_ips { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Firewalls_idPutReturnFirewallRulesDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="in")]
		_in = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="out")]
		_out = 1,
	}
	
	public enum Firewalls_idActionsGetBySortAndStatusSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command")]
		command = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:asc")]
		commandasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:desc")]
		commanddesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status")]
		status = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:asc")]
		statusasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:desc")]
		statusdesc = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress")]
		progress = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:asc")]
		progressasc = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:desc")]
		progressdesc = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started")]
		started = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:asc")]
		startedasc = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:desc")]
		starteddesc = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished")]
		finished = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:asc")]
		finishedasc = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:desc")]
		finisheddesc = 17,
	}
	
	public class Firewalls_idActionsGetBySortAndStatusReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public Firewalls_idActionsGetBySortAndStatusReturnActions[] Firewalls_idActionsGetBySortAndStatusReturnActions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Firewalls_idActionsGetBySortAndStatusReturnMeta Meta { get; set; }
	}
	
	public class Firewalls_idActionsGetBySortAndStatusReturnActions
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Firewalls_idActionsGetBySortAndStatusReturnActionsError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Firewalls_idActionsGetBySortAndStatusReturnActionsResources[] Firewalls_idActionsGetBySortAndStatusReturnActionsResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Firewalls_idActionsGetBySortAndStatusReturnActionsError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Firewalls_idActionsGetBySortAndStatusReturnActionsResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Firewalls_idActionsGetBySortAndStatusReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Firewalls_idActionsGetBySortAndStatusReturnMetaPagination Pagination { get; set; }
	}
	
	public class Firewalls_idActionsGetBySortAndStatusReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Firewalls_idActionsApply_to_resourcesPostPostBody
	{
		
		/// <summary>
		/// Resources the Firewall should be applied to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="apply_to")]
		public Firewalls_idActionsApply_to_resourcesPostPostBodyApply_to[] Firewalls_idActionsApply_to_resourcesPostPostBodyApply_to { get; set; }
	}
	
	public class Firewalls_idActionsApply_to_resourcesPostPostBodyApply_to
	{
		
		/// <summary>
		/// Configuration for type label_selector, required if type is `label_selector`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public Firewalls_idActionsApply_to_resourcesPostPostBodyApply_toLabel_selector Label_selector { get; set; }
		
		/// <summary>
		/// Configuration for type server, required if type is `server`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Firewalls_idActionsApply_to_resourcesPostPostBodyApply_toServer Server { get; set; }
		
		/// <summary>
		/// Type of the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toType Type { get; set; }
	}
	
	public class Firewalls_idActionsApply_to_resourcesPostPostBodyApply_toLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class Firewalls_idActionsApply_to_resourcesPostPostBodyApply_toServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Firewalls_idActionsRemove_from_resourcesPostPostBody
	{
		
		/// <summary>
		/// Resources the Firewall should be removed from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="remove_from")]
		public Firewalls_idActionsRemove_from_resourcesPostPostBodyRemove_from[] Firewalls_idActionsRemove_from_resourcesPostPostBodyRemove_from { get; set; }
	}
	
	public class Firewalls_idActionsRemove_from_resourcesPostPostBodyRemove_from
	{
		
		/// <summary>
		/// Configuration for type label_selector, required if type is `label_selector`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public Firewalls_idActionsRemove_from_resourcesPostPostBodyRemove_fromLabel_selector Label_selector { get; set; }
		
		/// <summary>
		/// Configuration for type server, required if type is `server`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Firewalls_idActionsRemove_from_resourcesPostPostBodyRemove_fromServer Server { get; set; }
		
		/// <summary>
		/// Type of the resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toType Type { get; set; }
	}
	
	public class Firewalls_idActionsRemove_from_resourcesPostPostBodyRemove_fromLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class Firewalls_idActionsRemove_from_resourcesPostPostBodyRemove_fromServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Firewalls_idActionsSet_rulesPostPostBody
	{
		
		/// <summary>
		/// Array of rules
		/// Required
		/// Maximum items: 50
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		[System.ComponentModel.DataAnnotations.MaxLength(50)]
		public Firewalls_idActionsSet_rulesPostPostBodyRules[] Firewalls_idActionsSet_rulesPostPostBodyRules { get; set; }
	}
	
	public class Firewalls_idActionsSet_rulesPostPostBodyRules
	{
		
		/// <summary>
		/// Description of the Rule
		/// Max length: 255
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		public string Description { get; set; }
		
		/// <summary>
		/// List of permitted IPv4/IPv6 addresses in CIDR notation. Use `0.0.0.0/0` to allow all IPv4 addresses and `::/0` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destination_ips")]
		public string[] Destination_ips { get; set; }
		
		/// <summary>
		/// Select traffic direction on which rule should be applied. Use `source_ips` for direction `in` and `destination_ips` for direction `out`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public Firewalls_idActionsSet_rulesPostPostBodyRulesDirection Direction { get; set; }
		
		/// <summary>
		/// Port or port range to which traffic will be allowed, only applicable for protocols TCP and UDP. A port range can be specified by separating two ports with a dash, e.g `1024-5000`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public string Port { get; set; }
		
		/// <summary>
		/// Type of traffic to allow
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsRulesProtocol Protocol { get; set; }
		
		/// <summary>
		/// List of permitted IPv4/IPv6 addresses in CIDR notation. Use `0.0.0.0/0` to allow all IPv4 addresses and `::/0` to allow all IPv6 addresses. You can specify 100 CIDRs at most.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source_ips")]
		public string[] Source_ips { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Firewalls_idActionsSet_rulesPostPostBodyRulesDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="in")]
		_in = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="out")]
		_out = 1,
	}
	
	public class Firewalls_idActions_action_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Firewalls_idActions_action_idGetReturnAction Action { get; set; }
	}
	
	public class Firewalls_idActions_action_idGetReturnAction
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Firewalls_idActions_action_idGetReturnActionError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Firewalls_idActions_action_idGetReturnActionResources[] Firewalls_idActions_action_idGetReturnActionResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Firewalls_idActions_action_idGetReturnActionError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Firewalls_idActions_action_idGetReturnActionResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public enum Floating_ipsGetByNameAndLabel_selectorAndSortSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created")]
		created = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:asc")]
		createdasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:desc")]
		createddesc = 5,
	}
	
	public class Floating_ipsGetByNameAndLabel_selectorAndSortReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="floating_ips")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ips[] Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ips { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnMeta Meta { get; set; }
	}
	
	public class Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ips
	{
		
		/// <summary>
		/// Whether the IP is blocked
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Description of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Array of reverse DNS entries
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsDns_ptr[] Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsDns_ptr { get; set; }
		
		/// <summary>
		/// Location the Floating IP was created in. Routing is optimized for this Location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="home_location")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsHome_location Home_location { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsProtection Protection { get; set; }
		
		/// <summary>
		/// ID of the Server the Floating IP is assigned to, null if it is not assigned at all
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server")]
		public System.Nullable<System.Int32> Server { get; set; }
		
		/// <summary>
		/// Type of the Floating IP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType Type { get; set; }
	}
	
	public class Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsDns_ptr
	{
		
		/// <summary>
		/// DNS pointer for the specific IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Single IPv4 or IPv6 address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsHome_location
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ipv4")]
		ipv4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ipv6")]
		ipv6 = 1,
	}
	
	public class Floating_ipsGetByNameAndLabel_selectorAndSortReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnMetaPagination Pagination { get; set; }
	}
	
	public class Floating_ipsGetByNameAndLabel_selectorAndSortReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Floating_ipsPostPostBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Home Location (routing is optimized for that Location). Only optional if Server argument is passed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="home_location")]
		public string Home_location { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Server to assign the Floating IP to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public System.Nullable<System.Int32> Server { get; set; }
		
		/// <summary>
		/// Floating IP type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType Type { get; set; }
	}
	
	public class Floating_ips_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="floating_ip")]
		public Floating_ips_idGetReturnFloating_ip Floating_ip { get; set; }
	}
	
	public class Floating_ips_idGetReturnFloating_ip
	{
		
		/// <summary>
		/// Whether the IP is blocked
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Description of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Array of reverse DNS entries
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public Floating_ips_idGetReturnFloating_ipDns_ptr[] Floating_ips_idGetReturnFloating_ipDns_ptr { get; set; }
		
		/// <summary>
		/// Location the Floating IP was created in. Routing is optimized for this Location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="home_location")]
		public Floating_ips_idGetReturnFloating_ipHome_location Home_location { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Floating_ips_idGetReturnFloating_ipProtection Protection { get; set; }
		
		/// <summary>
		/// ID of the Server the Floating IP is assigned to, null if it is not assigned at all
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server")]
		public System.Nullable<System.Int32> Server { get; set; }
		
		/// <summary>
		/// Type of the Floating IP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType Type { get; set; }
	}
	
	public class Floating_ips_idGetReturnFloating_ipDns_ptr
	{
		
		/// <summary>
		/// DNS pointer for the specific IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Single IPv4 or IPv6 address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Floating_ips_idGetReturnFloating_ipHome_location
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Floating_ips_idGetReturnFloating_ipProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Floating_ips_idPutPutBody
	{
		
		/// <summary>
		/// New Description to set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// New unique name to set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Floating_ips_idPutReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="floating_ip")]
		public Floating_ips_idPutReturnFloating_ip Floating_ip { get; set; }
	}
	
	public class Floating_ips_idPutReturnFloating_ip
	{
		
		/// <summary>
		/// Whether the IP is blocked
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Description of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Array of reverse DNS entries
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public Floating_ips_idPutReturnFloating_ipDns_ptr[] Floating_ips_idPutReturnFloating_ipDns_ptr { get; set; }
		
		/// <summary>
		/// Location the Floating IP was created in. Routing is optimized for this Location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="home_location")]
		public Floating_ips_idPutReturnFloating_ipHome_location Home_location { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Floating_ips_idPutReturnFloating_ipProtection Protection { get; set; }
		
		/// <summary>
		/// ID of the Server the Floating IP is assigned to, null if it is not assigned at all
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server")]
		public System.Nullable<System.Int32> Server { get; set; }
		
		/// <summary>
		/// Type of the Floating IP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType Type { get; set; }
	}
	
	public class Floating_ips_idPutReturnFloating_ipDns_ptr
	{
		
		/// <summary>
		/// DNS pointer for the specific IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Single IPv4 or IPv6 address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Floating_ips_idPutReturnFloating_ipHome_location
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Floating_ips_idPutReturnFloating_ipProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public enum Floating_ips_idActionsGetBySortAndStatusSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command")]
		command = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:asc")]
		commandasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:desc")]
		commanddesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status")]
		status = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:asc")]
		statusasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:desc")]
		statusdesc = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress")]
		progress = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:asc")]
		progressasc = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:desc")]
		progressdesc = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started")]
		started = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:asc")]
		startedasc = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:desc")]
		starteddesc = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished")]
		finished = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:asc")]
		finishedasc = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:desc")]
		finisheddesc = 17,
	}
	
	public class Floating_ips_idActionsGetBySortAndStatusReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public Floating_ips_idActionsGetBySortAndStatusReturnActions[] Floating_ips_idActionsGetBySortAndStatusReturnActions { get; set; }
	}
	
	public class Floating_ips_idActionsGetBySortAndStatusReturnActions
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Floating_ips_idActionsGetBySortAndStatusReturnActionsError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Floating_ips_idActionsGetBySortAndStatusReturnActionsResources[] Floating_ips_idActionsGetBySortAndStatusReturnActionsResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Floating_ips_idActionsGetBySortAndStatusReturnActionsError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Floating_ips_idActionsGetBySortAndStatusReturnActionsResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Floating_ips_idActionsAssignPostPostBody
	{
		
		/// <summary>
		/// ID of the Server the Floating IP shall be assigned to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server")]
		public int Server { get; set; }
	}
	
	public class Floating_ips_idActionsChange_dns_ptrPostPostBody
	{
		
		/// <summary>
		/// Hostname to set as a reverse DNS PTR entry, will reset to original default value if `null`
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// IP address for which to set the reverse DNS entry
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Floating_ips_idActionsChange_protectionPostPostBody
	{
		
		/// <summary>
		/// If true, prevents the Floating IP from being deleted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public System.Nullable<System.Boolean> Delete { get; set; }
	}
	
	public class Floating_ips_idActions_action_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Floating_ips_idActions_action_idGetReturnAction Action { get; set; }
	}
	
	public class Floating_ips_idActions_action_idGetReturnAction
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Floating_ips_idActions_action_idGetReturnActionError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Floating_ips_idActions_action_idGetReturnActionResources[] Floating_ips_idActions_action_idGetReturnActionResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Floating_ips_idActions_action_idGetReturnActionError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Floating_ips_idActions_action_idGetReturnActionResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public enum ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name")]
		name = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:asc")]
		nameasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:desc")]
		namedesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created")]
		created = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:asc")]
		createdasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:desc")]
		createddesc = 8,
	}
	
	public enum ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="system")]
		system = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="snapshot")]
		snapshot = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="backup")]
		backup = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="app")]
		app = 3,
	}
	
	public enum ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="available")]
		available = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="creating")]
		creating = 1,
	}
	
	public class ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="images")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImages[] ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImages { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnMeta Meta { get; set; }
	}
	
	public class ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImages
	{
		
		/// <summary>
		/// ID of Server the Image is bound to. Only set for Images of type `backup`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bound_to")]
		public System.Nullable<System.Int32> Bound_to { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Information about the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_from")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesCreated_from Created_from { get; set; }
		
		/// <summary>
		/// Point in time where the Image was deleted (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public string Deleted { get; set; }
		
		/// <summary>
		/// Point in time when the Image is considered to be deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Size of the disk contained in the Image in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk_size")]
		public double Disk_size { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_size")]
		public System.Nullable<System.Double> Image_size { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Unique identifier of the Image. This value is only set for system Images.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Flavor of operating system contained in the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_flavor")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesOs_flavor Os_flavor { get; set; }
		
		/// <summary>
		/// Operating system version
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_version")]
		public string Os_version { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesProtection Protection { get; set; }
		
		/// <summary>
		/// Indicates that rapid deploy of the Image is available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rapid_deploy")]
		public System.Nullable<System.Boolean> Rapid_deploy { get; set; }
		
		/// <summary>
		/// Whether the Image can be used or if it's still being created or unavailable
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesStatus Status { get; set; }
		
		/// <summary>
		/// Type of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesType Type { get; set; }
	}
	
	public class ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesCreated_from
	{
		
		/// <summary>
		/// ID of the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Server name at the time the Image was created
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesOs_flavor
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ubuntu")]
		ubuntu = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="centos")]
		centos = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="debian")]
		debian = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fedora")]
		fedora = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unknown")]
		unknown = 4,
	}
	
	public class ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="available")]
		available = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="creating")]
		creating = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unavailable")]
		unavailable = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="system")]
		system = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="app")]
		app = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="snapshot")]
		snapshot = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="backup")]
		backup = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="temporary")]
		temporary = 4,
	}
	
	public class ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnMetaPagination Pagination { get; set; }
	}
	
	public class ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Images_idGetReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="image")]
		public Images_idGetReturnImage Image { get; set; }
	}
	
	public class Images_idGetReturnImage
	{
		
		/// <summary>
		/// ID of Server the Image is bound to. Only set for Images of type `backup`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bound_to")]
		public System.Nullable<System.Int32> Bound_to { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Information about the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_from")]
		public Images_idGetReturnImageCreated_from Created_from { get; set; }
		
		/// <summary>
		/// Point in time where the Image was deleted (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public string Deleted { get; set; }
		
		/// <summary>
		/// Point in time when the Image is considered to be deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Size of the disk contained in the Image in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk_size")]
		public double Disk_size { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_size")]
		public System.Nullable<System.Double> Image_size { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Unique identifier of the Image. This value is only set for system Images.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Flavor of operating system contained in the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_flavor")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesOs_flavor Os_flavor { get; set; }
		
		/// <summary>
		/// Operating system version
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_version")]
		public string Os_version { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Images_idGetReturnImageProtection Protection { get; set; }
		
		/// <summary>
		/// Indicates that rapid deploy of the Image is available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rapid_deploy")]
		public System.Nullable<System.Boolean> Rapid_deploy { get; set; }
		
		/// <summary>
		/// Whether the Image can be used or if it's still being created or unavailable
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesStatus Status { get; set; }
		
		/// <summary>
		/// Type of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesType Type { get; set; }
	}
	
	public class Images_idGetReturnImageCreated_from
	{
		
		/// <summary>
		/// ID of the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Server name at the time the Image was created
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Images_idGetReturnImageProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Images_idPutPutBody
	{
		
		/// <summary>
		/// New description of Image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// Destination Image type to convert to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<Images_idPutPutBodyType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Images_idPutPutBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="snapshot")]
		snapshot = 0,
	}
	
	public class Images_idPutReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="image")]
		public Images_idPutReturnImage Image { get; set; }
	}
	
	public class Images_idPutReturnImage
	{
		
		/// <summary>
		/// ID of Server the Image is bound to. Only set for Images of type `backup`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bound_to")]
		public System.Nullable<System.Int32> Bound_to { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Information about the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_from")]
		public Images_idPutReturnImageCreated_from Created_from { get; set; }
		
		/// <summary>
		/// Point in time where the Image was deleted (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public string Deleted { get; set; }
		
		/// <summary>
		/// Point in time when the Image is considered to be deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Size of the disk contained in the Image in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk_size")]
		public double Disk_size { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_size")]
		public System.Nullable<System.Double> Image_size { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Unique identifier of the Image. This value is only set for system Images.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Flavor of operating system contained in the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_flavor")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesOs_flavor Os_flavor { get; set; }
		
		/// <summary>
		/// Operating system version
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_version")]
		public string Os_version { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Images_idPutReturnImageProtection Protection { get; set; }
		
		/// <summary>
		/// Indicates that rapid deploy of the Image is available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rapid_deploy")]
		public System.Nullable<System.Boolean> Rapid_deploy { get; set; }
		
		/// <summary>
		/// Whether the Image can be used or if it's still being created or unavailable
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesStatus Status { get; set; }
		
		/// <summary>
		/// Type of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesType Type { get; set; }
	}
	
	public class Images_idPutReturnImageCreated_from
	{
		
		/// <summary>
		/// ID of the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Server name at the time the Image was created
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Images_idPutReturnImageProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public enum Images_idActionsGetBySortAndStatusSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command")]
		command = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:asc")]
		commandasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:desc")]
		commanddesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status")]
		status = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:asc")]
		statusasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:desc")]
		statusdesc = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress")]
		progress = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:asc")]
		progressasc = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:desc")]
		progressdesc = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started")]
		started = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:asc")]
		startedasc = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:desc")]
		starteddesc = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished")]
		finished = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:asc")]
		finishedasc = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:desc")]
		finisheddesc = 17,
	}
	
	public class Images_idActionsGetBySortAndStatusReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public Images_idActionsGetBySortAndStatusReturnActions[] Images_idActionsGetBySortAndStatusReturnActions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Images_idActionsGetBySortAndStatusReturnMeta Meta { get; set; }
	}
	
	public class Images_idActionsGetBySortAndStatusReturnActions
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Images_idActionsGetBySortAndStatusReturnActionsError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Images_idActionsGetBySortAndStatusReturnActionsResources[] Images_idActionsGetBySortAndStatusReturnActionsResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Images_idActionsGetBySortAndStatusReturnActionsError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Images_idActionsGetBySortAndStatusReturnActionsResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Images_idActionsGetBySortAndStatusReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Images_idActionsGetBySortAndStatusReturnMetaPagination Pagination { get; set; }
	}
	
	public class Images_idActionsGetBySortAndStatusReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Images_idActionsChange_protectionPostPostBody
	{
		
		/// <summary>
		/// If true, prevents the snapshot from being deleted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public System.Nullable<System.Boolean> Delete { get; set; }
	}
	
	public class Images_idActions_action_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Images_idActions_action_idGetReturnAction Action { get; set; }
	}
	
	public class Images_idActions_action_idGetReturnAction
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Images_idActions_action_idGetReturnActionError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Images_idActions_action_idGetReturnActionResources[] Images_idActions_action_idGetReturnActionResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Images_idActions_action_idGetReturnActionError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Images_idActions_action_idGetReturnActionResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isos")]
		public IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsos[] IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsos { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnMeta Meta { get; set; }
	}
	
	public class IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsos
	{
		
		/// <summary>
		/// Type of cpu architecture this iso is compatible with. Null indicates no restriction on the architecture (wildcard).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public System.Nullable<IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsosArchitecture> Architecture { get; set; }
		
		/// <summary>
		/// ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the ISO
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Unique identifier of the ISO. Only set for public ISOs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Type of the ISO
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsosType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsosArchitecture
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="x86")]
		x86 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="arm")]
		arm = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsosType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
	}
	
	public class IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnMetaPagination Pagination { get; set; }
	}
	
	public class IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Isos_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="iso")]
		public Isos_idGetReturnIso Iso { get; set; }
	}
	
	public class Isos_idGetReturnIso
	{
		
		/// <summary>
		/// Type of cpu architecture this iso is compatible with. Null indicates no restriction on the architecture (wildcard).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsosArchitecture Architecture { get; set; }
		
		/// <summary>
		/// ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the ISO
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Unique identifier of the ISO. Only set for public ISOs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Type of the ISO
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Isos_idGetReturnIsoType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Isos_idGetReturnIsoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
	}
	
	public class Load_balancer_typesGetByNameReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="load_balancer_types")]
		public Load_balancer_typesGetByNameReturnLoad_balancer_types[] Load_balancer_typesGetByNameReturnLoad_balancer_types { get; set; }
	}
	
	public class Load_balancer_typesGetByNameReturnLoad_balancer_types
	{
		
		/// <summary>
		/// Point in time when the Load Balancer type is deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Number of SSL Certificates that can be assigned to a single Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_assigned_certificates")]
		public double Max_assigned_certificates { get; set; }
		
		/// <summary>
		/// Number of maximum simultaneous open connections
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_connections")]
		public double Max_connections { get; set; }
		
		/// <summary>
		/// Number of services a Load Balancer of this type can have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_services")]
		public double Max_services { get; set; }
		
		/// <summary>
		/// Number of targets a single Load Balancer can have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_targets")]
		public double Max_targets { get; set; }
		
		/// <summary>
		/// Unique identifier of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Prices in different network zones
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public Load_balancer_typesGetByNameReturnLoad_balancer_typesPrices[] Load_balancer_typesGetByNameReturnLoad_balancer_typesPrices { get; set; }
	}
	
	public class Load_balancer_typesGetByNameReturnLoad_balancer_typesPrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Resource in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public Load_balancer_typesGetByNameReturnLoad_balancer_typesPricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Resource in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public Load_balancer_typesGetByNameReturnLoad_balancer_typesPricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class Load_balancer_typesGetByNameReturnLoad_balancer_typesPricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Load_balancer_typesGetByNameReturnLoad_balancer_typesPricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Load_balancer_types_idGetReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="load_balancer_type")]
		public Load_balancer_types_idGetReturnLoad_balancer_type Load_balancer_type { get; set; }
	}
	
	public class Load_balancer_types_idGetReturnLoad_balancer_type
	{
		
		/// <summary>
		/// Point in time when the Load Balancer type is deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Number of SSL Certificates that can be assigned to a single Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_assigned_certificates")]
		public double Max_assigned_certificates { get; set; }
		
		/// <summary>
		/// Number of maximum simultaneous open connections
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_connections")]
		public double Max_connections { get; set; }
		
		/// <summary>
		/// Number of services a Load Balancer of this type can have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_services")]
		public double Max_services { get; set; }
		
		/// <summary>
		/// Number of targets a single Load Balancer can have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_targets")]
		public double Max_targets { get; set; }
		
		/// <summary>
		/// Unique identifier of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Prices in different network zones
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public Load_balancer_types_idGetReturnLoad_balancer_typePrices[] Load_balancer_types_idGetReturnLoad_balancer_typePrices { get; set; }
	}
	
	public class Load_balancer_types_idGetReturnLoad_balancer_typePrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Resource in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public Load_balancer_types_idGetReturnLoad_balancer_typePricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Resource in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public Load_balancer_types_idGetReturnLoad_balancer_typePricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class Load_balancer_types_idGetReturnLoad_balancer_typePricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Load_balancer_types_idGetReturnLoad_balancer_typePricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public enum Load_balancersGetBySortAndNameAndLabel_selectorSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name")]
		name = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:asc")]
		nameasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:desc")]
		namedesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created")]
		created = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:asc")]
		createdasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:desc")]
		createddesc = 8,
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="load_balancers")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancers[] Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnMeta Meta { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancers
	{
		
		/// <summary>
		/// Algorithm of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="algorithm")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersAlgorithm Algorithm { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Free Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="included_traffic")]
		public int Included_traffic { get; set; }
		
		/// <summary>
		/// Inbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ingoing_traffic")]
		public System.Nullable<System.Int32> Ingoing_traffic { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="load_balancer_type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLoad_balancer_type Load_balancer_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLocation Location { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Outbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="outgoing_traffic")]
		public System.Nullable<System.Int32> Outgoing_traffic { get; set; }
		
		/// <summary>
		/// Private networks information
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_net")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersPrivate_net[] Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersPrivate_net { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersProtection Protection { get; set; }
		
		/// <summary>
		/// Public network information
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_net")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersPublic_net Public_net { get; set; }
		
		/// <summary>
		/// List of services that belong to this Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="services")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServices[] Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServices { get; set; }
		
		/// <summary>
		/// List of targets that belong to this Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargets[] Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargets { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersAlgorithm
	{
		
		/// <summary>
		/// Type of the algorithm
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersAlgorithmType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersAlgorithmType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="round_robin")]
		round_robin = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="least_connections")]
		least_connections = 1,
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLoad_balancer_type
	{
		
		/// <summary>
		/// Point in time when the Load Balancer type is deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Number of SSL Certificates that can be assigned to a single Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_assigned_certificates")]
		public double Max_assigned_certificates { get; set; }
		
		/// <summary>
		/// Number of maximum simultaneous open connections
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_connections")]
		public double Max_connections { get; set; }
		
		/// <summary>
		/// Number of services a Load Balancer of this type can have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_services")]
		public double Max_services { get; set; }
		
		/// <summary>
		/// Number of targets a single Load Balancer can have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_targets")]
		public double Max_targets { get; set; }
		
		/// <summary>
		/// Unique identifier of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Prices in different network zones
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLoad_balancer_typePrices[] Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLoad_balancer_typePrices { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLoad_balancer_typePrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Resource in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLoad_balancer_typePricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Resource in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLoad_balancer_typePricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLoad_balancer_typePricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLoad_balancer_typePricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersPrivate_net
	{
		
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public System.Nullable<System.Int32> Network { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersPublic_net
	{
		
		/// <summary>
		/// Public Interface enabled or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// IP address (v4)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersPublic_netIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IP address (v6)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersPublic_netIpv6 Ipv6 { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersPublic_netIpv4
	{
		
		/// <summary>
		/// Reverse DNS PTR entry for the IPv4 address of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// IP address (v4) of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersPublic_netIpv6
	{
		
		/// <summary>
		/// Reverse DNS PTR entry for the IPv6 address of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// IP address (v6) of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServices
	{
		
		/// <summary>
		/// Port the Load Balancer will balance to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination_port")]
		public int Destination_port { get; set; }
		
		/// <summary>
		/// Service health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="health_check")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_check Health_check { get; set; }
		
		/// <summary>
		/// Configuration option for protocols http and https
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHttp Http { get; set; }
		
		/// <summary>
		/// Port the Load Balancer listens on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public int Listen_port { get; set; }
		
		/// <summary>
		/// Protocol of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Is Proxyprotocol enabled or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="proxyprotocol")]
		public bool Proxyprotocol { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_check
	{
		
		/// <summary>
		/// Additional configuration for protocol http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_checkHttp Http { get; set; }
		
		/// <summary>
		/// Time interval in seconds health checks are performed
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public int Interval { get; set; }
		
		/// <summary>
		/// Port the health check will be performed on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// Type of the health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_checkProtocol Protocol { get; set; }
		
		/// <summary>
		/// Unsuccessful retries needed until a target is considered unhealthy; an unhealthy target needs the same number of successful retries to become healthy again
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public int Retries { get; set; }
		
		/// <summary>
		/// Time in seconds after an attempt is considered a timeout
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public int Timeout { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_checkHttp
	{
		
		/// <summary>
		/// Host header to send in the HTTP request. May not contain spaces, percent or backslash symbols. Can be null, in that case no host header is sent.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// HTTP path to use for health checks. May not contain literal spaces, use percent-encoding instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// String that must be contained in HTTP response in order to pass the health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
		
		/// <summary>
		/// List of returned HTTP status codes in order to pass the health check. Supports the wildcards `?` for exactly one character and `*` for multiple ones. The default is to pass the health check for any status code between 2?? and 3??.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status_codes")]
		public string[] Status_codes { get; set; }
		
		/// <summary>
		/// Use HTTPS for health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tls")]
		public System.Nullable<System.Boolean> Tls { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_checkProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tcp")]
		tcp = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http")]
		http = 1,
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHttp
	{
		
		/// <summary>
		/// IDs of the Certificates to use for TLS/SSL termination by the Load Balancer; empty for TLS/SSL passthrough or if `protocol` is "http"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificates")]
		public int[] Certificates { get; set; }
		
		/// <summary>
		/// Lifetime of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_lifetime")]
		public System.Nullable<System.Int32> Cookie_lifetime { get; set; }
		
		/// <summary>
		/// Name of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_name")]
		public string Cookie_name { get; set; }
		
		/// <summary>
		/// Redirect HTTP requests to HTTPS. Only available if protocol is "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirect_http")]
		public System.Nullable<System.Boolean> Redirect_http { get; set; }
		
		/// <summary>
		/// Use sticky sessions. Only available if protocol is "http" or "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sticky_sessions")]
		public System.Nullable<System.Boolean> Sticky_sessions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tcp")]
		tcp = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="http")]
		http = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="https")]
		https = 2,
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargets
	{
		
		/// <summary>
		/// List of health statuses of the services on this target. Only present for target types "server" and "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="health_status")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_status[] Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_status { get; set; }
		
		/// <summary>
		/// IP targets where the traffic should be routed to. It is only possible to use the (Public or vSwitch) IPs of Hetzner Online Root Servers belonging to the project owner. IPs belonging to other users are blocked. Additionally IPs belonging to services provided by Hetzner Cloud (Servers, Load Balancers, ...) are blocked as well. Only present for target type "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsIp Ip { get; set; }
		
		/// <summary>
		/// Label selector used to determine targets. Only present for target type "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsLabel_selector Label_selector { get; set; }
		
		/// <summary>
		/// Server where the traffic should be routed to. Only present for target type "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsServer Server { get; set; }
		
		/// <summary>
		/// List of resolved label selector target Servers. Only present for type "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsTargets[] Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsTargets { get; set; }
		
		/// <summary>
		/// Type of the resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsType Type { get; set; }
		
		/// <summary>
		/// Use the private network IP instead of the public IP. Default value is false. Only present for target types "server" and "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_private_ip")]
		public System.Nullable<System.Boolean> Use_private_ip { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public System.Nullable<System.Int32> Listen_port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_statusStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_statusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="healthy")]
		healthy = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unhealthy")]
		unhealthy = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unknown")]
		unknown = 2,
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsIp
	{
		
		/// <summary>
		/// IP of a server that belongs to the same customer (public IPv4/IPv6) or private IP in a Subnetwork type vswitch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsTargets
	{
		
		/// <summary>
		/// List of health statuses of the services on this target. Only present for target types "server" and "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="health_status")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsTargetsHealth_status[] Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsTargetsHealth_status { get; set; }
		
		/// <summary>
		/// Server where the traffic should be routed to. Only present for target type "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsTargetsServer Server { get; set; }
		
		/// <summary>
		/// Type of the resource. Here always "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Use the private network IP instead of the public IP. Default value is false. Only present for target types "server" and "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_private_ip")]
		public System.Nullable<System.Boolean> Use_private_ip { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsTargetsHealth_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public System.Nullable<System.Int32> Listen_port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_statusStatus Status { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsTargetsServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="server")]
		server = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="label_selector")]
		label_selector = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ip")]
		ip = 2,
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnMetaPagination Pagination { get; set; }
	}
	
	public class Load_balancersGetBySortAndNameAndLabel_selectorReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Load_balancersPostPostBody
	{
		
		/// <summary>
		/// Algorithm of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="algorithm")]
		public Load_balancersPostPostBodyAlgorithm Algorithm { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Load_balancersPostPostBodyLabels Labels { get; set; }
		
		/// <summary>
		/// ID or name of the Load Balancer type this Load Balancer should be created with
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="load_balancer_type")]
		public string Load_balancer_type { get; set; }
		
		/// <summary>
		/// ID or name of Location to create Load Balancer in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Name of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the network the Load Balancer should be attached to on creation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public System.Nullable<System.Int32> Network { get; set; }
		
		/// <summary>
		/// Name of network zone
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
		
		/// <summary>
		/// Enable or disable the public interface of the Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public_interface")]
		public System.Nullable<System.Boolean> Public_interface { get; set; }
		
		/// <summary>
		/// Array of services
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="services")]
		public Load_balancersPostPostBodyServices[] Load_balancersPostPostBodyServices { get; set; }
		
		/// <summary>
		/// Array of targets
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Load_balancersPostPostBodyTargets[] Load_balancersPostPostBodyTargets { get; set; }
	}
	
	public class Load_balancersPostPostBodyAlgorithm
	{
		
		/// <summary>
		/// Type of the algorithm
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersAlgorithmType Type { get; set; }
	}
	
	public class Load_balancersPostPostBodyLabels
	{
		
		/// <summary>
		/// New label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelkey")]
		public string Labelkey { get; set; }
	}
	
	public class Load_balancersPostPostBodyServices
	{
		
		/// <summary>
		/// Port the Load Balancer will balance to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination_port")]
		public int Destination_port { get; set; }
		
		/// <summary>
		/// Service health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="health_check")]
		public Load_balancersPostPostBodyServicesHealth_check Health_check { get; set; }
		
		/// <summary>
		/// Configuration option for protocols http and https
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancersPostPostBodyServicesHttp Http { get; set; }
		
		/// <summary>
		/// Port the Load Balancer listens on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public int Listen_port { get; set; }
		
		/// <summary>
		/// Protocol of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Is Proxyprotocol enabled or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="proxyprotocol")]
		public bool Proxyprotocol { get; set; }
	}
	
	public class Load_balancersPostPostBodyServicesHealth_check
	{
		
		/// <summary>
		/// Additional configuration for protocol http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancersPostPostBodyServicesHealth_checkHttp Http { get; set; }
		
		/// <summary>
		/// Time interval in seconds health checks are performed
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public int Interval { get; set; }
		
		/// <summary>
		/// Port the health check will be performed on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// Type of the health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_checkProtocol Protocol { get; set; }
		
		/// <summary>
		/// Unsuccessful retries needed until a target is considered unhealthy; an unhealthy target needs the same number of successful retries to become healthy again
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public int Retries { get; set; }
		
		/// <summary>
		/// Time in seconds after an attempt is considered a timeout
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public int Timeout { get; set; }
	}
	
	public class Load_balancersPostPostBodyServicesHealth_checkHttp
	{
		
		/// <summary>
		/// Host header to send in the HTTP request. May not contain spaces, percent or backslash symbols. Can be null, in that case no host header is sent.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// HTTP path to use for health checks. May not contain literal spaces, use percent-encoding instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// String that must be contained in HTTP response in order to pass the health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
		
		/// <summary>
		/// List of returned HTTP status codes in order to pass the health check. Supports the wildcards `?` for exactly one character and `*` for multiple ones. The default is to pass the health check for any status code between 2?? and 3??.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status_codes")]
		public string[] Status_codes { get; set; }
		
		/// <summary>
		/// Use HTTPS for health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tls")]
		public System.Nullable<System.Boolean> Tls { get; set; }
	}
	
	public class Load_balancersPostPostBodyServicesHttp
	{
		
		/// <summary>
		/// IDs of the Certificates to use for TLS/SSL termination by the Load Balancer; empty for TLS/SSL passthrough or if `protocol` is "http"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificates")]
		public int[] Certificates { get; set; }
		
		/// <summary>
		/// Lifetime of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_lifetime")]
		public System.Nullable<System.Int32> Cookie_lifetime { get; set; }
		
		/// <summary>
		/// Name of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_name")]
		public string Cookie_name { get; set; }
		
		/// <summary>
		/// Redirect HTTP requests to HTTPS. Only available if protocol is "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirect_http")]
		public System.Nullable<System.Boolean> Redirect_http { get; set; }
		
		/// <summary>
		/// Use sticky sessions. Only available if protocol is "http" or "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sticky_sessions")]
		public System.Nullable<System.Boolean> Sticky_sessions { get; set; }
	}
	
	public class Load_balancersPostPostBodyTargets
	{
		
		/// <summary>
		/// List of health statuses of the services on this target. Only present for target types "server" and "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="health_status")]
		public Load_balancersPostPostBodyTargetsHealth_status[] Load_balancersPostPostBodyTargetsHealth_status { get; set; }
		
		/// <summary>
		/// IP targets where the traffic should be routed to. It is only possible to use the (Public or vSwitch) IPs of Hetzner Online Root Servers belonging to the project owner. IPs belonging to other users are blocked. Additionally IPs belonging to services provided by Hetzner Cloud (Servers, Load Balancers, ...) are blocked as well. Only present for target type "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public Load_balancersPostPostBodyTargetsIp Ip { get; set; }
		
		/// <summary>
		/// Label selector used to determine targets. Only present for target type "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public Load_balancersPostPostBodyTargetsLabel_selector Label_selector { get; set; }
		
		/// <summary>
		/// Server where the traffic should be routed to. Only present for target type "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Load_balancersPostPostBodyTargetsServer Server { get; set; }
		
		/// <summary>
		/// List of resolved label selector target Servers. Only present for type "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Load_balancersPostPostBodyTargetsTargets[] Load_balancersPostPostBodyTargetsTargets { get; set; }
		
		/// <summary>
		/// Type of the resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsType Type { get; set; }
		
		/// <summary>
		/// Use the private network IP instead of the public IP. Default value is false. Only present for target types "server" and "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_private_ip")]
		public System.Nullable<System.Boolean> Use_private_ip { get; set; }
	}
	
	public class Load_balancersPostPostBodyTargetsHealth_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public System.Nullable<System.Int32> Listen_port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_statusStatus Status { get; set; }
	}
	
	public class Load_balancersPostPostBodyTargetsIp
	{
		
		/// <summary>
		/// IP of a server that belongs to the same customer (public IPv4/IPv6) or private IP in a Subnetwork type vswitch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancersPostPostBodyTargetsLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class Load_balancersPostPostBodyTargetsServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Load_balancersPostPostBodyTargetsTargets
	{
		
		/// <summary>
		/// List of health statuses of the services on this target. Only present for target types "server" and "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="health_status")]
		public Load_balancersPostPostBodyTargetsTargetsHealth_status[] Load_balancersPostPostBodyTargetsTargetsHealth_status { get; set; }
		
		/// <summary>
		/// Server where the traffic should be routed to. Only present for target type "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Load_balancersPostPostBodyTargetsTargetsServer Server { get; set; }
		
		/// <summary>
		/// Type of the resource. Here always "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Use the private network IP instead of the public IP. Default value is false. Only present for target types "server" and "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_private_ip")]
		public System.Nullable<System.Boolean> Use_private_ip { get; set; }
	}
	
	public class Load_balancersPostPostBodyTargetsTargetsHealth_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public System.Nullable<System.Int32> Listen_port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_statusStatus Status { get; set; }
	}
	
	public class Load_balancersPostPostBodyTargetsTargetsServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Load_balancers_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="load_balancer")]
		public Load_balancers_idGetReturnLoad_balancer Load_balancer { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancer
	{
		
		/// <summary>
		/// Algorithm of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="algorithm")]
		public Load_balancers_idGetReturnLoad_balancerAlgorithm Algorithm { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Free Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="included_traffic")]
		public int Included_traffic { get; set; }
		
		/// <summary>
		/// Inbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ingoing_traffic")]
		public System.Nullable<System.Int32> Ingoing_traffic { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="load_balancer_type")]
		public Load_balancers_idGetReturnLoad_balancerLoad_balancer_type Load_balancer_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Load_balancers_idGetReturnLoad_balancerLocation Location { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Outbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="outgoing_traffic")]
		public System.Nullable<System.Int32> Outgoing_traffic { get; set; }
		
		/// <summary>
		/// Private networks information
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_net")]
		public Load_balancers_idGetReturnLoad_balancerPrivate_net[] Load_balancers_idGetReturnLoad_balancerPrivate_net { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Load_balancers_idGetReturnLoad_balancerProtection Protection { get; set; }
		
		/// <summary>
		/// Public network information
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_net")]
		public Load_balancers_idGetReturnLoad_balancerPublic_net Public_net { get; set; }
		
		/// <summary>
		/// List of services that belong to this Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="services")]
		public Load_balancers_idGetReturnLoad_balancerServices[] Load_balancers_idGetReturnLoad_balancerServices { get; set; }
		
		/// <summary>
		/// List of targets that belong to this Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Load_balancers_idGetReturnLoad_balancerTargets[] Load_balancers_idGetReturnLoad_balancerTargets { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerAlgorithm
	{
		
		/// <summary>
		/// Type of the algorithm
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersAlgorithmType Type { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerLoad_balancer_type
	{
		
		/// <summary>
		/// Point in time when the Load Balancer type is deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Number of SSL Certificates that can be assigned to a single Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_assigned_certificates")]
		public double Max_assigned_certificates { get; set; }
		
		/// <summary>
		/// Number of maximum simultaneous open connections
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_connections")]
		public double Max_connections { get; set; }
		
		/// <summary>
		/// Number of services a Load Balancer of this type can have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_services")]
		public double Max_services { get; set; }
		
		/// <summary>
		/// Number of targets a single Load Balancer can have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_targets")]
		public double Max_targets { get; set; }
		
		/// <summary>
		/// Unique identifier of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Prices in different network zones
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public Load_balancers_idGetReturnLoad_balancerLoad_balancer_typePrices[] Load_balancers_idGetReturnLoad_balancerLoad_balancer_typePrices { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerLoad_balancer_typePrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Resource in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public Load_balancers_idGetReturnLoad_balancerLoad_balancer_typePricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Resource in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public Load_balancers_idGetReturnLoad_balancerLoad_balancer_typePricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerLoad_balancer_typePricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerLoad_balancer_typePricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerPrivate_net
	{
		
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public System.Nullable<System.Int32> Network { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerPublic_net
	{
		
		/// <summary>
		/// Public Interface enabled or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// IP address (v4)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public Load_balancers_idGetReturnLoad_balancerPublic_netIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IP address (v6)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public Load_balancers_idGetReturnLoad_balancerPublic_netIpv6 Ipv6 { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerPublic_netIpv4
	{
		
		/// <summary>
		/// Reverse DNS PTR entry for the IPv4 address of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// IP address (v4) of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerPublic_netIpv6
	{
		
		/// <summary>
		/// Reverse DNS PTR entry for the IPv6 address of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// IP address (v6) of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerServices
	{
		
		/// <summary>
		/// Port the Load Balancer will balance to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination_port")]
		public int Destination_port { get; set; }
		
		/// <summary>
		/// Service health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="health_check")]
		public Load_balancers_idGetReturnLoad_balancerServicesHealth_check Health_check { get; set; }
		
		/// <summary>
		/// Configuration option for protocols http and https
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancers_idGetReturnLoad_balancerServicesHttp Http { get; set; }
		
		/// <summary>
		/// Port the Load Balancer listens on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public int Listen_port { get; set; }
		
		/// <summary>
		/// Protocol of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Is Proxyprotocol enabled or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="proxyprotocol")]
		public bool Proxyprotocol { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerServicesHealth_check
	{
		
		/// <summary>
		/// Additional configuration for protocol http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancers_idGetReturnLoad_balancerServicesHealth_checkHttp Http { get; set; }
		
		/// <summary>
		/// Time interval in seconds health checks are performed
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public int Interval { get; set; }
		
		/// <summary>
		/// Port the health check will be performed on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// Type of the health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_checkProtocol Protocol { get; set; }
		
		/// <summary>
		/// Unsuccessful retries needed until a target is considered unhealthy; an unhealthy target needs the same number of successful retries to become healthy again
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public int Retries { get; set; }
		
		/// <summary>
		/// Time in seconds after an attempt is considered a timeout
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public int Timeout { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerServicesHealth_checkHttp
	{
		
		/// <summary>
		/// Host header to send in the HTTP request. May not contain spaces, percent or backslash symbols. Can be null, in that case no host header is sent.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// HTTP path to use for health checks. May not contain literal spaces, use percent-encoding instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// String that must be contained in HTTP response in order to pass the health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
		
		/// <summary>
		/// List of returned HTTP status codes in order to pass the health check. Supports the wildcards `?` for exactly one character and `*` for multiple ones. The default is to pass the health check for any status code between 2?? and 3??.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status_codes")]
		public string[] Status_codes { get; set; }
		
		/// <summary>
		/// Use HTTPS for health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tls")]
		public System.Nullable<System.Boolean> Tls { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerServicesHttp
	{
		
		/// <summary>
		/// IDs of the Certificates to use for TLS/SSL termination by the Load Balancer; empty for TLS/SSL passthrough or if `protocol` is "http"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificates")]
		public int[] Certificates { get; set; }
		
		/// <summary>
		/// Lifetime of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_lifetime")]
		public System.Nullable<System.Int32> Cookie_lifetime { get; set; }
		
		/// <summary>
		/// Name of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_name")]
		public string Cookie_name { get; set; }
		
		/// <summary>
		/// Redirect HTTP requests to HTTPS. Only available if protocol is "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirect_http")]
		public System.Nullable<System.Boolean> Redirect_http { get; set; }
		
		/// <summary>
		/// Use sticky sessions. Only available if protocol is "http" or "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sticky_sessions")]
		public System.Nullable<System.Boolean> Sticky_sessions { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerTargets
	{
		
		/// <summary>
		/// List of health statuses of the services on this target. Only present for target types "server" and "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="health_status")]
		public Load_balancers_idGetReturnLoad_balancerTargetsHealth_status[] Load_balancers_idGetReturnLoad_balancerTargetsHealth_status { get; set; }
		
		/// <summary>
		/// IP targets where the traffic should be routed to. It is only possible to use the (Public or vSwitch) IPs of Hetzner Online Root Servers belonging to the project owner. IPs belonging to other users are blocked. Additionally IPs belonging to services provided by Hetzner Cloud (Servers, Load Balancers, ...) are blocked as well. Only present for target type "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public Load_balancers_idGetReturnLoad_balancerTargetsIp Ip { get; set; }
		
		/// <summary>
		/// Label selector used to determine targets. Only present for target type "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public Load_balancers_idGetReturnLoad_balancerTargetsLabel_selector Label_selector { get; set; }
		
		/// <summary>
		/// Server where the traffic should be routed to. Only present for target type "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Load_balancers_idGetReturnLoad_balancerTargetsServer Server { get; set; }
		
		/// <summary>
		/// List of resolved label selector target Servers. Only present for type "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Load_balancers_idGetReturnLoad_balancerTargetsTargets[] Load_balancers_idGetReturnLoad_balancerTargetsTargets { get; set; }
		
		/// <summary>
		/// Type of the resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsType Type { get; set; }
		
		/// <summary>
		/// Use the private network IP instead of the public IP. Default value is false. Only present for target types "server" and "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_private_ip")]
		public System.Nullable<System.Boolean> Use_private_ip { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerTargetsHealth_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public System.Nullable<System.Int32> Listen_port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_statusStatus Status { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerTargetsIp
	{
		
		/// <summary>
		/// IP of a server that belongs to the same customer (public IPv4/IPv6) or private IP in a Subnetwork type vswitch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerTargetsLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerTargetsServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerTargetsTargets
	{
		
		/// <summary>
		/// List of health statuses of the services on this target. Only present for target types "server" and "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="health_status")]
		public Load_balancers_idGetReturnLoad_balancerTargetsTargetsHealth_status[] Load_balancers_idGetReturnLoad_balancerTargetsTargetsHealth_status { get; set; }
		
		/// <summary>
		/// Server where the traffic should be routed to. Only present for target type "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Load_balancers_idGetReturnLoad_balancerTargetsTargetsServer Server { get; set; }
		
		/// <summary>
		/// Type of the resource. Here always "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Use the private network IP instead of the public IP. Default value is false. Only present for target types "server" and "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_private_ip")]
		public System.Nullable<System.Boolean> Use_private_ip { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerTargetsTargetsHealth_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public System.Nullable<System.Int32> Listen_port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_statusStatus Status { get; set; }
	}
	
	public class Load_balancers_idGetReturnLoad_balancerTargetsTargetsServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Load_balancers_idPutPutBody
	{
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// New Load Balancer name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Load_balancers_idPutReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="load_balancer")]
		public Load_balancers_idPutReturnLoad_balancer Load_balancer { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancer
	{
		
		/// <summary>
		/// Algorithm of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="algorithm")]
		public Load_balancers_idPutReturnLoad_balancerAlgorithm Algorithm { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Free Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="included_traffic")]
		public int Included_traffic { get; set; }
		
		/// <summary>
		/// Inbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ingoing_traffic")]
		public System.Nullable<System.Int32> Ingoing_traffic { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="load_balancer_type")]
		public Load_balancers_idPutReturnLoad_balancerLoad_balancer_type Load_balancer_type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Load_balancers_idPutReturnLoad_balancerLocation Location { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Outbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="outgoing_traffic")]
		public System.Nullable<System.Int32> Outgoing_traffic { get; set; }
		
		/// <summary>
		/// Private networks information
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_net")]
		public Load_balancers_idPutReturnLoad_balancerPrivate_net[] Load_balancers_idPutReturnLoad_balancerPrivate_net { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Load_balancers_idPutReturnLoad_balancerProtection Protection { get; set; }
		
		/// <summary>
		/// Public network information
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_net")]
		public Load_balancers_idPutReturnLoad_balancerPublic_net Public_net { get; set; }
		
		/// <summary>
		/// List of services that belong to this Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="services")]
		public Load_balancers_idPutReturnLoad_balancerServices[] Load_balancers_idPutReturnLoad_balancerServices { get; set; }
		
		/// <summary>
		/// List of targets that belong to this Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Load_balancers_idPutReturnLoad_balancerTargets[] Load_balancers_idPutReturnLoad_balancerTargets { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerAlgorithm
	{
		
		/// <summary>
		/// Type of the algorithm
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersAlgorithmType Type { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerLoad_balancer_type
	{
		
		/// <summary>
		/// Point in time when the Load Balancer type is deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Number of SSL Certificates that can be assigned to a single Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_assigned_certificates")]
		public double Max_assigned_certificates { get; set; }
		
		/// <summary>
		/// Number of maximum simultaneous open connections
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_connections")]
		public double Max_connections { get; set; }
		
		/// <summary>
		/// Number of services a Load Balancer of this type can have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_services")]
		public double Max_services { get; set; }
		
		/// <summary>
		/// Number of targets a single Load Balancer can have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="max_targets")]
		public double Max_targets { get; set; }
		
		/// <summary>
		/// Unique identifier of the Load Balancer type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Prices in different network zones
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public Load_balancers_idPutReturnLoad_balancerLoad_balancer_typePrices[] Load_balancers_idPutReturnLoad_balancerLoad_balancer_typePrices { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerLoad_balancer_typePrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Resource in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public Load_balancers_idPutReturnLoad_balancerLoad_balancer_typePricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Resource in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public Load_balancers_idPutReturnLoad_balancerLoad_balancer_typePricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerLoad_balancer_typePricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerLoad_balancer_typePricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerPrivate_net
	{
		
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public System.Nullable<System.Int32> Network { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerPublic_net
	{
		
		/// <summary>
		/// Public Interface enabled or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// IP address (v4)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public Load_balancers_idPutReturnLoad_balancerPublic_netIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IP address (v6)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public Load_balancers_idPutReturnLoad_balancerPublic_netIpv6 Ipv6 { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerPublic_netIpv4
	{
		
		/// <summary>
		/// Reverse DNS PTR entry for the IPv4 address of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// IP address (v4) of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerPublic_netIpv6
	{
		
		/// <summary>
		/// Reverse DNS PTR entry for the IPv6 address of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// IP address (v6) of this Load Balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerServices
	{
		
		/// <summary>
		/// Port the Load Balancer will balance to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination_port")]
		public int Destination_port { get; set; }
		
		/// <summary>
		/// Service health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="health_check")]
		public Load_balancers_idPutReturnLoad_balancerServicesHealth_check Health_check { get; set; }
		
		/// <summary>
		/// Configuration option for protocols http and https
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancers_idPutReturnLoad_balancerServicesHttp Http { get; set; }
		
		/// <summary>
		/// Port the Load Balancer listens on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public int Listen_port { get; set; }
		
		/// <summary>
		/// Protocol of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Is Proxyprotocol enabled or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="proxyprotocol")]
		public bool Proxyprotocol { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerServicesHealth_check
	{
		
		/// <summary>
		/// Additional configuration for protocol http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancers_idPutReturnLoad_balancerServicesHealth_checkHttp Http { get; set; }
		
		/// <summary>
		/// Time interval in seconds health checks are performed
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public int Interval { get; set; }
		
		/// <summary>
		/// Port the health check will be performed on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// Type of the health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_checkProtocol Protocol { get; set; }
		
		/// <summary>
		/// Unsuccessful retries needed until a target is considered unhealthy; an unhealthy target needs the same number of successful retries to become healthy again
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public int Retries { get; set; }
		
		/// <summary>
		/// Time in seconds after an attempt is considered a timeout
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public int Timeout { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerServicesHealth_checkHttp
	{
		
		/// <summary>
		/// Host header to send in the HTTP request. May not contain spaces, percent or backslash symbols. Can be null, in that case no host header is sent.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// HTTP path to use for health checks. May not contain literal spaces, use percent-encoding instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// String that must be contained in HTTP response in order to pass the health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
		
		/// <summary>
		/// List of returned HTTP status codes in order to pass the health check. Supports the wildcards `?` for exactly one character and `*` for multiple ones. The default is to pass the health check for any status code between 2?? and 3??.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status_codes")]
		public string[] Status_codes { get; set; }
		
		/// <summary>
		/// Use HTTPS for health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tls")]
		public System.Nullable<System.Boolean> Tls { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerServicesHttp
	{
		
		/// <summary>
		/// IDs of the Certificates to use for TLS/SSL termination by the Load Balancer; empty for TLS/SSL passthrough or if `protocol` is "http"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificates")]
		public int[] Certificates { get; set; }
		
		/// <summary>
		/// Lifetime of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_lifetime")]
		public System.Nullable<System.Int32> Cookie_lifetime { get; set; }
		
		/// <summary>
		/// Name of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_name")]
		public string Cookie_name { get; set; }
		
		/// <summary>
		/// Redirect HTTP requests to HTTPS. Only available if protocol is "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirect_http")]
		public System.Nullable<System.Boolean> Redirect_http { get; set; }
		
		/// <summary>
		/// Use sticky sessions. Only available if protocol is "http" or "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sticky_sessions")]
		public System.Nullable<System.Boolean> Sticky_sessions { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerTargets
	{
		
		/// <summary>
		/// List of health statuses of the services on this target. Only present for target types "server" and "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="health_status")]
		public Load_balancers_idPutReturnLoad_balancerTargetsHealth_status[] Load_balancers_idPutReturnLoad_balancerTargetsHealth_status { get; set; }
		
		/// <summary>
		/// IP targets where the traffic should be routed to. It is only possible to use the (Public or vSwitch) IPs of Hetzner Online Root Servers belonging to the project owner. IPs belonging to other users are blocked. Additionally IPs belonging to services provided by Hetzner Cloud (Servers, Load Balancers, ...) are blocked as well. Only present for target type "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public Load_balancers_idPutReturnLoad_balancerTargetsIp Ip { get; set; }
		
		/// <summary>
		/// Label selector used to determine targets. Only present for target type "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public Load_balancers_idPutReturnLoad_balancerTargetsLabel_selector Label_selector { get; set; }
		
		/// <summary>
		/// Server where the traffic should be routed to. Only present for target type "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Load_balancers_idPutReturnLoad_balancerTargetsServer Server { get; set; }
		
		/// <summary>
		/// List of resolved label selector target Servers. Only present for type "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targets")]
		public Load_balancers_idPutReturnLoad_balancerTargetsTargets[] Load_balancers_idPutReturnLoad_balancerTargetsTargets { get; set; }
		
		/// <summary>
		/// Type of the resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsType Type { get; set; }
		
		/// <summary>
		/// Use the private network IP instead of the public IP. Default value is false. Only present for target types "server" and "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_private_ip")]
		public System.Nullable<System.Boolean> Use_private_ip { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerTargetsHealth_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public System.Nullable<System.Int32> Listen_port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_statusStatus Status { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerTargetsIp
	{
		
		/// <summary>
		/// IP of a server that belongs to the same customer (public IPv4/IPv6) or private IP in a Subnetwork type vswitch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerTargetsLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerTargetsServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerTargetsTargets
	{
		
		/// <summary>
		/// List of health statuses of the services on this target. Only present for target types "server" and "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="health_status")]
		public Load_balancers_idPutReturnLoad_balancerTargetsTargetsHealth_status[] Load_balancers_idPutReturnLoad_balancerTargetsTargetsHealth_status { get; set; }
		
		/// <summary>
		/// Server where the traffic should be routed to. Only present for target type "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Load_balancers_idPutReturnLoad_balancerTargetsTargetsServer Server { get; set; }
		
		/// <summary>
		/// Type of the resource. Here always "server".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Use the private network IP instead of the public IP. Default value is false. Only present for target types "server" and "label_selector".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_private_ip")]
		public System.Nullable<System.Boolean> Use_private_ip { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerTargetsTargetsHealth_status
	{
		
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public System.Nullable<System.Int32> Listen_port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsHealth_statusStatus Status { get; set; }
	}
	
	public class Load_balancers_idPutReturnLoad_balancerTargetsTargetsServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
	}
	
	public enum Load_balancers_idActionsGetBySortAndStatusSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command")]
		command = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:asc")]
		commandasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:desc")]
		commanddesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status")]
		status = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:asc")]
		statusasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:desc")]
		statusdesc = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress")]
		progress = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:asc")]
		progressasc = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:desc")]
		progressdesc = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started")]
		started = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:asc")]
		startedasc = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:desc")]
		starteddesc = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished")]
		finished = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:asc")]
		finishedasc = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:desc")]
		finisheddesc = 17,
	}
	
	public class Load_balancers_idActionsGetBySortAndStatusReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public Load_balancers_idActionsGetBySortAndStatusReturnActions[] Load_balancers_idActionsGetBySortAndStatusReturnActions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Load_balancers_idActionsGetBySortAndStatusReturnMeta Meta { get; set; }
	}
	
	public class Load_balancers_idActionsGetBySortAndStatusReturnActions
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Load_balancers_idActionsGetBySortAndStatusReturnActionsError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Load_balancers_idActionsGetBySortAndStatusReturnActionsResources[] Load_balancers_idActionsGetBySortAndStatusReturnActionsResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Load_balancers_idActionsGetBySortAndStatusReturnActionsError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Load_balancers_idActionsGetBySortAndStatusReturnActionsResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Load_balancers_idActionsGetBySortAndStatusReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Load_balancers_idActionsGetBySortAndStatusReturnMetaPagination Pagination { get; set; }
	}
	
	public class Load_balancers_idActionsGetBySortAndStatusReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Load_balancers_idActionsAdd_servicePostPostBody
	{
		
		/// <summary>
		/// Port the Load Balancer will balance to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination_port")]
		public int Destination_port { get; set; }
		
		/// <summary>
		/// Service health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="health_check")]
		public Load_balancers_idActionsAdd_servicePostPostBodyHealth_check Health_check { get; set; }
		
		/// <summary>
		/// Configuration option for protocols http and https
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancers_idActionsAdd_servicePostPostBodyHttp Http { get; set; }
		
		/// <summary>
		/// Port the Load Balancer listens on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public int Listen_port { get; set; }
		
		/// <summary>
		/// Protocol of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Is Proxyprotocol enabled or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="proxyprotocol")]
		public bool Proxyprotocol { get; set; }
	}
	
	public class Load_balancers_idActionsAdd_servicePostPostBodyHealth_check
	{
		
		/// <summary>
		/// Additional configuration for protocol http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancers_idActionsAdd_servicePostPostBodyHealth_checkHttp Http { get; set; }
		
		/// <summary>
		/// Time interval in seconds health checks are performed
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public int Interval { get; set; }
		
		/// <summary>
		/// Port the health check will be performed on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// Type of the health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_checkProtocol Protocol { get; set; }
		
		/// <summary>
		/// Unsuccessful retries needed until a target is considered unhealthy; an unhealthy target needs the same number of successful retries to become healthy again
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public int Retries { get; set; }
		
		/// <summary>
		/// Time in seconds after an attempt is considered a timeout
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public int Timeout { get; set; }
	}
	
	public class Load_balancers_idActionsAdd_servicePostPostBodyHealth_checkHttp
	{
		
		/// <summary>
		/// Host header to send in the HTTP request. May not contain spaces, percent or backslash symbols. Can be null, in that case no host header is sent.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// HTTP path to use for health checks. May not contain literal spaces, use percent-encoding instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// String that must be contained in HTTP response in order to pass the health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
		
		/// <summary>
		/// List of returned HTTP status codes in order to pass the health check. Supports the wildcards `?` for exactly one character and `*` for multiple ones. The default is to pass the health check for any status code between 2?? and 3??.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status_codes")]
		public string[] Status_codes { get; set; }
		
		/// <summary>
		/// Use HTTPS for health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tls")]
		public System.Nullable<System.Boolean> Tls { get; set; }
	}
	
	public class Load_balancers_idActionsAdd_servicePostPostBodyHttp
	{
		
		/// <summary>
		/// IDs of the Certificates to use for TLS/SSL termination by the Load Balancer; empty for TLS/SSL passthrough or if `protocol` is "http"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificates")]
		public int[] Certificates { get; set; }
		
		/// <summary>
		/// Lifetime of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_lifetime")]
		public System.Nullable<System.Int32> Cookie_lifetime { get; set; }
		
		/// <summary>
		/// Name of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_name")]
		public string Cookie_name { get; set; }
		
		/// <summary>
		/// Redirect HTTP requests to HTTPS. Only available if protocol is "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirect_http")]
		public System.Nullable<System.Boolean> Redirect_http { get; set; }
		
		/// <summary>
		/// Use sticky sessions. Only available if protocol is "http" or "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sticky_sessions")]
		public System.Nullable<System.Boolean> Sticky_sessions { get; set; }
	}
	
	public class Load_balancers_idActionsAdd_targetPostPostBody
	{
		
		/// <summary>
		/// IP targets where the traffic should be routed to. It is only possible to use the (Public or vSwitch) IPs of Hetzner Online Root Servers belonging to the project owner. IPs belonging to other users are blocked. Additionally IPs belonging to services provided by Hetzner Cloud (Servers, Load Balancers, ...) are blocked as well. Only present for target type "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public Load_balancers_idActionsAdd_targetPostPostBodyIp Ip { get; set; }
		
		/// <summary>
		/// Configuration for label selector targets, required if type is `label_selector`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public Load_balancers_idActionsAdd_targetPostPostBodyLabel_selector Label_selector { get; set; }
		
		/// <summary>
		/// Configuration for type Server, required if type is `server`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Load_balancers_idActionsAdd_targetPostPostBodyServer Server { get; set; }
		
		/// <summary>
		/// Type of the resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsType Type { get; set; }
		
		/// <summary>
		/// Use the private network IP instead of the public IP of the Server, requires the Server and Load Balancer to be in the same network. Default value is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="use_private_ip")]
		public System.Nullable<System.Boolean> Use_private_ip { get; set; }
	}
	
	public class Load_balancers_idActionsAdd_targetPostPostBodyIp
	{
		
		/// <summary>
		/// IP of a server that belongs to the same customer (public IPv4/IPv6) or private IP in a Subnetwork type vswitch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancers_idActionsAdd_targetPostPostBodyLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class Load_balancers_idActionsAdd_targetPostPostBodyServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
	}
	
	public class Load_balancers_idActionsAttach_to_networkPostPostBody
	{
		
		/// <summary>
		/// IP to request to be assigned to this Load Balancer; if you do not provide this then you will be auto assigned an IP address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// ID of an existing network to attach the Load Balancer to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network")]
		public double Network { get; set; }
	}
	
	public class Load_balancers_idActionsChange_algorithmPostPostBody
	{
		
		/// <summary>
		/// Algorithm of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersAlgorithmType Type { get; set; }
	}
	
	public class Load_balancers_idActionsChange_dns_ptrPostPostBody
	{
		
		/// <summary>
		/// Hostname to set as a reverse DNS PTR entry
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Public IP address for which the reverse DNS entry should be set
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancers_idActionsChange_protectionPostPostBody
	{
		
		/// <summary>
		/// If true, prevents the Load Balancer from being deleted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public System.Nullable<System.Boolean> Delete { get; set; }
	}
	
	public class Load_balancers_idActionsChange_typePostPostBody
	{
		
		/// <summary>
		/// ID or name of Load Balancer type the Load Balancer should migrate to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="load_balancer_type")]
		public string Load_balancer_type { get; set; }
	}
	
	public class Load_balancers_idActionsDelete_servicePostPostBody
	{
		
		/// <summary>
		/// The listen port of the service you want to delete
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public double Listen_port { get; set; }
	}
	
	public class Load_balancers_idActionsDetach_from_networkPostPostBody
	{
		
		/// <summary>
		/// ID of an existing network to detach the Load Balancer from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network")]
		public double Network { get; set; }
	}
	
	public class Load_balancers_idActionsRemove_targetPostPostBody
	{
		
		/// <summary>
		/// IP targets where the traffic should be routed to. It is only possible to use the (Public or vSwitch) IPs of Hetzner Online Root Servers belonging to the project owner. IPs belonging to other users are blocked. Additionally IPs belonging to services provided by Hetzner Cloud (Servers, Load Balancers, ...) are blocked as well. Only present for target type "ip".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public Load_balancers_idActionsRemove_targetPostPostBodyIp Ip { get; set; }
		
		/// <summary>
		/// Configuration for label selector targets, required if type is `label_selector`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label_selector")]
		public Load_balancers_idActionsRemove_targetPostPostBodyLabel_selector Label_selector { get; set; }
		
		/// <summary>
		/// Configuration for type Server, required if type is `server`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Load_balancers_idActionsRemove_targetPostPostBodyServer Server { get; set; }
		
		/// <summary>
		/// Type of the resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersTargetsType Type { get; set; }
	}
	
	public class Load_balancers_idActionsRemove_targetPostPostBodyIp
	{
		
		/// <summary>
		/// IP of a server that belongs to the same customer (public IPv4/IPv6) or private IP in a Subnetwork type vswitch.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Load_balancers_idActionsRemove_targetPostPostBodyLabel_selector
	{
		
		/// <summary>
		/// Label selector
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public string Selector { get; set; }
	}
	
	public class Load_balancers_idActionsRemove_targetPostPostBodyServer
	{
		
		/// <summary>
		/// ID of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
	}
	
	public class Load_balancers_idActionsUpdate_servicePostPostBody
	{
		
		/// <summary>
		/// Port the Load Balancer will balance to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination_port")]
		public int Destination_port { get; set; }
		
		/// <summary>
		/// Service health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="health_check")]
		public Load_balancers_idActionsUpdate_servicePostPostBodyHealth_check Health_check { get; set; }
		
		/// <summary>
		/// Configuration option for protocols http and https
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancers_idActionsUpdate_servicePostPostBodyHttp Http { get; set; }
		
		/// <summary>
		/// Port the Load Balancer listens on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listen_port")]
		public int Listen_port { get; set; }
		
		/// <summary>
		/// Protocol of the Load Balancer
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesProtocol Protocol { get; set; }
		
		/// <summary>
		/// Is Proxyprotocol enabled or not
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="proxyprotocol")]
		public bool Proxyprotocol { get; set; }
	}
	
	public class Load_balancers_idActionsUpdate_servicePostPostBodyHealth_check
	{
		
		/// <summary>
		/// Additional configuration for protocol http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="http")]
		public Load_balancers_idActionsUpdate_servicePostPostBodyHealth_checkHttp Http { get; set; }
		
		/// <summary>
		/// Time interval in seconds health checks are performed
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public int Interval { get; set; }
		
		/// <summary>
		/// Port the health check will be performed on
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="port")]
		public int Port { get; set; }
		
		/// <summary>
		/// Type of the health check
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public Load_balancersGetBySortAndNameAndLabel_selectorReturnLoad_balancersServicesHealth_checkProtocol Protocol { get; set; }
		
		/// <summary>
		/// Unsuccessful retries needed until a target is considered unhealthy; an unhealthy target needs the same number of successful retries to become healthy again
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="retries")]
		public int Retries { get; set; }
		
		/// <summary>
		/// Time in seconds after an attempt is considered a timeout
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public int Timeout { get; set; }
	}
	
	public class Load_balancers_idActionsUpdate_servicePostPostBodyHealth_checkHttp
	{
		
		/// <summary>
		/// Host header to send in the HTTP request. May not contain spaces, percent or backslash symbols. Can be null, in that case no host header is sent.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// HTTP path to use for health checks. May not contain literal spaces, use percent-encoding instead.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// String that must be contained in HTTP response in order to pass the health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
		
		/// <summary>
		/// List of returned HTTP status codes in order to pass the health check. Supports the wildcards `?` for exactly one character and `*` for multiple ones. The default is to pass the health check for any status code between 2?? and 3??.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status_codes")]
		public string[] Status_codes { get; set; }
		
		/// <summary>
		/// Use HTTPS for health check
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tls")]
		public System.Nullable<System.Boolean> Tls { get; set; }
	}
	
	public class Load_balancers_idActionsUpdate_servicePostPostBodyHttp
	{
		
		/// <summary>
		/// IDs of the Certificates to use for TLS/SSL termination by the Load Balancer; empty for TLS/SSL passthrough or if `protocol` is "http"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificates")]
		public int[] Certificates { get; set; }
		
		/// <summary>
		/// Lifetime of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_lifetime")]
		public System.Nullable<System.Int32> Cookie_lifetime { get; set; }
		
		/// <summary>
		/// Name of the cookie used for sticky sessions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cookie_name")]
		public string Cookie_name { get; set; }
		
		/// <summary>
		/// Redirect HTTP requests to HTTPS. Only available if protocol is "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirect_http")]
		public System.Nullable<System.Boolean> Redirect_http { get; set; }
		
		/// <summary>
		/// Use sticky sessions. Only available if protocol is "http" or "https". Default `false`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sticky_sessions")]
		public System.Nullable<System.Boolean> Sticky_sessions { get; set; }
	}
	
	public class Load_balancers_idActions_action_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Load_balancers_idActions_action_idGetReturnAction Action { get; set; }
	}
	
	public class Load_balancers_idActions_action_idGetReturnAction
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Load_balancers_idActions_action_idGetReturnActionError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Load_balancers_idActions_action_idGetReturnActionResources[] Load_balancers_idActions_action_idGetReturnActionResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Load_balancers_idActions_action_idGetReturnActionError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Load_balancers_idActions_action_idGetReturnActionResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public enum Load_balancers_idMetricsGetByTypeAndStartAndEndAndStepType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="open_connections")]
		open_connections = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="connections_per_second")]
		connections_per_second = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="requests_per_second")]
		requests_per_second = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bandwidth")]
		bandwidth = 3,
	}
	
	public class Load_balancers_idMetricsGetByTypeAndStartAndEndAndStepReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metrics")]
		public Load_balancers_idMetricsGetByTypeAndStartAndEndAndStepReturnMetrics Metrics { get; set; }
	}
	
	public class Load_balancers_idMetricsGetByTypeAndStartAndEndAndStepReturnMetrics
	{
		
		/// <summary>
		/// End of period of metrics reported (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// Start of period of metrics reported (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
		
		/// <summary>
		/// Resolution of results in seconds.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="step")]
		public double Step { get; set; }
		
		/// <summary>
		/// Hash with timeseries information, containing the name of timeseries as key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="time_series")]
		public System.Collections.Generic.Dictionary<string, Load_balancers_idMetricsGetByTypeAndStartAndEndAndStepReturnMetricsTime_series> Time_series { get; set; }
	}
	
	public class Load_balancers_idMetricsGetByTypeAndStartAndEndAndStepReturnMetricsTime_series
	{
		
		/// <summary>
		/// Metrics Timestamps with values
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	public class LocationsGetByNameReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public LocationsGetByNameReturnLocations[] LocationsGetByNameReturnLocations { get; set; }
	}
	
	public class LocationsGetByNameReturnLocations
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Locations_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Locations_idGetReturnLocation Location { get; set; }
	}
	
	public class Locations_idGetReturnLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class NetworksGetByNameAndLabel_selectorReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public NetworksGetByNameAndLabel_selectorReturnMeta Meta { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public NetworksGetByNameAndLabel_selectorReturnNetworks[] NetworksGetByNameAndLabel_selectorReturnNetworks { get; set; }
	}
	
	public class NetworksGetByNameAndLabel_selectorReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public NetworksGetByNameAndLabel_selectorReturnMetaPagination Pagination { get; set; }
	}
	
	public class NetworksGetByNameAndLabel_selectorReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class NetworksGetByNameAndLabel_selectorReturnNetworks
	{
		
		/// <summary>
		/// Point in time when the Network was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// IPv4 prefix of the whole Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// Array of IDs of Load Balancers attached to this Network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="load_balancers")]
		public int[] Load_balancers { get; set; }
		
		/// <summary>
		/// Name of the Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public NetworksGetByNameAndLabel_selectorReturnNetworksProtection Protection { get; set; }
		
		/// <summary>
		/// Array of routes set in this Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routes")]
		public NetworksGetByNameAndLabel_selectorReturnNetworksRoutes[] NetworksGetByNameAndLabel_selectorReturnNetworksRoutes { get; set; }
		
		/// <summary>
		/// Array of IDs of Servers attached to this Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public int[] Servers { get; set; }
		
		/// <summary>
		/// Array subnets allocated in this Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subnets")]
		public NetworksGetByNameAndLabel_selectorReturnNetworksSubnets[] NetworksGetByNameAndLabel_selectorReturnNetworksSubnets { get; set; }
	}
	
	public class NetworksGetByNameAndLabel_selectorReturnNetworksProtection
	{
		
		/// <summary>
		/// If true, prevents the Network from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class NetworksGetByNameAndLabel_selectorReturnNetworksRoutes
	{
		
		/// <summary>
		/// Destination network or host of this route. Must not overlap with an existing ip_range in any subnets or with any destinations in other routes or with the first IP of the networks ip_range or with 172.31.1.1. Must be one of the private IPv4 ranges of RFC1918.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public string Destination { get; set; }
		
		/// <summary>
		/// Gateway for the route. Cannot be the first IP of the networks ip_range and also cannot be 172.31.1.1 as this IP is being used as a gateway for the public network interface of Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
	}
	
	public class NetworksGetByNameAndLabel_selectorReturnNetworksSubnets
	{
		
		/// <summary>
		/// Gateway for Servers attached to this subnet. For subnets of type Server this is always the first IP of the network IP range.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// Range to allocate IPs from. Must be a Subnet of the ip_range of the parent network object and must not overlap with any other subnets or with any destinations in routes. Minimum Network size is /30. We suggest that you pick a bigger Network with a /24 netmask.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
		
		/// <summary>
		/// Name of Network zone. The Location object contains the `network_zone` property each Location belongs to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
		
		/// <summary>
		/// Type of Subnetwork
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public NetworksGetByNameAndLabel_selectorReturnNetworksSubnetsType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum NetworksGetByNameAndLabel_selectorReturnNetworksSubnetsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cloud")]
		cloud = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="server")]
		server = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="vswitch")]
		vswitch = 2,
	}
	
	public class NetworksPostPostBody
	{
		
		/// <summary>
		/// IP range of the whole network which must span all included subnets. Must be one of the private IPv4 ranges of RFC1918. Minimum network size is /24. We highly recommend that you pick a larger network with a /16 netmask.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public NetworksPostPostBodyLabels Labels { get; set; }
		
		/// <summary>
		/// Name of the network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Array of routes set in this network. The destination of the route must be one of the private IPv4 ranges of RFC1918. The gateway must be a subnet/IP of the ip_range of the network object. The destination must not overlap with an existing ip_range in any subnets or with any destinations in other routes or with the first IP of the networks ip_range or with 172.31.1.1. The gateway cannot be the first IP of the networks ip_range and also cannot be 172.31.1.1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routes")]
		public NetworksPostPostBodyRoutes[] NetworksPostPostBodyRoutes { get; set; }
		
		/// <summary>
		/// Array of subnets allocated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnets")]
		public NetworksPostPostBodySubnets[] NetworksPostPostBodySubnets { get; set; }
	}
	
	public class NetworksPostPostBodyLabels
	{
		
		/// <summary>
		/// New label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelkey")]
		public string Labelkey { get; set; }
	}
	
	public class NetworksPostPostBodyRoutes
	{
		
		/// <summary>
		/// Destination network or host of this route. Must not overlap with an existing ip_range in any subnets or with any destinations in other routes or with the first IP of the networks ip_range or with 172.31.1.1. Must be one of the private IPv4 ranges of RFC1918.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public string Destination { get; set; }
		
		/// <summary>
		/// Gateway for the route. Cannot be the first IP of the networks ip_range and also cannot be 172.31.1.1 as this IP is being used as a gateway for the public network interface of Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
	}
	
	public class NetworksPostPostBodySubnets
	{
		
		/// <summary>
		/// Range to allocate IPs from. Must be a Subnet of the ip_range of the parent network object and must not overlap with any other subnets or with any destinations in routes. Minimum Network size is /30. We suggest that you pick a bigger Network with a /24 netmask.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
		
		/// <summary>
		/// Name of Network zone. The Location object contains the `network_zone` property each Location belongs to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
		
		/// <summary>
		/// Type of Subnetwork
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public NetworksGetByNameAndLabel_selectorReturnNetworksSubnetsType Type { get; set; }
		
		/// <summary>
		/// ID of the robot vSwitch. Must be supplied if the subnet is of type vswitch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vswitch_id")]
		public System.Nullable<System.Int32> Vswitch_id { get; set; }
	}
	
	public class Networks_idGetReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public Networks_idGetReturnNetwork Network { get; set; }
	}
	
	public class Networks_idGetReturnNetwork
	{
		
		/// <summary>
		/// Point in time when the Network was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// IPv4 prefix of the whole Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// Array of IDs of Load Balancers attached to this Network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="load_balancers")]
		public int[] Load_balancers { get; set; }
		
		/// <summary>
		/// Name of the Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Networks_idGetReturnNetworkProtection Protection { get; set; }
		
		/// <summary>
		/// Array of routes set in this Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routes")]
		public Networks_idGetReturnNetworkRoutes[] Networks_idGetReturnNetworkRoutes { get; set; }
		
		/// <summary>
		/// Array of IDs of Servers attached to this Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public int[] Servers { get; set; }
		
		/// <summary>
		/// Array subnets allocated in this Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subnets")]
		public Networks_idGetReturnNetworkSubnets[] Networks_idGetReturnNetworkSubnets { get; set; }
	}
	
	public class Networks_idGetReturnNetworkProtection
	{
		
		/// <summary>
		/// If true, prevents the Network from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Networks_idGetReturnNetworkRoutes
	{
		
		/// <summary>
		/// Destination network or host of this route. Must not overlap with an existing ip_range in any subnets or with any destinations in other routes or with the first IP of the networks ip_range or with 172.31.1.1. Must be one of the private IPv4 ranges of RFC1918.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public string Destination { get; set; }
		
		/// <summary>
		/// Gateway for the route. Cannot be the first IP of the networks ip_range and also cannot be 172.31.1.1 as this IP is being used as a gateway for the public network interface of Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
	}
	
	public class Networks_idGetReturnNetworkSubnets
	{
		
		/// <summary>
		/// Gateway for Servers attached to this subnet. For subnets of type Server this is always the first IP of the network IP range.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// Range to allocate IPs from. Must be a Subnet of the ip_range of the parent network object and must not overlap with any other subnets or with any destinations in routes. Minimum Network size is /30. We suggest that you pick a bigger Network with a /24 netmask.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
		
		/// <summary>
		/// Name of Network zone. The Location object contains the `network_zone` property each Location belongs to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
		
		/// <summary>
		/// Type of Subnetwork
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public NetworksGetByNameAndLabel_selectorReturnNetworksSubnetsType Type { get; set; }
	}
	
	public class Networks_idPutPutBody
	{
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Networks_idPutPutBodyLabels Labels { get; set; }
		
		/// <summary>
		/// New network name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Networks_idPutPutBodyLabels
	{
		
		[System.Runtime.Serialization.DataMember(Name="labelkey")]
		public string Labelkey { get; set; }
	}
	
	public class Networks_idPutReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public Networks_idPutReturnNetwork Network { get; set; }
	}
	
	public class Networks_idPutReturnNetwork
	{
		
		/// <summary>
		/// Point in time when the Network was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// IPv4 prefix of the whole Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// Array of IDs of Load Balancers attached to this Network
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="load_balancers")]
		public int[] Load_balancers { get; set; }
		
		/// <summary>
		/// Name of the Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Networks_idPutReturnNetworkProtection Protection { get; set; }
		
		/// <summary>
		/// Array of routes set in this Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="routes")]
		public Networks_idPutReturnNetworkRoutes[] Networks_idPutReturnNetworkRoutes { get; set; }
		
		/// <summary>
		/// Array of IDs of Servers attached to this Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public int[] Servers { get; set; }
		
		/// <summary>
		/// Array subnets allocated in this Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subnets")]
		public Networks_idPutReturnNetworkSubnets[] Networks_idPutReturnNetworkSubnets { get; set; }
	}
	
	public class Networks_idPutReturnNetworkProtection
	{
		
		/// <summary>
		/// If true, prevents the Network from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Networks_idPutReturnNetworkRoutes
	{
		
		/// <summary>
		/// Destination network or host of this route. Must not overlap with an existing ip_range in any subnets or with any destinations in other routes or with the first IP of the networks ip_range or with 172.31.1.1. Must be one of the private IPv4 ranges of RFC1918.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public string Destination { get; set; }
		
		/// <summary>
		/// Gateway for the route. Cannot be the first IP of the networks ip_range and also cannot be 172.31.1.1 as this IP is being used as a gateway for the public network interface of Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
	}
	
	public class Networks_idPutReturnNetworkSubnets
	{
		
		/// <summary>
		/// Gateway for Servers attached to this subnet. For subnets of type Server this is always the first IP of the network IP range.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
		
		/// <summary>
		/// Range to allocate IPs from. Must be a Subnet of the ip_range of the parent network object and must not overlap with any other subnets or with any destinations in routes. Minimum Network size is /30. We suggest that you pick a bigger Network with a /24 netmask.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
		
		/// <summary>
		/// Name of Network zone. The Location object contains the `network_zone` property each Location belongs to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
		
		/// <summary>
		/// Type of Subnetwork
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public NetworksGetByNameAndLabel_selectorReturnNetworksSubnetsType Type { get; set; }
	}
	
	public enum Networks_idActionsGetBySortAndStatusSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command")]
		command = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:asc")]
		commandasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:desc")]
		commanddesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status")]
		status = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:asc")]
		statusasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:desc")]
		statusdesc = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress")]
		progress = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:asc")]
		progressasc = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:desc")]
		progressdesc = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started")]
		started = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:asc")]
		startedasc = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:desc")]
		starteddesc = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished")]
		finished = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:asc")]
		finishedasc = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:desc")]
		finisheddesc = 17,
	}
	
	public class Networks_idActionsGetBySortAndStatusReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public Networks_idActionsGetBySortAndStatusReturnActions[] Networks_idActionsGetBySortAndStatusReturnActions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Networks_idActionsGetBySortAndStatusReturnMeta Meta { get; set; }
	}
	
	public class Networks_idActionsGetBySortAndStatusReturnActions
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Networks_idActionsGetBySortAndStatusReturnActionsError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Networks_idActionsGetBySortAndStatusReturnActionsResources[] Networks_idActionsGetBySortAndStatusReturnActionsResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Networks_idActionsGetBySortAndStatusReturnActionsError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Networks_idActionsGetBySortAndStatusReturnActionsResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Networks_idActionsGetBySortAndStatusReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Networks_idActionsGetBySortAndStatusReturnMetaPagination Pagination { get; set; }
	}
	
	public class Networks_idActionsGetBySortAndStatusReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Networks_idActionsAdd_routePostPostBody
	{
		
		/// <summary>
		/// Destination network or host of this route. Must not overlap with an existing ip_range in any subnets or with any destinations in other routes or with the first IP of the networks ip_range or with 172.31.1.1. Must be one of the private IPv4 ranges of RFC1918.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public string Destination { get; set; }
		
		/// <summary>
		/// Gateway for the route. Cannot be the first IP of the networks ip_range, an IP behind a vSwitch or 172.31.1.1, as this IP is being used as a gateway for the public network interface of Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
	}
	
	public class Networks_idActionsAdd_subnetPostPostBody
	{
		
		/// <summary>
		/// Range to allocate IPs from. Must be a Subnet of the ip_range of the parent network object and must not overlap with any other subnets or with any destinations in routes. If the Subnet is of type vSwitch, it also can not overlap with any gateway in routes. Minimum Network size is /30. We suggest that you pick a bigger Network with a /24 netmask.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
		
		/// <summary>
		/// Name of Network zone. The Location object contains the `network_zone` property each Location belongs to.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
		
		/// <summary>
		/// Type of Subnetwork
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public NetworksGetByNameAndLabel_selectorReturnNetworksSubnetsType Type { get; set; }
		
		/// <summary>
		/// ID of the robot vSwitch. Must be supplied if the subnet is of type vswitch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vswitch_id")]
		public System.Nullable<System.Int32> Vswitch_id { get; set; }
	}
	
	public class Networks_idActionsChange_ip_rangePostPostBody
	{
		
		/// <summary>
		/// The new prefix for the whole Network
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
	}
	
	public class Networks_idActionsChange_protectionPostPostBody
	{
		
		/// <summary>
		/// If true, prevents the Network from being deleted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public System.Nullable<System.Boolean> Delete { get; set; }
	}
	
	public class Networks_idActionsDelete_routePostPostBody
	{
		
		/// <summary>
		/// Destination network or host of this route. Must not overlap with an existing ip_range in any subnets or with any destinations in other routes or with the first IP of the networks ip_range or with 172.31.1.1. Must be one of the private IPv4 ranges of RFC1918.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public string Destination { get; set; }
		
		/// <summary>
		/// Gateway for the route. Cannot be the first IP of the networks ip_range, an IP behind a vSwitch or 172.31.1.1, as this IP is being used as a gateway for the public network interface of Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gateway")]
		public string Gateway { get; set; }
	}
	
	public class Networks_idActionsDelete_subnetPostPostBody
	{
		
		/// <summary>
		/// IP range of subnet to delete
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip_range")]
		public string Ip_range { get; set; }
	}
	
	public class Networks_idActions_action_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Networks_idActions_action_idGetReturnAction Action { get; set; }
	}
	
	public class Networks_idActions_action_idGetReturnAction
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Networks_idActions_action_idGetReturnActionError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Networks_idActions_action_idGetReturnActionResources[] Networks_idActions_action_idGetReturnActionResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Networks_idActions_action_idGetReturnActionError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Networks_idActions_action_idGetReturnActionResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public enum Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name")]
		name = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:asc")]
		nameasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:desc")]
		namedesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created")]
		created = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:asc")]
		createdasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:desc")]
		createddesc = 8,
	}
	
	public enum Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="spread")]
		spread = 0,
	}
	
	public class Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeReturnMeta Meta { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="placement_groups")]
		public Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeReturnPlacement_groups[] Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeReturnPlacement_groups { get; set; }
	}
	
	public class Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeReturnMetaPagination Pagination { get; set; }
	}
	
	public class Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeReturnPlacement_groups
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Array of IDs of Servers that are part of this Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public int[] Servers { get; set; }
		
		/// <summary>
		/// Type of the Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
	}
	
	public class Placement_groupsPostPostBody
	{
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// Name of the PlacementGroup
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Define the Placement Group Type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
	}
	
	public class Placement_groups_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="placement_group")]
		public Placement_groups_idGetReturnPlacement_group Placement_group { get; set; }
	}
	
	public class Placement_groups_idGetReturnPlacement_group
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Array of IDs of Servers that are part of this Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public int[] Servers { get; set; }
		
		/// <summary>
		/// Type of the Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
	}
	
	public class Placement_groups_idPutPutBody
	{
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// New PlacementGroup name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Placement_groups_idPutReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="placement_group")]
		public Placement_groups_idPutReturnPlacement_group Placement_group { get; set; }
	}
	
	public class Placement_groups_idPutReturnPlacement_group
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Array of IDs of Servers that are part of this Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public int[] Servers { get; set; }
		
		/// <summary>
		/// Type of the Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
	}
	
	public class PricingGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pricing")]
		public PricingGetReturnPricing Pricing { get; set; }
	}
	
	public class PricingGetReturnPricing
	{
		
		/// <summary>
		/// Currency the returned prices are expressed in, coded according to ISO 4217
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currency")]
		public string Currency { get; set; }
		
		/// <summary>
		/// The cost of one Floating IP per month
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="floating_ip")]
		public PricingGetReturnPricingFloating_ip Floating_ip { get; set; }
		
		/// <summary>
		/// Costs of Floating IPs types per Location and type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="floating_ips")]
		public PricingGetReturnPricingFloating_ips[] PricingGetReturnPricingFloating_ips { get; set; }
		
		/// <summary>
		/// The cost of Image per GB/month
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image")]
		public PricingGetReturnPricingImage Image { get; set; }
		
		/// <summary>
		/// Costs of Load Balancer types per Location and type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="load_balancer_types")]
		public PricingGetReturnPricingLoad_balancer_types[] PricingGetReturnPricingLoad_balancer_types { get; set; }
		
		/// <summary>
		/// Costs of Primary IPs types per Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary_ips")]
		public PricingGetReturnPricingPrimary_ips[] PricingGetReturnPricingPrimary_ips { get; set; }
		
		/// <summary>
		/// Will increase base Server costs by specific percentage
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_backup")]
		public PricingGetReturnPricingServer_backup Server_backup { get; set; }
		
		/// <summary>
		/// Costs of Server types per Location and type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_types")]
		public PricingGetReturnPricingServer_types[] PricingGetReturnPricingServer_types { get; set; }
		
		/// <summary>
		/// The cost of additional traffic per TB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="traffic")]
		public PricingGetReturnPricingTraffic Traffic { get; set; }
		
		/// <summary>
		/// The VAT rate used for calculating prices with VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vat_rate")]
		public string Vat_rate { get; set; }
		
		/// <summary>
		/// The cost of Volume per GB/month
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="volume")]
		public PricingGetReturnPricingVolume Volume { get; set; }
	}
	
	public class PricingGetReturnPricingFloating_ip
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public PricingGetReturnPricingFloating_ipPrice_monthly Price_monthly { get; set; }
	}
	
	public class PricingGetReturnPricingFloating_ipPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class PricingGetReturnPricingFloating_ips
	{
		
		/// <summary>
		/// Floating IP type costs per Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public PricingGetReturnPricingFloating_ipsPrices[] PricingGetReturnPricingFloating_ipsPrices { get; set; }
		
		/// <summary>
		/// The type of the Floating IP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType Type { get; set; }
	}
	
	public class PricingGetReturnPricingFloating_ipsPrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Monthly costs for a Floating IP type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public PricingGetReturnPricingFloating_ipsPricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class PricingGetReturnPricingFloating_ipsPricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class PricingGetReturnPricingImage
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_per_gb_month")]
		public PricingGetReturnPricingImagePrice_per_gb_month Price_per_gb_month { get; set; }
	}
	
	public class PricingGetReturnPricingImagePrice_per_gb_month
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class PricingGetReturnPricingLoad_balancer_types
	{
		
		/// <summary>
		/// ID of the Load Balancer type the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Name of the Load Balancer type the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Load Balancer type costs per Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public PricingGetReturnPricingLoad_balancer_typesPrices[] PricingGetReturnPricingLoad_balancer_typesPrices { get; set; }
	}
	
	public class PricingGetReturnPricingLoad_balancer_typesPrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Load Balancer type in this network zone
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public PricingGetReturnPricingLoad_balancer_typesPricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Load Balancer type in this network zone
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public PricingGetReturnPricingLoad_balancer_typesPricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class PricingGetReturnPricingLoad_balancer_typesPricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class PricingGetReturnPricingLoad_balancer_typesPricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class PricingGetReturnPricingPrimary_ips
	{
		
		/// <summary>
		/// Primary IP type costs per Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public PricingGetReturnPricingPrimary_ipsPrices[] PricingGetReturnPricingPrimary_ipsPrices { get; set; }
		
		/// <summary>
		/// The type of the Primary IP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType Type { get; set; }
	}
	
	public class PricingGetReturnPricingPrimary_ipsPrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Primary IP type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public PricingGetReturnPricingPrimary_ipsPricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Primary IP type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public PricingGetReturnPricingPrimary_ipsPricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class PricingGetReturnPricingPrimary_ipsPricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class PricingGetReturnPricingPrimary_ipsPricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class PricingGetReturnPricingServer_backup
	{
		
		/// <summary>
		/// Percentage by how much the base price will increase
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public string Percentage { get; set; }
	}
	
	public class PricingGetReturnPricingServer_types
	{
		
		/// <summary>
		/// ID of the Server type the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Name of the Server type the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Server type costs per Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public PricingGetReturnPricingServer_typesPrices[] PricingGetReturnPricingServer_typesPrices { get; set; }
	}
	
	public class PricingGetReturnPricingServer_typesPrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public PricingGetReturnPricingServer_typesPricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public PricingGetReturnPricingServer_typesPricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class PricingGetReturnPricingServer_typesPricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class PricingGetReturnPricingServer_typesPricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class PricingGetReturnPricingTraffic
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_per_tb")]
		public PricingGetReturnPricingTrafficPrice_per_tb Price_per_tb { get; set; }
	}
	
	public class PricingGetReturnPricingTrafficPrice_per_tb
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class PricingGetReturnPricingVolume
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_per_gb_month")]
		public PricingGetReturnPricingVolumePrice_per_gb_month Price_per_gb_month { get; set; }
	}
	
	public class PricingGetReturnPricingVolumePrice_per_gb_month
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public enum Primary_ipsGetByNameAndLabel_selectorAndIpAndSortSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created")]
		created = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:asc")]
		createdasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:desc")]
		createddesc = 5,
	}
	
	public class Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnMeta Meta { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary_ips")]
		public Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ips[] Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ips { get; set; }
	}
	
	public class Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnMetaPagination Pagination { get; set; }
	}
	
	public class Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ips
	{
		
		/// <summary>
		/// ID of the resource the Primary IP is assigned to, null if it is not assigned at all
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee_id")]
		public System.Nullable<System.Int32> Assignee_id { get; set; }
		
		/// <summary>
		/// Resource type the Primary IP can be assigned to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee_type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesType Assignee_type { get; set; }
		
		/// <summary>
		/// Delete this Primary IP when the resource it is assigned to is deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="auto_delete")]
		public bool Auto_delete { get; set; }
		
		/// <summary>
		/// Whether the IP is blocked
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Datacenter this Primary IP is located at
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsDatacenter Datacenter { get; set; }
		
		/// <summary>
		/// Array of reverse DNS entries
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsDns_ptr[] Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsDns_ptr { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsProtection Protection { get; set; }
		
		/// <summary>
		/// Type of the Primary IP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType Type { get; set; }
	}
	
	public class Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsDatacenter
	{
		
		/// <summary>
		/// Description of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsDatacenterLocation Location { get; set; }
		
		/// <summary>
		/// Unique identifier of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Server types the Datacenter can handle
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_types")]
		public Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsDatacenterServer_types Server_types { get; set; }
	}
	
	public class Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsDatacenterLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsDatacenterServer_types
	{
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available")]
		public double[] Available { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available_for_migration")]
		public double[] Available_for_migration { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported in the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="supported")]
		public double[] Supported { get; set; }
	}
	
	public class Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsDns_ptr
	{
		
		/// <summary>
		/// DNS pointer for the specific IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Single IPv4 or IPv6 address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Primary_ipsGetByNameAndLabel_selectorAndIpAndSortReturnPrimary_ipsProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Primary_ipsPostPostBody
	{
		
		/// <summary>
		/// ID of the resource the Primary IP should be assigned to. Omitted if it should not be assigned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assignee_id")]
		public System.Nullable<System.Int32> Assignee_id { get; set; }
		
		/// <summary>
		/// Resource type the Primary IP can be assigned to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee_type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesType Assignee_type { get; set; }
		
		/// <summary>
		/// Delete the Primary IP when the Server it is assigned to is deleted. If omitted defaults to `false`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auto_delete")]
		public System.Nullable<System.Boolean> Auto_delete { get; set; }
		
		/// <summary>
		/// ID or name of Datacenter the Primary IP will be bound to. Needs to be omitted if `assignee_id` is passed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public string Datacenter { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Primary IP type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType Type { get; set; }
	}
	
	public class Primary_ips_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary_ip")]
		public Primary_ips_idGetReturnPrimary_ip Primary_ip { get; set; }
	}
	
	public class Primary_ips_idGetReturnPrimary_ip
	{
		
		/// <summary>
		/// ID of the resource the Primary IP is assigned to, null if it is not assigned at all
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee_id")]
		public System.Nullable<System.Int32> Assignee_id { get; set; }
		
		/// <summary>
		/// Resource type the Primary IP can be assigned to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee_type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesType Assignee_type { get; set; }
		
		/// <summary>
		/// Delete this Primary IP when the resource it is assigned to is deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="auto_delete")]
		public bool Auto_delete { get; set; }
		
		/// <summary>
		/// Whether the IP is blocked
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Datacenter this Primary IP is located at
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public Primary_ips_idGetReturnPrimary_ipDatacenter Datacenter { get; set; }
		
		/// <summary>
		/// Array of reverse DNS entries
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public Primary_ips_idGetReturnPrimary_ipDns_ptr[] Primary_ips_idGetReturnPrimary_ipDns_ptr { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Primary_ips_idGetReturnPrimary_ipProtection Protection { get; set; }
		
		/// <summary>
		/// Type of the Primary IP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType Type { get; set; }
	}
	
	public class Primary_ips_idGetReturnPrimary_ipDatacenter
	{
		
		/// <summary>
		/// Description of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Primary_ips_idGetReturnPrimary_ipDatacenterLocation Location { get; set; }
		
		/// <summary>
		/// Unique identifier of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Server types the Datacenter can handle
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_types")]
		public Primary_ips_idGetReturnPrimary_ipDatacenterServer_types Server_types { get; set; }
	}
	
	public class Primary_ips_idGetReturnPrimary_ipDatacenterLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Primary_ips_idGetReturnPrimary_ipDatacenterServer_types
	{
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available")]
		public double[] Available { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available_for_migration")]
		public double[] Available_for_migration { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported in the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="supported")]
		public double[] Supported { get; set; }
	}
	
	public class Primary_ips_idGetReturnPrimary_ipDns_ptr
	{
		
		/// <summary>
		/// DNS pointer for the specific IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Single IPv4 or IPv6 address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Primary_ips_idGetReturnPrimary_ipProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Primary_ips_idPutPutBody
	{
		
		/// <summary>
		/// Delete this Primary IP when the resource it is assigned to is deleted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auto_delete")]
		public System.Nullable<System.Boolean> Auto_delete { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// New unique name to set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Primary_ips_idPutReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary_ip")]
		public Primary_ips_idPutReturnPrimary_ip Primary_ip { get; set; }
	}
	
	public class Primary_ips_idPutReturnPrimary_ip
	{
		
		/// <summary>
		/// ID of the resource the Primary IP is assigned to, null if it is not assigned at all
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee_id")]
		public System.Nullable<System.Int32> Assignee_id { get; set; }
		
		/// <summary>
		/// Resource type the Primary IP can be assigned to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee_type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesType Assignee_type { get; set; }
		
		/// <summary>
		/// Delete this Primary IP when the resource it is assigned to is deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="auto_delete")]
		public bool Auto_delete { get; set; }
		
		/// <summary>
		/// Whether the IP is blocked
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Datacenter this Primary IP is located at
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public Primary_ips_idPutReturnPrimary_ipDatacenter Datacenter { get; set; }
		
		/// <summary>
		/// Array of reverse DNS entries
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public Primary_ips_idPutReturnPrimary_ipDns_ptr[] Primary_ips_idPutReturnPrimary_ipDns_ptr { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Primary_ips_idPutReturnPrimary_ipProtection Protection { get; set; }
		
		/// <summary>
		/// Type of the Primary IP
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Floating_ipsGetByNameAndLabel_selectorAndSortReturnFloating_ipsType Type { get; set; }
	}
	
	public class Primary_ips_idPutReturnPrimary_ipDatacenter
	{
		
		/// <summary>
		/// Description of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Primary_ips_idPutReturnPrimary_ipDatacenterLocation Location { get; set; }
		
		/// <summary>
		/// Unique identifier of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Server types the Datacenter can handle
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_types")]
		public Primary_ips_idPutReturnPrimary_ipDatacenterServer_types Server_types { get; set; }
	}
	
	public class Primary_ips_idPutReturnPrimary_ipDatacenterLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Primary_ips_idPutReturnPrimary_ipDatacenterServer_types
	{
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available")]
		public double[] Available { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available_for_migration")]
		public double[] Available_for_migration { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported in the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="supported")]
		public double[] Supported { get; set; }
	}
	
	public class Primary_ips_idPutReturnPrimary_ipDns_ptr
	{
		
		/// <summary>
		/// DNS pointer for the specific IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Single IPv4 or IPv6 address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Primary_ips_idPutReturnPrimary_ipProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Primary_ips_idActionsAssignPostPostBody
	{
		
		/// <summary>
		/// ID of a resource of type `assignee_type`
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee_id")]
		public int Assignee_id { get; set; }
		
		/// <summary>
		/// Type of resource assigning the Primary IP to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="assignee_type")]
		public FirewallsGetBySortAndNameAndLabel_selectorReturnFirewallsApplied_toApplied_to_resourcesType Assignee_type { get; set; }
	}
	
	public class Primary_ips_idActionsChange_dns_ptrPostPostBody
	{
		
		/// <summary>
		/// Hostname to set as a reverse DNS PTR entry, will reset to original default value if `null`
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// IP address for which to set the reverse DNS entry
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Primary_ips_idActionsChange_protectionPostPostBody
	{
		
		/// <summary>
		/// If true, prevents the Primary IP from being deleted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public System.Nullable<System.Boolean> Delete { get; set; }
	}
	
	public class Server_typesGetByNameReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_types")]
		public Server_typesGetByNameReturnServer_types[] Server_typesGetByNameReturnServer_types { get; set; }
	}
	
	public class Server_typesGetByNameReturnServer_types
	{
		
		/// <summary>
		/// Type of cpu architecture
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsosArchitecture Architecture { get; set; }
		
		/// <summary>
		/// Number of cpu cores a Server of this type will have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cores")]
		public double Cores { get; set; }
		
		/// <summary>
		/// Type of cpu
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cpu_type")]
		public Server_typesGetByNameReturnServer_typesCpu_type Cpu_type { get; set; }
		
		/// <summary>
		/// True if Server type is deprecated
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public bool Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Disk size a Server of this type will have in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public double Disk { get; set; }
		
		/// <summary>
		/// ID of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Memory a Server of this type will have in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public double Memory { get; set; }
		
		/// <summary>
		/// Unique identifier of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Prices in different Locations
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public Server_typesGetByNameReturnServer_typesPrices[] Server_typesGetByNameReturnServer_typesPrices { get; set; }
		
		/// <summary>
		/// Type of Server boot drive. Local has higher speed. Network has better availability.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storage_type")]
		public Server_typesGetByNameReturnServer_typesStorage_type Storage_type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Server_typesGetByNameReturnServer_typesCpu_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="shared")]
		shared = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="dedicated")]
		dedicated = 1,
	}
	
	public class Server_typesGetByNameReturnServer_typesPrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public Server_typesGetByNameReturnServer_typesPricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public Server_typesGetByNameReturnServer_typesPricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class Server_typesGetByNameReturnServer_typesPricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Server_typesGetByNameReturnServer_typesPricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Server_typesGetByNameReturnServer_typesStorage_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="local")]
		local = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network")]
		network = 1,
	}
	
	public class Server_types_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_type")]
		public Server_types_idGetReturnServer_type Server_type { get; set; }
	}
	
	public class Server_types_idGetReturnServer_type
	{
		
		/// <summary>
		/// Type of cpu architecture
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsosArchitecture Architecture { get; set; }
		
		/// <summary>
		/// Number of cpu cores a Server of this type will have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cores")]
		public double Cores { get; set; }
		
		/// <summary>
		/// Type of cpu
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cpu_type")]
		public Server_typesGetByNameReturnServer_typesCpu_type Cpu_type { get; set; }
		
		/// <summary>
		/// True if Server type is deprecated
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public bool Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Disk size a Server of this type will have in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public double Disk { get; set; }
		
		/// <summary>
		/// ID of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Memory a Server of this type will have in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public double Memory { get; set; }
		
		/// <summary>
		/// Unique identifier of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Prices in different Locations
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public Server_types_idGetReturnServer_typePrices[] Server_types_idGetReturnServer_typePrices { get; set; }
		
		/// <summary>
		/// Type of Server boot drive. Local has higher speed. Network has better availability.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storage_type")]
		public Server_typesGetByNameReturnServer_typesStorage_type Storage_type { get; set; }
	}
	
	public class Server_types_idGetReturnServer_typePrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public Server_types_idGetReturnServer_typePricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public Server_types_idGetReturnServer_typePricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class Server_types_idGetReturnServer_typePricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Server_types_idGetReturnServer_typePricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public enum ServersGetByNameAndLabel_selectorAndSortAndStatusSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name")]
		name = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:asc")]
		nameasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:desc")]
		namedesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created")]
		created = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:asc")]
		createdasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:desc")]
		createddesc = 8,
	}
	
	public enum ServersGetByNameAndLabel_selectorAndSortAndStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="initializing")]
		initializing = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="starting")]
		starting = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="running")]
		running = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="stopping")]
		stopping = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="off")]
		off = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="deleting")]
		deleting = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="rebuilding")]
		rebuilding = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="migrating")]
		migrating = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unknown")]
		unknown = 8,
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnMeta Meta { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServers[] ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServers { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnMetaPagination Pagination { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServers
	{
		
		/// <summary>
		/// Time window (UTC) in which the backup will run, or null if the backups are not enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backup_window")]
		public string Backup_window { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Datacenter this Resource is located at
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersDatacenter Datacenter { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersImage Image { get; set; }
		
		/// <summary>
		/// Free Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="included_traffic")]
		public System.Nullable<System.Double> Included_traffic { get; set; }
		
		/// <summary>
		/// Inbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ingoing_traffic")]
		public System.Nullable<System.Double> Ingoing_traffic { get; set; }
		
		/// <summary>
		/// ISO Image that is attached to this Server. Null if no ISO is attached.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="iso")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersIso Iso { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="load_balancers")]
		public int[] Load_balancers { get; set; }
		
		/// <summary>
		/// True if Server has been locked and is not available to user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public bool Locked { get; set; }
		
		/// <summary>
		/// Name of the Server (must be unique per Project and a valid hostname as per RFC 1123)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Outbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="outgoing_traffic")]
		public System.Nullable<System.Double> Outgoing_traffic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="placement_group")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPlacement_group Placement_group { get; set; }
		
		/// <summary>
		/// Size of the primary Disk
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary_disk_size")]
		public double Primary_disk_size { get; set; }
		
		/// <summary>
		/// Private networks information
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_net")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPrivate_net[] ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPrivate_net { get; set; }
		
		/// <summary>
		/// Protection configuration for the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersProtection Protection { get; set; }
		
		/// <summary>
		/// Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_net")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_net Public_net { get; set; }
		
		/// <summary>
		/// True if rescue mode is enabled. Server will then boot into rescue system on next reboot
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rescue_enabled")]
		public bool Rescue_enabled { get; set; }
		
		/// <summary>
		/// Type of Server - determines how much ram, disk and cpu a Server has
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_type")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersServer_type Server_type { get; set; }
		
		/// <summary>
		/// Status of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersStatus Status { get; set; }
		
		/// <summary>
		/// IDs of Volumes assigned to this Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumes")]
		public int[] Volumes { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersDatacenter
	{
		
		/// <summary>
		/// Description of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersDatacenterLocation Location { get; set; }
		
		/// <summary>
		/// Unique identifier of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Server types the Datacenter can handle
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_types")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersDatacenterServer_types Server_types { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersDatacenterLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersDatacenterServer_types
	{
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available")]
		public double[] Available { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available_for_migration")]
		public double[] Available_for_migration { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported in the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="supported")]
		public double[] Supported { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersImage
	{
		
		/// <summary>
		/// ID of Server the Image is bound to. Only set for Images of type `backup`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bound_to")]
		public System.Nullable<System.Int32> Bound_to { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Information about the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_from")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersImageCreated_from Created_from { get; set; }
		
		/// <summary>
		/// Point in time where the Image was deleted (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public string Deleted { get; set; }
		
		/// <summary>
		/// Point in time when the Image is considered to be deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Size of the disk contained in the Image in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk_size")]
		public double Disk_size { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_size")]
		public System.Nullable<System.Double> Image_size { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Unique identifier of the Image. This value is only set for system Images.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Flavor of operating system contained in the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_flavor")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesOs_flavor Os_flavor { get; set; }
		
		/// <summary>
		/// Operating system version
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_version")]
		public string Os_version { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersImageProtection Protection { get; set; }
		
		/// <summary>
		/// Indicates that rapid deploy of the Image is available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rapid_deploy")]
		public System.Nullable<System.Boolean> Rapid_deploy { get; set; }
		
		/// <summary>
		/// Whether the Image can be used or if it's still being created or unavailable
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesStatus Status { get; set; }
		
		/// <summary>
		/// Type of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesType Type { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersImageCreated_from
	{
		
		/// <summary>
		/// ID of the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Server name at the time the Image was created
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersImageProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersIso
	{
		
		/// <summary>
		/// Type of cpu architecture this iso is compatible with. Null indicates no restriction on the architecture (wildcard).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsosArchitecture Architecture { get; set; }
		
		/// <summary>
		/// ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the ISO
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Unique identifier of the ISO. Only set for public ISOs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Type of the ISO
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersIsoType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersIsoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPlacement_group
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Array of IDs of Servers that are part of this Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public int[] Servers { get; set; }
		
		/// <summary>
		/// Type of the Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPrivate_net
	{
		
		[System.Runtime.Serialization.DataMember(Name="alias_ips")]
		public string[] Alias_ips { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mac_address")]
		public string Mac_address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public System.Nullable<System.Int32> Network { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersProtection
	{
		
		/// <summary>
		/// If true, prevents the Server from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
		
		/// <summary>
		/// If true, prevents the Server from being rebuilt
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rebuild")]
		public bool Rebuild { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_net
	{
		
		/// <summary>
		/// Firewalls applied to the public network interface of this Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewalls")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netFirewalls[] ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netFirewalls { get; set; }
		
		/// <summary>
		/// IDs of Floating IPs assigned to this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="floating_ips")]
		public int[] Floating_ips { get; set; }
		
		/// <summary>
		/// IP address (v4) and its reverse DNS entry of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IPv6 network assigned to this Server and its reverse DNS entry
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netIpv6 Ipv6 { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netFirewalls
	{
		
		/// <summary>
		/// ID of the Resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Status of the Firewall on the Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netFirewallsStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netFirewallsStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="applied")]
		applied = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pending")]
		pending = 1,
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netIpv4
	{
		
		/// <summary>
		/// If the IP is blocked by our anti abuse dept
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Reverse DNS PTR entry for the IPv4 addresses of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// IP address (v4) of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netIpv6
	{
		
		/// <summary>
		/// If the IP is blocked by our anti abuse dept
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Reverse DNS PTR entries for the IPv6 addresses of this Server, `null` by default
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netIpv6Dns_ptr[] ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netIpv6Dns_ptr { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// IP address (v6) of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netIpv6Dns_ptr
	{
		
		/// <summary>
		/// DNS pointer for the specific IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Single IPv6 address of this Server for which the reverse DNS entry has been set up
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersServer_type
	{
		
		/// <summary>
		/// Number of cpu cores a Server of this type will have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cores")]
		public double Cores { get; set; }
		
		/// <summary>
		/// Type of cpu
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cpu_type")]
		public Server_typesGetByNameReturnServer_typesCpu_type Cpu_type { get; set; }
		
		/// <summary>
		/// True if Server type is deprecated
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public bool Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Disk size a Server of this type will have in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public double Disk { get; set; }
		
		/// <summary>
		/// ID of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Memory a Server of this type will have in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public double Memory { get; set; }
		
		/// <summary>
		/// Unique identifier of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Prices in different Locations
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersServer_typePrices[] ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersServer_typePrices { get; set; }
		
		/// <summary>
		/// Type of Server boot drive. Local has higher speed. Network has better availability.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storage_type")]
		public Server_typesGetByNameReturnServer_typesStorage_type Storage_type { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersServer_typePrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersServer_typePricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersServer_typePricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersServer_typePricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersServer_typePricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="running")]
		running = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="initializing")]
		initializing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="starting")]
		starting = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="stopping")]
		stopping = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="off")]
		off = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="deleting")]
		deleting = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="migrating")]
		migrating = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="rebuilding")]
		rebuilding = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="unknown")]
		unknown = 8,
	}
	
	public class ServersPostPostBody
	{
		
		/// <summary>
		/// Auto-mount Volumes after attach
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="automount")]
		public System.Nullable<System.Boolean> Automount { get; set; }
		
		/// <summary>
		/// ID or name of Datacenter to create Server in (must not be used together with location)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public string Datacenter { get; set; }
		
		/// <summary>
		/// Firewalls which should be applied on the Server's public network interface at creation time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewalls")]
		public ServersPostPostBodyFirewalls[] ServersPostPostBodyFirewalls { get; set; }
		
		/// <summary>
		/// ID or name of the Image the Server is created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image")]
		public string Image { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// ID or name of Location to create Server in (must not be used together with datacenter)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Name of the Server to create (must be unique per Project and a valid hostname as per RFC 1123)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Network IDs which should be attached to the Server private network interface at the creation time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networks")]
		public int[] Networks { get; set; }
		
		/// <summary>
		/// ID of the Placement Group the server should be in
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="placement_group")]
		public System.Nullable<System.Int32> Placement_group { get; set; }
		
		/// <summary>
		/// Public Network options
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="public_net")]
		public ServersPostPostBodyPublic_net Public_net { get; set; }
		
		/// <summary>
		/// ID or name of the Server type this Server should be created with
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_type")]
		public string Server_type { get; set; }
		
		/// <summary>
		/// SSH key IDs (`integer`) or names (`string`) which should be injected into the Server at creation time
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssh_keys")]
		public string[] Ssh_keys { get; set; }
		
		/// <summary>
		/// Start Server right after creation. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start_after_create")]
		public System.Nullable<System.Boolean> Start_after_create { get; set; }
		
		/// <summary>
		/// Cloud-Init user data to use during Server creation. This field is limited to 32KiB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user_data")]
		public string User_data { get; set; }
		
		/// <summary>
		/// Volume IDs which should be attached to the Server at the creation time. Volumes must be in the same Location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumes")]
		public int[] Volumes { get; set; }
	}
	
	public class ServersPostPostBodyFirewalls
	{
		
		/// <summary>
		/// ID of the Firewall
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewall")]
		public System.Nullable<System.Int32> Firewall { get; set; }
	}
	
	public class ServersPostPostBodyPublic_net
	{
		
		/// <summary>
		/// Attach an IPv4 on the public NIC. If false, no IPv4 address will be attached. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable_ipv4")]
		public System.Nullable<System.Boolean> Enable_ipv4 { get; set; }
		
		/// <summary>
		/// Attach an IPv6 on the public NIC. If false, no IPv6 address will be attached. Defaults to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable_ipv6")]
		public System.Nullable<System.Boolean> Enable_ipv6 { get; set; }
		
		/// <summary>
		/// ID of the ipv4 Primary IP to use. If omitted and enable_ipv4 is true, a new ipv4 Primary IP will automatically be created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public System.Nullable<System.Int32> Ipv4 { get; set; }
		
		/// <summary>
		/// ID of the ipv6 Primary IP to use. If omitted and enable_ipv6 is true, a new ipv6 Primary IP will automatically be created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public System.Nullable<System.Int32> Ipv6 { get; set; }
	}
	
	public class Servers_idDeleteReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Servers_idDeleteReturnAction Action { get; set; }
	}
	
	public class Servers_idDeleteReturnAction
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Servers_idDeleteReturnActionError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Servers_idDeleteReturnActionResources[] Servers_idDeleteReturnActionResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Servers_idDeleteReturnActionError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Servers_idDeleteReturnActionResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Servers_idGetReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Servers_idGetReturnServer Server { get; set; }
	}
	
	public class Servers_idGetReturnServer
	{
		
		/// <summary>
		/// Time window (UTC) in which the backup will run, or null if the backups are not enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backup_window")]
		public string Backup_window { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Datacenter this Resource is located at
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public Servers_idGetReturnServerDatacenter Datacenter { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image")]
		public Servers_idGetReturnServerImage Image { get; set; }
		
		/// <summary>
		/// Free Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="included_traffic")]
		public System.Nullable<System.Double> Included_traffic { get; set; }
		
		/// <summary>
		/// Inbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ingoing_traffic")]
		public System.Nullable<System.Double> Ingoing_traffic { get; set; }
		
		/// <summary>
		/// ISO Image that is attached to this Server. Null if no ISO is attached.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="iso")]
		public Servers_idGetReturnServerIso Iso { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="load_balancers")]
		public int[] Load_balancers { get; set; }
		
		/// <summary>
		/// True if Server has been locked and is not available to user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public bool Locked { get; set; }
		
		/// <summary>
		/// Name of the Server (must be unique per Project and a valid hostname as per RFC 1123)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Outbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="outgoing_traffic")]
		public System.Nullable<System.Double> Outgoing_traffic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="placement_group")]
		public Servers_idGetReturnServerPlacement_group Placement_group { get; set; }
		
		/// <summary>
		/// Size of the primary Disk
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary_disk_size")]
		public double Primary_disk_size { get; set; }
		
		/// <summary>
		/// Private networks information
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_net")]
		public Servers_idGetReturnServerPrivate_net[] Servers_idGetReturnServerPrivate_net { get; set; }
		
		/// <summary>
		/// Protection configuration for the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Servers_idGetReturnServerProtection Protection { get; set; }
		
		/// <summary>
		/// Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_net")]
		public Servers_idGetReturnServerPublic_net Public_net { get; set; }
		
		/// <summary>
		/// True if rescue mode is enabled. Server will then boot into rescue system on next reboot
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rescue_enabled")]
		public bool Rescue_enabled { get; set; }
		
		/// <summary>
		/// Type of Server - determines how much ram, disk and cpu a Server has
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_type")]
		public Servers_idGetReturnServerServer_type Server_type { get; set; }
		
		/// <summary>
		/// Status of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersStatus Status { get; set; }
		
		/// <summary>
		/// IDs of Volumes assigned to this Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumes")]
		public int[] Volumes { get; set; }
	}
	
	public class Servers_idGetReturnServerDatacenter
	{
		
		/// <summary>
		/// Description of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Servers_idGetReturnServerDatacenterLocation Location { get; set; }
		
		/// <summary>
		/// Unique identifier of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Server types the Datacenter can handle
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_types")]
		public Servers_idGetReturnServerDatacenterServer_types Server_types { get; set; }
	}
	
	public class Servers_idGetReturnServerDatacenterLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Servers_idGetReturnServerDatacenterServer_types
	{
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available")]
		public double[] Available { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available_for_migration")]
		public double[] Available_for_migration { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported in the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="supported")]
		public double[] Supported { get; set; }
	}
	
	public class Servers_idGetReturnServerImage
	{
		
		/// <summary>
		/// ID of Server the Image is bound to. Only set for Images of type `backup`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bound_to")]
		public System.Nullable<System.Int32> Bound_to { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Information about the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_from")]
		public Servers_idGetReturnServerImageCreated_from Created_from { get; set; }
		
		/// <summary>
		/// Point in time where the Image was deleted (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public string Deleted { get; set; }
		
		/// <summary>
		/// Point in time when the Image is considered to be deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Size of the disk contained in the Image in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk_size")]
		public double Disk_size { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_size")]
		public System.Nullable<System.Double> Image_size { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Unique identifier of the Image. This value is only set for system Images.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Flavor of operating system contained in the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_flavor")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesOs_flavor Os_flavor { get; set; }
		
		/// <summary>
		/// Operating system version
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_version")]
		public string Os_version { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Servers_idGetReturnServerImageProtection Protection { get; set; }
		
		/// <summary>
		/// Indicates that rapid deploy of the Image is available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rapid_deploy")]
		public System.Nullable<System.Boolean> Rapid_deploy { get; set; }
		
		/// <summary>
		/// Whether the Image can be used or if it's still being created or unavailable
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesStatus Status { get; set; }
		
		/// <summary>
		/// Type of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesType Type { get; set; }
	}
	
	public class Servers_idGetReturnServerImageCreated_from
	{
		
		/// <summary>
		/// ID of the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Server name at the time the Image was created
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Servers_idGetReturnServerImageProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Servers_idGetReturnServerIso
	{
		
		/// <summary>
		/// Type of cpu architecture this iso is compatible with. Null indicates no restriction on the architecture (wildcard).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsosArchitecture Architecture { get; set; }
		
		/// <summary>
		/// ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the ISO
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Unique identifier of the ISO. Only set for public ISOs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Type of the ISO
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Servers_idGetReturnServerIsoType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Servers_idGetReturnServerIsoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
	}
	
	public class Servers_idGetReturnServerPlacement_group
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Array of IDs of Servers that are part of this Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public int[] Servers { get; set; }
		
		/// <summary>
		/// Type of the Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
	}
	
	public class Servers_idGetReturnServerPrivate_net
	{
		
		[System.Runtime.Serialization.DataMember(Name="alias_ips")]
		public string[] Alias_ips { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mac_address")]
		public string Mac_address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public System.Nullable<System.Int32> Network { get; set; }
	}
	
	public class Servers_idGetReturnServerProtection
	{
		
		/// <summary>
		/// If true, prevents the Server from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
		
		/// <summary>
		/// If true, prevents the Server from being rebuilt
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rebuild")]
		public bool Rebuild { get; set; }
	}
	
	public class Servers_idGetReturnServerPublic_net
	{
		
		/// <summary>
		/// Firewalls applied to the public network interface of this Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewalls")]
		public Servers_idGetReturnServerPublic_netFirewalls[] Servers_idGetReturnServerPublic_netFirewalls { get; set; }
		
		/// <summary>
		/// IDs of Floating IPs assigned to this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="floating_ips")]
		public int[] Floating_ips { get; set; }
		
		/// <summary>
		/// IP address (v4) and its reverse DNS entry of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public Servers_idGetReturnServerPublic_netIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IPv6 network assigned to this Server and its reverse DNS entry
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public Servers_idGetReturnServerPublic_netIpv6 Ipv6 { get; set; }
	}
	
	public class Servers_idGetReturnServerPublic_netFirewalls
	{
		
		/// <summary>
		/// ID of the Resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Status of the Firewall on the Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netFirewallsStatus Status { get; set; }
	}
	
	public class Servers_idGetReturnServerPublic_netIpv4
	{
		
		/// <summary>
		/// If the IP is blocked by our anti abuse dept
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Reverse DNS PTR entry for the IPv4 addresses of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// IP address (v4) of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Servers_idGetReturnServerPublic_netIpv6
	{
		
		/// <summary>
		/// If the IP is blocked by our anti abuse dept
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Reverse DNS PTR entries for the IPv6 addresses of this Server, `null` by default
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public Servers_idGetReturnServerPublic_netIpv6Dns_ptr[] Servers_idGetReturnServerPublic_netIpv6Dns_ptr { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// IP address (v6) of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Servers_idGetReturnServerPublic_netIpv6Dns_ptr
	{
		
		/// <summary>
		/// DNS pointer for the specific IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Single IPv6 address of this Server for which the reverse DNS entry has been set up
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Servers_idGetReturnServerServer_type
	{
		
		/// <summary>
		/// Number of cpu cores a Server of this type will have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cores")]
		public double Cores { get; set; }
		
		/// <summary>
		/// Type of cpu
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cpu_type")]
		public Server_typesGetByNameReturnServer_typesCpu_type Cpu_type { get; set; }
		
		/// <summary>
		/// True if Server type is deprecated
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public bool Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Disk size a Server of this type will have in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public double Disk { get; set; }
		
		/// <summary>
		/// ID of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Memory a Server of this type will have in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public double Memory { get; set; }
		
		/// <summary>
		/// Unique identifier of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Prices in different Locations
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public Servers_idGetReturnServerServer_typePrices[] Servers_idGetReturnServerServer_typePrices { get; set; }
		
		/// <summary>
		/// Type of Server boot drive. Local has higher speed. Network has better availability.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storage_type")]
		public Server_typesGetByNameReturnServer_typesStorage_type Storage_type { get; set; }
	}
	
	public class Servers_idGetReturnServerServer_typePrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public Servers_idGetReturnServerServer_typePricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public Servers_idGetReturnServerServer_typePricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class Servers_idGetReturnServerServer_typePricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Servers_idGetReturnServerServer_typePricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Servers_idPutPutBody
	{
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// New name to set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Servers_idPutReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="server")]
		public Servers_idPutReturnServer Server { get; set; }
	}
	
	public class Servers_idPutReturnServer
	{
		
		/// <summary>
		/// Time window (UTC) in which the backup will run, or null if the backups are not enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="backup_window")]
		public string Backup_window { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Datacenter this Resource is located at
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="datacenter")]
		public Servers_idPutReturnServerDatacenter Datacenter { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image")]
		public Servers_idPutReturnServerImage Image { get; set; }
		
		/// <summary>
		/// Free Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="included_traffic")]
		public System.Nullable<System.Double> Included_traffic { get; set; }
		
		/// <summary>
		/// Inbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ingoing_traffic")]
		public System.Nullable<System.Double> Ingoing_traffic { get; set; }
		
		/// <summary>
		/// ISO Image that is attached to this Server. Null if no ISO is attached.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="iso")]
		public Servers_idPutReturnServerIso Iso { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="load_balancers")]
		public int[] Load_balancers { get; set; }
		
		/// <summary>
		/// True if Server has been locked and is not available to user
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locked")]
		public bool Locked { get; set; }
		
		/// <summary>
		/// Name of the Server (must be unique per Project and a valid hostname as per RFC 1123)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Outbound Traffic for the current billing period in bytes
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="outgoing_traffic")]
		public System.Nullable<System.Double> Outgoing_traffic { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="placement_group")]
		public Servers_idPutReturnServerPlacement_group Placement_group { get; set; }
		
		/// <summary>
		/// Size of the primary Disk
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="primary_disk_size")]
		public double Primary_disk_size { get; set; }
		
		/// <summary>
		/// Private networks information
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="private_net")]
		public Servers_idPutReturnServerPrivate_net[] Servers_idPutReturnServerPrivate_net { get; set; }
		
		/// <summary>
		/// Protection configuration for the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Servers_idPutReturnServerProtection Protection { get; set; }
		
		/// <summary>
		/// Public network information. The Server's IPv4 address can be found in `public_net->ipv4->ip`
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_net")]
		public Servers_idPutReturnServerPublic_net Public_net { get; set; }
		
		/// <summary>
		/// True if rescue mode is enabled. Server will then boot into rescue system on next reboot
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rescue_enabled")]
		public bool Rescue_enabled { get; set; }
		
		/// <summary>
		/// Type of Server - determines how much ram, disk and cpu a Server has
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_type")]
		public Servers_idPutReturnServerServer_type Server_type { get; set; }
		
		/// <summary>
		/// Status of the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersStatus Status { get; set; }
		
		/// <summary>
		/// IDs of Volumes assigned to this Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumes")]
		public int[] Volumes { get; set; }
	}
	
	public class Servers_idPutReturnServerDatacenter
	{
		
		/// <summary>
		/// Description of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Servers_idPutReturnServerDatacenterLocation Location { get; set; }
		
		/// <summary>
		/// Unique identifier of the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Server types the Datacenter can handle
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_types")]
		public Servers_idPutReturnServerDatacenterServer_types Server_types { get; set; }
	}
	
	public class Servers_idPutReturnServerDatacenterLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Servers_idPutReturnServerDatacenterServer_types
	{
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available")]
		public double[] Available { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported and for which the Datacenter has enough resources left
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available_for_migration")]
		public double[] Available_for_migration { get; set; }
		
		/// <summary>
		/// IDs of Server types that are supported in the Datacenter
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="supported")]
		public double[] Supported { get; set; }
	}
	
	public class Servers_idPutReturnServerImage
	{
		
		/// <summary>
		/// ID of Server the Image is bound to. Only set for Images of type `backup`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="bound_to")]
		public System.Nullable<System.Int32> Bound_to { get; set; }
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Information about the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created_from")]
		public Servers_idPutReturnServerImageCreated_from Created_from { get; set; }
		
		/// <summary>
		/// Point in time where the Image was deleted (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public string Deleted { get; set; }
		
		/// <summary>
		/// Point in time when the Image is considered to be deprecated (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Size of the disk contained in the Image in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk_size")]
		public double Disk_size { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Size of the Image file in our storage in GB. For snapshot Images this is the value relevant for calculating costs for the Image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_size")]
		public System.Nullable<System.Double> Image_size { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Unique identifier of the Image. This value is only set for system Images.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Flavor of operating system contained in the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_flavor")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesOs_flavor Os_flavor { get; set; }
		
		/// <summary>
		/// Operating system version
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="os_version")]
		public string Os_version { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Servers_idPutReturnServerImageProtection Protection { get; set; }
		
		/// <summary>
		/// Indicates that rapid deploy of the Image is available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rapid_deploy")]
		public System.Nullable<System.Boolean> Rapid_deploy { get; set; }
		
		/// <summary>
		/// Whether the Image can be used or if it's still being created or unavailable
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesStatus Status { get; set; }
		
		/// <summary>
		/// Type of the Image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ImagesGetBySortAndTypeAndStatusAndBound_toAndInclude_deprecatedAndNameAndLabel_selectorAndArchitectureReturnImagesType Type { get; set; }
	}
	
	public class Servers_idPutReturnServerImageCreated_from
	{
		
		/// <summary>
		/// ID of the Server the Image was created from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Server name at the time the Image was created
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Servers_idPutReturnServerImageProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Servers_idPutReturnServerIso
	{
		
		/// <summary>
		/// Type of cpu architecture this iso is compatible with. Null indicates no restriction on the architecture (wildcard).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public IsosGetByNameAndArchitectureAndInclude_architecture_wildcardReturnIsosArchitecture Architecture { get; set; }
		
		/// <summary>
		/// ISO 8601 timestamp of deprecation, null if ISO is still available. After the deprecation time it will no longer be possible to attach the ISO to Servers.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// Description of the ISO
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Unique identifier of the ISO. Only set for public ISOs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Type of the ISO
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Servers_idPutReturnServerIsoType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Servers_idPutReturnServerIsoType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="public")]
		_public = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="private")]
		_private = 1,
	}
	
	public class Servers_idPutReturnServerPlacement_group
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Array of IDs of Servers that are part of this Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="servers")]
		public int[] Servers { get; set; }
		
		/// <summary>
		/// Type of the Placement Group
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public Placement_groupsGetBySortAndNameAndLabel_selectorAndTypeType Type { get; set; }
	}
	
	public class Servers_idPutReturnServerPrivate_net
	{
		
		[System.Runtime.Serialization.DataMember(Name="alias_ips")]
		public string[] Alias_ips { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mac_address")]
		public string Mac_address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public System.Nullable<System.Int32> Network { get; set; }
	}
	
	public class Servers_idPutReturnServerProtection
	{
		
		/// <summary>
		/// If true, prevents the Server from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
		
		/// <summary>
		/// If true, prevents the Server from being rebuilt
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rebuild")]
		public bool Rebuild { get; set; }
	}
	
	public class Servers_idPutReturnServerPublic_net
	{
		
		/// <summary>
		/// Firewalls applied to the public network interface of this Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewalls")]
		public Servers_idPutReturnServerPublic_netFirewalls[] Servers_idPutReturnServerPublic_netFirewalls { get; set; }
		
		/// <summary>
		/// IDs of Floating IPs assigned to this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="floating_ips")]
		public int[] Floating_ips { get; set; }
		
		/// <summary>
		/// IP address (v4) and its reverse DNS entry of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv4")]
		public Servers_idPutReturnServerPublic_netIpv4 Ipv4 { get; set; }
		
		/// <summary>
		/// IPv6 network assigned to this Server and its reverse DNS entry
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ipv6")]
		public Servers_idPutReturnServerPublic_netIpv6 Ipv6 { get; set; }
	}
	
	public class Servers_idPutReturnServerPublic_netFirewalls
	{
		
		/// <summary>
		/// ID of the Resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// Status of the Firewall on the Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ServersGetByNameAndLabel_selectorAndSortAndStatusReturnServersPublic_netFirewallsStatus Status { get; set; }
	}
	
	public class Servers_idPutReturnServerPublic_netIpv4
	{
		
		/// <summary>
		/// If the IP is blocked by our anti abuse dept
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Reverse DNS PTR entry for the IPv4 addresses of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// IP address (v4) of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Servers_idPutReturnServerPublic_netIpv6
	{
		
		/// <summary>
		/// If the IP is blocked by our anti abuse dept
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="blocked")]
		public bool Blocked { get; set; }
		
		/// <summary>
		/// Reverse DNS PTR entries for the IPv6 addresses of this Server, `null` by default
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public Servers_idPutReturnServerPublic_netIpv6Dns_ptr[] Servers_idPutReturnServerPublic_netIpv6Dns_ptr { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Int32> Id { get; set; }
		
		/// <summary>
		/// IP address (v6) of this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Servers_idPutReturnServerPublic_netIpv6Dns_ptr
	{
		
		/// <summary>
		/// DNS pointer for the specific IP address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Single IPv6 address of this Server for which the reverse DNS entry has been set up
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Servers_idPutReturnServerServer_type
	{
		
		/// <summary>
		/// Number of cpu cores a Server of this type will have
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cores")]
		public double Cores { get; set; }
		
		/// <summary>
		/// Type of cpu
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cpu_type")]
		public Server_typesGetByNameReturnServer_typesCpu_type Cpu_type { get; set; }
		
		/// <summary>
		/// True if Server type is deprecated
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public bool Deprecated { get; set; }
		
		/// <summary>
		/// Description of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Disk size a Server of this type will have in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public double Disk { get; set; }
		
		/// <summary>
		/// ID of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Memory a Server of this type will have in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public double Memory { get; set; }
		
		/// <summary>
		/// Unique identifier of the Server type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Prices in different Locations
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="prices")]
		public Servers_idPutReturnServerServer_typePrices[] Servers_idPutReturnServerServer_typePrices { get; set; }
		
		/// <summary>
		/// Type of Server boot drive. Local has higher speed. Network has better availability.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="storage_type")]
		public Server_typesGetByNameReturnServer_typesStorage_type Storage_type { get; set; }
	}
	
	public class Servers_idPutReturnServerServer_typePrices
	{
		
		/// <summary>
		/// Name of the Location the price is for
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Hourly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_hourly")]
		public Servers_idPutReturnServerServer_typePricesPrice_hourly Price_hourly { get; set; }
		
		/// <summary>
		/// Monthly costs for a Server type in this Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="price_monthly")]
		public Servers_idPutReturnServerServer_typePricesPrice_monthly Price_monthly { get; set; }
	}
	
	public class Servers_idPutReturnServerServer_typePricesPrice_hourly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public class Servers_idPutReturnServerServer_typePricesPrice_monthly
	{
		
		/// <summary>
		/// Price with VAT added
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gross")]
		public string Gross { get; set; }
		
		/// <summary>
		/// Price without VAT
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="net")]
		public string Net { get; set; }
	}
	
	public enum Servers_idActionsGetBySortAndStatusSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command")]
		command = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:asc")]
		commandasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:desc")]
		commanddesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status")]
		status = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:asc")]
		statusasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:desc")]
		statusdesc = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress")]
		progress = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:asc")]
		progressasc = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:desc")]
		progressdesc = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started")]
		started = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:asc")]
		startedasc = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:desc")]
		starteddesc = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished")]
		finished = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:asc")]
		finishedasc = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:desc")]
		finisheddesc = 17,
	}
	
	public class Servers_idActionsGetBySortAndStatusReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public Servers_idActionsGetBySortAndStatusReturnActions[] Servers_idActionsGetBySortAndStatusReturnActions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Servers_idActionsGetBySortAndStatusReturnMeta Meta { get; set; }
	}
	
	public class Servers_idActionsGetBySortAndStatusReturnActions
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Servers_idActionsGetBySortAndStatusReturnActionsError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Servers_idActionsGetBySortAndStatusReturnActionsResources[] Servers_idActionsGetBySortAndStatusReturnActionsResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Servers_idActionsGetBySortAndStatusReturnActionsError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Servers_idActionsGetBySortAndStatusReturnActionsResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Servers_idActionsGetBySortAndStatusReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Servers_idActionsGetBySortAndStatusReturnMetaPagination Pagination { get; set; }
	}
	
	public class Servers_idActionsGetBySortAndStatusReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Servers_idActionsAdd_to_placement_groupPostPostBody
	{
		
		/// <summary>
		/// ID of Placement Group the Server should be added to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="placement_group")]
		public int Placement_group { get; set; }
	}
	
	public class Servers_idActionsAttach_isoPostPostBody
	{
		
		/// <summary>
		/// ID or name of ISO to attach to the Server as listed in GET `/isos`
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="iso")]
		public string Iso { get; set; }
	}
	
	public class Servers_idActionsAttach_to_networkPostPostBody
	{
		
		/// <summary>
		/// Additional IPs to be assigned to this Server
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="alias_ips")]
		public string[] Alias_ips { get; set; }
		
		/// <summary>
		/// IP to request to be assigned to this Server; if you do not provide this then you will be auto assigned an IP address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
		
		/// <summary>
		/// ID of an existing network to attach the Server to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network")]
		public int Network { get; set; }
	}
	
	public class Servers_idActionsChange_alias_ipsPostPostBody
	{
		
		/// <summary>
		/// New alias IPs to set for this Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="alias_ips")]
		public string[] Alias_ips { get; set; }
		
		/// <summary>
		/// ID of an existing Network already attached to the Server
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network")]
		public int Network { get; set; }
	}
	
	public class Servers_idActionsChange_dns_ptrPostPostBody
	{
		
		/// <summary>
		/// Hostname to set as a reverse DNS PTR entry, reset to original value if `null`
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dns_ptr")]
		public string Dns_ptr { get; set; }
		
		/// <summary>
		/// Primary IP address for which the reverse DNS entry should be set
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ip")]
		public string Ip { get; set; }
	}
	
	public class Servers_idActionsChange_protectionPostPostBody
	{
		
		/// <summary>
		/// If true, prevents the Server from being deleted (currently delete and rebuild attribute needs to have the same value)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public System.Nullable<System.Boolean> Delete { get; set; }
		
		/// <summary>
		/// If true, prevents the Server from being rebuilt (currently delete and rebuild attribute needs to have the same value)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rebuild")]
		public System.Nullable<System.Boolean> Rebuild { get; set; }
	}
	
	public class Servers_idActionsChange_typePostPostBody
	{
		
		/// <summary>
		/// ID or name of Server type the Server should migrate to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server_type")]
		public string Server_type { get; set; }
		
		/// <summary>
		/// If false, do not upgrade the disk (this allows downgrading the Server type later)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="upgrade_disk")]
		public bool Upgrade_disk { get; set; }
	}
	
	public class Servers_idActionsCreate_imagePostPostBody
	{
		
		/// <summary>
		/// Description of the Image, will be auto-generated if not set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Servers_idActionsCreate_imagePostPostBodyLabels Labels { get; set; }
		
		/// <summary>
		/// Type of Image to create (default: `snapshot`)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<Servers_idActionsCreate_imagePostPostBodyType> Type { get; set; }
	}
	
	public class Servers_idActionsCreate_imagePostPostBodyLabels
	{
		
		/// <summary>
		/// New label
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelkey")]
		public string Labelkey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Servers_idActionsCreate_imagePostPostBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="snapshot")]
		snapshot = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="backup")]
		backup = 1,
	}
	
	public class Servers_idActionsDetach_from_networkPostPostBody
	{
		
		/// <summary>
		/// ID of an existing network to detach the Server from
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network")]
		public int Network { get; set; }
	}
	
	public class Servers_idActionsEnable_rescuePostPostBody
	{
		
		/// <summary>
		/// Array of SSH key IDs which should be injected into the rescue system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ssh_keys")]
		public int[] Ssh_keys { get; set; }
		
		/// <summary>
		/// Type of rescue system to boot (default: `linux64`)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<Servers_idActionsEnable_rescuePostPostBodyType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum Servers_idActionsEnable_rescuePostPostBodyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="linux64")]
		linux64 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="linux32")]
		linux32 = 1,
	}
	
	public class Servers_idActionsRebuildPostPostBody
	{
		
		/// <summary>
		/// ID or name of Image to rebuilt from.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image")]
		public string Image { get; set; }
	}
	
	public class Servers_idActions_action_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Servers_idActions_action_idGetReturnAction Action { get; set; }
	}
	
	public class Servers_idActions_action_idGetReturnAction
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Servers_idActions_action_idGetReturnActionError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Servers_idActions_action_idGetReturnActionResources[] Servers_idActions_action_idGetReturnActionResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Servers_idActions_action_idGetReturnActionError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Servers_idActions_action_idGetReturnActionResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public enum Servers_idMetricsGetByTypeAndStartAndEndAndStepType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="cpu")]
		cpu = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="disk")]
		disk = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="network")]
		network = 2,
	}
	
	public class Servers_idMetricsGetByTypeAndStartAndEndAndStepReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metrics")]
		public Servers_idMetricsGetByTypeAndStartAndEndAndStepReturnMetrics Metrics { get; set; }
	}
	
	public class Servers_idMetricsGetByTypeAndStartAndEndAndStepReturnMetrics
	{
		
		/// <summary>
		/// End of period of metrics reported (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="end")]
		public string End { get; set; }
		
		/// <summary>
		/// Start of period of metrics reported (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
		
		/// <summary>
		/// Resolution of results in seconds.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="step")]
		public double Step { get; set; }
		
		/// <summary>
		/// Hash with timeseries information, containing the name of timeseries as key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="time_series")]
		public System.Collections.Generic.Dictionary<string, Servers_idMetricsGetByTypeAndStartAndEndAndStepReturnMetricsTime_series> Time_series { get; set; }
	}
	
	public class Servers_idMetricsGetByTypeAndStartAndEndAndStepReturnMetricsTime_series
	{
		
		/// <summary>
		/// Metrics Timestamps with values
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	public enum Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name")]
		name = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:asc")]
		nameasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:desc")]
		namedesc = 5,
	}
	
	public class Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorReturnMeta Meta { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssh_keys")]
		public Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorReturnSsh_keys[] Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorReturnSsh_keys { get; set; }
	}
	
	public class Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorReturnMetaPagination Pagination { get; set; }
	}
	
	public class Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Ssh_keysGetBySortAndNameAndFingerprintAndLabel_selectorReturnSsh_keys
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Fingerprint of public key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Public key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_key")]
		public string Public_key { get; set; }
	}
	
	public class Ssh_keysPostPostBody
	{
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// Name of the SSH key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Public key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_key")]
		public string Public_key { get; set; }
	}
	
	public class Ssh_keys_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssh_key")]
		public Ssh_keys_idGetReturnSsh_key Ssh_key { get; set; }
	}
	
	public class Ssh_keys_idGetReturnSsh_key
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Fingerprint of public key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Public key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_key")]
		public string Public_key { get; set; }
	}
	
	public class Ssh_keys_idPutPutBody
	{
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// New name Name to set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Ssh_keys_idPutReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssh_key")]
		public Ssh_keys_idPutReturnSsh_key Ssh_key { get; set; }
	}
	
	public class Ssh_keys_idPutReturnSsh_key
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Fingerprint of public key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Public key
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public_key")]
		public string Public_key { get; set; }
	}
	
	public enum VolumesGetByStatusAndSortAndNameAndLabel_selectorSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name")]
		name = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:asc")]
		nameasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="name:desc")]
		namedesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created")]
		created = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:asc")]
		createdasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="created:desc")]
		createddesc = 8,
	}
	
	public class VolumesGetByStatusAndSortAndNameAndLabel_selectorReturn
	{
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnMeta Meta { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="volumes")]
		public VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumes[] VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumes { get; set; }
	}
	
	public class VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnMetaPagination Pagination { get; set; }
	}
	
	public class VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumes
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Filesystem of the Volume if formatted on creation, null if not formatted on creation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Device path on the file system for the Volume
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="linux_device")]
		public string Linux_device { get; set; }
		
		/// <summary>
		/// Location of the Volume. Volume can only be attached to Servers in the same Location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumesLocation Location { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumesProtection Protection { get; set; }
		
		/// <summary>
		/// ID of the Server the Volume is attached to, null if it is not attached at all
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server")]
		public System.Nullable<System.Int32> Server { get; set; }
		
		/// <summary>
		/// Size in GB of the Volume
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public double Size { get; set; }
		
		/// <summary>
		/// Current status of the Volume
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumesStatus Status { get; set; }
	}
	
	public class VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumesLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumesProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="creating")]
		creating = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="available")]
		available = 1,
	}
	
	public class VolumesPostPostBody
	{
		
		/// <summary>
		/// Auto-mount Volume after attach. `server` must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="automount")]
		public System.Nullable<System.Boolean> Automount { get; set; }
		
		/// <summary>
		/// Format Volume after creation. One of: `xfs`, `ext4`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string Labels { get; set; }
		
		/// <summary>
		/// Location to create the Volume in (can be omitted if Server is specified)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Name of the volume
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Server to which to attach the Volume once it's created (Volume will be created in the same Location as the server)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="server")]
		public System.Nullable<System.Int32> Server { get; set; }
		
		/// <summary>
		/// Size of the Volume in GB
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
	}
	
	public class Volumes_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="volume")]
		public Volumes_idGetReturnVolume Volume { get; set; }
	}
	
	public class Volumes_idGetReturnVolume
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Filesystem of the Volume if formatted on creation, null if not formatted on creation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Device path on the file system for the Volume
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="linux_device")]
		public string Linux_device { get; set; }
		
		/// <summary>
		/// Location of the Volume. Volume can only be attached to Servers in the same Location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Volumes_idGetReturnVolumeLocation Location { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Volumes_idGetReturnVolumeProtection Protection { get; set; }
		
		/// <summary>
		/// ID of the Server the Volume is attached to, null if it is not attached at all
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server")]
		public System.Nullable<System.Int32> Server { get; set; }
		
		/// <summary>
		/// Size in GB of the Volume
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public double Size { get; set; }
		
		/// <summary>
		/// Current status of the Volume
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumesStatus Status { get; set; }
	}
	
	public class Volumes_idGetReturnVolumeLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Volumes_idGetReturnVolumeProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public class Volumes_idPutPutBody
	{
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public Volumes_idPutPutBodyLabels Labels { get; set; }
		
		/// <summary>
		/// New Volume name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	public class Volumes_idPutPutBodyLabels
	{
		
		[System.Runtime.Serialization.DataMember(Name="labelkey")]
		public string Labelkey { get; set; }
	}
	
	public class Volumes_idPutReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="volume")]
		public Volumes_idPutReturnVolume Volume { get; set; }
	}
	
	public class Volumes_idPutReturnVolume
	{
		
		/// <summary>
		/// Point in time when the Resource was created (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="created")]
		public string Created { get; set; }
		
		/// <summary>
		/// Filesystem of the Volume if formatted on creation, null if not formatted on creation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="format")]
		public string Format { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// User-defined labels (key-value pairs)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Device path on the file system for the Volume
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="linux_device")]
		public string Linux_device { get; set; }
		
		/// <summary>
		/// Location of the Volume. Volume can only be attached to Servers in the same Location.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="location")]
		public Volumes_idPutReturnVolumeLocation Location { get; set; }
		
		/// <summary>
		/// Name of the Resource. Must be unique per Project.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Protection configuration for the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="protection")]
		public Volumes_idPutReturnVolumeProtection Protection { get; set; }
		
		/// <summary>
		/// ID of the Server the Volume is attached to, null if it is not attached at all
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server")]
		public System.Nullable<System.Int32> Server { get; set; }
		
		/// <summary>
		/// Size in GB of the Volume
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public double Size { get; set; }
		
		/// <summary>
		/// Current status of the Volume
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public VolumesGetByStatusAndSortAndNameAndLabel_selectorReturnVolumesStatus Status { get; set; }
	}
	
	public class Volumes_idPutReturnVolumeLocation
	{
		
		/// <summary>
		/// City the Location is closest to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// ISO 3166-1 alpha-2 code of the country the Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		/// <summary>
		/// Description of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// ID of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public double Id { get; set; }
		
		/// <summary>
		/// Latitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="latitude")]
		public double Latitude { get; set; }
		
		/// <summary>
		/// Longitude of the city closest to the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="longitude")]
		public double Longitude { get; set; }
		
		/// <summary>
		/// Unique identifier of the Location
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of network zone this Location resides in
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="network_zone")]
		public string Network_zone { get; set; }
	}
	
	public class Volumes_idPutReturnVolumeProtection
	{
		
		/// <summary>
		/// If true, prevents the Resource from being deleted
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public bool Delete { get; set; }
	}
	
	public enum Volumes_idActionsGetBySortAndStatusSort
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:asc")]
		idasc = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id:desc")]
		iddesc = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command")]
		command = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:asc")]
		commandasc = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="command:desc")]
		commanddesc = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status")]
		status = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:asc")]
		statusasc = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="status:desc")]
		statusdesc = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress")]
		progress = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:asc")]
		progressasc = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="progress:desc")]
		progressdesc = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started")]
		started = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:asc")]
		startedasc = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="started:desc")]
		starteddesc = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished")]
		finished = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:asc")]
		finishedasc = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="finished:desc")]
		finisheddesc = 17,
	}
	
	public class Volumes_idActionsGetBySortAndStatusReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="actions")]
		public Volumes_idActionsGetBySortAndStatusReturnActions[] Volumes_idActionsGetBySortAndStatusReturnActions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="meta")]
		public Volumes_idActionsGetBySortAndStatusReturnMeta Meta { get; set; }
	}
	
	public class Volumes_idActionsGetBySortAndStatusReturnActions
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Volumes_idActionsGetBySortAndStatusReturnActionsError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Volumes_idActionsGetBySortAndStatusReturnActionsResources[] Volumes_idActionsGetBySortAndStatusReturnActionsResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Volumes_idActionsGetBySortAndStatusReturnActionsError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Volumes_idActionsGetBySortAndStatusReturnActionsResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class Volumes_idActionsGetBySortAndStatusReturnMeta
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Volumes_idActionsGetBySortAndStatusReturnMetaPagination Pagination { get; set; }
	}
	
	public class Volumes_idActionsGetBySortAndStatusReturnMetaPagination
	{
		
		/// <summary>
		/// ID of the last page available. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="last_page")]
		public System.Nullable<System.Double> Last_page { get; set; }
		
		/// <summary>
		/// ID of the next page. Can be null if the current page is the last one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Double> Next_page { get; set; }
		
		/// <summary>
		/// Current page number
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="page")]
		public double Page { get; set; }
		
		/// <summary>
		/// Maximum number of items shown per page in the response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="per_page")]
		public double Per_page { get; set; }
		
		/// <summary>
		/// ID of the previous page. Can be null if the current page is the first one.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="previous_page")]
		public System.Nullable<System.Double> Previous_page { get; set; }
		
		/// <summary>
		/// The total number of entries that exist in the database for this query. Nullable if unknown.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="total_entries")]
		public System.Nullable<System.Double> Total_entries { get; set; }
	}
	
	public class Volumes_idActionsAttachPostPostBody
	{
		
		/// <summary>
		/// Auto-mount the Volume after attaching it
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="automount")]
		public System.Nullable<System.Boolean> Automount { get; set; }
		
		/// <summary>
		/// ID of the Server the Volume will be attached to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="server")]
		public int Server { get; set; }
	}
	
	public class Volumes_idActionsChange_protectionPostPostBody
	{
		
		/// <summary>
		/// If true, prevents the Volume from being deleted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delete")]
		public System.Nullable<System.Boolean> Delete { get; set; }
	}
	
	public class Volumes_idActionsResizePostPostBody
	{
		
		/// <summary>
		/// New Volume size in GB (must be greater than current size)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public double Size { get; set; }
	}
	
	public class Volumes_idActions_action_idGetReturn
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public Volumes_idActions_action_idGetReturnAction Action { get; set; }
	}
	
	public class Volumes_idActions_action_idGetReturnAction
	{
		
		/// <summary>
		/// Command executed in the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="command")]
		public string Command { get; set; }
		
		/// <summary>
		/// Error message for the Action if error occurred, otherwise null
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Volumes_idActions_action_idGetReturnActionError Error { get; set; }
		
		/// <summary>
		/// Point in time when the Action was finished (in ISO-8601 format). Only set if the Action is finished otherwise null.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="finished")]
		public string Finished { get; set; }
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Progress of Action in percent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public double Progress { get; set; }
		
		/// <summary>
		/// Resources the Action relates to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public Volumes_idActions_action_idGetReturnActionResources[] Volumes_idActions_action_idGetReturnActionResources { get; set; }
		
		/// <summary>
		/// Point in time when the Action was started (in ISO-8601 format)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="started")]
		public string Started { get; set; }
		
		/// <summary>
		/// Status of the Action
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ActionsGetByIdAndSortAndStatusReturnActionsStatus Status { get; set; }
	}
	
	public class Volumes_idActions_action_idGetReturnActionError
	{
		
		/// <summary>
		/// Fixed machine readable code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Humanized error message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class Volumes_idActions_action_idGetReturnActionResources
	{
		
		/// <summary>
		/// ID of the Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Type of resource referenced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
