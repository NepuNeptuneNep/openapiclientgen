//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Message describing AWS Credentials using access key id and secret.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AccessKeyCredentials
	{
		
		/// <summary>
		/// AWS access key ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessKeyId")]
		public string AccessKeyId { get; set; }
		
		/// <summary>
		/// Input only. AWS secret access key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secretAccessKey")]
		public string SecretAccessKey { get; set; }
		
		/// <summary>
		/// Input only. AWS session token. Used only when AWS security token service (STS) is responsible for creating the temporary credentials.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sessionToken")]
		public string SessionToken { get; set; }
	}
	
	/// <summary>
	/// AdaptingOSStep contains specific step details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AdaptingOSStep
	{
	}
	
	/// <summary>
	/// Request message for 'AddGroupMigration' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AddGroupMigrationRequest
	{
		
		/// <summary>
		/// The full path name of the MigratingVm to add.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="migratingVm")]
		public string MigratingVm { get; set; }
	}
	
	/// <summary>
	/// Describes an appliance version.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ApplianceVersion
	{
		
		/// <summary>
		/// Determine whether it's critical to upgrade the appliance to this version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="critical")]
		public System.Nullable<System.Boolean> Critical { get; set; }
		
		/// <summary>
		/// Link to a page that contains the version release notes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseNotesUri")]
		public string ReleaseNotesUri { get; set; }
		
		/// <summary>
		/// A link for downloading the version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
		
		/// <summary>
		/// The appliance version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// AppliedLicense holds the license data returned by adaptation module report.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AppliedLicense
	{
		
		/// <summary>
		/// The OS license returned from the adaptation module's report.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osLicense")]
		public string OsLicense { get; set; }
		
		/// <summary>
		/// The license type that was used in OS adaptation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<AppliedLicenseType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AppliedLicenseType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAYG = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BYOL = 3,
	}
	
	/// <summary>
	/// Holds informatiom about the available versions for upgrade.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AvailableUpdates
	{
		
		/// <summary>
		/// Describes an appliance version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inPlaceUpdate")]
		public ApplianceVersion InPlaceUpdate { get; set; }
		
		/// <summary>
		/// Describes an appliance version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newDeployableAppliance")]
		public ApplianceVersion NewDeployableAppliance { get; set; }
	}
	
	/// <summary>
	/// The details of an AWS instance disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AwsDiskDetails
	{
		
		/// <summary>
		/// The ordinal number of the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskNumber")]
		public System.Nullable<System.Int32> DiskNumber { get; set; }
		
		/// <summary>
		/// Size in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public string SizeGb { get; set; }
		
		/// <summary>
		/// AWS volume ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeId")]
		public string VolumeId { get; set; }
	}
	
	/// <summary>
	/// AwsSecurityGroup describes a security group of an AWS VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AwsSecurityGroup
	{
		
		/// <summary>
		/// The AWS security group id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The AWS security group name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// AwsSourceDetails message describes a specific source details for the AWS source type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AwsSourceDetails
	{
		
		/// <summary>
		/// Message describing AWS Credentials using access key id and secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessKeyCreds")]
		public AccessKeyCredentials AccessKeyCreds { get; set; }
		
		/// <summary>
		/// Immutable. The AWS region that the source VMs will be migrated from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="awsRegion")]
		public string AwsRegion { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// AWS security group names to limit the scope of the source inventory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inventorySecurityGroupNames")]
		public string[] InventorySecurityGroupNames { get; set; }
		
		/// <summary>
		/// AWS resource tags to limit the scope of the source inventory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inventoryTagList")]
		public Tag[] InventoryTagList { get; set; }
		
		/// <summary>
		/// User specified tags to add to every M2VM generated resource in AWS. These tags will be set in addition to the default tags that are set as part of the migration process. The tags must not begin with the reserved prefix `m2vm`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="migrationResourcesUserTags")]
		public System.Collections.Generic.Dictionary<string, string> MigrationResourcesUserTags { get; set; }
		
		/// <summary>
		/// Output only. The source's public IP. All communication initiated by this source will originate from this IP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicIp")]
		public string PublicIp { get; set; }
		
		/// <summary>
		/// Output only. State of the source as determined by the health check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<AwsSourceDetailsState> State { get; set; }
	}
	
	/// <summary>
	/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Status
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Tag is an AWS tag representation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Tag
	{
		
		/// <summary>
		/// Key of tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Value of tag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AwsSourceDetailsState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 3,
	}
	
	/// <summary>
	/// Represent the source AWS VM details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AwsSourceVmDetails
	{
		
		/// <summary>
		/// The total size of the disks being migrated in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="committedStorageBytes")]
		public string CommittedStorageBytes { get; set; }
		
		/// <summary>
		/// The disks attached to the source VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public AwsDiskDetails[] Disks { get; set; }
		
		/// <summary>
		/// The firmware type of the source VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public System.Nullable<AwsSourceVmDetailsFirmware> Firmware { get; set; }
		
		/// <summary>
		/// Migrating VM source information about the VM capabilities needed for some Compute Engine features.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmCapabilitiesInfo")]
		public VmCapabilities VmCapabilitiesInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AwsSourceVmDetailsFirmware
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIRMWARE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EFI = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BIOS = 2,
	}
	
	/// <summary>
	/// Migrating VM source information about the VM capabilities needed for some Compute Engine features.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VmCapabilities
	{
		
		/// <summary>
		/// Output only. The last time OS capabilities list was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastOsCapabilitiesUpdateTime")]
		public string LastOsCapabilitiesUpdateTime { get; set; }
		
		/// <summary>
		/// Output only. Unordered list. List of certain VM OS capabilities needed for some Compute Engine features.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osCapabilities")]
		public string[] OsCapabilities { get; set; }
	}
	
	/// <summary>
	/// AwsVmDetails describes a VM in AWS.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AwsVmDetails
	{
		
		/// <summary>
		/// The CPU architecture.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public System.Nullable<AwsVmDetailsArchitecture> Architecture { get; set; }
		
		/// <summary>
		/// The VM Boot Option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootOption")]
		public System.Nullable<AwsVmDetailsBootOption> BootOption { get; set; }
		
		/// <summary>
		/// The total size of the storage allocated to the VM in MB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="committedStorageMb")]
		public string CommittedStorageMb { get; set; }
		
		/// <summary>
		/// The number of cpus the VM has.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuCount")]
		public System.Nullable<System.Int32> CpuCount { get; set; }
		
		/// <summary>
		/// The number of disks the VM has.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskCount")]
		public System.Nullable<System.Int32> DiskCount { get; set; }
		
		/// <summary>
		/// The display name of the VM. Note that this value is not necessarily unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The instance type of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceType")]
		public string InstanceType { get; set; }
		
		/// <summary>
		/// The memory size of the VM in MB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryMb")]
		public System.Nullable<System.Int32> MemoryMb { get; set; }
		
		/// <summary>
		/// The VM's OS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osDescription")]
		public string OsDescription { get; set; }
		
		/// <summary>
		/// Output only. The power state of the VM at the moment list was taken.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerState")]
		public System.Nullable<AwsVmDetailsPowerState> PowerState { get; set; }
		
		/// <summary>
		/// The security groups the VM belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securityGroups")]
		public AwsSecurityGroup[] SecurityGroups { get; set; }
		
		/// <summary>
		/// The descriptive name of the AWS's source this VM is connected to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDescription")]
		public string SourceDescription { get; set; }
		
		/// <summary>
		/// The id of the AWS's source this VM is connected to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// The tags of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// The virtualization type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualizationType")]
		public System.Nullable<AwsVmDetailsVirtualizationType> VirtualizationType { get; set; }
		
		/// <summary>
		/// The VM ID in AWS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
		
		/// <summary>
		/// The VPC ID the VM belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpcId")]
		public string VpcId { get; set; }
		
		/// <summary>
		/// The AWS zone of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AwsVmDetailsArchitecture
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VM_ARCHITECTURE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		I386 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		X86_64 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARM64 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		X86_64_MAC = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AwsVmDetailsBootOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOOT_OPTION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EFI = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BIOS = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AwsVmDetailsPowerState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POWER_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ON = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFF = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUSPENDED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AwsVmDetailsVirtualizationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VM_VIRTUALIZATION_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HVM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARAVIRTUAL = 2,
	}
	
	/// <summary>
	/// AWSVmsDetails describes VMs in AWS.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AwsVmsDetails
	{
		
		/// <summary>
		/// The details of the AWS VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public AwsVmDetails[] Details { get; set; }
	}
	
	/// <summary>
	/// The details of an Azure VM disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AzureDiskDetails
	{
		
		/// <summary>
		/// Azure disk ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskId")]
		public string DiskId { get; set; }
		
		/// <summary>
		/// The ordinal number of the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskNumber")]
		public System.Nullable<System.Int32> DiskNumber { get; set; }
		
		/// <summary>
		/// Size in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public string SizeGb { get; set; }
	}
	
	/// <summary>
	/// AzureSourceDetails message describes a specific source details for the Azure source type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AzureSourceDetails
	{
		
		/// <summary>
		/// Immutable. The Azure location (region) that the source VMs will be migrated from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="azureLocation")]
		public string AzureLocation { get; set; }
		
		/// <summary>
		/// Message describing Azure Credentials using tenant ID, client ID and secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientSecretCreds")]
		public ClientSecretCredentials ClientSecretCreds { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// User specified tags to add to every M2VM generated resource in Azure. These tags will be set in addition to the default tags that are set as part of the migration process. The tags must not begin with the reserved prefix `m4ce` or `m2vm`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="migrationResourcesUserTags")]
		public System.Collections.Generic.Dictionary<string, string> MigrationResourcesUserTags { get; set; }
		
		/// <summary>
		/// Output only. The ID of the Azure resource group that contains all resources related to the migration process of this source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceGroupId")]
		public string ResourceGroupId { get; set; }
		
		/// <summary>
		/// Output only. State of the source as determined by the health check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public AwsSourceDetailsState State { get; set; }
		
		/// <summary>
		/// Immutable. Azure subscription ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscriptionId")]
		public string SubscriptionId { get; set; }
	}
	
	/// <summary>
	/// Message describing Azure Credentials using tenant ID, client ID and secret.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ClientSecretCredentials
	{
		
		/// <summary>
		/// Azure client ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientId")]
		public string ClientId { get; set; }
		
		/// <summary>
		/// Input only. Azure client secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientSecret")]
		public string ClientSecret { get; set; }
		
		/// <summary>
		/// Azure tenant ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tenantId")]
		public string TenantId { get; set; }
	}
	
	/// <summary>
	/// Represent the source Azure VM details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AzureSourceVmDetails
	{
		
		/// <summary>
		/// The total size of the disks being migrated in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="committedStorageBytes")]
		public string CommittedStorageBytes { get; set; }
		
		/// <summary>
		/// The disks attached to the source VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public AzureDiskDetails[] Disks { get; set; }
		
		/// <summary>
		/// The firmware type of the source VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public AwsSourceVmDetailsFirmware Firmware { get; set; }
		
		/// <summary>
		/// Migrating VM source information about the VM capabilities needed for some Compute Engine features.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmCapabilitiesInfo")]
		public VmCapabilities VmCapabilitiesInfo { get; set; }
	}
	
	/// <summary>
	/// AwsVmDetails describes a VM in AWS.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AzureVmDetails
	{
		
		/// <summary>
		/// The VM Boot Option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootOption")]
		public AwsVmDetailsBootOption BootOption { get; set; }
		
		/// <summary>
		/// The total size of the storage allocated to the VM in MB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="committedStorageMb")]
		public string CommittedStorageMb { get; set; }
		
		/// <summary>
		/// The VM's ComputerName.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computerName")]
		public string ComputerName { get; set; }
		
		/// <summary>
		/// The number of cpus the VM has.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuCount")]
		public System.Nullable<System.Int32> CpuCount { get; set; }
		
		/// <summary>
		/// The number of disks the VM has, including OS disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskCount")]
		public System.Nullable<System.Int32> DiskCount { get; set; }
		
		/// <summary>
		/// Description of the data disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public Disk[] Disks { get; set; }
		
		/// <summary>
		/// The memory size of the VM in MB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryMb")]
		public System.Nullable<System.Int32> MemoryMb { get; set; }
		
		/// <summary>
		/// A message describing the VM's OS. Including OS, Publisher, Offer and Plan if applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osDescription")]
		public OSDescription OsDescription { get; set; }
		
		/// <summary>
		/// A message describing the OS disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="osDisk")]
		public OSDisk OsDisk { get; set; }
		
		/// <summary>
		/// The power state of the VM at the moment list was taken.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerState")]
		public System.Nullable<AzureVmDetailsPowerState> PowerState { get; set; }
		
		/// <summary>
		/// The tags of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// The VM full path in Azure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
		
		/// <summary>
		/// VM size as configured in Azure. Determines the VM's hardware spec.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmSize")]
		public string VmSize { get; set; }
	}
	
	/// <summary>
	/// A message describing a data disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Disk
	{
		
		/// <summary>
		/// The disk's Logical Unit Number (LUN).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lun")]
		public System.Nullable<System.Int32> Lun { get; set; }
		
		/// <summary>
		/// The disk name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The disk size in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public System.Nullable<System.Int32> SizeGb { get; set; }
	}
	
	/// <summary>
	/// A message describing the VM's OS. Including OS, Publisher, Offer and Plan if applicable.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OSDescription
	{
		
		/// <summary>
		/// OS offer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="offer")]
		public string Offer { get; set; }
		
		/// <summary>
		/// OS plan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public string Plan { get; set; }
		
		/// <summary>
		/// OS publisher.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publisher")]
		public string Publisher { get; set; }
		
		/// <summary>
		/// OS type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A message describing the OS disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OSDisk
	{
		
		/// <summary>
		/// The disk's full name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The disk's size in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public System.Nullable<System.Int32> SizeGb { get; set; }
		
		/// <summary>
		/// The disk's type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AzureVmDetailsPowerState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POWER_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEALLOCATING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEALLOCATED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 7,
	}
	
	/// <summary>
	/// AzureVmsDetails describes VMs in Azure.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AzureVmsDetails
	{
		
		/// <summary>
		/// The details of the Azure VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public AzureVmDetails[] Details { get; set; }
	}
	
	/// <summary>
	/// BootDiskDefaults hold information about the boot disk of a VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BootDiskDefaults
	{
		
		/// <summary>
		/// Optional. Specifies a unique device name of your choice that is reflected into the /dev/disk/by-id/google-* tree of a Linux operating system running within the instance. If not specified, the server chooses a default device name to apply to this disk, in the form persistent-disk-x, where x is a number assigned by Google Compute Engine. This field is only applicable for persistent disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceName")]
		public string DeviceName { get; set; }
		
		/// <summary>
		/// Optional. The name of the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskName")]
		public string DiskName { get; set; }
		
		/// <summary>
		/// Optional. The type of disk provisioning to use for the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskType")]
		public System.Nullable<BootDiskDefaultsDiskType> DiskType { get; set; }
		
		/// <summary>
		/// Encryption message describes the details of the applied encryption.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryption")]
		public Encryption Encryption { get; set; }
		
		/// <summary>
		/// Contains details about the image source used to create the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public DiskImageDefaults Image { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum BootDiskDefaultsDiskType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_ENGINE_DISK_TYPE_STANDARD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_ENGINE_DISK_TYPE_SSD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_ENGINE_DISK_TYPE_BALANCED = 3,
	}
	
	/// <summary>
	/// Encryption message describes the details of the applied encryption.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Encryption
	{
		
		/// <summary>
		/// Required. The name of the encryption key that is stored in Google Cloud KMS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kmsKey")]
		public string KmsKey { get; set; }
	}
	
	/// <summary>
	/// Contains details about the image source used to create the disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DiskImageDefaults
	{
		
		/// <summary>
		/// Required. The Image resource used when creating the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceImage")]
		public string SourceImage { get; set; }
	}
	
	/// <summary>
	/// Request message for 'CancelCloneJob' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CancelCloneJobRequest
	{
	}
	
	/// <summary>
	/// Request message for 'CancelCutoverJob' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CancelCutoverJobRequest
	{
	}
	
	/// <summary>
	/// The request message for Operations.CancelOperation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CancelOperationRequest
	{
	}
	
	/// <summary>
	/// CloneJob describes the process of creating a clone of a MigratingVM to the requested target based on the latest successful uploaded snapshots. While the migration cycles of a MigratingVm take place, it is possible to verify the uploaded VM can be started in the cloud, by creating a clone. The clone can be created without any downtime, and it is created using the latest snapshots which are already in the cloud. The cloneJob is only responsible for its work, not its products, which means once it is finished, it will never touch the instance it created. It will only delete it in case of the CloneJob being cancelled or upon failure to clone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CloneJob
	{
		
		/// <summary>
		/// ComputeEngineDisksTargetDetails is a collection of created Persistent Disks details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeEngineDisksTargetDetails")]
		public ComputeEngineDisksTargetDetails ComputeEngineDisksTargetDetails { get; set; }
		
		/// <summary>
		/// ComputeEngineTargetDetails is a collection of details for creating a VM in a target Compute Engine project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeEngineTargetDetails")]
		public ComputeEngineTargetDetails ComputeEngineTargetDetails { get; set; }
		
		/// <summary>
		/// Output only. The time the clone job was created (as an API call, not when it was actually created in the target).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The time the clone job was ended.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Output only. The name of the clone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. State of the clone job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<CloneJobState> State { get; set; }
		
		/// <summary>
		/// Output only. The time the state was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stateTime")]
		public string StateTime { get; set; }
		
		/// <summary>
		/// Output only. The clone steps list representing its progress.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="steps")]
		public CloneStep[] Steps { get; set; }
	}
	
	/// <summary>
	/// ComputeEngineDisksTargetDetails is a collection of created Persistent Disks details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ComputeEngineDisksTargetDetails
	{
		
		/// <summary>
		/// The details of each created Persistent Disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public PersistentDisk[] Disks { get; set; }
		
		/// <summary>
		/// Details for a disks-only migration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disksTargetDetails")]
		public DisksMigrationDisksTargetDetails DisksTargetDetails { get; set; }
		
		/// <summary>
		/// Details for the VM created VM as part of disks migration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmTargetDetails")]
		public DisksMigrationVmTargetDetails VmTargetDetails { get; set; }
	}
	
	/// <summary>
	/// Details of a created Persistent Disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PersistentDisk
	{
		
		/// <summary>
		/// The URI of the Persistent Disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskUri")]
		public string DiskUri { get; set; }
		
		/// <summary>
		/// The ordinal number of the source VM disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDiskNumber")]
		public System.Nullable<System.Int32> SourceDiskNumber { get; set; }
	}
	
	/// <summary>
	/// Details for a disks-only migration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DisksMigrationDisksTargetDetails
	{
	}
	
	/// <summary>
	/// Details for the VM created VM as part of disks migration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DisksMigrationVmTargetDetails
	{
		
		/// <summary>
		/// Output only. The URI of the Compute Engine VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmUri")]
		public string VmUri { get; set; }
	}
	
	/// <summary>
	/// ComputeEngineTargetDetails is a collection of details for creating a VM in a target Compute Engine project.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ComputeEngineTargetDetails
	{
		
		/// <summary>
		/// Additional licenses to assign to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalLicenses")]
		public string[] AdditionalLicenses { get; set; }
		
		/// <summary>
		/// AppliedLicense holds the license data returned by adaptation module report.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appliedLicense")]
		public AppliedLicense AppliedLicense { get; set; }
		
		/// <summary>
		/// The VM Boot Option, as set in the source VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootOption")]
		public System.Nullable<ComputeEngineTargetDetailsBootOption> BootOption { get; set; }
		
		/// <summary>
		/// Scheduling information for VM on maintenance/restart behaviour and node allocation in sole tenant nodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeScheduling")]
		public ComputeScheduling ComputeScheduling { get; set; }
		
		/// <summary>
		/// The disk type to use in the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskType")]
		public BootDiskDefaultsDiskType DiskType { get; set; }
		
		/// <summary>
		/// Encryption message describes the details of the applied encryption.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryption")]
		public Encryption Encryption { get; set; }
		
		/// <summary>
		/// The hostname to assign to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// A map of labels to associate with the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// The license type to use in OS adaptation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public System.Nullable<ComputeEngineTargetDetailsLicenseType> LicenseType { get; set; }
		
		/// <summary>
		/// The machine type to create the VM with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
		
		/// <summary>
		/// The machine type series to create the VM with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineTypeSeries")]
		public string MachineTypeSeries { get; set; }
		
		/// <summary>
		/// The metadata key/value pairs to assign to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// List of NICs connected to this VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaces")]
		public NetworkInterface[] NetworkInterfaces { get; set; }
		
		/// <summary>
		/// A list of network tags to associate with the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTags")]
		public string[] NetworkTags { get; set; }
		
		/// <summary>
		/// The Google Cloud target project ID or project name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="project")]
		public string Project { get; set; }
		
		/// <summary>
		/// Defines whether the instance has Secure Boot enabled. This can be set to true only if the VM boot option is EFI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secureBoot")]
		public System.Nullable<System.Boolean> SecureBoot { get; set; }
		
		/// <summary>
		/// The service account to associate the VM with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccount")]
		public string ServiceAccount { get; set; }
		
		/// <summary>
		/// The name of the VM to create.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmName")]
		public string VmName { get; set; }
		
		/// <summary>
		/// The zone in which to create the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ComputeEngineTargetDetailsBootOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_ENGINE_BOOT_OPTION_EFI = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_ENGINE_BOOT_OPTION_BIOS = 2,
	}
	
	/// <summary>
	/// Scheduling information for VM on maintenance/restart behaviour and node allocation in sole tenant nodes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ComputeScheduling
	{
		
		/// <summary>
		/// The minimum number of virtual CPUs this instance will consume when running on a sole-tenant node. Ignored if no node_affinites are configured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minNodeCpus")]
		public System.Nullable<System.Int32> MinNodeCpus { get; set; }
		
		/// <summary>
		/// A set of node affinity and anti-affinity configurations for sole tenant nodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeAffinities")]
		public SchedulingNodeAffinity[] NodeAffinities { get; set; }
		
		/// <summary>
		/// How the instance should behave when the host machine undergoes maintenance that may temporarily impact instance performance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="onHostMaintenance")]
		public System.Nullable<ComputeSchedulingOnHostMaintenance> OnHostMaintenance { get; set; }
		
		/// <summary>
		/// Whether the Instance should be automatically restarted whenever it is terminated by Compute Engine (not terminated by user). This configuration is identical to `automaticRestart` field in Compute Engine create instance under scheduling. It was changed to an enum (instead of a boolean) to match the default value in Compute Engine which is automatic restart.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restartType")]
		public System.Nullable<ComputeSchedulingRestartType> RestartType { get; set; }
	}
	
	/// <summary>
	/// Node Affinity: the configuration of desired nodes onto which this Instance could be scheduled. Based on https://cloud.google.com/compute/docs/reference/rest/v1/instances/setScheduling
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SchedulingNodeAffinity
	{
		
		/// <summary>
		/// The label key of Node resource to reference.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// The operator to use for the node resources specified in the `values` parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operator")]
		public System.Nullable<SchedulingNodeAffinityOperator> Operator { get; set; }
		
		/// <summary>
		/// Corresponds to the label values of Node resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SchedulingNodeAffinityOperator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPERATOR_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_IN = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ComputeSchedulingOnHostMaintenance
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ON_HOST_MAINTENANCE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TERMINATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIGRATE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ComputeSchedulingRestartType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTART_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMATIC_RESTART = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_AUTOMATIC_RESTART = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ComputeEngineTargetDetailsLicenseType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_ENGINE_LICENSE_TYPE_PAYG = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_ENGINE_LICENSE_TYPE_BYOL = 2,
	}
	
	/// <summary>
	/// NetworkInterface represents a NIC of a VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NetworkInterface
	{
		
		/// <summary>
		/// The external IP to define in the NIC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalIp")]
		public string ExternalIp { get; set; }
		
		/// <summary>
		/// The internal IP to define in the NIC. The formats accepted are: `ephemeral` \ ipv4 address \ a named address resource full path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalIp")]
		public string InternalIp { get; set; }
		
		/// <summary>
		/// The network to connect the NIC to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// The subnetwork to connect the NIC to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetwork")]
		public string Subnetwork { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CloneJobState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLING = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADAPTING_OS = 7,
	}
	
	/// <summary>
	/// CloneStep holds information about the clone step progress.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CloneStep
	{
		
		/// <summary>
		/// AdaptingOSStep contains specific step details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adaptingOs")]
		public AdaptingOSStep AdaptingOs { get; set; }
		
		/// <summary>
		/// The time the step has ended.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// InstantiatingMigratedVMStep contains specific step details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instantiatingMigratedVm")]
		public InstantiatingMigratedVMStep InstantiatingMigratedVm { get; set; }
		
		/// <summary>
		/// PreparingVMDisksStep contains specific step details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preparingVmDisks")]
		public PreparingVMDisksStep PreparingVmDisks { get; set; }
		
		/// <summary>
		/// The time the step has started.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	/// <summary>
	/// InstantiatingMigratedVMStep contains specific step details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InstantiatingMigratedVMStep
	{
	}
	
	/// <summary>
	/// PreparingVMDisksStep contains specific step details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PreparingVMDisksStep
	{
	}
	
	/// <summary>
	/// ComputeEngineDisksTargetDefaults is a collection of details for creating Persistent Disks in a target Compute Engine project.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ComputeEngineDisksTargetDefaults
	{
		
		/// <summary>
		/// The details of each Persistent Disk to create.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public PersistentDiskDefaults[] Disks { get; set; }
		
		/// <summary>
		/// Details for a disk only migration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disksTargetDefaults")]
		public DisksMigrationDisksTargetDefaults DisksTargetDefaults { get; set; }
		
		/// <summary>
		/// The full path of the resource of type TargetProject which represents the Compute Engine project in which to create the Persistent Disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetProject")]
		public string TargetProject { get; set; }
		
		/// <summary>
		/// Details for creation of a VM that migrated data disks will be attached to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmTargetDefaults")]
		public DisksMigrationVmTargetDefaults VmTargetDefaults { get; set; }
		
		/// <summary>
		/// The zone in which to create the Persistent Disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// Details for creation of a Persistent Disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PersistentDiskDefaults
	{
		
		/// <summary>
		/// A map of labels to associate with the Persistent Disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalLabels")]
		public System.Collections.Generic.Dictionary<string, string> AdditionalLabels { get; set; }
		
		/// <summary>
		/// Optional. The name of the Persistent Disk to create.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskName")]
		public string DiskName { get; set; }
		
		/// <summary>
		/// The disk type to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskType")]
		public BootDiskDefaultsDiskType DiskType { get; set; }
		
		/// <summary>
		/// Encryption message describes the details of the applied encryption.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryption")]
		public Encryption Encryption { get; set; }
		
		/// <summary>
		/// Required. The ordinal number of the source VM disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDiskNumber")]
		public System.Nullable<System.Int32> SourceDiskNumber { get; set; }
		
		/// <summary>
		/// Details for attachment of the disk to a VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmAttachmentDetails")]
		public VmAttachmentDetails VmAttachmentDetails { get; set; }
	}
	
	/// <summary>
	/// Details for attachment of the disk to a VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VmAttachmentDetails
	{
		
		/// <summary>
		/// Optional. Specifies a unique device name of your choice that is reflected into the /dev/disk/by-id/google-* tree of a Linux operating system running within the instance. If not specified, the server chooses a default device name to apply to this disk, in the form persistent-disk-x, where x is a number assigned by Google Compute Engine. This field is only applicable for persistent disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceName")]
		public string DeviceName { get; set; }
	}
	
	/// <summary>
	/// Details for a disk only migration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DisksMigrationDisksTargetDefaults
	{
	}
	
	/// <summary>
	/// Details for creation of a VM that migrated data disks will be attached to.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DisksMigrationVmTargetDefaults
	{
		
		/// <summary>
		/// Optional. Additional licenses to assign to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalLicenses")]
		public string[] AdditionalLicenses { get; set; }
		
		/// <summary>
		/// BootDiskDefaults hold information about the boot disk of a VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootDiskDefaults")]
		public BootDiskDefaults BootDiskDefaults { get; set; }
		
		/// <summary>
		/// Scheduling information for VM on maintenance/restart behaviour and node allocation in sole tenant nodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeScheduling")]
		public ComputeScheduling ComputeScheduling { get; set; }
		
		/// <summary>
		/// Encryption message describes the details of the applied encryption.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryption")]
		public Encryption Encryption { get; set; }
		
		/// <summary>
		/// Optional. The hostname to assign to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// Optional. A map of labels to associate with the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Required. The machine type to create the VM with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
		
		/// <summary>
		/// Optional. The machine type series to create the VM with. For presentation only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineTypeSeries")]
		public string MachineTypeSeries { get; set; }
		
		/// <summary>
		/// Optional. The metadata key/value pairs to assign to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// Optional. NICs to attach to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaces")]
		public NetworkInterface[] NetworkInterfaces { get; set; }
		
		/// <summary>
		/// Optional. A list of network tags to associate with the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTags")]
		public string[] NetworkTags { get; set; }
		
		/// <summary>
		/// Optional. Defines whether the instance has Secure Boot enabled. This can be set to true only if the VM boot option is EFI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secureBoot")]
		public System.Nullable<System.Boolean> SecureBoot { get; set; }
		
		/// <summary>
		/// Optional. The service account to associate the VM with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccount")]
		public string ServiceAccount { get; set; }
		
		/// <summary>
		/// Required. The name of the VM to create.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmName")]
		public string VmName { get; set; }
	}
	
	/// <summary>
	/// ComputeEngineTargetDefaults is a collection of details for creating a VM in a target Compute Engine project.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ComputeEngineTargetDefaults
	{
		
		/// <summary>
		/// Additional licenses to assign to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalLicenses")]
		public string[] AdditionalLicenses { get; set; }
		
		/// <summary>
		/// AppliedLicense holds the license data returned by adaptation module report.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appliedLicense")]
		public AppliedLicense AppliedLicense { get; set; }
		
		/// <summary>
		/// Output only. The VM Boot Option, as set in the source VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootOption")]
		public ComputeEngineTargetDetailsBootOption BootOption { get; set; }
		
		/// <summary>
		/// Scheduling information for VM on maintenance/restart behaviour and node allocation in sole tenant nodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeScheduling")]
		public ComputeScheduling ComputeScheduling { get; set; }
		
		/// <summary>
		/// The disk type to use in the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskType")]
		public BootDiskDefaultsDiskType DiskType { get; set; }
		
		/// <summary>
		/// Encryption message describes the details of the applied encryption.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryption")]
		public Encryption Encryption { get; set; }
		
		/// <summary>
		/// The hostname to assign to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// A map of labels to associate with the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// The license type to use in OS adaptation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseType")]
		public ComputeEngineTargetDetailsLicenseType LicenseType { get; set; }
		
		/// <summary>
		/// The machine type to create the VM with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
		
		/// <summary>
		/// The machine type series to create the VM with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineTypeSeries")]
		public string MachineTypeSeries { get; set; }
		
		/// <summary>
		/// The metadata key/value pairs to assign to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
		
		/// <summary>
		/// List of NICs connected to this VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaces")]
		public NetworkInterface[] NetworkInterfaces { get; set; }
		
		/// <summary>
		/// A list of network tags to associate with the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTags")]
		public string[] NetworkTags { get; set; }
		
		/// <summary>
		/// Defines whether the instance has Secure Boot enabled. This can be set to true only if the VM boot option is EFI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secureBoot")]
		public System.Nullable<System.Boolean> SecureBoot { get; set; }
		
		/// <summary>
		/// The service account to associate the VM with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccount")]
		public string ServiceAccount { get; set; }
		
		/// <summary>
		/// The full path of the resource of type TargetProject which represents the Compute Engine project in which to create this VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetProject")]
		public string TargetProject { get; set; }
		
		/// <summary>
		/// The name of the VM to create.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmName")]
		public string VmName { get; set; }
		
		/// <summary>
		/// The zone in which to create the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// CutoverForecast holds information about future CutoverJobs of a MigratingVm.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CutoverForecast
	{
		
		/// <summary>
		/// Output only. Estimation of the CutoverJob duration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="estimatedCutoverJobDuration")]
		public string EstimatedCutoverJobDuration { get; set; }
	}
	
	/// <summary>
	/// CutoverJob message describes a cutover of a migrating VM. The CutoverJob is the operation of shutting down the VM, creating a snapshot and clonning the VM using the replicated snapshot.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CutoverJob
	{
		
		/// <summary>
		/// ComputeEngineDisksTargetDetails is a collection of created Persistent Disks details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeEngineDisksTargetDetails")]
		public ComputeEngineDisksTargetDetails ComputeEngineDisksTargetDetails { get; set; }
		
		/// <summary>
		/// ComputeEngineTargetDetails is a collection of details for creating a VM in a target Compute Engine project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeEngineTargetDetails")]
		public ComputeEngineTargetDetails ComputeEngineTargetDetails { get; set; }
		
		/// <summary>
		/// Output only. The time the cutover job was created (as an API call, not when it was actually created in the target).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The time the cutover job had finished.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Output only. The name of the cutover job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The current progress in percentage of the cutover job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progressPercent")]
		public System.Nullable<System.Int32> ProgressPercent { get; set; }
		
		/// <summary>
		/// Output only. State of the cutover job.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<CutoverJobState> State { get; set; }
		
		/// <summary>
		/// Output only. A message providing possible extra details about the current state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stateMessage")]
		public string StateMessage { get; set; }
		
		/// <summary>
		/// Output only. The time the state was last updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stateTime")]
		public string StateTime { get; set; }
		
		/// <summary>
		/// Output only. The cutover steps list representing its progress.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="steps")]
		public CutoverStep[] Steps { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CutoverJobState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADAPTING_OS = 7,
	}
	
	/// <summary>
	/// CutoverStep holds information about the cutover step progress.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CutoverStep
	{
		
		/// <summary>
		/// The time the step has ended.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// ReplicationCycle contains information about the current replication cycle status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="finalSync")]
		public ReplicationCycle FinalSync { get; set; }
		
		/// <summary>
		/// InstantiatingMigratedVMStep contains specific step details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instantiatingMigratedVm")]
		public InstantiatingMigratedVMStep InstantiatingMigratedVm { get; set; }
		
		/// <summary>
		/// PreparingVMDisksStep contains specific step details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preparingVmDisks")]
		public PreparingVMDisksStep PreparingVmDisks { get; set; }
		
		/// <summary>
		/// ReplicationCycle contains information about the current replication cycle status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="previousReplicationCycle")]
		public ReplicationCycle PreviousReplicationCycle { get; set; }
		
		/// <summary>
		/// ShuttingDownSourceVMStep contains specific step details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shuttingDownSourceVm")]
		public ShuttingDownSourceVMStep ShuttingDownSourceVm { get; set; }
		
		/// <summary>
		/// The time the step has started.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	/// <summary>
	/// ReplicationCycle contains information about the current replication cycle status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReplicationCycle
	{
		
		/// <summary>
		/// The cycle's ordinal number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cycleNumber")]
		public System.Nullable<System.Int32> CycleNumber { get; set; }
		
		/// <summary>
		/// The time the replication cycle has ended.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// The identifier of the ReplicationCycle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The current progress in percentage of this cycle. Was replaced by 'steps' field, which breaks down the cycle progression more accurately.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progressPercent")]
		public System.Nullable<System.Int32> ProgressPercent { get; set; }
		
		/// <summary>
		/// The time the replication cycle has started.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// State of the ReplicationCycle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ReplicationCycleState> State { get; set; }
		
		/// <summary>
		/// The cycle's steps list representing its progress.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="steps")]
		public CycleStep[] Steps { get; set; }
		
		/// <summary>
		/// The accumulated duration the replication cycle was paused.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalPauseDuration")]
		public string TotalPauseDuration { get; set; }
		
		/// <summary>
		/// Output only. Warnings that occurred during the cycle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warnings")]
		public MigrationWarning[] Warnings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ReplicationCycleState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAUSED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 4,
	}
	
	/// <summary>
	/// CycleStep holds information about a step progress.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CycleStep
	{
		
		/// <summary>
		/// The time the cycle step has ended.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// InitializingReplicationStep contains specific step details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="initializingReplication")]
		public InitializingReplicationStep InitializingReplication { get; set; }
		
		/// <summary>
		/// PostProcessingStep contains specific step details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postProcessing")]
		public PostProcessingStep PostProcessing { get; set; }
		
		/// <summary>
		/// ReplicatingStep contains specific step details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicating")]
		public ReplicatingStep Replicating { get; set; }
		
		/// <summary>
		/// The time the cycle step has started.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	/// <summary>
	/// InitializingReplicationStep contains specific step details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InitializingReplicationStep
	{
	}
	
	/// <summary>
	/// PostProcessingStep contains specific step details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PostProcessingStep
	{
	}
	
	/// <summary>
	/// ReplicatingStep contains specific step details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReplicatingStep
	{
		
		/// <summary>
		/// The source disks replication rate for the last 30 minutes in bytes per second.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastThirtyMinutesAverageBytesPerSecond")]
		public string LastThirtyMinutesAverageBytesPerSecond { get; set; }
		
		/// <summary>
		/// The source disks replication rate for the last 2 minutes in bytes per second.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastTwoMinutesAverageBytesPerSecond")]
		public string LastTwoMinutesAverageBytesPerSecond { get; set; }
		
		/// <summary>
		/// Replicated bytes in the step.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicatedBytes")]
		public string ReplicatedBytes { get; set; }
		
		/// <summary>
		/// Total bytes to be handled in the step.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalBytes")]
		public string TotalBytes { get; set; }
	}
	
	/// <summary>
	/// Represents migration resource warning information that can be used with google.rpc.Status message. MigrationWarning is used to present the user with warning information in migration operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MigrationWarning
	{
		
		/// <summary>
		/// Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionItem")]
		public LocalizedMessage ActionItem { get; set; }
		
		/// <summary>
		/// The warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<MigrationWarningCode> Code { get; set; }
		
		/// <summary>
		/// URL(s) pointing to additional information on handling the current warning.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpLinks")]
		public Link[] HelpLinks { get; set; }
		
		/// <summary>
		/// Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warningMessage")]
		public LocalizedMessage WarningMessage { get; set; }
		
		/// <summary>
		/// The time the warning occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warningTime")]
		public string WarningTime { get; set; }
	}
	
	/// <summary>
	/// Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LocalizedMessage
	{
		
		/// <summary>
		/// The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locale")]
		public string Locale { get; set; }
		
		/// <summary>
		/// The localized error message in the above locale.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MigrationWarningCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WARNING_CODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADAPTATION_WARNING = 1,
	}
	
	/// <summary>
	/// Describes a URL link.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Link
	{
		
		/// <summary>
		/// Describes what the link offers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The URL of the link.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// ShuttingDownSourceVMStep contains specific step details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ShuttingDownSourceVMStep
	{
	}
	
	/// <summary>
	/// DatacenterConnector message describes a connector between the Source and Google Cloud, which is installed on a vmware datacenter (an OVA vm installed by the user) to connect the Datacenter to Google Cloud and support vm migration data transfer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DatacenterConnector
	{
		
		/// <summary>
		/// Output only. Appliance OVA version. This is the OVA which is manually installed by the user and contains the infrastructure for the automatically updatable components on the appliance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceInfrastructureVersion")]
		public string ApplianceInfrastructureVersion { get; set; }
		
		/// <summary>
		/// Output only. Appliance last installed update bundle version. This is the version of the automatically updatable components on the appliance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="applianceSoftwareVersion")]
		public string ApplianceSoftwareVersion { get; set; }
		
		/// <summary>
		/// Holds informatiom about the available versions for upgrade.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableVersions")]
		public AvailableUpdates AvailableVersions { get; set; }
		
		/// <summary>
		/// Output only. The communication channel between the datacenter connector and Google Cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucket")]
		public string Bucket { get; set; }
		
		/// <summary>
		/// Output only. The time the connector was created (as an API call, not when it was actually installed).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Output only. The connector's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Immutable. A unique key for this connector. This key is internal to the OVA connector and is supplied with its creation during the registration process and can not be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registrationId")]
		public string RegistrationId { get; set; }
		
		/// <summary>
		/// The service account to use in the connector when communicating with the cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccount")]
		public string ServiceAccount { get; set; }
		
		/// <summary>
		/// Output only. State of the DatacenterConnector, as determined by the health checks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<DatacenterConnectorState> State { get; set; }
		
		/// <summary>
		/// Output only. The time the state was last set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stateTime")]
		public string StateTime { get; set; }
		
		/// <summary>
		/// Output only. The last time the connector was updated with an API call.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// UpgradeStatus contains information about upgradeAppliance operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upgradeStatus")]
		public UpgradeStatus UpgradeStatus { get; set; }
		
		/// <summary>
		/// The version running in the DatacenterConnector. This is supplied by the OVA connector during the registration process and can not be modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DatacenterConnectorState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFFLINE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 4,
	}
	
	/// <summary>
	/// UpgradeStatus contains information about upgradeAppliance operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpgradeStatus
	{
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// The version from which we upgraded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="previousVersion")]
		public string PreviousVersion { get; set; }
		
		/// <summary>
		/// The time the operation was started.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// The state of the upgradeAppliance operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<UpgradeStatusState> State { get; set; }
		
		/// <summary>
		/// The version to upgrade to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpgradeStatusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 3,
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Empty
	{
	}
	
	/// <summary>
	/// Response message for fetchInventory.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FetchInventoryResponse
	{
		
		/// <summary>
		/// AWSVmsDetails describes VMs in AWS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="awsVms")]
		public AwsVmsDetails AwsVms { get; set; }
		
		/// <summary>
		/// AzureVmsDetails describes VMs in Azure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="azureVms")]
		public AzureVmsDetails AzureVms { get; set; }
		
		/// <summary>
		/// Output only. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Output only. The timestamp when the source was last queried (if the result is from the cache).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// VmwareVmsDetails describes VMs in vCenter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmwareVms")]
		public VmwareVmsDetails VmwareVms { get; set; }
	}
	
	/// <summary>
	/// VmwareVmsDetails describes VMs in vCenter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VmwareVmsDetails
	{
		
		/// <summary>
		/// The details of the vmware VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public VmwareVmDetails[] Details { get; set; }
	}
	
	/// <summary>
	/// VmwareVmDetails describes a VM in vCenter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VmwareVmDetails
	{
		
		/// <summary>
		/// Output only. The VM Boot Option.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bootOption")]
		public AwsVmDetailsBootOption BootOption { get; set; }
		
		/// <summary>
		/// The total size of the storage allocated to the VM in MB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="committedStorageMb")]
		public string CommittedStorageMb { get; set; }
		
		/// <summary>
		/// The number of cpus in the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuCount")]
		public System.Nullable<System.Int32> CpuCount { get; set; }
		
		/// <summary>
		/// The descriptive name of the vCenter's datacenter this VM is contained in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datacenterDescription")]
		public string DatacenterDescription { get; set; }
		
		/// <summary>
		/// The id of the vCenter's datacenter this VM is contained in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datacenterId")]
		public string DatacenterId { get; set; }
		
		/// <summary>
		/// The number of disks the VM has.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskCount")]
		public System.Nullable<System.Int32> DiskCount { get; set; }
		
		/// <summary>
		/// The display name of the VM. Note that this is not necessarily unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The VM's OS. See for example https://vdc-repo.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html for types of strings this might hold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestDescription")]
		public string GuestDescription { get; set; }
		
		/// <summary>
		/// The size of the memory of the VM in MB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryMb")]
		public System.Nullable<System.Int32> MemoryMb { get; set; }
		
		/// <summary>
		/// The power state of the VM at the moment list was taken.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="powerState")]
		public System.Nullable<VmwareVmDetailsPowerState> PowerState { get; set; }
		
		/// <summary>
		/// The unique identifier of the VM in vCenter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
		
		/// <summary>
		/// The VM's id in the source (note that this is not the MigratingVm's id). This is the moref id of the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum VmwareVmDetailsPowerState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POWER_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ON = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFF = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUSPENDED = 3,
	}
	
	/// <summary>
	/// Request message for 'FinalizeMigration' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FinalizeMigrationRequest
	{
	}
	
	/// <summary>
	/// Describes message for 'Group' resource. The Group is a collections of several MigratingVms.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Group
	{
		
		/// <summary>
		/// Output only. The create time timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// User-provided description of the group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Display name is a user defined name for this group which can be updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Immutable. The target type of this group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="migrationTargetType")]
		public System.Nullable<GroupMigrationTargetType> MigrationTargetType { get; set; }
		
		/// <summary>
		/// Output only. The Group name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The update time timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GroupMigrationTargetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIGRATION_TARGET_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIGRATION_TARGET_TYPE_GCE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIGRATION_TARGET_TYPE_DISKS = 2,
	}
	
	/// <summary>
	/// Response message for 'ListCloneJobs' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListCloneJobsResponse
	{
		
		/// <summary>
		/// Output only. The list of clone jobs response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloneJobs")]
		public CloneJob[] CloneJobs { get; set; }
		
		/// <summary>
		/// Output only. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Output only. Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for 'ListCutoverJobs' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListCutoverJobsResponse
	{
		
		/// <summary>
		/// Output only. The list of cutover jobs response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cutoverJobs")]
		public CutoverJob[] CutoverJobs { get; set; }
		
		/// <summary>
		/// Output only. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Output only. Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for 'ListDatacenterConnectors' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListDatacenterConnectorsResponse
	{
		
		/// <summary>
		/// Output only. The list of sources response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="datacenterConnectors")]
		public DatacenterConnector[] DatacenterConnectors { get; set; }
		
		/// <summary>
		/// Output only. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Output only. Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for 'ListGroups' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListGroupsResponse
	{
		
		/// <summary>
		/// Output only. The list of groups response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public Group[] Groups { get; set; }
		
		/// <summary>
		/// Output only. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Output only. Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// The response message for Locations.ListLocations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListLocationsResponse
	{
		
		/// <summary>
		/// A list of locations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public Location[] Locations { get; set; }
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A resource that represents a Google Cloud location.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Location
	{
		
		/// <summary>
		/// The friendly name for this location, typically a nearby city name. For example, "Tokyo".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Cross-service attributes for the location. For example {"cloud.googleapis.com/region": "us-east1"}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// The canonical id for this location. For example: `"us-east1"`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// Service-specific metadata. For example the available capacity at the given location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// Resource name for the location, which may vary between implementations. For example: `"projects/example-project/locations/us-east1"`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Response message for 'ListMigratingVms' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListMigratingVmsResponse
	{
		
		/// <summary>
		/// Output only. The list of Migrating VMs response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="migratingVms")]
		public MigratingVm[] MigratingVms { get; set; }
		
		/// <summary>
		/// Output only. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Output only. Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// MigratingVm describes the VM that will be migrated from a Source environment and its replication state.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MigratingVm
	{
		
		/// <summary>
		/// Represent the source AWS VM details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="awsSourceVmDetails")]
		public AwsSourceVmDetails AwsSourceVmDetails { get; set; }
		
		/// <summary>
		/// Represent the source Azure VM details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="azureSourceVmDetails")]
		public AzureSourceVmDetails AzureSourceVmDetails { get; set; }
		
		/// <summary>
		/// ComputeEngineDisksTargetDefaults is a collection of details for creating Persistent Disks in a target Compute Engine project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeEngineDisksTargetDefaults")]
		public ComputeEngineDisksTargetDefaults ComputeEngineDisksTargetDefaults { get; set; }
		
		/// <summary>
		/// ComputeEngineTargetDefaults is a collection of details for creating a VM in a target Compute Engine project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="computeEngineTargetDefaults")]
		public ComputeEngineTargetDefaults ComputeEngineTargetDefaults { get; set; }
		
		/// <summary>
		/// Output only. The time the migrating VM was created (this refers to this resource and not to the time it was installed in the source).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// ReplicationCycle contains information about the current replication cycle status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentSyncInfo")]
		public ReplicationCycle CurrentSyncInfo { get; set; }
		
		/// <summary>
		/// CutoverForecast holds information about future CutoverJobs of a MigratingVm.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cutoverForecast")]
		public CutoverForecast CutoverForecast { get; set; }
		
		/// <summary>
		/// The description attached to the migrating VM by the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The display name attached to the MigratingVm by the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Output only. The group this migrating vm is included in, if any. The group is represented by the full path of the appropriate Group resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		/// <summary>
		/// The labels of the migrating VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// ReplicationCycle contains information about the current replication cycle status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastReplicationCycle")]
		public ReplicationCycle LastReplicationCycle { get; set; }
		
		/// <summary>
		/// ReplicationSync contain information about the last replica sync to the cloud.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSync")]
		public ReplicationSync LastSync { get; set; }
		
		/// <summary>
		/// Output only. The identifier of the MigratingVm.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A policy for scheduling replications.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public SchedulePolicy Policy { get; set; }
		
		/// <summary>
		/// Output only. The recent clone jobs performed on the migrating VM. This field holds the vm's last completed clone job and the vm's running clone job, if one exists. Note: To have this field populated you need to explicitly request it via the "view" parameter of the Get/List request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentCloneJobs")]
		public CloneJob[] RecentCloneJobs { get; set; }
		
		/// <summary>
		/// Output only. The recent cutover jobs performed on the migrating VM. This field holds the vm's last completed cutover job and the vm's running cutover job, if one exists. Note: To have this field populated you need to explicitly request it via the "view" parameter of the Get/List request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentCutoverJobs")]
		public CutoverJob[] RecentCutoverJobs { get; set; }
		
		/// <summary>
		/// The unique ID of the VM in the source. The VM's name in vSphere can be changed, so this is not the VM's name but rather its moRef id. This id is of the form vm-.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceVmId")]
		public string SourceVmId { get; set; }
		
		/// <summary>
		/// Output only. State of the MigratingVm.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<MigratingVmState> State { get; set; }
		
		/// <summary>
		/// Output only. The last time the migrating VM state was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stateTime")]
		public string StateTime { get; set; }
		
		/// <summary>
		/// Output only. The last time the migrating VM resource was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// Represent the source Vmware VM details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmwareSourceVmDetails")]
		public VmwareSourceVmDetails VmwareSourceVmDetails { get; set; }
	}
	
	/// <summary>
	/// ReplicationSync contain information about the last replica sync to the cloud.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReplicationSync
	{
		
		/// <summary>
		/// The most updated snapshot created time in the source that finished replication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSyncTime")]
		public string LastSyncTime { get; set; }
	}
	
	/// <summary>
	/// A policy for scheduling replications.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SchedulePolicy
	{
		
		/// <summary>
		/// The idle duration between replication stages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idleDuration")]
		public string IdleDuration { get; set; }
		
		/// <summary>
		/// A flag to indicate whether to skip OS adaptation during the replication sync. OS adaptation is a process where the VM's operating system undergoes changes and adaptations to fully function on Compute Engine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="skipOsAdaptation")]
		public System.Nullable<System.Boolean> SkipOsAdaptation { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MigratingVmState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIRST_SYNC = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUTTING_OVER = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUTOVER = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINAL_SYNC = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAUSED = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINALIZING = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FINALIZED = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 11,
	}
	
	/// <summary>
	/// Represent the source Vmware VM details.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VmwareSourceVmDetails
	{
		
		/// <summary>
		/// The total size of the disks being migrated in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="committedStorageBytes")]
		public string CommittedStorageBytes { get; set; }
		
		/// <summary>
		/// The disks attached to the source VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public VmwareDiskDetails[] Disks { get; set; }
		
		/// <summary>
		/// The firmware type of the source VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firmware")]
		public AwsSourceVmDetailsFirmware Firmware { get; set; }
		
		/// <summary>
		/// Migrating VM source information about the VM capabilities needed for some Compute Engine features.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmCapabilitiesInfo")]
		public VmCapabilities VmCapabilitiesInfo { get; set; }
	}
	
	/// <summary>
	/// The details of a Vmware VM disk.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VmwareDiskDetails
	{
		
		/// <summary>
		/// The ordinal number of the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskNumber")]
		public System.Nullable<System.Int32> DiskNumber { get; set; }
		
		/// <summary>
		/// The disk label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public string Label { get; set; }
		
		/// <summary>
		/// Size in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public string SizeGb { get; set; }
	}
	
	/// <summary>
	/// The response message for Operations.ListOperations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListOperationsResponse
	{
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A list of operations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public Operation[] Operations { get; set; }
	}
	
	/// <summary>
	/// This resource represents a long-running operation that is the result of a network API call.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Operation
	{
		
		/// <summary>
		/// If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="done")]
		public System.Nullable<System.Boolean> Done { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public System.Collections.Generic.Dictionary<string, object> Response { get; set; }
	}
	
	/// <summary>
	/// Response message for 'ListReplicationCycles' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListReplicationCyclesResponse
	{
		
		/// <summary>
		/// Output only. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Output only. The list of replication cycles response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicationCycles")]
		public ReplicationCycle[] ReplicationCycles { get; set; }
		
		/// <summary>
		/// Output only. Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Response message for 'ListSources' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListSourcesResponse
	{
		
		/// <summary>
		/// Output only. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Output only. The list of sources response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sources")]
		public Source[] Sources { get; set; }
		
		/// <summary>
		/// Output only. Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Source message describes a specific vm migration Source resource. It contains the source environment information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Source
	{
		
		/// <summary>
		/// AwsSourceDetails message describes a specific source details for the AWS source type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aws")]
		public AwsSourceDetails Aws { get; set; }
		
		/// <summary>
		/// AzureSourceDetails message describes a specific source details for the Azure source type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="azure")]
		public AzureSourceDetails Azure { get; set; }
		
		/// <summary>
		/// Output only. The create time timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// User-provided description of the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Encryption message describes the details of the applied encryption.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryption")]
		public Encryption Encryption { get; set; }
		
		/// <summary>
		/// The labels of the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. The Source name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The update time timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
		
		/// <summary>
		/// VmwareSourceDetails message describes a specific source details for the vmware source type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmware")]
		public VmwareSourceDetails Vmware { get; set; }
	}
	
	/// <summary>
	/// VmwareSourceDetails message describes a specific source details for the vmware source type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VmwareSourceDetails
	{
		
		/// <summary>
		/// Input only. The credentials password. This is write only and can not be read in a GET operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		/// <summary>
		/// The hostname of the vcenter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolvedVcenterHost")]
		public string ResolvedVcenterHost { get; set; }
		
		/// <summary>
		/// The thumbprint representing the certificate for the vcenter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thumbprint")]
		public string Thumbprint { get; set; }
		
		/// <summary>
		/// The credentials username.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
		
		/// <summary>
		/// The ip address of the vcenter this Source represents.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vcenterIp")]
		public string VcenterIp { get; set; }
	}
	
	/// <summary>
	/// Response message for 'ListTargetProjects' call.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListTargetProjectsResponse
	{
		
		/// <summary>
		/// Output only. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Output only. The list of target response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetProjects")]
		public TargetProject[] TargetProjects { get; set; }
		
		/// <summary>
		/// Output only. Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// TargetProject message represents a target Compute Engine project for a migration or a clone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TargetProject
	{
		
		/// <summary>
		/// Output only. The time this target project resource was created (not related to when the Compute Engine project it points to was created).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// The target project's description.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Output only. The name of the target project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required. The target project ID (number) or project name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="project")]
		public string Project { get; set; }
		
		/// <summary>
		/// Output only. The last time the target project resource was updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// Response message for 'ListUtilizationReports' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListUtilizationReportsResponse
	{
		
		/// <summary>
		/// Output only. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Output only. Locations that could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
		
		/// <summary>
		/// Output only. The list of reports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizationReports")]
		public UtilizationReport[] UtilizationReports { get; set; }
	}
	
	/// <summary>
	/// Utilization report details the utilization (CPU, memory, etc.) of selected source VMs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UtilizationReport
	{
		
		/// <summary>
		/// Output only. The time the report was created (this refers to the time of the request, not the time the report creation completed).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// The report display name, as assigned by the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Output only. The point in time when the time frame ends. Notice that the time frame is counted backwards. For instance if the "frame_end_time" value is 2021/01/20 and the time frame is WEEK then the report covers the week between 2021/01/20 and 2021/01/14.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="frameEndTime")]
		public string FrameEndTime { get; set; }
		
		/// <summary>
		/// Output only. The report unique name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Current state of the report.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<UtilizationReportState> State { get; set; }
		
		/// <summary>
		/// Output only. The time the state was last set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stateTime")]
		public string StateTime { get; set; }
		
		/// <summary>
		/// Time frame of the report.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeFrame")]
		public System.Nullable<UtilizationReportTimeFrame> TimeFrame { get; set; }
		
		/// <summary>
		/// Output only. Total number of VMs included in the report.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmCount")]
		public System.Nullable<System.Int32> VmCount { get; set; }
		
		/// <summary>
		/// List of utilization information per VM. When sent as part of the request, the "vm_id" field is used in order to specify which VMs to include in the report. In that case all other fields are ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vms")]
		public VmUtilizationInfo[] Vms { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UtilizationReportState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UtilizationReportTimeFrame
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIME_FRAME_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEEK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MONTH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		YEAR = 3,
	}
	
	/// <summary>
	/// Utilization information of a single VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VmUtilizationInfo
	{
		
		/// <summary>
		/// Utilization metrics values for a single VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilization")]
		public VmUtilizationMetrics Utilization { get; set; }
		
		/// <summary>
		/// The VM's ID in the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmId")]
		public string VmId { get; set; }
		
		/// <summary>
		/// VmwareVmDetails describes a VM in vCenter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmwareVmDetails")]
		public VmwareVmDetails VmwareVmDetails { get; set; }
	}
	
	/// <summary>
	/// Utilization metrics values for a single VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VmUtilizationMetrics
	{
		
		/// <summary>
		/// Average CPU usage, percent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuAveragePercent")]
		public System.Nullable<System.Int32> CpuAveragePercent { get; set; }
		
		/// <summary>
		/// Max CPU usage, percent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuMaxPercent")]
		public System.Nullable<System.Int32> CpuMaxPercent { get; set; }
		
		/// <summary>
		/// Average disk IO rate, in kilobytes per second.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskIoRateAverageKbps")]
		public string DiskIoRateAverageKbps { get; set; }
		
		/// <summary>
		/// Max disk IO rate, in kilobytes per second.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskIoRateMaxKbps")]
		public string DiskIoRateMaxKbps { get; set; }
		
		/// <summary>
		/// Average memory usage, percent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryAveragePercent")]
		public System.Nullable<System.Int32> MemoryAveragePercent { get; set; }
		
		/// <summary>
		/// Max memory usage, percent.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryMaxPercent")]
		public System.Nullable<System.Int32> MemoryMaxPercent { get; set; }
		
		/// <summary>
		/// Average network throughput (combined transmit-rates and receive-rates), in kilobytes per second.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkThroughputAverageKbps")]
		public string NetworkThroughputAverageKbps { get; set; }
		
		/// <summary>
		/// Max network throughput (combined transmit-rates and receive-rates), in kilobytes per second.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkThroughputMaxKbps")]
		public string NetworkThroughputMaxKbps { get; set; }
	}
	
	/// <summary>
	/// Represents migration resource error information that can be used with google.rpc.Status message. MigrationError is used to present the user with error information in migration operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MigrationError
	{
		
		/// <summary>
		/// Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionItem")]
		public LocalizedMessage ActionItem { get; set; }
		
		/// <summary>
		/// Output only. The error code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<MigrationErrorCode> Code { get; set; }
		
		/// <summary>
		/// Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorMessage")]
		public LocalizedMessage ErrorMessage { get; set; }
		
		/// <summary>
		/// Output only. The time the error occurred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorTime")]
		public string ErrorTime { get; set; }
		
		/// <summary>
		/// Output only. URL(s) pointing to additional information on handling the current error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="helpLinks")]
		public Link[] HelpLinks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MigrationErrorCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR_CODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN_ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOURCE_VALIDATION_ERROR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOURCE_REPLICATION_ERROR = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TARGET_REPLICATION_ERROR = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OS_ADAPTATION_ERROR = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLONE_ERROR = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUTOVER_ERROR = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UTILIZATION_REPORT_ERROR = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPLIANCE_UPGRADE_ERROR = 9,
	}
	
	/// <summary>
	/// Represents the metadata of the long-running operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationMetadata
	{
		
		/// <summary>
		/// Output only. API version used to start the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
		
		/// <summary>
		/// Output only. The time the operation was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The time the operation finished running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Output only. Identifies whether the user has requested cancellation of the operation. Operations that have successfully been cancelled have Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestedCancellation")]
		public System.Nullable<System.Boolean> RequestedCancellation { get; set; }
		
		/// <summary>
		/// Output only. Human-readable status of the operation, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// Output only. Server-defined resource path for the target of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// Output only. Name of the verb executed by the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verb")]
		public string Verb { get; set; }
	}
	
	/// <summary>
	/// Request message for 'PauseMigration' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PauseMigrationRequest
	{
	}
	
	/// <summary>
	/// Request message for 'RemoveMigration' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RemoveGroupMigrationRequest
	{
		
		/// <summary>
		/// The MigratingVm to remove.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="migratingVm")]
		public string MigratingVm { get; set; }
	}
	
	/// <summary>
	/// Request message for 'ResumeMigration' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResumeMigrationRequest
	{
	}
	
	/// <summary>
	/// Request message for 'StartMigrationRequest' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StartMigrationRequest
	{
	}
	
	/// <summary>
	/// Request message for 'UpgradeAppliance' request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpgradeApplianceRequest
	{
		
		/// <summary>
		/// A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestId")]
		public string RequestId { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Upgrades the appliance relate to this DatacenterConnector to the in-place updateable version.
		/// Vmmigration_projects_locations_sources_datacenterConnectors_upgradeAppliance v1/{datacenterConnector}:upgradeAppliance
		/// </summary>
		/// <param name="datacenterConnector">Required. The DatacenterConnector name.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_datacenterConnectors_upgradeApplianceAsync(string datacenterConnector, UpgradeApplianceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (datacenterConnector==null? "" : System.Uri.EscapeDataString(datacenterConnector))+":upgradeAppliance";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a MigratingVm to a Group.
		/// Vmmigration_projects_locations_groups_addGroupMigration v1/{group}:addGroupMigration
		/// </summary>
		/// <param name="group">Required. The full path name of the Group to add to.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_groups_addGroupMigrationAsync(string group, AddGroupMigrationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (group==null? "" : System.Uri.EscapeDataString(group))+":addGroupMigration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a MigratingVm from a Group.
		/// Vmmigration_projects_locations_groups_removeGroupMigration v1/{group}:removeGroupMigration
		/// </summary>
		/// <param name="group">Required. The name of the Group.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_groups_removeGroupMigrationAsync(string group, RemoveGroupMigrationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (group==null? "" : System.Uri.EscapeDataString(group))+":removeGroupMigration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Marks a migration as completed, deleting migration resources that are no longer being used. Only applicable after cutover is done.
		/// Vmmigration_projects_locations_sources_migratingVms_finalizeMigration v1/{migratingVm}:finalizeMigration
		/// </summary>
		/// <param name="migratingVm">Required. The name of the MigratingVm.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_migratingVms_finalizeMigrationAsync(string migratingVm, FinalizeMigrationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (migratingVm==null? "" : System.Uri.EscapeDataString(migratingVm))+":finalizeMigration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Pauses a migration for a VM. If cycle tasks are running they will be cancelled, preserving source task data. Further replication cycles will not be triggered while the VM is paused.
		/// Vmmigration_projects_locations_sources_migratingVms_pauseMigration v1/{migratingVm}:pauseMigration
		/// </summary>
		/// <param name="migratingVm">Required. The name of the MigratingVm.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_migratingVms_pauseMigrationAsync(string migratingVm, PauseMigrationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (migratingVm==null? "" : System.Uri.EscapeDataString(migratingVm))+":pauseMigration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resumes a migration for a VM. When called on a paused migration, will start the process of uploading data and creating snapshots; when called on a completed cut-over migration, will update the migration to active state and start the process of uploading data and creating snapshots.
		/// Vmmigration_projects_locations_sources_migratingVms_resumeMigration v1/{migratingVm}:resumeMigration
		/// </summary>
		/// <param name="migratingVm">Required. The name of the MigratingVm.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_migratingVms_resumeMigrationAsync(string migratingVm, ResumeMigrationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (migratingVm==null? "" : System.Uri.EscapeDataString(migratingVm))+":resumeMigration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts migration for a VM. Starts the process of uploading data and creating snapshots, in replication cycles scheduled by the policy.
		/// Vmmigration_projects_locations_sources_migratingVms_startMigration v1/{migratingVm}:startMigration
		/// </summary>
		/// <param name="migratingVm">Required. The name of the MigratingVm.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_migratingVms_startMigrationAsync(string migratingVm, StartMigrationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (migratingVm==null? "" : System.Uri.EscapeDataString(migratingVm))+":startMigration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a single TargetProject. NOTE: TargetProject is a global resource; hence the only supported value for location is `global`.
		/// Vmmigration_projects_locations_targetProjects_delete v1/{name}
		/// </summary>
		/// <param name="name">Required. The TargetProject name.</param>
		/// <param name="requestId">Optional. A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes after the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_targetProjects_deleteAsync(string name, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets details of a single TargetProject. NOTE: TargetProject is a global resource; hence the only supported value for location is `global`.
		/// Vmmigration_projects_locations_targetProjects_get v1/{name}
		/// </summary>
		/// <param name="name">Required. The TargetProject name.</param>
		/// <param name="view">Optional. The level of details of the report. Defaults to FULL</param>
		/// <returns>Successful response</returns>
		public async Task<TargetProject> Vmmigration_projects_locations_targetProjects_getAsync(string name, Vmmigration_projects_locations_targetProjects_getView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TargetProject>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the parameters of a single TargetProject. NOTE: TargetProject is a global resource; hence the only supported value for location is `global`.
		/// Vmmigration_projects_locations_targetProjects_patch v1/{name}
		/// </summary>
		/// <param name="name">Output only. The name of the target project.</param>
		/// <param name="requestId">A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">Field mask is used to specify the fields to be overwritten in the TargetProject resource by the update. The fields specified in the update_mask are relative to the resource, not the full request. A field will be overwritten if it is in the mask. If the user does not provide a mask then all fields will be overwritten.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_targetProjects_patchAsync(string name, string requestId, string updateMask, TargetProject requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists information about the supported locations for this service.
		/// Vmmigration_projects_locations_list v1/{name}/locations
		/// </summary>
		/// <param name="name">The resource that owns the locations collection, if applicable.</param>
		/// <param name="filter">A filter to narrow down results to a preferred subset. The filtering language accepts strings like `"displayName=tokyo"`, and is documented in more detail in [AIP-160](https://google.aip.dev/160).</param>
		/// <param name="pageSize">The maximum number of results to return. If not set, the service selects a default.</param>
		/// <param name="pageToken">A page token received from the `next_page_token` field in the response. Send that page token to receive the subsequent page.</param>
		/// <returns>Successful response</returns>
		public async Task<ListLocationsResponse> Vmmigration_projects_locations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/locations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListLocationsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
		/// Vmmigration_projects_locations_operations_list v1/{name}/operations
		/// </summary>
		/// <param name="name">The name of the operation's parent resource.</param>
		/// <param name="filter">The standard list filter.</param>
		/// <param name="pageSize">The standard list page size.</param>
		/// <param name="pageToken">The standard list page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListOperationsResponse> Vmmigration_projects_locations_operations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/operations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListOperationsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiates the cancellation of a running cutover job.
		/// Vmmigration_projects_locations_sources_migratingVms_cutoverJobs_cancel v1/{name}:cancel
		/// </summary>
		/// <param name="name">Required. The cutover job id</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_migratingVms_cutoverJobs_cancelAsync(string name, CancelCutoverJobRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the CloneJobs of a migrating VM. Only 25 most recent CloneJobs are listed.
		/// Vmmigration_projects_locations_sources_migratingVms_cloneJobs_list v1/{parent}/cloneJobs
		/// </summary>
		/// <param name="parent">Required. The parent, which owns this collection of source VMs.</param>
		/// <param name="filter">Optional. The filter request.</param>
		/// <param name="orderBy">Optional. the order by fields for the result.</param>
		/// <param name="pageSize">Optional. The maximum number of clone jobs to return. The service may return fewer than this value. If unspecified, at most 500 clone jobs will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Required. A page token, received from a previous `ListCloneJobs` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListCloneJobs` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListCloneJobsResponse> Vmmigration_projects_locations_sources_migratingVms_cloneJobs_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/cloneJobs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListCloneJobsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiates a Clone of a specific migrating VM.
		/// Vmmigration_projects_locations_sources_migratingVms_cloneJobs_create v1/{parent}/cloneJobs
		/// </summary>
		/// <param name="parent">Required. The Clone's parent.</param>
		/// <param name="cloneJobId">Required. The clone job identifier.</param>
		/// <param name="requestId">A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_migratingVms_cloneJobs_createAsync(string parent, string cloneJobId, string requestId, CloneJob requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/cloneJobs&cloneJobId=" + (cloneJobId==null? "" : System.Uri.EscapeDataString(cloneJobId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the CutoverJobs of a migrating VM. Only 25 most recent CutoverJobs are listed.
		/// Vmmigration_projects_locations_sources_migratingVms_cutoverJobs_list v1/{parent}/cutoverJobs
		/// </summary>
		/// <param name="parent">Required. The parent, which owns this collection of migrating VMs.</param>
		/// <param name="filter">Optional. The filter request.</param>
		/// <param name="orderBy">Optional. the order by fields for the result.</param>
		/// <param name="pageSize">Optional. The maximum number of cutover jobs to return. The service may return fewer than this value. If unspecified, at most 500 cutover jobs will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Required. A page token, received from a previous `ListCutoverJobs` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListCutoverJobs` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListCutoverJobsResponse> Vmmigration_projects_locations_sources_migratingVms_cutoverJobs_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/cutoverJobs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListCutoverJobsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Initiates a Cutover of a specific migrating VM. The returned LRO is completed when the cutover job resource is created and the job is initiated.
		/// Vmmigration_projects_locations_sources_migratingVms_cutoverJobs_create v1/{parent}/cutoverJobs
		/// </summary>
		/// <param name="parent">Required. The Cutover's parent.</param>
		/// <param name="cutoverJobId">Required. The cutover job identifier.</param>
		/// <param name="requestId">A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_migratingVms_cutoverJobs_createAsync(string parent, string cutoverJobId, string requestId, CutoverJob requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/cutoverJobs&cutoverJobId=" + (cutoverJobId==null? "" : System.Uri.EscapeDataString(cutoverJobId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists DatacenterConnectors in a given Source.
		/// Vmmigration_projects_locations_sources_datacenterConnectors_list v1/{parent}/datacenterConnectors
		/// </summary>
		/// <param name="parent">Required. The parent, which owns this collection of connectors.</param>
		/// <param name="filter">Optional. The filter request.</param>
		/// <param name="orderBy">Optional. the order by fields for the result.</param>
		/// <param name="pageSize">Optional. The maximum number of connectors to return. The service may return fewer than this value. If unspecified, at most 500 sources will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Required. A page token, received from a previous `ListDatacenterConnectors` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListDatacenterConnectors` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListDatacenterConnectorsResponse> Vmmigration_projects_locations_sources_datacenterConnectors_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/datacenterConnectors&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListDatacenterConnectorsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new DatacenterConnector in a given Source.
		/// Vmmigration_projects_locations_sources_datacenterConnectors_create v1/{parent}/datacenterConnectors
		/// </summary>
		/// <param name="parent">Required. The DatacenterConnector's parent. Required. The Source in where the new DatacenterConnector will be created. For example: `projects/my-project/locations/us-central1/sources/my-source`</param>
		/// <param name="datacenterConnectorId">Required. The datacenterConnector identifier.</param>
		/// <param name="requestId">A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_datacenterConnectors_createAsync(string parent, string datacenterConnectorId, string requestId, DatacenterConnector requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/datacenterConnectors&datacenterConnectorId=" + (datacenterConnectorId==null? "" : System.Uri.EscapeDataString(datacenterConnectorId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists Groups in a given project and location.
		/// Vmmigration_projects_locations_groups_list v1/{parent}/groups
		/// </summary>
		/// <param name="parent">Required. The parent, which owns this collection of groups.</param>
		/// <param name="filter">Optional. The filter request.</param>
		/// <param name="orderBy">Optional. the order by fields for the result.</param>
		/// <param name="pageSize">Optional. The maximum number of groups to return. The service may return fewer than this value. If unspecified, at most 500 groups will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Required. A page token, received from a previous `ListGroups` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListGroups` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListGroupsResponse> Vmmigration_projects_locations_groups_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/groups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListGroupsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new Group in a given project and location.
		/// Vmmigration_projects_locations_groups_create v1/{parent}/groups
		/// </summary>
		/// <param name="parent">Required. The Group's parent.</param>
		/// <param name="groupId">Required. The group identifier.</param>
		/// <param name="requestId">A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_groups_createAsync(string parent, string groupId, string requestId, Group requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/groups&groupId=" + (groupId==null? "" : System.Uri.EscapeDataString(groupId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists MigratingVms in a given Source.
		/// Vmmigration_projects_locations_sources_migratingVms_list v1/{parent}/migratingVms
		/// </summary>
		/// <param name="parent">Required. The parent, which owns this collection of MigratingVms.</param>
		/// <param name="filter">Optional. The filter request.</param>
		/// <param name="orderBy">Optional. the order by fields for the result.</param>
		/// <param name="pageSize">Optional. The maximum number of migrating VMs to return. The service may return fewer than this value. If unspecified, at most 500 migrating VMs will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Required. A page token, received from a previous `ListMigratingVms` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListMigratingVms` must match the call that provided the page token.</param>
		/// <param name="view">Optional. The level of details of each migrating VM.</param>
		/// <returns>Successful response</returns>
		public async Task<ListMigratingVmsResponse> Vmmigration_projects_locations_sources_migratingVms_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Vmmigration_projects_locations_sources_migratingVms_listView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/migratingVms&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListMigratingVmsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new MigratingVm in a given Source.
		/// Vmmigration_projects_locations_sources_migratingVms_create v1/{parent}/migratingVms
		/// </summary>
		/// <param name="parent">Required. The MigratingVm's parent.</param>
		/// <param name="migratingVmId">Required. The migratingVm identifier.</param>
		/// <param name="requestId">A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_migratingVms_createAsync(string parent, string migratingVmId, string requestId, MigratingVm requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/migratingVms&migratingVmId=" + (migratingVmId==null? "" : System.Uri.EscapeDataString(migratingVmId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists ReplicationCycles in a given MigratingVM.
		/// Vmmigration_projects_locations_sources_migratingVms_replicationCycles_list v1/{parent}/replicationCycles
		/// </summary>
		/// <param name="parent">Required. The parent, which owns this collection of ReplicationCycles.</param>
		/// <param name="filter">Optional. The filter request.</param>
		/// <param name="orderBy">Optional. the order by fields for the result.</param>
		/// <param name="pageSize">Optional. The maximum number of replication cycles to return. The service may return fewer than this value. If unspecified, at most 100 migrating VMs will be returned. The maximum value is 100; values above 100 will be coerced to 100.</param>
		/// <param name="pageToken">Required. A page token, received from a previous `ListReplicationCycles` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListReplicationCycles` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListReplicationCyclesResponse> Vmmigration_projects_locations_sources_migratingVms_replicationCycles_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/replicationCycles&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListReplicationCyclesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists Sources in a given project and location.
		/// Vmmigration_projects_locations_sources_list v1/{parent}/sources
		/// </summary>
		/// <param name="parent">Required. The parent, which owns this collection of sources.</param>
		/// <param name="filter">Optional. The filter request.</param>
		/// <param name="orderBy">Optional. the order by fields for the result.</param>
		/// <param name="pageSize">Optional. The maximum number of sources to return. The service may return fewer than this value. If unspecified, at most 500 sources will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Required. A page token, received from a previous `ListSources` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListSources` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListSourcesResponse> Vmmigration_projects_locations_sources_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/sources&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListSourcesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new Source in a given project and location.
		/// Vmmigration_projects_locations_sources_create v1/{parent}/sources
		/// </summary>
		/// <param name="parent">Required. The Source's parent.</param>
		/// <param name="requestId">A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <param name="sourceId">Required. The source identifier.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_createAsync(string parent, string requestId, string sourceId, Source requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/sources&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&sourceId=" + (sourceId==null? "" : System.Uri.EscapeDataString(sourceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists TargetProjects in a given project. NOTE: TargetProject is a global resource; hence the only supported value for location is `global`.
		/// Vmmigration_projects_locations_targetProjects_list v1/{parent}/targetProjects
		/// </summary>
		/// <param name="parent">Required. The parent, which owns this collection of targets.</param>
		/// <param name="filter">Optional. The filter request.</param>
		/// <param name="orderBy">Optional. the order by fields for the result.</param>
		/// <param name="pageSize">Optional. The maximum number of targets to return. The service may return fewer than this value. If unspecified, at most 500 targets will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Required. A page token, received from a previous `ListTargets` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListTargets` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListTargetProjectsResponse> Vmmigration_projects_locations_targetProjects_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/targetProjects&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListTargetProjectsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new TargetProject in a given project. NOTE: TargetProject is a global resource; hence the only supported value for location is `global`.
		/// Vmmigration_projects_locations_targetProjects_create v1/{parent}/targetProjects
		/// </summary>
		/// <param name="parent">Required. The TargetProject's parent.</param>
		/// <param name="requestId">A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <param name="targetProjectId">Required. The target_project identifier.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_targetProjects_createAsync(string parent, string requestId, string targetProjectId, TargetProject requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/targetProjects&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&targetProjectId=" + (targetProjectId==null? "" : System.Uri.EscapeDataString(targetProjectId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists Utilization Reports of the given Source.
		/// Vmmigration_projects_locations_sources_utilizationReports_list v1/{parent}/utilizationReports
		/// </summary>
		/// <param name="parent">Required. The Utilization Reports parent.</param>
		/// <param name="filter">Optional. The filter request.</param>
		/// <param name="orderBy">Optional. the order by fields for the result.</param>
		/// <param name="pageSize">Optional. The maximum number of reports to return. The service may return fewer than this value. If unspecified, at most 500 reports will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000.</param>
		/// <param name="pageToken">Required. A page token, received from a previous `ListUtilizationReports` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListUtilizationReports` must match the call that provided the page token.</param>
		/// <param name="view">Optional. The level of details of each report. Defaults to BASIC.</param>
		/// <returns>Successful response</returns>
		public async Task<ListUtilizationReportsResponse> Vmmigration_projects_locations_sources_utilizationReports_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Vmmigration_projects_locations_targetProjects_getView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/utilizationReports&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListUtilizationReportsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new UtilizationReport.
		/// Vmmigration_projects_locations_sources_utilizationReports_create v1/{parent}/utilizationReports
		/// </summary>
		/// <param name="parent">Required. The Utilization Report's parent.</param>
		/// <param name="requestId">A request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. The server will guarantee that for at least 60 minutes since the first request. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).</param>
		/// <param name="utilizationReportId">Required. The ID to use for the report, which will become the final component of the reports's resource name. This value maximum length is 63 characters, and valid characters are /a-z-/. It must start with an english letter and must not end with a hyphen.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vmmigration_projects_locations_sources_utilizationReports_createAsync(string parent, string requestId, string utilizationReportId, UtilizationReport requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/utilizationReports&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&utilizationReportId=" + (utilizationReportId==null? "" : System.Uri.EscapeDataString(utilizationReportId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List remote source's inventory of VMs. The remote source is the onprem vCenter (remote in the sense it's not in Compute Engine). The inventory describes the list of existing VMs in that source. Note that this operation lists the VMs on the remote source, as opposed to listing the MigratingVms resources in the vmmigration service.
		/// Vmmigration_projects_locations_sources_fetchInventory v1/{source}:fetchInventory
		/// </summary>
		/// <param name="source">Required. The name of the Source.</param>
		/// <param name="forceRefresh">If this flag is set to true, the source will be queried instead of using cached results. Using this flag will make the call slower.</param>
		/// <param name="pageSize">The maximum number of VMs to return. The service may return fewer than this value. For AWS source: If unspecified, at most 500 VMs will be returned. The maximum value is 1000; values above 1000 will be coerced to 1000. For VMWare source: If unspecified, all VMs will be returned. There is no limit for maximum value.</param>
		/// <param name="pageToken">A page token, received from a previous `FetchInventory` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `FetchInventory` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<FetchInventoryResponse> Vmmigration_projects_locations_sources_fetchInventoryAsync(string source, bool forceRefresh, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (source==null? "" : System.Uri.EscapeDataString(source))+":fetchInventory&forceRefresh="+forceRefresh+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<FetchInventoryResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Vmmigration_projects_locations_targetProjects_getView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UTILIZATION_REPORT_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL = 2,
	}
	
	public enum Vmmigration_projects_locations_sources_migratingVms_listView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIGRATING_VM_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIGRATING_VM_VIEW_BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIGRATING_VM_VIEW_FULL = 2,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
