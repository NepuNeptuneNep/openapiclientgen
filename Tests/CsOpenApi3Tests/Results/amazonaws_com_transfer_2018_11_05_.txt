//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateAccessResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExternalId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateAccessRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryType HomeDirectoryType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryMapEntry[] HomeDirectoryMappings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
		
		/// <summary>
		/// The full POSIX identity, including user ID (<code>Uid</code>), group ID (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PosixProfile PosixProfile { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Role { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExternalId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum HomeDirectoryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOGICAL = 1,
	}
	
	/// <summary>
	/// <p>Represents an object that contains entries and targets for <code>HomeDirectoryMappings</code>.</p> <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p> <p> <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code> </p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HomeDirectoryMapEntry
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Entry { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Target { get; set; }
	}
	
	/// <summary>
	/// The full POSIX identity, including user ID (<code>Uid</code>), group ID (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PosixProfile
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Uid { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Gid { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SecondaryGids { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceUnavailableException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InternalServiceError
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InvalidRequestException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResourceExistsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResourceNotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateAgreementResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AgreementId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateAgreementRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string LocalProfileId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string PartnerProfileId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string BaseDirectory { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AccessRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AgreementStatusType Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AgreementStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 1,
	}
	
	/// <summary>
	/// Creates a key-value pair for a specific resource. Tags are metadata that you can use to search for and group a resource for various purposes. You can apply tags to servers, users, and roles. A tag key can take more than one value. For example, to group servers for accounting purposes, you might create a tag called <code>Group</code> and assign the values <code>Research</code> and <code>Accounting</code> to that group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Tag
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ThrottlingException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateConnectorResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConnectorId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateConnectorRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public As2ConnectorConfig As2Config { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AccessRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LoggingRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SftpConnectorConfig SftpConfig { get; set; }
	}
	
	/// <summary>
	/// Contains the details for an AS2 connector object. The connector object is used for AS2 outbound processes, to connect the Transfer Family customer with the trading partner.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class As2ConnectorConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string LocalProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PartnerProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string MessageSubject { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CompressionEnum Compression { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionAlg EncryptionAlgorithm { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SigningAlg SigningAlgorithm { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MdnSigningAlg MdnSigningAlgorithm { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MdnResponse MdnResponse { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BasicAuthSecretId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CompressionEnum
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZLIB = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum EncryptionAlg
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AES128_CBC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AES192_CBC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AES256_CBC = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SigningAlg
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHA256 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHA384 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHA512 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHA1 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MdnSigningAlg
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHA256 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHA384 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHA512 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHA1 = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MdnResponse
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SYNC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 1,
	}
	
	/// <summary>
	/// Contains the details for an SFTP connector object. The connector object is used for transferring files to and from a partner's SFTP server.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SftpConnectorConfig
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string UserSecretId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] TrustedHostKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateProfileResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ProfileId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateProfileRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string As2Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ProfileType ProfileType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] CertificateIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ProfileType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTNER = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateServerResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateServerRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Certificate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Domain Domain { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EndpointDetails EndpointDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EndpointType EndpointType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostKey { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IdentityProviderDetails IdentityProviderDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IdentityProviderType IdentityProviderType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LoggingRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PostAuthenticationLoginBanner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PreAuthenticationLoginBanner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Protocol[] Protocols { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProtocolDetails ProtocolDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SecurityPolicyName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public WorkflowDetails WorkflowDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] StructuredLogDestinations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Domain
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		S3 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EFS = 1,
	}
	
	/// <summary>
	/// <p>The virtual private cloud (VPC) endpoint settings that are configured for your file transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server and resources only within your VPC. To control incoming internet traffic, invoke the <code>UpdateServer</code> API and attach an Elastic IP address to your server's endpoint.</p> <note> <p> After May 19, 2021, you won't be able to create a server using <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount if your account hasn't already done so before May 19, 2021. If you have already created servers with <code>EndpointType=VPC_ENDPOINT</code> in your Amazon Web Servicesaccount on or before May 19, 2021, you will not be affected. After this date, use <code>EndpointType</code>=<code>VPC</code>.</p> <p>For more information, see https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p> </note>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EndpointDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] AddressAllocationIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SubnetIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcEndpointId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SecurityGroupIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum EndpointType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC_ENDPOINT = 2,
	}
	
	/// <summary>
	/// Returns information related to the type of user authentication that is in use for a file transfer protocol-enabled server's users. A server can have only one method of authentication.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IdentityProviderDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string InvocationRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string DirectoryId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Function { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SftpAuthenticationMethods SftpAuthenticationMethods { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SftpAuthenticationMethods
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PASSWORD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC_KEY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC_KEY_OR_PASSWORD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC_KEY_AND_PASSWORD = 3,
	}
	
	/// <summary>
	/// <p>The mode of authentication for a server. The default value is <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within the Transfer Family service.</p> <p>Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to Active Directory groups in Directory Service for Microsoft Active Directory or Microsoft Active Directory in your on-premises environment or in Amazon Web Services using AD Connector. This option also requires you to provide a Directory ID by using the <code>IdentityProviderDetails</code> parameter.</p> <p>Use the <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The <code>API_GATEWAY</code> setting requires you to provide an Amazon API Gateway endpoint URL to call for authentication by using the <code>IdentityProviderDetails</code> parameter.</p> <p>Use the <code>AWS_LAMBDA</code> value to directly use an Lambda function as your identity provider. If you choose this value, you must specify the ARN for the Lambda function in the <code>Function</code> parameter for the <code>IdentityProviderDetails</code> data type.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum IdentityProviderType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVICE_MANAGED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		API_GATEWAY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_DIRECTORY_SERVICE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWS_LAMBDA = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Protocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SFTP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FTP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FTPS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AS2 = 3,
	}
	
	/// <summary>
	///  The protocol settings that are configured for your server. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ProtocolDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string PassiveIp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TlsSessionResumptionMode TlsSessionResumptionMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SetStatOption SetStatOption { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public As2Transport[] As2Transports { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TlsSessionResumptionMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENFORCED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SetStatOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLE_NO_OP = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum As2Transport
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 0,
	}
	
	/// <summary>
	/// Container for the <code>WorkflowDetail</code> data type. It is used by actions that trigger a workflow to begin execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkflowDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public WorkflowDetail[] OnUpload { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public WorkflowDetail[] OnPartialUpload { get; set; }
	}
	
	/// <summary>
	/// <p>Specifies the workflow ID for the workflow to assign and the execution role that's used for executing the workflow.</p> <p>In addition to a workflow to execute when a file is uploaded completely, <code>WorkflowDetails</code> can also contain a workflow ID (and execution role) for a workflow to execute on partial upload. A partial upload occurs when the server session disconnects while the file is still being uploaded.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkflowDetail
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExecutionRole { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AccessDeniedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateUserResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateUserRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryType HomeDirectoryType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryMapEntry[] HomeDirectoryMappings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PosixProfile PosixProfile { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Role { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SshPublicKeyBody { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateWorkflowResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateWorkflowRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public WorkflowStep[] Steps { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public WorkflowStep[] OnExceptionSteps { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	/// <summary>
	/// The basic building block of a workflow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkflowStep
	{
		
		[System.Runtime.Serialization.DataMember()]
		public WorkflowStepType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CopyStepDetails CopyStepDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CustomStepDetails CustomStepDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DeleteStepDetails DeleteStepDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public TagStepDetails TagStepDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DecryptStepDetails DecryptStepDetails { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum WorkflowStepType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COPY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TAG = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DECRYPT = 4,
	}
	
	/// <summary>
	/// Each step type has its own <code>StepDetails</code> structure.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CopyStepDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public InputFileLocation DestinationFileLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OverwriteExisting OverwriteExisting { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceFileLocation { get; set; }
	}
	
	/// <summary>
	/// Specifies the location for the file that's being processed.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InputFileLocation
	{
		
		[System.Runtime.Serialization.DataMember()]
		public S3InputFileLocation S3FileLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EfsFileLocation EfsFileLocation { get; set; }
	}
	
	/// <summary>
	/// <p>Specifies the customer input Amazon S3 file location. If it is used inside <code>copyStepDetails.DestinationFileLocation</code>, it should be the S3 copy destination.</p> <p> You need to provide the bucket and key. The key can represent either a path or a file. This is determined by whether or not you end the key value with the forward slash (/) character. If the final character is "/", then your file is copied to the folder, and its name does not change. If, rather, the final character is alphanumeric, your uploaded file is renamed to the path value. In this case, if a file with that name already exists, it is overwritten. </p> <p>For example, if your path is <code>shared-files/bob/</code>, your uploaded files are copied to the <code>shared-files/bob/</code>, folder. If your path is <code>shared-files/today</code>, each uploaded file is copied to the <code>shared-files</code> folder and named <code>today</code>: each upload overwrites the previous version of the <i>bob</i> file.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class S3InputFileLocation
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Bucket { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
	}
	
	/// <summary>
	/// <p>Specifies the details for the file location for the file that's being used in the workflow. Only applicable if you are using Amazon Elastic File Systems (Amazon EFS) for storage.</p> <p> </p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EfsFileLocation
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string FileSystemId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OverwriteExisting
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRUE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FALSE = 1,
	}
	
	/// <summary>
	/// Each step type has its own <code>StepDetails</code> structure.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CustomStepDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Target { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TimeoutSeconds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceFileLocation { get; set; }
	}
	
	/// <summary>
	/// The name of the step, used to identify the delete step.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteStepDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceFileLocation { get; set; }
	}
	
	/// <summary>
	/// <p>Each step type has its own <code>StepDetails</code> structure.</p> <p>The key/value pairs used to tag a file during the execution of a workflow step.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TagStepDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public S3Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceFileLocation { get; set; }
	}
	
	/// <summary>
	/// Specifies the key-value pair that are assigned to a file during the execution of a Tagging step.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class S3Tag
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Each step type has its own <code>StepDetails</code> structure.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DecryptStepDetails
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public EncryptionType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceFileLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OverwriteExisting OverwriteExisting { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public InputFileLocation DestinationFileLocation { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum EncryptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PGP = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteAccessRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExternalId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteAgreementRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AgreementId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteCertificateRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteConnectorRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConnectorId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteHostKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteProfileRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ProfileId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteServerRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteSshPublicKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SshPublicKeyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteUserRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteWorkflowRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeAccessResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedAccess Access { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of the access that was specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedAccess
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryMapEntry[] HomeDirectoryMappings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryType HomeDirectoryType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
		
		/// <summary>
		/// The full POSIX identity, including user ID (<code>Uid</code>), group ID (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PosixProfile PosixProfile { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Role { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ExternalId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeAccessRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExternalId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeAgreementResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedAgreement Agreement { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of an agreement.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedAgreement
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AgreementId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AgreementStatusType Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LocalProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PartnerProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AccessRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeAgreementRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AgreementId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeCertificateResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedCertificate Certificate { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedCertificate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CertificateUsageType Usage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CertificateStatusType Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Certificate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CertificateChain { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ActiveDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset InactiveDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Serial { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset NotBeforeDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset NotAfterDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CertificateType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateUsageType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SIGNING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENCRYPTION = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_ROTATION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CERTIFICATE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CERTIFICATE_WITH_PRIVATE_KEY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeCertificateRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeConnectorResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedConnector Connector { get; set; }
	}
	
	/// <summary>
	/// Describes the parameters for the connector, as identified by the <code>ConnectorId</code>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedConnector
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ConnectorId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public As2ConnectorConfig As2Config { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AccessRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LoggingRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SftpConnectorConfig SftpConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeConnectorRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConnectorId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeExecutionResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedExecution Execution { get; set; }
	}
	
	/// <summary>
	/// The details for an execution object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedExecution
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ExecutionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FileLocation InitialFileLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ServiceMetadata ServiceMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ExecutionRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingConfiguration LoggingConfiguration { get; set; }
		
		/// <summary>
		/// The full POSIX identity, including user ID (<code>Uid</code>), group ID (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PosixProfile PosixProfile { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExecutionStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExecutionResults Results { get; set; }
	}
	
	/// <summary>
	/// Specifies the Amazon S3 or EFS file details to be used in the step.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FileLocation
	{
		
		[System.Runtime.Serialization.DataMember()]
		public S3FileLocation S3FileLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EfsFileLocation EfsFileLocation { get; set; }
	}
	
	/// <summary>
	/// Specifies the details for the file location for the file that's being used in the workflow. Only applicable if you are using S3 storage.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class S3FileLocation
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Bucket { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Key { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VersionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Etag { get; set; }
	}
	
	/// <summary>
	/// A container object for the session details that are associated with a workflow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceMetadata
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public UserDetails UserDetails { get; set; }
	}
	
	/// <summary>
	/// Specifies the user name, server ID, and session ID for a workflow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UserDetails
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SessionId { get; set; }
	}
	
	/// <summary>
	/// Consists of the logging role and the log group name.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LoggingConfiguration
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string LoggingRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LogGroupName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ExecutionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_PROGRESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXCEPTION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HANDLING_EXCEPTION = 3,
	}
	
	/// <summary>
	/// Specifies the steps in the workflow, as well as the steps to execute in case of any errors during workflow execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExecutionResults
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ExecutionStepResult[] Steps { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExecutionStepResult[] OnExceptionSteps { get; set; }
	}
	
	/// <summary>
	/// Specifies the following details for the step: error (if any), outputs (if any), and the step type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExecutionStepResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public WorkflowStepType StepType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Outputs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExecutionError Error { get; set; }
	}
	
	/// <summary>
	/// Specifies the error message and type, for an error that occurs during the execution of the workflow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExecutionError
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ExecutionErrorType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ExecutionErrorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PERMISSION_DENIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_STEP_FAILED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THROTTLED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALREADY_EXISTS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_FOUND = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BAD_REQUEST = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIMEOUT = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL_SERVER_ERROR = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeExecutionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExecutionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeHostKeyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedHostKey HostKey { get; set; }
	}
	
	/// <summary>
	/// The details for a server host key.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedHostKey
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyFingerprint { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset DateImported { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeHostKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeProfileResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedProfile Profile { get; set; }
	}
	
	/// <summary>
	/// The details for a local or partner AS2 profile. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedProfile
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProfileType ProfileType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string As2Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] CertificateIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeProfileRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ProfileId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeSecurityPolicyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedSecurityPolicy SecurityPolicy { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a security policy that was specified. For more information about security policies, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html">Working with security policies</a>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedSecurityPolicy
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Fips { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SecurityPolicyName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SshCiphers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SshKexs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SshMacs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] TlsCiphers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeSecurityPolicyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SecurityPolicyName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeServerResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedServer Server { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a file transfer protocol-enabled server that was specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedServer
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Certificate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProtocolDetails ProtocolDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Domain Domain { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EndpointDetails EndpointDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EndpointType EndpointType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyFingerprint { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IdentityProviderDetails IdentityProviderDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IdentityProviderType IdentityProviderType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LoggingRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PostAuthenticationLoginBanner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PreAuthenticationLoginBanner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Protocol[] Protocols { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SecurityPolicyName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public State State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> UserCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public WorkflowDetails WorkflowDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] StructuredLogDestinations { get; set; }
	}
	
	/// <summary>
	/// <p>Describes the condition of a file transfer protocol-enabled server with respect to its ability to perform file operations. There are six possible states: <code>OFFLINE</code>, <code>ONLINE</code>, <code>STARTING</code>, <code>STOPPING</code>, <code>START_FAILED</code>, and <code>STOP_FAILED</code>.</p> <p> <code>OFFLINE</code> indicates that the server exists, but that it is not available for file operations. <code>ONLINE</code> indicates that the server is available to perform file operations. <code>STARTING</code> indicates that the server's was instantiated, but the server is not yet available to perform file operations. Under normal conditions, it can take a couple of minutes for the server to be completely operational. Both <code>START_FAILED</code> and <code>STOP_FAILED</code> are error conditions.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum State
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFFLINE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONLINE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		START_FAILED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOP_FAILED = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeServerRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeUserResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedUser User { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a user that was specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedUser
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryMapEntry[] HomeDirectoryMappings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryType HomeDirectoryType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PosixProfile PosixProfile { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Role { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SshPublicKey[] SshPublicKeys { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	/// <summary>
	/// Provides information about the public Secure Shell (SSH) key that is associated with a Transfer Family user for the specific file transfer protocol-enabled server (as identified by <code>ServerId</code>). The information returned includes the date the key was imported, the public key contents, and the public key ID. A user can store more than one SSH public key associated with their user name on a specific server.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SshPublicKey
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset DateImported { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SshPublicKeyBody { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SshPublicKeyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeUserRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeWorkflowResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public DescribedWorkflow Workflow { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of the specified workflow
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribedWorkflow
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public WorkflowStep[] Steps { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public WorkflowStep[] OnExceptionSteps { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeWorkflowRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportCertificateResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportCertificateRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CertificateUsageType Usage { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Certificate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CertificateChain { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PrivateKey { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ActiveDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset InactiveDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportHostKeyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportHostKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyBody { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	/// <summary>
	/// Identifies the user, the server they belong to, and the identifier of the SSH public key associated with that user. A user can have more than one key on each server that they are associated with.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportSshPublicKeyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SshPublicKeyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportSshPublicKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string SshPublicKeyBody { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListAccessesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedAccess[] Accesses { get; set; }
	}
	
	/// <summary>
	/// Lists the properties for one or more specified associated accesses.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListedAccess
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryType HomeDirectoryType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Role { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ExternalId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListAccessesRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InvalidNextTokenException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListAgreementsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedAgreement[] Agreements { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of an agreement.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListedAgreement
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AgreementId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AgreementStatusType Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LocalProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PartnerProfileId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListAgreementsRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListCertificatesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedCertificate[] Certificates { get; set; }
	}
	
	/// <summary>
	/// Describes the properties of a certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListedCertificate
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CertificateUsageType Usage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CertificateStatusType Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ActiveDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset InactiveDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CertificateType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListCertificatesRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListConnectorsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedConnector[] Connectors { get; set; }
	}
	
	/// <summary>
	/// Returns details of the connector that is specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListedConnector
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ConnectorId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListConnectorsRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListExecutionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedExecution[] Executions { get; set; }
	}
	
	/// <summary>
	/// Returns properties of the execution that is specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListedExecution
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ExecutionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FileLocation InitialFileLocation { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ServiceMetadata ServiceMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ExecutionStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListExecutionsRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListHostKeysResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedHostKey[] HostKeys { get; set; }
	}
	
	/// <summary>
	/// Returns properties of the host key that's specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListedHostKey
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Fingerprint { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset DateImported { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListHostKeysRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListProfilesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedProfile[] Profiles { get; set; }
	}
	
	/// <summary>
	/// Returns the properties of the profile that was specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListedProfile
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string As2Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProfileType ProfileType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListProfilesRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProfileType ProfileType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListSecurityPoliciesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] SecurityPolicyNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListSecurityPoliciesRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListServersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedServer[] Servers { get; set; }
	}
	
	/// <summary>
	/// Returns properties of a file transfer protocol-enabled server that was specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListedServer
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Domain Domain { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IdentityProviderType IdentityProviderType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EndpointType EndpointType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LoggingRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public State State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> UserCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListServersRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListTagsForResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListUsersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedUser[] Users { get; set; }
	}
	
	/// <summary>
	/// Returns properties of the user that you specify.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListedUser
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryType HomeDirectoryType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Role { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> SshPublicKeyCount { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListUsersRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListWorkflowsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ListedWorkflow[] Workflows { get; set; }
	}
	
	/// <summary>
	/// Contains the identifier, text description, and Amazon Resource Name (ARN) for the workflow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListedWorkflow
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListWorkflowsRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> MaxResults { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SendWorkflowStepStateResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SendWorkflowStepStateRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string WorkflowId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExecutionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Token { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CustomStepStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CustomStepStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILURE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StartFileTransferResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TransferId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StartFileTransferRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConnectorId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SendFilePaths { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] RetrieveFilePaths { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LocalDirectoryPath { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RemoteDirectoryPath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StartServerRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StopServerRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Tag[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestConnectionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ConnectorId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StatusMessage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestConnectionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConnectorId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestIdentityProviderResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Response { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int StatusCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestIdentityProviderRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Protocol ServerProtocol { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceIp { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string UserPassword { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UntagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] TagKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateAccessResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExternalId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateAccessRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryType HomeDirectoryType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryMapEntry[] HomeDirectoryMappings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
		
		/// <summary>
		/// The full POSIX identity, including user ID (<code>Uid</code>), group ID (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls your users' access to your Amazon EFS file systems. The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public PosixProfile PosixProfile { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Role { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ExternalId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateAgreementResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AgreementId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateAgreementRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string AgreementId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AgreementStatusType Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LocalProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PartnerProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BaseDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AccessRole { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateCertificateResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateCertificateRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CertificateId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ActiveDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset InactiveDate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateConnectorResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConnectorId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateConnectorRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ConnectorId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Url { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public As2ConnectorConfig As2Config { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string AccessRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LoggingRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SftpConnectorConfig SftpConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateHostKeyResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateHostKeyRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string HostKeyId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateProfileResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ProfileId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateProfileRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ProfileId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] CertificateIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateServerResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateServerRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Certificate { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProtocolDetails ProtocolDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EndpointDetails EndpointDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EndpointType EndpointType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string HostKey { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public IdentityProviderDetails IdentityProviderDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LoggingRole { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PostAuthenticationLoginBanner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PreAuthenticationLoginBanner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Protocol[] Protocols { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SecurityPolicyName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public WorkflowDetails WorkflowDetails { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] StructuredLogDestinations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConflictException
	{
	}
	
	/// <summary>
	///  <code>UpdateUserResponse</code> returns the user name and identifier for the request to update a user's properties.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateUserResponse
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateUserRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string HomeDirectory { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryType HomeDirectoryType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public HomeDirectoryMapEntry[] HomeDirectoryMappings { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PosixProfile PosixProfile { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Role { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string UserName { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Used by administrators to choose which groups in the directory should have access to upload and download files over the enabled protocols using Transfer Family. For example, a Microsoft Active Directory might contain 50,000 users, but only a small fraction might need the ability to transfer files to the server. An administrator can use <code>CreateAccess</code> to limit the access to the correct set of users who need this ability.
		/// CreateAccess #X-Amz-Target=TransferService.CreateAccess
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateAccessResponse> CreateAccessAsync(CreateAccessRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.CreateAccess";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateAccessResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates an agreement. An agreement is a bilateral trading partner agreement, or partnership, between an Transfer Family server and an AS2 process. The agreement defines the file and message transfer relationship between the server and the AS2 process. To define an agreement, Transfer Family combines a server, local profile, partner profile, certificate, and other attributes.</p> <p>The partner is identified with the <code>PartnerProfileId</code>, and the AS2 process is identified with the <code>LocalProfileId</code>.</p>
		/// CreateAgreement #X-Amz-Target=TransferService.CreateAgreement
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateAgreementResponse> CreateAgreementAsync(CreateAgreementRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.CreateAgreement";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateAgreementResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates the connector, which captures the parameters for an outbound connection for the AS2 or SFTP protocol. The connector is required for sending files to an externally hosted AS2 or SFTP server. For more details about AS2 connectors, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/create-b2b-server.html#configure-as2-connector">Create AS2 connectors</a>.</p> <note> <p>You must specify exactly one configuration object: either for AS2 (<code>As2Config</code>) or SFTP (<code>SftpConfig</code>).</p> </note>
		/// CreateConnector #X-Amz-Target=TransferService.CreateConnector
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateConnectorResponse> CreateConnectorAsync(CreateConnectorRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.CreateConnector";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateConnectorResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates the local or partner profile to use for AS2 transfers.
		/// CreateProfile #X-Amz-Target=TransferService.CreateProfile
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateProfileResponse> CreateProfileAsync(CreateProfileRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.CreateProfile";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateProfileResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Instantiates an auto-scaling virtual server based on the selected file transfer protocol in Amazon Web Services. When you make updates to your file transfer protocol-enabled server or when you work with users, use the service-generated <code>ServerId</code> property that is assigned to the newly created server.
		/// CreateServer #X-Amz-Target=TransferService.CreateServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateServerResponse> CreateServerAsync(CreateServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.CreateServer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateServerResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a user and associates them with an existing file transfer protocol-enabled server. You can only create and associate users with servers that have the <code>IdentityProviderType</code> set to <code>SERVICE_MANAGED</code>. Using parameters for <code>CreateUser</code>, you can specify the user name, set the home directory, store the user's public key, and assign the user's Identity and Access Management (IAM) role. You can also optionally add a session policy, and assign metadata with tags that can be used to group and search for users.
		/// CreateUser #X-Amz-Target=TransferService.CreateUser
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateUserResponse> CreateUserAsync(CreateUserRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.CreateUser";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateUserResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Allows you to create a workflow with specified steps and step details the workflow invokes after file transfer completes. After creating a workflow, you can associate the workflow created with any transfer servers by specifying the <code>workflow-details</code> field in <code>CreateServer</code> and <code>UpdateServer</code> operations.
		/// CreateWorkflow #X-Amz-Target=TransferService.CreateWorkflow
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateWorkflowResponse> CreateWorkflowAsync(CreateWorkflowRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.CreateWorkflow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateWorkflowResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Allows you to delete the access specified in the <code>ServerID</code> and <code>ExternalID</code> parameters.
		/// DeleteAccess #X-Amz-Target=TransferService.DeleteAccess
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteAccessAsync(DeleteAccessRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DeleteAccess";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete the agreement that's specified in the provided <code>AgreementId</code>.
		/// DeleteAgreement #X-Amz-Target=TransferService.DeleteAgreement
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteAgreementAsync(DeleteAgreementRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DeleteAgreement";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the certificate that's specified in the <code>CertificateId</code> parameter.
		/// DeleteCertificate #X-Amz-Target=TransferService.DeleteCertificate
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteCertificateAsync(DeleteCertificateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DeleteCertificate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the connector that's specified in the provided <code>ConnectorId</code>.
		/// DeleteConnector #X-Amz-Target=TransferService.DeleteConnector
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteConnectorAsync(DeleteConnectorRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DeleteConnector";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the host key that's specified in the <code>HostKeyId</code> parameter.
		/// DeleteHostKey #X-Amz-Target=TransferService.DeleteHostKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteHostKeyAsync(DeleteHostKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DeleteHostKey";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the profile that's specified in the <code>ProfileId</code> parameter.
		/// DeleteProfile #X-Amz-Target=TransferService.DeleteProfile
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteProfileAsync(DeleteProfileRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DeleteProfile";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes the file transfer protocol-enabled server that you specify.</p> <p>No response returns from this operation.</p>
		/// DeleteServer #X-Amz-Target=TransferService.DeleteServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteServerAsync(DeleteServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DeleteServer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a user's Secure Shell (SSH) public key.
		/// DeleteSshPublicKey #X-Amz-Target=TransferService.DeleteSshPublicKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteSshPublicKeyAsync(DeleteSshPublicKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DeleteSshPublicKey";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes the user belonging to a file transfer protocol-enabled server you specify.</p> <p>No response returns from this operation.</p> <note> <p>When you delete a user from a server, the user's information is lost.</p> </note>
		/// DeleteUser #X-Amz-Target=TransferService.DeleteUser
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteUserAsync(DeleteUserRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DeleteUser";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified workflow.
		/// DeleteWorkflow #X-Amz-Target=TransferService.DeleteWorkflow
		/// </summary>
		/// <returns>Success</returns>
		public async Task DeleteWorkflowAsync(DeleteWorkflowRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DeleteWorkflow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Describes the access that is assigned to the specific file transfer protocol-enabled server, as identified by its <code>ServerId</code> property and its <code>ExternalId</code>.</p> <p>The response from this call returns the properties of the access that is associated with the <code>ServerId</code> value that was specified.</p>
		/// DescribeAccess #X-Amz-Target=TransferService.DescribeAccess
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeAccessResponse> DescribeAccessAsync(DescribeAccessRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeAccess";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeAccessResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes the agreement that's identified by the <code>AgreementId</code>.
		/// DescribeAgreement #X-Amz-Target=TransferService.DescribeAgreement
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeAgreementResponse> DescribeAgreementAsync(DescribeAgreementRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeAgreement";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeAgreementResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes the certificate that's identified by the <code>CertificateId</code>.
		/// DescribeCertificate #X-Amz-Target=TransferService.DescribeCertificate
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeCertificateResponse> DescribeCertificateAsync(DescribeCertificateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeCertificate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeCertificateResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes the connector that's identified by the <code>ConnectorId.</code>
		/// DescribeConnector #X-Amz-Target=TransferService.DescribeConnector
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeConnectorResponse> DescribeConnectorAsync(DescribeConnectorRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeConnector";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeConnectorResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>You can use <code>DescribeExecution</code> to check the details of the execution of the specified workflow.</p> <note> <p>This API call only returns details for in-progress workflows.</p> <p> If you provide an ID for an execution that is not in progress, or if the execution doesn't match the specified workflow ID, you receive a <code>ResourceNotFound</code> exception.</p> </note>
		/// DescribeExecution #X-Amz-Target=TransferService.DescribeExecution
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeExecutionResponse> DescribeExecutionAsync(DescribeExecutionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeExecution";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeExecutionResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the details of the host key that's specified by the <code>HostKeyId</code> and <code>ServerId</code>.
		/// DescribeHostKey #X-Amz-Target=TransferService.DescribeHostKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeHostKeyResponse> DescribeHostKeyAsync(DescribeHostKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeHostKey";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeHostKeyResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the details of the profile that's specified by the <code>ProfileId</code>.
		/// DescribeProfile #X-Amz-Target=TransferService.DescribeProfile
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeProfileResponse> DescribeProfileAsync(DescribeProfileRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeProfile";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeProfileResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes the security policy that is attached to your file transfer protocol-enabled server. The response contains a description of the security policy's properties. For more information about security policies, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html">Working with security policies</a>.
		/// DescribeSecurityPolicy #X-Amz-Target=TransferService.DescribeSecurityPolicy
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeSecurityPolicyResponse> DescribeSecurityPolicyAsync(DescribeSecurityPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeSecurityPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeSecurityPolicyResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Describes a file transfer protocol-enabled server that you specify by passing the <code>ServerId</code> parameter.</p> <p>The response contains a description of a server's properties. When you set <code>EndpointType</code> to VPC, the response will contain the <code>EndpointDetails</code>.</p>
		/// DescribeServer #X-Amz-Target=TransferService.DescribeServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeServerResponse> DescribeServerAsync(DescribeServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeServer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeServerResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Describes the user assigned to the specific file transfer protocol-enabled server, as identified by its <code>ServerId</code> property.</p> <p>The response from this call returns the properties of the user associated with the <code>ServerId</code> value that was specified.</p>
		/// DescribeUser #X-Amz-Target=TransferService.DescribeUser
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeUserResponse> DescribeUserAsync(DescribeUserRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeUser";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeUserResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes the specified workflow.
		/// DescribeWorkflow #X-Amz-Target=TransferService.DescribeWorkflow
		/// </summary>
		/// <returns>Success</returns>
		public async Task<DescribeWorkflowResponse> DescribeWorkflowAsync(DescribeWorkflowRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.DescribeWorkflow";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeWorkflowResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Imports the signing and encryption certificates that you need to create local (AS2) profiles and partner profiles.
		/// ImportCertificate #X-Amz-Target=TransferService.ImportCertificate
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ImportCertificateResponse> ImportCertificateAsync(ImportCertificateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ImportCertificate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImportCertificateResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a host key to the server that's specified by the <code>ServerId</code> parameter.
		/// ImportHostKey #X-Amz-Target=TransferService.ImportHostKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ImportHostKeyResponse> ImportHostKeyAsync(ImportHostKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ImportHostKey";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImportHostKeyResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Adds a Secure Shell (SSH) public key to a Transfer Family user identified by a <code>UserName</code> value assigned to the specific file transfer protocol-enabled server, identified by <code>ServerId</code>.</p> <p>The response returns the <code>UserName</code> value, the <code>ServerId</code> value, and the name of the <code>SshPublicKeyId</code>.</p>
		/// ImportSshPublicKey #X-Amz-Target=TransferService.ImportSshPublicKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ImportSshPublicKeyResponse> ImportSshPublicKeyAsync(ImportSshPublicKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ImportSshPublicKey";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImportSshPublicKeyResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the details for all the accesses you have on your server.
		/// ListAccesses #X-Amz-Target=TransferService.ListAccesses
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListAccessesResponse> ListAccessesAsync(string MaxResults, string NextToken, ListAccessesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListAccesses?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListAccessesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of the agreements for the server that's identified by the <code>ServerId</code> that you supply. If you want to limit the results to a certain number, supply a value for the <code>MaxResults</code> parameter. If you ran the command previously and received a value for <code>NextToken</code>, you can supply that value to continue listing agreements from where you left off.
		/// ListAgreements #X-Amz-Target=TransferService.ListAgreements
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListAgreementsResponse> ListAgreementsAsync(string MaxResults, string NextToken, ListAgreementsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListAgreements?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListAgreementsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of the current certificates that have been imported into Transfer Family. If you want to limit the results to a certain number, supply a value for the <code>MaxResults</code> parameter. If you ran the command previously and received a value for the <code>NextToken</code> parameter, you can supply that value to continue listing certificates from where you left off.
		/// ListCertificates #X-Amz-Target=TransferService.ListCertificates
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListCertificatesResponse> ListCertificatesAsync(string MaxResults, string NextToken, ListCertificatesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListCertificates?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListCertificatesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the connectors for the specified Region.
		/// ListConnectors #X-Amz-Target=TransferService.ListConnectors
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListConnectorsResponse> ListConnectorsAsync(string MaxResults, string NextToken, ListConnectorsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListConnectors?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListConnectorsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Lists all in-progress executions for the specified workflow.</p> <note> <p>If the specified workflow ID cannot be found, <code>ListExecutions</code> returns a <code>ResourceNotFound</code> exception.</p> </note>
		/// ListExecutions #X-Amz-Target=TransferService.ListExecutions
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListExecutionsResponse> ListExecutionsAsync(string MaxResults, string NextToken, ListExecutionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListExecutions?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListExecutionsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of host keys for the server that's specified by the <code>ServerId</code> parameter.
		/// ListHostKeys #X-Amz-Target=TransferService.ListHostKeys
		/// </summary>
		/// <returns>Success</returns>
		public async Task<ListHostKeysResponse> ListHostKeysAsync(ListHostKeysRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListHostKeys";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListHostKeysResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a list of the profiles for your system. If you want to limit the results to a certain number, supply a value for the <code>MaxResults</code> parameter. If you ran the command previously and received a value for <code>NextToken</code>, you can supply that value to continue listing profiles from where you left off.
		/// ListProfiles #X-Amz-Target=TransferService.ListProfiles
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListProfilesResponse> ListProfilesAsync(string MaxResults, string NextToken, ListProfilesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListProfiles?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListProfilesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the security policies that are attached to your file transfer protocol-enabled servers.
		/// ListSecurityPolicies #X-Amz-Target=TransferService.ListSecurityPolicies
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListSecurityPoliciesResponse> ListSecurityPoliciesAsync(string MaxResults, string NextToken, ListSecurityPoliciesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListSecurityPolicies?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListSecurityPoliciesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the file transfer protocol-enabled servers that are associated with your Amazon Web Services account.
		/// ListServers #X-Amz-Target=TransferService.ListServers
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListServersResponse> ListServersAsync(string MaxResults, string NextToken, ListServersRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListServers?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListServersResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all of the tags associated with the Amazon Resource Name (ARN) that you specify. The resource can be a user, server, or role.
		/// ListTagsForResource #X-Amz-Target=TransferService.ListTagsForResource
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string MaxResults, string NextToken, ListTagsForResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListTagsForResource?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListTagsForResourceResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the users for a file transfer protocol-enabled server that you specify by passing the <code>ServerId</code> parameter.
		/// ListUsers #X-Amz-Target=TransferService.ListUsers
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListUsersResponse> ListUsersAsync(string MaxResults, string NextToken, ListUsersRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListUsers?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListUsersResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all workflows associated with your Amazon Web Services account for your current region.
		/// ListWorkflows #X-Amz-Target=TransferService.ListWorkflows
		/// </summary>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListWorkflowsResponse> ListWorkflowsAsync(string MaxResults, string NextToken, ListWorkflowsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.ListWorkflows?MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListWorkflowsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Sends a callback for asynchronous custom steps.</p> <p> The <code>ExecutionId</code>, <code>WorkflowId</code>, and <code>Token</code> are passed to the target resource during execution of a custom step of a workflow. You must include those with their callback as well as providing a status. </p>
		/// SendWorkflowStepState #X-Amz-Target=TransferService.SendWorkflowStepState
		/// </summary>
		/// <returns>Success</returns>
		public async Task<SendWorkflowStepStateResponse> SendWorkflowStepStateAsync(SendWorkflowStepStateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.SendWorkflowStepState";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SendWorkflowStepStateResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Begins a file transfer between local Amazon Web Services storage and a remote AS2 or SFTP server.</p> <ul> <li> <p>For an AS2 connector, you specify the <code>ConnectorId</code> and one or more <code>SendFilePaths</code> to identify the files you want to transfer.</p> </li> <li> <p>For an SFTP connector, the file transfer can be either outbound or inbound. In both cases, you specify the <code>ConnectorId</code>. Depending on the direction of the transfer, you also specify the following items:</p> <ul> <li> <p>If you are transferring file from a partner's SFTP server to a Transfer Family server, you specify one or more <code>RetreiveFilePaths</code> to identify the files you want to transfer, and a <code>LocalDirectoryPath</code> to specify the destination folder.</p> </li> <li> <p>If you are transferring file to a partner's SFTP server from Amazon Web Services storage, you specify one or more <code>SendFilePaths</code> to identify the files you want to transfer, and a <code>RemoteDirectoryPath</code> to specify the destination folder.</p> </li> </ul> </li> </ul>
		/// StartFileTransfer #X-Amz-Target=TransferService.StartFileTransfer
		/// </summary>
		/// <returns>Success</returns>
		public async Task<StartFileTransferResponse> StartFileTransferAsync(StartFileTransferRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.StartFileTransfer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<StartFileTransferResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Changes the state of a file transfer protocol-enabled server from <code>OFFLINE</code> to <code>ONLINE</code>. It has no impact on a server that is already <code>ONLINE</code>. An <code>ONLINE</code> server can accept and process file transfer jobs.</p> <p>The state of <code>STARTING</code> indicates that the server is in an intermediate state, either not fully able to respond, or not fully online. The values of <code>START_FAILED</code> can indicate an error condition.</p> <p>No response is returned from this call.</p>
		/// StartServer #X-Amz-Target=TransferService.StartServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task StartServerAsync(StartServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.StartServer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Changes the state of a file transfer protocol-enabled server from <code>ONLINE</code> to <code>OFFLINE</code>. An <code>OFFLINE</code> server cannot accept and process file transfer jobs. Information tied to your server, such as server and user properties, are not affected by stopping your server.</p> <note> <p>Stopping the server does not reduce or impact your file transfer protocol endpoint billing; you must delete the server to stop being billed.</p> </note> <p>The state of <code>STOPPING</code> indicates that the server is in an intermediate state, either not fully able to respond, or not fully offline. The values of <code>STOP_FAILED</code> can indicate an error condition.</p> <p>No response is returned from this call.</p>
		/// StopServer #X-Amz-Target=TransferService.StopServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task StopServerAsync(StopServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.StopServer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Attaches a key-value pair to a resource, as identified by its Amazon Resource Name (ARN). Resources are users, servers, roles, and other entities.</p> <p>There is no response returned from this call.</p>
		/// TagResource #X-Amz-Target=TransferService.TagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task TagResourceAsync(TagResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.TagResource";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Tests whether your SFTP connector is set up successfully. We highly recommend that you call this operation to test your ability to transfer files between a Transfer Family server and a trading partner's SFTP server.
		/// TestConnection #X-Amz-Target=TransferService.TestConnection
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TestConnectionResponse> TestConnectionAsync(TestConnectionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.TestConnection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TestConnectionResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>If the <code>IdentityProviderType</code> of a file transfer protocol-enabled server is <code>AWS_DIRECTORY_SERVICE</code> or <code>API_Gateway</code>, tests whether your identity provider is set up successfully. We highly recommend that you call this operation to test your authentication method as soon as you create your server. By doing so, you can troubleshoot issues with the identity provider integration to ensure that your users can successfully use the service.</p> <p> The <code>ServerId</code> and <code>UserName</code> parameters are required. The <code>ServerProtocol</code>, <code>SourceIp</code>, and <code>UserPassword</code> are all optional. </p> <p>Note the following:</p> <ul> <li> <p> You cannot use <code>TestIdentityProvider</code> if the <code>IdentityProviderType</code> of your server is <code>SERVICE_MANAGED</code>.</p> </li> <li> <p> <code>TestIdentityProvider</code> does not work with keys: it only accepts passwords.</p> </li> <li> <p> <code>TestIdentityProvider</code> can test the password operation for a custom Identity Provider that handles keys and passwords.</p> </li> <li> <p> If you provide any incorrect values for any parameters, the <code>Response</code> field is empty. </p> </li> <li> <p> If you provide a server ID for a server that uses service-managed users, you get an error: </p> <p> <code> An error occurred (InvalidRequestException) when calling the TestIdentityProvider operation: s-<i>server-ID</i> not configured for external auth </code> </p> </li> <li> <p> If you enter a Server ID for the <code>--server-id</code> parameter that does not identify an actual Transfer server, you receive the following error: </p> <p> <code>An error occurred (ResourceNotFoundException) when calling the TestIdentityProvider operation: Unknown server</code>. </p> <p>It is possible your sever is in a different region. You can specify a region by adding the following: <code>--region region-code</code>, such as <code>--region us-east-2</code> to specify a server in <b>US East (Ohio)</b>.</p> </li> </ul>
		/// TestIdentityProvider #X-Amz-Target=TransferService.TestIdentityProvider
		/// </summary>
		/// <returns>Success</returns>
		public async Task<TestIdentityProviderResponse> TestIdentityProviderAsync(TestIdentityProviderRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.TestIdentityProvider";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TestIdentityProviderResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Detaches a key-value pair from a resource, as identified by its Amazon Resource Name (ARN). Resources are users, servers, roles, and other entities.</p> <p>No response is returned from this call.</p>
		/// UntagResource #X-Amz-Target=TransferService.UntagResource
		/// </summary>
		/// <returns>Success</returns>
		public async Task UntagResourceAsync(UntagResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.UntagResource";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Allows you to update parameters for the access specified in the <code>ServerID</code> and <code>ExternalID</code> parameters.
		/// UpdateAccess #X-Amz-Target=TransferService.UpdateAccess
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateAccessResponse> UpdateAccessAsync(UpdateAccessRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.UpdateAccess";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateAccessResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates some of the parameters for an existing agreement. Provide the <code>AgreementId</code> and the <code>ServerId</code> for the agreement that you want to update, along with the new values for the parameters to update.
		/// UpdateAgreement #X-Amz-Target=TransferService.UpdateAgreement
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateAgreementResponse> UpdateAgreementAsync(UpdateAgreementRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.UpdateAgreement";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateAgreementResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the active and inactive dates for a certificate.
		/// UpdateCertificate #X-Amz-Target=TransferService.UpdateCertificate
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateCertificateResponse> UpdateCertificateAsync(UpdateCertificateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.UpdateCertificate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateCertificateResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates some of the parameters for an existing connector. Provide the <code>ConnectorId</code> for the connector that you want to update, along with the new values for the parameters to update.
		/// UpdateConnector #X-Amz-Target=TransferService.UpdateConnector
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateConnectorResponse> UpdateConnectorAsync(UpdateConnectorRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.UpdateConnector";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateConnectorResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the description for the host key that's specified by the <code>ServerId</code> and <code>HostKeyId</code> parameters.
		/// UpdateHostKey #X-Amz-Target=TransferService.UpdateHostKey
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateHostKeyResponse> UpdateHostKeyAsync(UpdateHostKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.UpdateHostKey";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateHostKeyResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates some of the parameters for an existing profile. Provide the <code>ProfileId</code> for the profile that you want to update, along with the new values for the parameters to update.
		/// UpdateProfile #X-Amz-Target=TransferService.UpdateProfile
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateProfileResponse> UpdateProfileAsync(UpdateProfileRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.UpdateProfile";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateProfileResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Updates the file transfer protocol-enabled server's properties after that server has been created.</p> <p>The <code>UpdateServer</code> call returns the <code>ServerId</code> of the server you updated.</p>
		/// UpdateServer #X-Amz-Target=TransferService.UpdateServer
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateServerResponse> UpdateServerAsync(UpdateServerRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.UpdateServer";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateServerResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Assigns new properties to a user. Parameters you pass modify any or all of the following: the home directory, role, and policy for the <code>UserName</code> and <code>ServerId</code> you specify.</p> <p>The response returns the <code>ServerId</code> and the <code>UserName</code> for the updated user.</p>
		/// UpdateUser #X-Amz-Target=TransferService.UpdateUser
		/// </summary>
		/// <returns>Success</returns>
		public async Task<UpdateUserResponse> UpdateUserAsync(UpdateUserRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "#X-Amz-Target=TransferService.UpdateUser";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateUserResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum CreateAccessX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.CreateAccess")]
		TransferService_CreateAccess = 0,
	}
	
	public enum CreateAgreementX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.CreateAgreement")]
		TransferService_CreateAgreement = 0,
	}
	
	public enum CreateConnectorX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.CreateConnector")]
		TransferService_CreateConnector = 0,
	}
	
	public enum CreateProfileX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.CreateProfile")]
		TransferService_CreateProfile = 0,
	}
	
	public enum CreateServerX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.CreateServer")]
		TransferService_CreateServer = 0,
	}
	
	public enum CreateUserX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.CreateUser")]
		TransferService_CreateUser = 0,
	}
	
	public enum CreateWorkflowX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.CreateWorkflow")]
		TransferService_CreateWorkflow = 0,
	}
	
	public enum DeleteAccessX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DeleteAccess")]
		TransferService_DeleteAccess = 0,
	}
	
	public enum DeleteAgreementX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DeleteAgreement")]
		TransferService_DeleteAgreement = 0,
	}
	
	public enum DeleteCertificateX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DeleteCertificate")]
		TransferService_DeleteCertificate = 0,
	}
	
	public enum DeleteConnectorX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DeleteConnector")]
		TransferService_DeleteConnector = 0,
	}
	
	public enum DeleteHostKeyX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DeleteHostKey")]
		TransferService_DeleteHostKey = 0,
	}
	
	public enum DeleteProfileX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DeleteProfile")]
		TransferService_DeleteProfile = 0,
	}
	
	public enum DeleteServerX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DeleteServer")]
		TransferService_DeleteServer = 0,
	}
	
	public enum DeleteSshPublicKeyX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DeleteSshPublicKey")]
		TransferService_DeleteSshPublicKey = 0,
	}
	
	public enum DeleteUserX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DeleteUser")]
		TransferService_DeleteUser = 0,
	}
	
	public enum DeleteWorkflowX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DeleteWorkflow")]
		TransferService_DeleteWorkflow = 0,
	}
	
	public enum DescribeAccessX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeAccess")]
		TransferService_DescribeAccess = 0,
	}
	
	public enum DescribeAgreementX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeAgreement")]
		TransferService_DescribeAgreement = 0,
	}
	
	public enum DescribeCertificateX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeCertificate")]
		TransferService_DescribeCertificate = 0,
	}
	
	public enum DescribeConnectorX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeConnector")]
		TransferService_DescribeConnector = 0,
	}
	
	public enum DescribeExecutionX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeExecution")]
		TransferService_DescribeExecution = 0,
	}
	
	public enum DescribeHostKeyX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeHostKey")]
		TransferService_DescribeHostKey = 0,
	}
	
	public enum DescribeProfileX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeProfile")]
		TransferService_DescribeProfile = 0,
	}
	
	public enum DescribeSecurityPolicyX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeSecurityPolicy")]
		TransferService_DescribeSecurityPolicy = 0,
	}
	
	public enum DescribeServerX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeServer")]
		TransferService_DescribeServer = 0,
	}
	
	public enum DescribeUserX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeUser")]
		TransferService_DescribeUser = 0,
	}
	
	public enum DescribeWorkflowX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.DescribeWorkflow")]
		TransferService_DescribeWorkflow = 0,
	}
	
	public enum ImportCertificateX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ImportCertificate")]
		TransferService_ImportCertificate = 0,
	}
	
	public enum ImportHostKeyX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ImportHostKey")]
		TransferService_ImportHostKey = 0,
	}
	
	public enum ImportSshPublicKeyX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ImportSshPublicKey")]
		TransferService_ImportSshPublicKey = 0,
	}
	
	public enum ListAccessesX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListAccesses")]
		TransferService_ListAccesses = 0,
	}
	
	public enum ListAgreementsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListAgreements")]
		TransferService_ListAgreements = 0,
	}
	
	public enum ListCertificatesX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListCertificates")]
		TransferService_ListCertificates = 0,
	}
	
	public enum ListConnectorsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListConnectors")]
		TransferService_ListConnectors = 0,
	}
	
	public enum ListExecutionsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListExecutions")]
		TransferService_ListExecutions = 0,
	}
	
	public enum ListHostKeysX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListHostKeys")]
		TransferService_ListHostKeys = 0,
	}
	
	public enum ListProfilesX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListProfiles")]
		TransferService_ListProfiles = 0,
	}
	
	public enum ListSecurityPoliciesX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListSecurityPolicies")]
		TransferService_ListSecurityPolicies = 0,
	}
	
	public enum ListServersX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListServers")]
		TransferService_ListServers = 0,
	}
	
	public enum ListTagsForResourceX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListTagsForResource")]
		TransferService_ListTagsForResource = 0,
	}
	
	public enum ListUsersX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListUsers")]
		TransferService_ListUsers = 0,
	}
	
	public enum ListWorkflowsX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.ListWorkflows")]
		TransferService_ListWorkflows = 0,
	}
	
	public enum SendWorkflowStepStateX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.SendWorkflowStepState")]
		TransferService_SendWorkflowStepState = 0,
	}
	
	public enum StartFileTransferX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.StartFileTransfer")]
		TransferService_StartFileTransfer = 0,
	}
	
	public enum StartServerX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.StartServer")]
		TransferService_StartServer = 0,
	}
	
	public enum StopServerX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.StopServer")]
		TransferService_StopServer = 0,
	}
	
	public enum TagResourceX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.TagResource")]
		TransferService_TagResource = 0,
	}
	
	public enum TestConnectionX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.TestConnection")]
		TransferService_TestConnection = 0,
	}
	
	public enum TestIdentityProviderX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.TestIdentityProvider")]
		TransferService_TestIdentityProvider = 0,
	}
	
	public enum UntagResourceX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.UntagResource")]
		TransferService_UntagResource = 0,
	}
	
	public enum UpdateAccessX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.UpdateAccess")]
		TransferService_UpdateAccess = 0,
	}
	
	public enum UpdateAgreementX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.UpdateAgreement")]
		TransferService_UpdateAgreement = 0,
	}
	
	public enum UpdateCertificateX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.UpdateCertificate")]
		TransferService_UpdateCertificate = 0,
	}
	
	public enum UpdateConnectorX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.UpdateConnector")]
		TransferService_UpdateConnector = 0,
	}
	
	public enum UpdateHostKeyX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.UpdateHostKey")]
		TransferService_UpdateHostKey = 0,
	}
	
	public enum UpdateProfileX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.UpdateProfile")]
		TransferService_UpdateProfile = 0,
	}
	
	public enum UpdateServerX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.UpdateServer")]
		TransferService_UpdateServer = 0,
	}
	
	public enum UpdateUserX_Amz_Target
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TransferService.UpdateUser")]
		TransferService_UpdateUser = 0,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
