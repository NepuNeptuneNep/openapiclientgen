//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1ComputeThreatListDiffResponse
	{
		
		/// <summary>
		/// Contains the set of entries to add to a local database. May contain a combination of compressed and raw data in a single response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additions")]
		public GoogleCloudWebriskV1ThreatEntryAdditions Additions { get; set; }
		
		/// <summary>
		/// The expected state of a client's local database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checksum")]
		public GoogleCloudWebriskV1ComputeThreatListDiffResponseChecksum Checksum { get; set; }
		
		/// <summary>
		/// The new opaque client version token. This should be retained by the client and passed into the next call of ComputeThreatListDiff as 'version_token'. A separate version token should be stored and used for each threatList.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newVersionToken")]
		public string NewVersionToken { get; set; }
		
		/// <summary>
		/// The soonest the client should wait before issuing any diff request. Querying sooner is unlikely to produce a meaningful diff. Waiting longer is acceptable considering the use case. If this field is not set clients may update as soon as they want.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recommendedNextDiff")]
		public string RecommendedNextDiff { get; set; }
		
		/// <summary>
		/// Contains the set of entries to remove from a local database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="removals")]
		public GoogleCloudWebriskV1ThreatEntryRemovals Removals { get; set; }
		
		/// <summary>
		/// The type of response. This may indicate that an action must be taken by the client when the response is received.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseType")]
		public System.Nullable<GoogleCloudWebriskV1ComputeThreatListDiffResponseResponseType> ResponseType { get; set; }
	}
	
	/// <summary>
	/// Contains the set of entries to add to a local database. May contain a combination of compressed and raw data in a single response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1ThreatEntryAdditions
	{
		
		/// <summary>
		/// The raw SHA256-formatted entries. Repeated to allow returning sets of hashes with different prefix sizes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rawHashes")]
		public GoogleCloudWebriskV1RawHashes[] RawHashes { get; set; }
		
		/// <summary>
		/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or compressed removal indices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="riceHashes")]
		public GoogleCloudWebriskV1RiceDeltaEncoding RiceHashes { get; set; }
	}
	
	/// <summary>
	/// The uncompressed threat entries in hash format. Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4 bytes, but some hashes are lengthened if they collide with the hash of a popular URI. Used for sending ThreatEntryAdditons to clients that do not support compression, or when sending non-4-byte hashes to clients that do support compression.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1RawHashes
	{
		
		/// <summary>
		/// The number of bytes for each prefix encoded below. This field can be anywhere from 4 (shortest prefix) to 32 (full SHA256 hash). In practice this is almost always 4, except in exceptional circumstances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixSize")]
		public System.Nullable<System.Int32> PrefixSize { get; set; }
		
		/// <summary>
		/// The hashes, in binary format, concatenated into one long string. Hashes are sorted in lexicographic order. For JSON API users, hashes are base64-encoded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rawHashes")]
		public string RawHashes { get; set; }
	}
	
	/// <summary>
	/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or compressed removal indices.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1RiceDeltaEncoding
	{
		
		/// <summary>
		/// The encoded deltas that are encoded using the Golomb-Rice coder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encodedData")]
		public string EncodedData { get; set; }
		
		/// <summary>
		/// The number of entries that are delta encoded in the encoded data. If only a single integer was encoded, this will be zero and the single value will be stored in `first_value`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entryCount")]
		public System.Nullable<System.Int32> EntryCount { get; set; }
		
		/// <summary>
		/// The offset of the first entry in the encoded data, or, if only a single integer was encoded, that single integer's value. If the field is empty or missing, assume zero.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstValue")]
		public string FirstValue { get; set; }
		
		/// <summary>
		/// The Golomb-Rice parameter, which is a number between 2 and 28. This field is missing (that is, zero) if `num_entries` is zero.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="riceParameter")]
		public System.Nullable<System.Int32> RiceParameter { get; set; }
	}
	
	/// <summary>
	/// The expected state of a client's local database.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1ComputeThreatListDiffResponseChecksum
	{
		
		/// <summary>
		/// The SHA256 hash of the client state; that is, of the sorted list of all hashes present in the database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sha256")]
		public string Sha256 { get; set; }
	}
	
	/// <summary>
	/// Contains the set of entries to remove from a local database.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1ThreatEntryRemovals
	{
		
		/// <summary>
		/// A set of raw indices to remove from a local list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rawIndices")]
		public GoogleCloudWebriskV1RawIndices RawIndices { get; set; }
		
		/// <summary>
		/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or compressed removal indices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="riceIndices")]
		public GoogleCloudWebriskV1RiceDeltaEncoding RiceIndices { get; set; }
	}
	
	/// <summary>
	/// A set of raw indices to remove from a local list.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1RawIndices
	{
		
		/// <summary>
		/// The indices to remove from a lexicographically-sorted local list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="indices")]
		public int[] Indices { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleCloudWebriskV1ComputeThreatListDiffResponseResponseType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESPONSE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIFF = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESET = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1SearchHashesResponse
	{
		
		/// <summary>
		/// For requested entities that did not match the threat list, how long to cache the response until.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="negativeExpireTime")]
		public string NegativeExpireTime { get; set; }
		
		/// <summary>
		/// The full hashes that matched the requested prefixes. The hash will be populated in the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threats")]
		public GoogleCloudWebriskV1SearchHashesResponseThreatHash[] Threats { get; set; }
	}
	
	/// <summary>
	/// Contains threat information on a matching hash.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1SearchHashesResponseThreatHash
	{
		
		/// <summary>
		/// The cache lifetime for the returned match. Clients must not cache this response past this timestamp to avoid false positives.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expireTime")]
		public string ExpireTime { get; set; }
		
		/// <summary>
		/// A 32 byte SHA256 hash. This field is in binary format. For JSON requests, hashes are base64-encoded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hash")]
		public string Hash { get; set; }
		
		/// <summary>
		/// The ThreatList this threat belongs to. This must contain at least one entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatTypes")]
		public string[] ThreatTypes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1SearchUrisResponse
	{
		
		/// <summary>
		/// Contains threat information on a matching uri.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threat")]
		public GoogleCloudWebriskV1SearchUrisResponseThreatUri Threat { get; set; }
	}
	
	/// <summary>
	/// Contains threat information on a matching uri.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1SearchUrisResponseThreatUri
	{
		
		/// <summary>
		/// The cache lifetime for the returned match. Clients must not cache this response past this timestamp to avoid false positives.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expireTime")]
		public string ExpireTime { get; set; }
		
		/// <summary>
		/// The ThreatList this threat belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threatTypes")]
		public string[] ThreatTypes { get; set; }
	}
	
	/// <summary>
	/// Wraps a URI that might be displaying malicious content.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleCloudWebriskV1Submission
	{
		
		/// <summary>
		/// Required. The URI that is being reported for malicious content to be analyzed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uri")]
		public string Uri { get; set; }
	}
	
	/// <summary>
	/// The request message for Operations.CancelOperation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleLongrunningCancelOperationRequest
	{
	}
	
	/// <summary>
	/// The response message for Operations.ListOperations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleLongrunningListOperationsResponse
	{
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A list of operations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public GoogleLongrunningOperation[] Operations { get; set; }
	}
	
	/// <summary>
	/// This resource represents a long-running operation that is the result of a network API call.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleLongrunningOperation
	{
		
		/// <summary>
		/// If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="done")]
		public System.Nullable<System.Boolean> Done { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public GoogleRpcStatus Error { get; set; }
		
		/// <summary>
		/// Contains a `SubmitUriMetadata` object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// Matches the `/v1/{project-name}/operations/{operation-id}` pattern.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public System.Collections.Generic.Dictionary<string, object> Response { get; set; }
	}
	
	/// <summary>
	/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleRpcStatus
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleProtobufEmpty
	{
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Gets the full hashes that match the requested hash prefix. This is used after a hash prefix is looked up in a threatList and there is a match. The client side threatList only holds partial hashes so the client must query this method to determine if there is a full hash match of a threat.
		/// Webrisk_hashes_search v1/hashes:search
		/// </summary>
		/// <param name="hashPrefix">A hash prefix, consisting of the most significant 4-32 bytes of a SHA256 hash. For JSON requests, this field is base64-encoded. Note that if this parameter is provided by a URI, it must be encoded using the web safe base64 variant (RFC 4648).</param>
		/// <param name="threatTypes">Required. The ThreatLists to search in. Multiple ThreatLists may be specified.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleCloudWebriskV1SearchHashesResponse> Webrisk_hashes_searchAsync(string hashPrefix, string[] threatTypes, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/hashes:search?hashPrefix=" + (hashPrefix==null? "" : System.Uri.EscapeDataString(hashPrefix))+"&"+string.Join("&", threatTypes.Select(z => $"threatTypes={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GoogleCloudWebriskV1SearchHashesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the most recent threat list diffs. These diffs should be applied to a local database of hashes to keep it up-to-date. If the local database is empty or excessively out-of-date, a complete snapshot of the database will be returned. This Method only updates a single ThreatList at a time. To update multiple ThreatList databases, this method needs to be called once for each list.
		/// Webrisk_threatLists_computeDiff v1/threatLists:computeDiff
		/// </summary>
		/// <param name="constraints_maxDatabaseEntries">Sets the maximum number of entries that the client is willing to have in the local database. This should be a power of 2 between 2**10 and 2**20. If zero, no database size limit is set.</param>
		/// <param name="constraints_maxDiffEntries">The maximum size in number of entries. The diff will not contain more entries than this value. This should be a power of 2 between 2**10 and 2**20. If zero, no diff size limit is set.</param>
		/// <param name="constraints_supportedCompressions">The compression types supported by the client.</param>
		/// <param name="threatType">Required. The threat list to update. Only a single ThreatType should be specified per request. If you want to handle multiple ThreatTypes, you must make one request per ThreatType.</param>
		/// <param name="versionToken">The current version token of the client for the requested list (the client version that was received from the last successful diff). If the client does not have a version token (this is the first time calling ComputeThreatListDiff), this may be left empty and a full database snapshot will be returned.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleCloudWebriskV1ComputeThreatListDiffResponse> Webrisk_threatLists_computeDiffAsync(int constraints_maxDatabaseEntries, int constraints_maxDiffEntries, string[] constraints_supportedCompressions, Webrisk_threatLists_computeDiffThreatType threatType, string versionToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/threatLists:computeDiff?constraints.maxDatabaseEntries="+constraints_maxDatabaseEntries+"&constraints.maxDiffEntries="+constraints_maxDiffEntries+"&"+string.Join("&", constraints_supportedCompressions.Select(z => $"constraints.supportedCompressions={System.Uri.EscapeDataString(z.ToString())}"))+"&threatType=" + threatType+"&versionToken=" + (versionToken==null? "" : System.Uri.EscapeDataString(versionToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GoogleCloudWebriskV1ComputeThreatListDiffResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// This method is used to check whether a URI is on a given threatList. Multiple threatLists may be searched in a single query. The response will list all requested threatLists the URI was found to match. If the URI is not found on any of the requested ThreatList an empty response will be returned.
		/// Webrisk_uris_search v1/uris:search
		/// </summary>
		/// <param name="threatTypes">Required. The ThreatLists to search in. Multiple ThreatLists may be specified.</param>
		/// <param name="uri">Required. The URI to be checked for matches.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleCloudWebriskV1SearchUrisResponse> Webrisk_uris_searchAsync(Webrisk_threatLists_computeDiffThreatType[] threatTypes, string uri, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/uris:search?"+string.Join("&", threatTypes.Select(z => $"threatTypes={z}"))+"&uri=" + (uri==null? "" : System.Uri.EscapeDataString(uri));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GoogleCloudWebriskV1SearchUrisResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a long-running operation. This method indicates that the client is no longer interested in the operation result. It does not cancel the operation. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
		/// Webrisk_projects_operations_delete v1/{name}
		/// </summary>
		/// <param name="name">The name of the operation resource to be deleted.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleProtobufEmpty> Webrisk_projects_operations_deleteAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GoogleProtobufEmpty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service.
		/// Webrisk_projects_operations_get v1/{name}
		/// </summary>
		/// <param name="name">The name of the operation resource.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleLongrunningOperation> Webrisk_projects_operations_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GoogleLongrunningOperation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
		/// Webrisk_projects_operations_list v1/{name}/operations
		/// </summary>
		/// <param name="name">The name of the operation's parent resource.</param>
		/// <param name="filter">The standard list filter.</param>
		/// <param name="pageSize">The standard list page size.</param>
		/// <param name="pageToken">The standard list page token.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleLongrunningListOperationsResponse> Webrisk_projects_operations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/operations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GoogleLongrunningListOperationsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// Webrisk_projects_operations_cancel v1/{name}:cancel
		/// </summary>
		/// <param name="name">The name of the operation resource to be cancelled.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleProtobufEmpty> Webrisk_projects_operations_cancelAsync(string name, GoogleLongrunningCancelOperationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GoogleProtobufEmpty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a Submission of a URI suspected of containing phishing content to be reviewed. If the result verifies the existence of malicious phishing content, the site will be added to the [Google's Social Engineering lists](https://support.google.com/webmasters/answer/6350487/) in order to protect users that could get exposed to this threat in the future. Only allowlisted projects can use this method during Early Access. Please reach out to Sales or your customer engineer to obtain access.
		/// Webrisk_projects_submissions_create v1/{parent}/submissions
		/// </summary>
		/// <param name="parent">Required. The name of the project that is making the submission. This string is in the format "projects/{project_number}".</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleCloudWebriskV1Submission> Webrisk_projects_submissions_createAsync(string parent, GoogleCloudWebriskV1Submission requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/submissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GoogleCloudWebriskV1Submission>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Webrisk_threatLists_computeDiffThreatType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THREAT_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MALWARE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOCIAL_ENGINEERING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNWANTED_SOFTWARE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOCIAL_ENGINEERING_EXTENDED_COVERAGE = 4,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
