//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// The results count for each account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AccountCount
	{
		
		/// <summary>
		/// User's information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account")]
		public UserInfo Account { get; set; }
		
		/// <summary>
		/// The number of results (messages or files) found for this account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public string Count { get; set; }
	}
	
	/// <summary>
	/// User's information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UserInfo
	{
		
		/// <summary>
		/// The displayed name of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// The email address of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
	}
	
	/// <summary>
	/// An error that occurred when querying a specific account
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AccountCountError
	{
		
		/// <summary>
		/// User's information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account")]
		public UserInfo Account { get; set; }
		
		/// <summary>
		/// Account query error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorType")]
		public System.Nullable<AccountCountErrorErrorType> ErrorType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AccountCountErrorErrorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WILDCARD_TOO_BROAD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOO_MANY_TERMS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCATION_UNAVAILABLE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEADLINE_EXCEEDED = 5,
	}
	
	/// <summary>
	/// The accounts to search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AccountInfo
	{
		
		/// <summary>
		/// A set of accounts to search.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
	}
	
	/// <summary>
	/// The status of each account creation, and the **HeldAccount**, if successful.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AddHeldAccountResult
	{
		
		/// <summary>
		/// An account covered by a hold. This structure is immutable. It can be an individual account or a Google Group, depending on the service. To work with Vault resources, the account must have the [required Vault privileges] (https://support.google.com/vault/answer/2799699) and access to the matter. To access a matter, the account must have created the matter, have the matter shared with them, or have the **View All Matters** privilege.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="account")]
		public HeldAccount Account { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public Status Status { get; set; }
	}
	
	/// <summary>
	/// An account covered by a hold. This structure is immutable. It can be an individual account or a Google Group, depending on the service. To work with Vault resources, the account must have the [required Vault privileges] (https://support.google.com/vault/answer/2799699) and access to the matter. To access a matter, the account must have created the matter, have the matter shared with them, or have the **View All Matters** privilege.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HeldAccount
	{
		
		/// <summary>
		/// The account ID, as provided by the [Admin SDK](https://developers.google.com/admin-sdk/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountId")]
		public string AccountId { get; set; }
		
		/// <summary>
		/// The primary email address of the account. If used as an input, this takes precedence over **accountId**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Output only. The first name of the account holder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firstName")]
		public string FirstName { get; set; }
		
		/// <summary>
		/// Output only. When the account was put on hold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="holdTime")]
		public string HoldTime { get; set; }
		
		/// <summary>
		/// Output only. The last name of the account holder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastName")]
		public string LastName { get; set; }
	}
	
	/// <summary>
	/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Status
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Add a list of accounts to a hold.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AddHeldAccountsRequest
	{
		
		/// <summary>
		/// A comma-separated list of the account IDs of the accounts to add to the hold. Specify either **emails** or **account_ids**, but not both.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountIds")]
		public string[] AccountIds { get; set; }
		
		/// <summary>
		/// A comma-separated list of the emails of the accounts to add to the hold. Specify either **emails** or **account_ids**, but not both.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emails")]
		public string[] Emails { get; set; }
	}
	
	/// <summary>
	/// Response for batch create held accounts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AddHeldAccountsResponse
	{
		
		/// <summary>
		/// The list of responses, in the same order as the batch request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responses")]
		public AddHeldAccountResult[] Responses { get; set; }
	}
	
	/// <summary>
	/// Add an account with the permission specified. The role cannot be owner. If an account already has a role in the matter, the existing role is overwritten.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AddMatterPermissionsRequest
	{
		
		/// <summary>
		/// Only relevant if **sendEmails** is **true**. To CC the requestor in the email message, set to **true**. To not CC requestor, set to **false**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ccMe")]
		public System.Nullable<System.Boolean> CcMe { get; set; }
		
		/// <summary>
		/// Users can be matter owners or collaborators. Each matter has only one owner. All others users who can access the matter are collaborators. When an account is purged, its corresponding MatterPermission resources cease to exist.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matterPermission")]
		public MatterPermission MatterPermission { get; set; }
		
		/// <summary>
		/// To send a notification email to the added account, set to **true**. To not send a notification email, set to **false**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sendEmails")]
		public System.Nullable<System.Boolean> SendEmails { get; set; }
	}
	
	/// <summary>
	/// Users can be matter owners or collaborators. Each matter has only one owner. All others users who can access the matter are collaborators. When an account is purged, its corresponding MatterPermission resources cease to exist.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MatterPermission
	{
		
		/// <summary>
		/// The account ID, as provided by the [Admin SDK](https://developers.google.com/admin-sdk/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountId")]
		public string AccountId { get; set; }
		
		/// <summary>
		/// The user's role for the matter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public System.Nullable<MatterPermissionRole> Role { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MatterPermissionRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ROLE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COLLABORATOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNER = 2,
	}
	
	/// <summary>
	/// The options for Calendar exports.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CalendarExportOptions
	{
		
		/// <summary>
		/// The file format for exported text messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportFormat")]
		public System.Nullable<CalendarExportOptionsExportFormat> ExportFormat { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CalendarExportOptionsExportFormat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPORT_FORMAT_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MBOX = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PST = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ICS = 3,
	}
	
	/// <summary>
	/// Additional options for Calendar search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CalendarOptions
	{
		
		/// <summary>
		/// Matches only those events whose location contains all of the words in the given set. If the string contains quoted phrases, this method only matches those events whose location contain the exact phrase. Entries in the set are considered in "and". Word splitting example: ["New Zealand"] vs ["New","Zealand"] "New Zealand": matched by both "New and better Zealand": only matched by the later
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationQuery")]
		public string[] LocationQuery { get; set; }
		
		/// <summary>
		/// Matches only those events that do not contain any of the words in the given set in title, description, location, or attendees. Entries in the set are considered in "or".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minusWords")]
		public string[] MinusWords { get; set; }
		
		/// <summary>
		/// Matches only those events whose attendees contain all of the words in the given set. Entries in the set are considered in "and".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peopleQuery")]
		public string[] PeopleQuery { get; set; }
		
		/// <summary>
		/// Matches only events for which the custodian gave one of these responses. If the set is empty or contains ATTENDEE_RESPONSE_UNSPECIFIED there will be no filtering on responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseStatuses")]
		public string[] ResponseStatuses { get; set; }
		
		/// <summary>
		/// Search the current version of the Calendar event, but export the contents of the last version saved before 12:00 AM UTC on the specified date. Enter the date in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="versionDate")]
		public string VersionDate { get; set; }
	}
	
	/// <summary>
	/// The request message for Operations.CancelOperation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CancelOperationRequest
	{
	}
	
	/// <summary>
	/// Close a matter by ID.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CloseMatterRequest
	{
	}
	
	/// <summary>
	/// Response to a CloseMatterRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CloseMatterResponse
	{
		
		/// <summary>
		/// Represents a matter. To work with Vault resources, the account must have the [required Vault privileges] (https://support.google.com/vault/answer/2799699) and access to the matter. To access a matter, the account must have created the matter, have the matter shared with them, or have the **View All Matters** privilege.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matter")]
		public Matter Matter { get; set; }
	}
	
	/// <summary>
	/// Represents a matter. To work with Vault resources, the account must have the [required Vault privileges] (https://support.google.com/vault/answer/2799699) and access to the matter. To access a matter, the account must have created the matter, have the matter shared with them, or have the **View All Matters** privilege.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Matter
	{
		
		/// <summary>
		/// An optional description for the matter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The matter ID, which is generated by the server. Leave blank when creating a matter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matterId")]
		public string MatterId { get; set; }
		
		/// <summary>
		/// Lists the users and their permission for the matter. Currently there is no programmer defined limit on the number of permissions a matter can have.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matterPermissions")]
		public MatterPermission[] MatterPermissions { get; set; }
		
		/// <summary>
		/// The name of the matter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The state of the matter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<MatterState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum MatterState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOSED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 3,
	}
	
	/// <summary>
	/// The export file in Cloud Storage
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CloudStorageFile
	{
		
		/// <summary>
		/// The name of the Cloud Storage bucket for the export file. You can use this value in the Cloud Storage [JSON API](https://cloud.google.com/storage/docs/json_api) or [XML API](https://cloud.google.com/storage/docs/xml-api), but not to list the bucket contents. Instead, you can [get individual export files](https://cloud.google.com/storage/docs/json_api/v1/objects/get) by object name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucketName")]
		public string BucketName { get; set; }
		
		/// <summary>
		/// The md5 hash of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5Hash")]
		public string Md5Hash { get; set; }
		
		/// <summary>
		/// The name of the Cloud Storage object for the export file. You can use this value in the Cloud Storage [JSON API](https://cloud.google.com/storage/docs/json_api) or [XML API](https://cloud.google.com/storage/docs/xml-api).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="objectName")]
		public string ObjectName { get; set; }
		
		/// <summary>
		/// The export file size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public string Size { get; set; }
	}
	
	/// <summary>
	/// Export sink for Cloud Storage files.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CloudStorageSink
	{
		
		/// <summary>
		/// Output only. The exported files in Cloud Storage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="files")]
		public CloudStorageFile[] Files { get; set; }
	}
	
	/// <summary>
	/// Service-specific options for holds.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CorpusQuery
	{
		
		/// <summary>
		/// Options for Drive holds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="driveQuery")]
		public HeldDriveQuery DriveQuery { get; set; }
		
		/// <summary>
		/// Query options for group holds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupsQuery")]
		public HeldGroupsQuery GroupsQuery { get; set; }
		
		/// <summary>
		/// Options for Chat holds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hangoutsChatQuery")]
		public HeldHangoutsChatQuery HangoutsChatQuery { get; set; }
		
		/// <summary>
		/// Query options for Gmail holds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mailQuery")]
		public HeldMailQuery MailQuery { get; set; }
		
		/// <summary>
		/// Options for Voice holds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceQuery")]
		public HeldVoiceQuery VoiceQuery { get; set; }
	}
	
	/// <summary>
	/// Options for Drive holds.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HeldDriveQuery
	{
		
		/// <summary>
		/// To include files in shared drives in the hold, set to **true**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeSharedDriveFiles")]
		public System.Nullable<System.Boolean> IncludeSharedDriveFiles { get; set; }
		
		/// <summary>
		/// To include files in Team Drives in the hold, set to **true**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeTeamDriveFiles")]
		public System.Nullable<System.Boolean> IncludeTeamDriveFiles { get; set; }
	}
	
	/// <summary>
	/// Query options for group holds.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HeldGroupsQuery
	{
		
		/// <summary>
		/// The end time for the query. Specify in GMT. The value is rounded to 12 AM on the specified date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// The start time for the query. Specify in GMT. The value is rounded to 12 AM on the specified date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// The [search operators](https://support.google.com/vault/answer/2474474) used to refine the messages covered by the hold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="terms")]
		public string Terms { get; set; }
	}
	
	/// <summary>
	/// Options for Chat holds.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HeldHangoutsChatQuery
	{
		
		/// <summary>
		/// To include messages in Chat spaces the user was a member of, set to **true**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeRooms")]
		public System.Nullable<System.Boolean> IncludeRooms { get; set; }
	}
	
	/// <summary>
	/// Query options for Gmail holds.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HeldMailQuery
	{
		
		/// <summary>
		/// The end time for the query. Specify in GMT. The value is rounded to 12 AM on the specified date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// The start time for the query. Specify in GMT. The value is rounded to 12 AM on the specified date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// The [search operators](https://support.google.com/vault/answer/2474474) used to refine the messages covered by the hold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="terms")]
		public string Terms { get; set; }
	}
	
	/// <summary>
	/// Options for Voice holds.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HeldVoiceQuery
	{
		
		/// <summary>
		/// A list of data types covered by the hold. Should be non-empty. Order does not matter and duplicates are ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coveredData")]
		public string[] CoveredData { get; set; }
	}
	
	/// <summary>
	/// Long running operation metadata for CountArtifacts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CountArtifactsMetadata
	{
		
		/// <summary>
		/// End time of count operation. Available when operation is done.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// The matter ID of the associated matter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matterId")]
		public string MatterId { get; set; }
		
		/// <summary>
		/// The query definition used for search and export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query")]
		public Query Query { get; set; }
		
		/// <summary>
		/// Creation time of count operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	/// <summary>
	/// The query definition used for search and export.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Query
	{
		
		/// <summary>
		/// The accounts to search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountInfo")]
		public AccountInfo AccountInfo { get; set; }
		
		/// <summary>
		/// Additional options for Calendar search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="calendarOptions")]
		public CalendarOptions CalendarOptions { get; set; }
		
		/// <summary>
		/// The Google Workspace service to search.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="corpus")]
		public System.Nullable<QueryCorpus> Corpus { get; set; }
		
		/// <summary>
		/// The data source to search.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataScope")]
		public System.Nullable<QueryDataScope> DataScope { get; set; }
		
		/// <summary>
		/// Additional options for Drive search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="driveOptions")]
		public DriveOptions DriveOptions { get; set; }
		
		/// <summary>
		/// The end time for the search query. Specify in GMT. The value is rounded to 12 AM on the specified date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// The Chat spaces to search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hangoutsChatInfo")]
		public HangoutsChatInfo HangoutsChatInfo { get; set; }
		
		/// <summary>
		/// Additional options for Google Chat search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hangoutsChatOptions")]
		public HangoutsChatOptions HangoutsChatOptions { get; set; }
		
		/// <summary>
		/// Additional options for Gmail search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mailOptions")]
		public MailOptions MailOptions { get; set; }
		
		/// <summary>
		/// The entity to search. This field replaces **searchMethod** to support shared drives. When **searchMethod** is **TEAM_DRIVE**, the response of this field is **SHARED_DRIVE**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="method")]
		public System.Nullable<QueryMethod> Method { get; set; }
		
		/// <summary>
		/// The organizational unit to search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orgUnitInfo")]
		public OrgUnitInfo OrgUnitInfo { get; set; }
		
		/// <summary>
		/// The search method to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="searchMethod")]
		public QueryMethod SearchMethod { get; set; }
		
		/// <summary>
		/// The shared drives to search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharedDriveInfo")]
		public SharedDriveInfo SharedDriveInfo { get; set; }
		
		/// <summary>
		/// The published site URLs of new Google Sites to search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sitesUrlInfo")]
		public SitesUrlInfo SitesUrlInfo { get; set; }
		
		/// <summary>
		/// The start time for the search query. Specify in GMT. The value is rounded to 12 AM on the specified date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// Team Drives to search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="teamDriveInfo")]
		public TeamDriveInfo TeamDriveInfo { get; set; }
		
		/// <summary>
		/// Service-specific [search operators](https://support.google.com/vault/answer/2474474) to filter search results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="terms")]
		public string Terms { get; set; }
		
		/// <summary>
		/// The time zone name. It should be an IANA TZ name, such as "America/Los_Angeles". For a list of time zone names, see [Time Zone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For more information about how Vault uses time zones, see [the Vault help center](https://support.google.com/vault/answer/6092995#time).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
		
		/// <summary>
		/// Additional options for Voice search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceOptions")]
		public VoiceOptions VoiceOptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum QueryCorpus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CORPUS_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DRIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAIL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GROUPS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HANGOUTS_CHAT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VOICE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CALENDAR = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum QueryDataScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_SCOPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_DATA = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HELD_DATA = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNPROCESSED_DATA = 3,
	}
	
	/// <summary>
	/// Additional options for Drive search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DriveOptions
	{
		
		/// <summary>
		/// Set whether the results include only content encrypted with [Google Workspace Client-side encryption](https://support.google.com/a?p=cse_ov) content, only unencrypted content, or both. Defaults to both. Currently supported for Drive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientSideEncryptedOption")]
		public System.Nullable<DriveOptionsClientSideEncryptedOption> ClientSideEncryptedOption { get; set; }
		
		/// <summary>
		/// Set to **true** to include shared drives.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeSharedDrives")]
		public System.Nullable<System.Boolean> IncludeSharedDrives { get; set; }
		
		/// <summary>
		/// Set to true to include Team Drive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeTeamDrives")]
		public System.Nullable<System.Boolean> IncludeTeamDrives { get; set; }
		
		/// <summary>
		/// Search the current version of the Drive file, but export the contents of the last version saved before 12:00 AM UTC on the specified date. Enter the date in UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="versionDate")]
		public string VersionDate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DriveOptionsClientSideEncryptedOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT_SIDE_ENCRYPTED_OPTION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT_SIDE_ENCRYPTED_OPTION_ANY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT_SIDE_ENCRYPTED_OPTION_ENCRYPTED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT_SIDE_ENCRYPTED_OPTION_UNENCRYPTED = 3,
	}
	
	/// <summary>
	/// The Chat spaces to search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HangoutsChatInfo
	{
		
		/// <summary>
		/// A list of Chat spaces IDs, as provided by the [Chat API](https://developers.google.com/chat). There is a limit of exporting from 500 Chat spaces per request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="roomId")]
		public string[] RoomId { get; set; }
	}
	
	/// <summary>
	/// Additional options for Google Chat search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HangoutsChatOptions
	{
		
		/// <summary>
		/// For searches by account or organizational unit, set to **true** to include rooms.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeRooms")]
		public System.Nullable<System.Boolean> IncludeRooms { get; set; }
	}
	
	/// <summary>
	/// Additional options for Gmail search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MailOptions
	{
		
		/// <summary>
		/// Specifies whether the results should include encrypted content, unencrypted content, or both. Defaults to including both.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientSideEncryptedOption")]
		public DriveOptionsClientSideEncryptedOption ClientSideEncryptedOption { get; set; }
		
		/// <summary>
		/// Set to **true** to exclude drafts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="excludeDrafts")]
		public System.Nullable<System.Boolean> ExcludeDrafts { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum QueryMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEARCH_METHOD_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCOUNT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORG_UNIT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TEAM_DRIVE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENTIRE_ORG = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ROOM = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SITES_URL = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHARED_DRIVE = 7,
	}
	
	/// <summary>
	/// The organizational unit to search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OrgUnitInfo
	{
		
		/// <summary>
		/// The name of the organizational unit to search, as provided by the [Admin SDK Directory API](https://developers.google.com/admin-sdk/directory/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orgUnitId")]
		public string OrgUnitId { get; set; }
	}
	
	/// <summary>
	/// The shared drives to search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SharedDriveInfo
	{
		
		/// <summary>
		/// A list of shared drive IDs, as provided by the [Drive API](https://developers.google.com/drive).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharedDriveIds")]
		public string[] SharedDriveIds { get; set; }
	}
	
	/// <summary>
	/// The published site URLs of new Google Sites to search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SitesUrlInfo
	{
		
		/// <summary>
		/// A list of published site URLs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urls")]
		public string[] Urls { get; set; }
	}
	
	/// <summary>
	/// Team Drives to search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TeamDriveInfo
	{
		
		/// <summary>
		/// List of Team Drive IDs, as provided by the [Drive API](https://developers.google.com/drive).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="teamDriveIds")]
		public string[] TeamDriveIds { get; set; }
	}
	
	/// <summary>
	/// Additional options for Voice search
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VoiceOptions
	{
		
		/// <summary>
		/// Datatypes to search
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coveredData")]
		public string[] CoveredData { get; set; }
	}
	
	/// <summary>
	/// Count artifacts request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CountArtifactsRequest
	{
		
		/// <summary>
		/// The query definition used for search and export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query")]
		public Query Query { get; set; }
		
		/// <summary>
		/// Sets the granularity of the count results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="view")]
		public System.Nullable<CountArtifactsRequestView> View { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CountArtifactsRequestView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COUNT_RESULT_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOTAL_COUNT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 2,
	}
	
	/// <summary>
	/// Definition of the response for method CountArtifacts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CountArtifactsResponse
	{
		
		/// <summary>
		/// Groups specific count metrics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupsCountResult")]
		public GroupsCountResult GroupsCountResult { get; set; }
		
		/// <summary>
		/// Gmail and classic Hangouts-specific count metrics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mailCountResult")]
		public MailCountResult MailCountResult { get; set; }
		
		/// <summary>
		/// Total count of messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalCount")]
		public string TotalCount { get; set; }
	}
	
	/// <summary>
	/// Groups specific count metrics.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GroupsCountResult
	{
		
		/// <summary>
		/// Error occurred when querying these accounts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountCountErrors")]
		public AccountCountError[] AccountCountErrors { get; set; }
		
		/// <summary>
		/// Subtotal count per matching account that have more than zero messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountCounts")]
		public AccountCount[] AccountCounts { get; set; }
		
		/// <summary>
		/// Total number of accounts that can be queried and have more than zero messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matchingAccountsCount")]
		public string MatchingAccountsCount { get; set; }
		
		/// <summary>
		/// When **DataScope** is **HELD_DATA**, these accounts in the request are not queried because they are not on hold. For other data scope, this field is not set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nonQueryableAccounts")]
		public string[] NonQueryableAccounts { get; set; }
		
		/// <summary>
		/// Total number of accounts involved in this count operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queriedAccountsCount")]
		public string QueriedAccountsCount { get; set; }
	}
	
	/// <summary>
	/// Gmail and classic Hangouts-specific count metrics.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MailCountResult
	{
		
		/// <summary>
		/// Errors occurred when querying these accounts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountCountErrors")]
		public AccountCountError[] AccountCountErrors { get; set; }
		
		/// <summary>
		/// Subtotal count per matching account that have more than zero messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountCounts")]
		public AccountCount[] AccountCounts { get; set; }
		
		/// <summary>
		/// Total number of accounts that can be queried and have more than zero messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matchingAccountsCount")]
		public string MatchingAccountsCount { get; set; }
		
		/// <summary>
		/// When **DataScope** is **HELD_DATA** and when account emails are passed in explicitly, the list of accounts in the request that are not queried because they are not on hold in the matter. For other data scopes, this field is not set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nonQueryableAccounts")]
		public string[] NonQueryableAccounts { get; set; }
		
		/// <summary>
		/// Total number of accounts involved in this count operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queriedAccountsCount")]
		public string QueriedAccountsCount { get; set; }
	}
	
	/// <summary>
	/// Options for Drive exports.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DriveExportOptions
	{
		
		/// <summary>
		/// To include access level information for users with [indirect access](https://support.google.com/vault/answer/6099459#metadata) to files, set to **true**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeAccessInfo")]
		public System.Nullable<System.Boolean> IncludeAccessInfo { get; set; }
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Empty
	{
	}
	
	/// <summary>
	/// An export. To work with Vault resources, the account must have the [required Vault privileges](https://support.google.com/vault/answer/2799699) and access to the matter. To access a matter, the account must have created the matter, have the matter shared with them, or have the **View All Matters** privilege.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Export
	{
		
		/// <summary>
		/// Export sink for Cloud Storage files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudStorageSink")]
		public CloudStorageSink CloudStorageSink { get; set; }
		
		/// <summary>
		/// Output only. The time when the export was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Additional options for exports
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportOptions")]
		public ExportOptions ExportOptions { get; set; }
		
		/// <summary>
		/// Output only. The generated export ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Output only. The matter ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matterId")]
		public string MatterId { get; set; }
		
		/// <summary>
		/// The export name. Don't use special characters (~!$'(),;@:/?) in the name, they can prevent you from downloading exports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Identifies the parent export that spawned this child export. This is only set on child exports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentExportId")]
		public string ParentExportId { get; set; }
		
		/// <summary>
		/// The query definition used for search and export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query")]
		public Query Query { get; set; }
		
		/// <summary>
		/// User's information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requester")]
		public UserInfo Requester { get; set; }
		
		/// <summary>
		/// Progress information for an export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stats")]
		public ExportStats Stats { get; set; }
		
		/// <summary>
		/// Output only. The status of the export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ExportStatus> Status { get; set; }
	}
	
	/// <summary>
	/// Additional options for exports
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExportOptions
	{
		
		/// <summary>
		/// The options for Calendar exports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="calendarOptions")]
		public CalendarExportOptions CalendarOptions { get; set; }
		
		/// <summary>
		/// Options for Drive exports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="driveOptions")]
		public DriveExportOptions DriveOptions { get; set; }
		
		/// <summary>
		/// Options for Groups exports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupsOptions")]
		public GroupsExportOptions GroupsOptions { get; set; }
		
		/// <summary>
		/// Options for Chat exports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hangoutsChatOptions")]
		public HangoutsChatExportOptions HangoutsChatOptions { get; set; }
		
		/// <summary>
		/// Options for Gmail exports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mailOptions")]
		public MailExportOptions MailOptions { get; set; }
		
		/// <summary>
		/// The requested data region for the export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public System.Nullable<ExportOptionsRegion> Region { get; set; }
		
		/// <summary>
		/// The options for Voice exports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="voiceOptions")]
		public VoiceExportOptions VoiceOptions { get; set; }
	}
	
	/// <summary>
	/// Options for Groups exports.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GroupsExportOptions
	{
		
		/// <summary>
		/// The file format for exported messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportFormat")]
		public CalendarExportOptionsExportFormat ExportFormat { get; set; }
	}
	
	/// <summary>
	/// Options for Chat exports.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HangoutsChatExportOptions
	{
		
		/// <summary>
		/// The file format for exported messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportFormat")]
		public CalendarExportOptionsExportFormat ExportFormat { get; set; }
	}
	
	/// <summary>
	/// Options for Gmail exports.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MailExportOptions
	{
		
		/// <summary>
		/// The file format for exported messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportFormat")]
		public CalendarExportOptionsExportFormat ExportFormat { get; set; }
		
		/// <summary>
		/// Optional. To enable exporting linked Drive files, set to **true**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportLinkedDriveFiles")]
		public System.Nullable<System.Boolean> ExportLinkedDriveFiles { get; set; }
		
		/// <summary>
		/// To export confidential mode content, set to **true**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="showConfidentialModeContent")]
		public System.Nullable<System.Boolean> ShowConfidentialModeContent { get; set; }
		
		/// <summary>
		/// To use the new export system, set to **true**.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="useNewExport")]
		public System.Nullable<System.Boolean> UseNewExport { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ExportOptionsRegion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPORT_REGION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		US = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EUROPE = 3,
	}
	
	/// <summary>
	/// The options for Voice exports.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VoiceExportOptions
	{
		
		/// <summary>
		/// The file format for exported text messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportFormat")]
		public CalendarExportOptionsExportFormat ExportFormat { get; set; }
	}
	
	/// <summary>
	/// Progress information for an export.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExportStats
	{
		
		/// <summary>
		/// The number of messages or files already processed for export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportedArtifactCount")]
		public string ExportedArtifactCount { get; set; }
		
		/// <summary>
		/// The size of export in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeInBytes")]
		public string SizeInBytes { get; set; }
		
		/// <summary>
		/// The number of messages or files to be exported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalArtifactCount")]
		public string TotalArtifactCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ExportStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPORT_STATUS_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_PROGRESS = 3,
	}
	
	/// <summary>
	/// The organizational unit covered by a hold. This structure is immutable.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HeldOrgUnit
	{
		
		/// <summary>
		/// When the organizational unit was put on hold. This property is immutable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="holdTime")]
		public string HoldTime { get; set; }
		
		/// <summary>
		/// The organizational unit's immutable ID as provided by the [Admin SDK](https://developers.google.com/admin-sdk/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orgUnitId")]
		public string OrgUnitId { get; set; }
	}
	
	/// <summary>
	/// A hold. A hold prevents the specified Google Workspace service from purging data for specific accounts or all members of an organizational unit. To work with Vault resources, the account must have the [required Vault privileges] (https://support.google.com/vault/answer/2799699) and access to the matter. To access a matter, the account must have created the matter, have the matter shared with them, or have the **View All Matters** privilege.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Hold
	{
		
		/// <summary>
		/// If set, the hold applies to the specified accounts and **orgUnit** must be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accounts")]
		public HeldAccount[] Accounts { get; set; }
		
		/// <summary>
		/// The service to be searched.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="corpus")]
		public QueryCorpus Corpus { get; set; }
		
		/// <summary>
		/// The unique immutable ID of the hold. Assigned during creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="holdId")]
		public string HoldId { get; set; }
		
		/// <summary>
		/// The name of the hold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The organizational unit covered by a hold. This structure is immutable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="orgUnit")]
		public HeldOrgUnit OrgUnit { get; set; }
		
		/// <summary>
		/// Service-specific options for holds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query")]
		public CorpusQuery Query { get; set; }
		
		/// <summary>
		/// The last time this hold was modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateTime")]
		public string UpdateTime { get; set; }
	}
	
	/// <summary>
	/// The exports for a matter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListExportsResponse
	{
		
		/// <summary>
		/// The list of exports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exports")]
		public Export[] Exports { get; set; }
		
		/// <summary>
		/// Page token to retrieve the next page of results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Returns a list of the accounts covered by a hold.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListHeldAccountsResponse
	{
		
		/// <summary>
		/// The held accounts on a hold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accounts")]
		public HeldAccount[] Accounts { get; set; }
	}
	
	/// <summary>
	/// The holds for a matter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListHoldsResponse
	{
		
		/// <summary>
		/// The list of holds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="holds")]
		public Hold[] Holds { get; set; }
		
		/// <summary>
		/// Page token to retrieve the next page of results in the list. If this is empty, then there are no more holds to list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Provides the list of matters.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListMattersResponse
	{
		
		/// <summary>
		/// List of matters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matters")]
		public Matter[] Matters { get; set; }
		
		/// <summary>
		/// Page token to retrieve the next page of results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// The response message for Operations.ListOperations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListOperationsResponse
	{
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// A list of operations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public Operation[] Operations { get; set; }
	}
	
	/// <summary>
	/// This resource represents a long-running operation that is the result of a network API call.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Operation
	{
		
		/// <summary>
		/// If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="done")]
		public System.Nullable<System.Boolean> Done { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public System.Collections.Generic.Dictionary<string, object> Response { get; set; }
	}
	
	/// <summary>
	/// Definition of the response for method ListSaveQuery.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListSavedQueriesResponse
	{
		
		/// <summary>
		/// Page token to retrieve the next page of results in the list. If this is empty, then there are no more saved queries to list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// List of saved queries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="savedQueries")]
		public SavedQuery[] SavedQueries { get; set; }
	}
	
	/// <summary>
	/// The definition of a saved query. To work with Vault resources, the account must have the [required Vault privileges](https://support.google.com/vault/answer/2799699) and access to the matter. To access a matter, the account must have created the matter, have the matter shared with them, or have the **View All Matters** privilege.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SavedQuery
	{
		
		/// <summary>
		/// Output only. The server-generated timestamp when the saved query was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// The name of the saved query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Output only. The matter ID of the matter the saved query is saved in. The server does not use this field during create and always uses matter ID in the URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matterId")]
		public string MatterId { get; set; }
		
		/// <summary>
		/// The query definition used for search and export.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="query")]
		public Query Query { get; set; }
		
		/// <summary>
		/// A unique identifier for the saved query.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="savedQueryId")]
		public string SavedQueryId { get; set; }
	}
	
	/// <summary>
	/// Remove a list of accounts from a hold.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RemoveHeldAccountsRequest
	{
		
		/// <summary>
		/// The account IDs of the accounts to remove from the hold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountIds")]
		public string[] AccountIds { get; set; }
	}
	
	/// <summary>
	/// Response for batch delete held accounts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RemoveHeldAccountsResponse
	{
		
		/// <summary>
		/// A list of statuses for the deleted accounts. Results have the same order as the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statuses")]
		public Status[] Statuses { get; set; }
	}
	
	/// <summary>
	/// Remove an account as a matter collaborator.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RemoveMatterPermissionsRequest
	{
		
		/// <summary>
		/// The account ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accountId")]
		public string AccountId { get; set; }
	}
	
	/// <summary>
	/// Reopen a matter by ID.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReopenMatterRequest
	{
	}
	
	/// <summary>
	/// Response to a ReopenMatterRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReopenMatterResponse
	{
		
		/// <summary>
		/// Represents a matter. To work with Vault resources, the account must have the [required Vault privileges] (https://support.google.com/vault/answer/2799699) and access to the matter. To access a matter, the account must have created the matter, have the matter shared with them, or have the **View All Matters** privilege.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matter")]
		public Matter Matter { get; set; }
	}
	
	/// <summary>
	/// Undelete a matter by ID.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UndeleteMatterRequest
	{
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists matters the requestor has access to.
		/// Vault_matters_list v1/matters
		/// </summary>
		/// <param name="pageSize">The number of matters to return in the response. Default and maximum are 100.</param>
		/// <param name="pageToken">The pagination token as returned in the response.</param>
		/// <param name="state">If set, lists only matters with the specified state. The default lists matters of all states.</param>
		/// <param name="view">Specifies how much information about the matter to return in response.</param>
		/// <returns>Successful response</returns>
		public async Task<ListMattersResponse> Vault_matters_listAsync(int pageSize, string pageToken, MatterState state, Vault_matters_listView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters?pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&state=" + state+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListMattersResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a matter with the given name and description. The initial state is open, and the owner is the method caller. Returns the created matter with default view.
		/// Vault_matters_create v1/matters
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<Matter> Vault_matters_createAsync(Matter requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Matter>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified matter. Returns the matter with updated state.
		/// Vault_matters_delete v1/matters/{matterId}
		/// </summary>
		/// <param name="matterId">The matter ID</param>
		/// <returns>Successful response</returns>
		public async Task<Matter> Vault_matters_deleteAsync(string matterId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Matter>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the specified matter.
		/// Vault_matters_get v1/matters/{matterId}
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="view">Specifies how much information about the matter to return in the response.</param>
		/// <returns>Successful response</returns>
		public async Task<Matter> Vault_matters_getAsync(string matterId, Vault_matters_listView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Matter>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified matter. This updates only the name and description of the matter, identified by matter ID. Changes to any other fields are ignored. Returns the default view of the matter.
		/// Vault_matters_update v1/matters/{matterId}
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <returns>Successful response</returns>
		public async Task<Matter> Vault_matters_updateAsync(string matterId, Matter requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Matter>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists details about the exports in the specified matter.
		/// Vault_matters_exports_list v1/matters/{matterId}/exports
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="pageSize">The number of exports to return in the response.</param>
		/// <param name="pageToken">The pagination token as returned in the response.</param>
		/// <returns>Successful response</returns>
		public async Task<ListExportsResponse> Vault_matters_exports_listAsync(string matterId, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/exports&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListExportsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an export.
		/// Vault_matters_exports_create v1/matters/{matterId}/exports
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <returns>Successful response</returns>
		public async Task<Export> Vault_matters_exports_createAsync(string matterId, Export requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/exports";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Export>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an export.
		/// Vault_matters_exports_delete v1/matters/{matterId}/exports/{exportId}
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="exportId">The export ID.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Vault_matters_exports_deleteAsync(string matterId, string exportId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/exports/"+ (exportId==null? "" : System.Uri.EscapeDataString(exportId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an export.
		/// Vault_matters_exports_get v1/matters/{matterId}/exports/{exportId}
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="exportId">The export ID.</param>
		/// <returns>Successful response</returns>
		public async Task<Export> Vault_matters_exports_getAsync(string matterId, string exportId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/exports/"+ (exportId==null? "" : System.Uri.EscapeDataString(exportId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Export>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the holds in a matter.
		/// Vault_matters_holds_list v1/matters/{matterId}/holds
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="pageSize">The number of holds to return in the response, between 0 and 100 inclusive. Leaving this empty, or as 0, is the same as **page_size** = 100.</param>
		/// <param name="pageToken">The pagination token as returned in the response. An empty token means start from the beginning.</param>
		/// <param name="view">The amount of detail to return for a hold.</param>
		/// <returns>Successful response</returns>
		public async Task<ListHoldsResponse> Vault_matters_holds_listAsync(string matterId, int pageSize, string pageToken, Vault_matters_holds_listView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/holds&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListHoldsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a hold in the specified matter.
		/// Vault_matters_holds_create v1/matters/{matterId}/holds
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <returns>Successful response</returns>
		public async Task<Hold> Vault_matters_holds_createAsync(string matterId, Hold requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/holds";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Hold>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes the specified hold and releases the accounts or organizational unit covered by the hold. If the data is not preserved by another hold or retention rule, it might be purged.
		/// Vault_matters_holds_delete v1/matters/{matterId}/holds/{holdId}
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="holdId">The hold ID.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Vault_matters_holds_deleteAsync(string matterId, string holdId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/holds/"+ (holdId==null? "" : System.Uri.EscapeDataString(holdId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the specified hold.
		/// Vault_matters_holds_get v1/matters/{matterId}/holds/{holdId}
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="holdId">The hold ID.</param>
		/// <param name="view">The amount of detail to return for a hold.</param>
		/// <returns>Successful response</returns>
		public async Task<Hold> Vault_matters_holds_getAsync(string matterId, string holdId, Vault_matters_holds_listView view, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/holds/"+ (holdId==null? "" : System.Uri.EscapeDataString(holdId))+"&view=" + view;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Hold>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the scope (organizational unit or accounts) and query parameters of a hold. You cannot add accounts to a hold that covers an organizational unit, nor can you add organizational units to a hold that covers individual accounts. If you try, the unsupported values are ignored.
		/// Vault_matters_holds_update v1/matters/{matterId}/holds/{holdId}
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="holdId">The ID of the hold.</param>
		/// <returns>Successful response</returns>
		public async Task<Hold> Vault_matters_holds_updateAsync(string matterId, string holdId, Hold requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/holds/"+ (holdId==null? "" : System.Uri.EscapeDataString(holdId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Hold>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the accounts covered by a hold. This can list only individually-specified accounts covered by the hold. If the hold covers an organizational unit, use the [Admin SDK](https://developers.google.com/admin-sdk/). to list the members of the organizational unit on hold.
		/// Vault_matters_holds_accounts_list v1/matters/{matterId}/holds/{holdId}/accounts
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="holdId">The hold ID.</param>
		/// <returns>Successful response</returns>
		public async Task<ListHeldAccountsResponse> Vault_matters_holds_accounts_listAsync(string matterId, string holdId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/holds/"+ (holdId==null? "" : System.Uri.EscapeDataString(holdId))+"/accounts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListHeldAccountsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds an account to a hold. Accounts can be added only to a hold that does not have an organizational unit set. If you try to add an account to an organizational unit-based hold, an error is returned.
		/// Vault_matters_holds_accounts_create v1/matters/{matterId}/holds/{holdId}/accounts
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="holdId">The hold ID.</param>
		/// <returns>Successful response</returns>
		public async Task<HeldAccount> Vault_matters_holds_accounts_createAsync(string matterId, string holdId, HeldAccount requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/holds/"+ (holdId==null? "" : System.Uri.EscapeDataString(holdId))+"/accounts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<HeldAccount>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes an account from a hold.
		/// Vault_matters_holds_accounts_delete v1/matters/{matterId}/holds/{holdId}/accounts/{accountId}
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="holdId">The hold ID.</param>
		/// <param name="accountId">The ID of the account to remove from the hold.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Vault_matters_holds_accounts_deleteAsync(string matterId, string holdId, string accountId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/holds/"+ (holdId==null? "" : System.Uri.EscapeDataString(holdId))+"/accounts/"+ (accountId==null? "" : System.Uri.EscapeDataString(accountId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds accounts to a hold. Returns a list of accounts that have been successfully added. Accounts can be added only to an existing account-based hold.
		/// Vault_matters_holds_addHeldAccounts v1/matters/{matterId}/holds/{holdId}:addHeldAccounts
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="holdId">The hold ID.</param>
		/// <returns>Successful response</returns>
		public async Task<AddHeldAccountsResponse> Vault_matters_holds_addHeldAccountsAsync(string matterId, string holdId, AddHeldAccountsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/holds/"+ (holdId==null? "" : System.Uri.EscapeDataString(holdId))+":addHeldAccounts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AddHeldAccountsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes the specified accounts from a hold. Returns a list of statuses in the same order as the request.
		/// Vault_matters_holds_removeHeldAccounts v1/matters/{matterId}/holds/{holdId}:removeHeldAccounts
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <param name="holdId">The hold ID.</param>
		/// <returns>Successful response</returns>
		public async Task<RemoveHeldAccountsResponse> Vault_matters_holds_removeHeldAccountsAsync(string matterId, string holdId, RemoveHeldAccountsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/holds/"+ (holdId==null? "" : System.Uri.EscapeDataString(holdId))+":removeHeldAccounts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RemoveHeldAccountsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the saved queries in a matter.
		/// Vault_matters_savedQueries_list v1/matters/{matterId}/savedQueries
		/// </summary>
		/// <param name="matterId">The ID of the matter to get the saved queries for.</param>
		/// <param name="pageSize">The maximum number of saved queries to return.</param>
		/// <param name="pageToken">The pagination token as returned in the previous response. An empty token means start from the beginning.</param>
		/// <returns>Successful response</returns>
		public async Task<ListSavedQueriesResponse> Vault_matters_savedQueries_listAsync(string matterId, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/savedQueries&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListSavedQueriesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a saved query.
		/// Vault_matters_savedQueries_create v1/matters/{matterId}/savedQueries
		/// </summary>
		/// <param name="matterId">The ID of the matter to create the saved query in.</param>
		/// <returns>Successful response</returns>
		public async Task<SavedQuery> Vault_matters_savedQueries_createAsync(string matterId, SavedQuery requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/savedQueries";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SavedQuery>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified saved query.
		/// Vault_matters_savedQueries_delete v1/matters/{matterId}/savedQueries/{savedQueryId}
		/// </summary>
		/// <param name="matterId">The ID of the matter to delete the saved query from.</param>
		/// <param name="savedQueryId">ID of the saved query to delete.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Vault_matters_savedQueries_deleteAsync(string matterId, string savedQueryId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/savedQueries/"+ (savedQueryId==null? "" : System.Uri.EscapeDataString(savedQueryId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the specified saved query.
		/// Vault_matters_savedQueries_get v1/matters/{matterId}/savedQueries/{savedQueryId}
		/// </summary>
		/// <param name="matterId">The ID of the matter to get the saved query from.</param>
		/// <param name="savedQueryId">ID of the saved query to retrieve.</param>
		/// <returns>Successful response</returns>
		public async Task<SavedQuery> Vault_matters_savedQueries_getAsync(string matterId, string savedQueryId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+"/savedQueries/"+ (savedQueryId==null? "" : System.Uri.EscapeDataString(savedQueryId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SavedQuery>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds an account as a matter collaborator.
		/// Vault_matters_addPermissions v1/matters/{matterId}:addPermissions
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <returns>Successful response</returns>
		public async Task<MatterPermission> Vault_matters_addPermissionsAsync(string matterId, AddMatterPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+":addPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<MatterPermission>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Closes the specified matter. Returns the matter with updated state.
		/// Vault_matters_close v1/matters/{matterId}:close
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <returns>Successful response</returns>
		public async Task<CloseMatterResponse> Vault_matters_closeAsync(string matterId, CloseMatterRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+":close";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CloseMatterResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Counts the accounts processed by the specified query.
		/// Vault_matters_count v1/matters/{matterId}:count
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Vault_matters_countAsync(string matterId, CountArtifactsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+":count";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Operation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes an account as a matter collaborator.
		/// Vault_matters_removePermissions v1/matters/{matterId}:removePermissions
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Vault_matters_removePermissionsAsync(string matterId, RemoveMatterPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+":removePermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reopens the specified matter. Returns the matter with updated state.
		/// Vault_matters_reopen v1/matters/{matterId}:reopen
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <returns>Successful response</returns>
		public async Task<ReopenMatterResponse> Vault_matters_reopenAsync(string matterId, ReopenMatterRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+":reopen";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ReopenMatterResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Undeletes the specified matter. Returns the matter with updated state.
		/// Vault_matters_undelete v1/matters/{matterId}:undelete
		/// </summary>
		/// <param name="matterId">The matter ID.</param>
		/// <returns>Successful response</returns>
		public async Task<Matter> Vault_matters_undeleteAsync(string matterId, UndeleteMatterRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/matters/"+ (matterId==null? "" : System.Uri.EscapeDataString(matterId))+":undelete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Matter>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a long-running operation. This method indicates that the client is no longer interested in the operation result. It does not cancel the operation. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`.
		/// Vault_operations_delete v1/{name}
		/// </summary>
		/// <param name="name">The name of the operation resource to be deleted.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Vault_operations_deleteAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`.
		/// Vault_operations_list v1/{name}
		/// </summary>
		/// <param name="name">The name of the operation's parent resource.</param>
		/// <param name="filter">The standard list filter.</param>
		/// <param name="pageSize">The standard list page size.</param>
		/// <param name="pageToken">The standard list page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListOperationsResponse> Vault_operations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListOperationsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// Vault_operations_cancel v1/{name}:cancel
		/// </summary>
		/// <param name="name">The name of the operation resource to be cancelled.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Vault_operations_cancelAsync(string name, CancelOperationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Vault_matters_listView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BASIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL = 2,
	}
	
	public enum Vault_matters_holds_listView
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HOLD_VIEW_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BASIC_HOLD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_HOLD = 2,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
