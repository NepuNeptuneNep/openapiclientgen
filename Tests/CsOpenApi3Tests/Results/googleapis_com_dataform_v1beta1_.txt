//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Represents an assertion upon a SQL query which is required return zero rows.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Assertion
	{
		
		/// <summary>
		/// A list of actions that this action depends on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dependencyTargets")]
		public Target[] DependencyTargets { get; set; }
		
		/// <summary>
		/// Whether this action is disabled (i.e. should not be run).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// Represents an action identifier. If the action writes output, the output will be written to the referenced database object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentAction")]
		public Target ParentAction { get; set; }
		
		/// <summary>
		/// Describes a relation and its columns.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relationDescriptor")]
		public RelationDescriptor RelationDescriptor { get; set; }
		
		/// <summary>
		/// The SELECT query which must return zero rows in order for this assertion to succeed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selectQuery")]
		public string SelectQuery { get; set; }
		
		/// <summary>
		/// Arbitrary, user-defined tags on this action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	/// <summary>
	/// Represents an action identifier. If the action writes output, the output will be written to the referenced database object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Target
	{
		
		/// <summary>
		/// The action's database (Google Cloud project ID) .
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="database")]
		public string Database { get; set; }
		
		/// <summary>
		/// The action's name, within `database` and `schema`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The action's schema (BigQuery dataset ID), within `database`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public string Schema { get; set; }
	}
	
	/// <summary>
	/// Describes a relation and its columns.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RelationDescriptor
	{
		
		/// <summary>
		/// A set of BigQuery labels that should be applied to the relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bigqueryLabels")]
		public System.Collections.Generic.Dictionary<string, string> BigqueryLabels { get; set; }
		
		/// <summary>
		/// A list of descriptions of columns within the relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="columns")]
		public ColumnDescriptor[] Columns { get; set; }
		
		/// <summary>
		/// A text description of the relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
	}
	
	/// <summary>
	/// Describes a column.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ColumnDescriptor
	{
		
		/// <summary>
		/// A list of BigQuery policy tags that will be applied to the column.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bigqueryPolicyTags")]
		public string[] BigqueryPolicyTags { get; set; }
		
		/// <summary>
		/// A textual description of the column.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The identifier for the column. Each entry in `path` represents one level of nesting.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string[] Path { get; set; }
	}
	
	/// <summary>
	/// Represents a workflow action that will run against BigQuery.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BigQueryAction
	{
		
		/// <summary>
		/// Output only. The generated BigQuery SQL script that will be executed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sqlScript")]
		public string SqlScript { get; set; }
	}
	
	/// <summary>
	/// Associates `members`, or principals, with a `role`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Binding
	{
		
		/// <summary>
		/// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="condition")]
		public Expr Condition { get; set; }
		
		/// <summary>
		/// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members")]
		public string[] Members { get; set; }
		
		/// <summary>
		/// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
	}
	
	/// <summary>
	/// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Expr
	{
		
		/// <summary>
		/// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Textual representation of an expression in Common Expression Language syntax.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expression")]
		public string Expression { get; set; }
		
		/// <summary>
		/// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// `CancelWorkflowInvocation` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CancelWorkflowInvocationRequest
	{
	}
	
	/// <summary>
	/// Configures various aspects of Dataform code compilation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CodeCompilationConfig
	{
		
		/// <summary>
		/// Optional. The default schema (BigQuery dataset ID) for assertions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assertionSchema")]
		public string AssertionSchema { get; set; }
		
		/// <summary>
		/// Optional. The suffix that should be appended to all database (Google Cloud project ID) names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="databaseSuffix")]
		public string DatabaseSuffix { get; set; }
		
		/// <summary>
		/// Optional. The default database (Google Cloud project ID).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultDatabase")]
		public string DefaultDatabase { get; set; }
		
		/// <summary>
		/// Optional. The default BigQuery location to use. Defaults to "US". See the BigQuery docs for a full list of locations: https://cloud.google.com/bigquery/docs/locations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultLocation")]
		public string DefaultLocation { get; set; }
		
		/// <summary>
		/// Optional. The default schema (BigQuery dataset ID).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultSchema")]
		public string DefaultSchema { get; set; }
		
		/// <summary>
		/// Optional. The suffix that should be appended to all schema (BigQuery dataset ID) names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schemaSuffix")]
		public string SchemaSuffix { get; set; }
		
		/// <summary>
		/// Optional. The prefix that should be prepended to all table names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tablePrefix")]
		public string TablePrefix { get; set; }
		
		/// <summary>
		/// Optional. User-defined variables that are made available to project code during compilation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vars")]
		public System.Collections.Generic.Dictionary<string, string> Vars { get; set; }
	}
	
	/// <summary>
	/// Represents the author of a Git commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CommitAuthor
	{
		
		/// <summary>
		/// Required. The commit author's email address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="emailAddress")]
		public string EmailAddress { get; set; }
		
		/// <summary>
		/// Required. The commit author's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Represents a single commit log.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CommitLogEntry
	{
		
		/// <summary>
		/// Represents the author of a Git commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author")]
		public CommitAuthor Author { get; set; }
		
		/// <summary>
		/// The commit message for this commit log entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitMessage")]
		public string CommitMessage { get; set; }
		
		/// <summary>
		/// The commit SHA for this commit log entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitSha")]
		public string CommitSha { get; set; }
		
		/// <summary>
		/// Commit timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitTime")]
		public string CommitTime { get; set; }
	}
	
	/// <summary>
	/// Represents a Dataform Git commit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CommitMetadata
	{
		
		/// <summary>
		/// Represents the author of a Git commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author")]
		public CommitAuthor Author { get; set; }
		
		/// <summary>
		/// Optional. The commit's message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitMessage")]
		public string CommitMessage { get; set; }
	}
	
	/// <summary>
	/// `CommitRepositoryChanges` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CommitRepositoryChangesRequest
	{
		
		/// <summary>
		/// Represents a Dataform Git commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitMetadata")]
		public CommitMetadata CommitMetadata { get; set; }
		
		/// <summary>
		/// A map to the path of the file to the operation. The path is the full file path including filename, from repository root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileOperations")]
		public System.Collections.Generic.Dictionary<string, FileOperation> FileOperations { get; set; }
		
		/// <summary>
		/// Optional. The commit SHA which must be the repository's current HEAD before applying this commit; otherwise this request will fail. If unset, no validation on the current HEAD commit SHA is performed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requiredHeadCommitSha")]
		public string RequiredHeadCommitSha { get; set; }
	}
	
	/// <summary>
	/// Represents a single file operation to the repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FileOperation
	{
		
		/// <summary>
		/// Represents the delete file operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleteFile")]
		public DeleteFile DeleteFile { get; set; }
		
		/// <summary>
		/// Represents the write file operation (for files added or modified).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="writeFile")]
		public WriteFile WriteFile { get; set; }
	}
	
	/// <summary>
	/// Represents the delete file operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteFile
	{
	}
	
	/// <summary>
	/// Represents the write file operation (for files added or modified).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WriteFile
	{
		
		/// <summary>
		/// The file's contents.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
	}
	
	/// <summary>
	/// `CommitWorkspaceChanges` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CommitWorkspaceChangesRequest
	{
		
		/// <summary>
		/// Represents the author of a Git commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author")]
		public CommitAuthor Author { get; set; }
		
		/// <summary>
		/// Optional. The commit's message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitMessage")]
		public string CommitMessage { get; set; }
		
		/// <summary>
		/// Optional. Full file paths to commit including filename, rooted at workspace root. If left empty, all files will be committed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="paths")]
		public string[] Paths { get; set; }
	}
	
	/// <summary>
	/// An error encountered when attempting to compile a Dataform project.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CompilationError
	{
		
		/// <summary>
		/// Represents an action identifier. If the action writes output, the output will be written to the referenced database object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionTarget")]
		public Target ActionTarget { get; set; }
		
		/// <summary>
		/// Output only. The error's top level message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Output only. The path of the file where this error occurred, if available, relative to the project root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Output only. The error's full stack trace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stack")]
		public string Stack { get; set; }
	}
	
	/// <summary>
	/// Represents the result of compiling a Dataform project.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CompilationResult
	{
		
		/// <summary>
		/// Configures various aspects of Dataform code compilation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="codeCompilationConfig")]
		public CodeCompilationConfig CodeCompilationConfig { get; set; }
		
		/// <summary>
		/// Output only. Errors encountered during project compilation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compilationErrors")]
		public CompilationError[] CompilationErrors { get; set; }
		
		/// <summary>
		/// Output only. The version of `@dataform/core` that was used for compilation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataformCoreVersion")]
		public string DataformCoreVersion { get; set; }
		
		/// <summary>
		/// Immutable. Git commit/tag/branch name at which the repository should be compiled. Must exist in the remote repository. Examples: - a commit SHA: `12ade345` - a tag: `tag1` - a branch name: `branch1`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gitCommitish")]
		public string GitCommitish { get; set; }
		
		/// <summary>
		/// Output only. The compilation result's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Immutable. The name of the release config to compile. The release config's 'current_compilation_result' field will be updated to this compilation result. Must be in the format `projects/*/locations/*/repositories/*/releaseConfigs/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseConfig")]
		public string ReleaseConfig { get; set; }
		
		/// <summary>
		/// Output only. The fully resolved Git commit SHA of the code that was compiled. Not set for compilation results whose source is a workspace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolvedGitCommitSha")]
		public string ResolvedGitCommitSha { get; set; }
		
		/// <summary>
		/// Immutable. The name of the workspace to compile. Must be in the format `projects/*/locations/*/repositories/*/workspaces/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workspace")]
		public string Workspace { get; set; }
	}
	
	/// <summary>
	/// Represents a single Dataform action in a compilation result.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CompilationResultAction
	{
		
		/// <summary>
		/// Represents an assertion upon a SQL query which is required return zero rows.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assertion")]
		public Assertion Assertion { get; set; }
		
		/// <summary>
		/// Represents an action identifier. If the action writes output, the output will be written to the referenced database object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canonicalTarget")]
		public Target CanonicalTarget { get; set; }
		
		/// <summary>
		/// Represents a relation which is not managed by Dataform but which may be referenced by Dataform actions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="declaration")]
		public Declaration Declaration { get; set; }
		
		/// <summary>
		/// The full path including filename in which this action is located, relative to the workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filePath")]
		public string FilePath { get; set; }
		
		/// <summary>
		/// Represents a list of arbitrary database operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public Operations Operations { get; set; }
		
		/// <summary>
		/// Represents a database relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relation")]
		public Relation Relation { get; set; }
		
		/// <summary>
		/// Represents an action identifier. If the action writes output, the output will be written to the referenced database object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Target Target { get; set; }
	}
	
	/// <summary>
	/// Represents a relation which is not managed by Dataform but which may be referenced by Dataform actions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Declaration
	{
		
		/// <summary>
		/// Describes a relation and its columns.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relationDescriptor")]
		public RelationDescriptor RelationDescriptor { get; set; }
	}
	
	/// <summary>
	/// Represents a list of arbitrary database operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Operations
	{
		
		/// <summary>
		/// A list of actions that this action depends on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dependencyTargets")]
		public Target[] DependencyTargets { get; set; }
		
		/// <summary>
		/// Whether this action is disabled (i.e. should not be run).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// Whether these operations produce an output relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasOutput")]
		public System.Nullable<System.Boolean> HasOutput { get; set; }
		
		/// <summary>
		/// A list of arbitrary SQL statements that will be executed without alteration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queries")]
		public string[] Queries { get; set; }
		
		/// <summary>
		/// Describes a relation and its columns.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relationDescriptor")]
		public RelationDescriptor RelationDescriptor { get; set; }
		
		/// <summary>
		/// Arbitrary, user-defined tags on this action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	/// <summary>
	/// Represents a database relation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Relation
	{
		
		/// <summary>
		/// Additional options that will be provided as key/value pairs into the options clause of a create table/view statement. See https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language for more information on which options are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalOptions")]
		public System.Collections.Generic.Dictionary<string, string> AdditionalOptions { get; set; }
		
		/// <summary>
		/// A list of columns or SQL expressions used to cluster the table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clusterExpressions")]
		public string[] ClusterExpressions { get; set; }
		
		/// <summary>
		/// A list of actions that this action depends on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dependencyTargets")]
		public Target[] DependencyTargets { get; set; }
		
		/// <summary>
		/// Whether this action is disabled (i.e. should not be run).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// Contains settings for relations of type `INCREMENTAL_TABLE`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="incrementalTableConfig")]
		public IncrementalTableConfig IncrementalTableConfig { get; set; }
		
		/// <summary>
		/// Sets the partition expiration in days.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partitionExpirationDays")]
		public System.Nullable<System.Int32> PartitionExpirationDays { get; set; }
		
		/// <summary>
		/// The SQL expression used to partition the relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partitionExpression")]
		public string PartitionExpression { get; set; }
		
		/// <summary>
		/// SQL statements to be executed after creating the relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postOperations")]
		public string[] PostOperations { get; set; }
		
		/// <summary>
		/// SQL statements to be executed before creating the relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preOperations")]
		public string[] PreOperations { get; set; }
		
		/// <summary>
		/// Describes a relation and its columns.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relationDescriptor")]
		public RelationDescriptor RelationDescriptor { get; set; }
		
		/// <summary>
		/// The type of this relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="relationType")]
		public System.Nullable<RelationRelationType> RelationType { get; set; }
		
		/// <summary>
		/// Specifies whether queries on this table must include a predicate filter that filters on the partitioning column.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requirePartitionFilter")]
		public System.Nullable<System.Boolean> RequirePartitionFilter { get; set; }
		
		/// <summary>
		/// The SELECT query which returns rows which this relation should contain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selectQuery")]
		public string SelectQuery { get; set; }
		
		/// <summary>
		/// Arbitrary, user-defined tags on this action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	/// <summary>
	/// Contains settings for relations of type `INCREMENTAL_TABLE`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IncrementalTableConfig
	{
		
		/// <summary>
		/// SQL statements to be executed after inserting new rows into the relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="incrementalPostOperations")]
		public string[] IncrementalPostOperations { get; set; }
		
		/// <summary>
		/// SQL statements to be executed before inserting new rows into the relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="incrementalPreOperations")]
		public string[] IncrementalPreOperations { get; set; }
		
		/// <summary>
		/// The SELECT query which returns rows which should be inserted into the relation if it already exists and is not being refreshed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="incrementalSelectQuery")]
		public string IncrementalSelectQuery { get; set; }
		
		/// <summary>
		/// Whether this table should be protected from being refreshed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="refreshDisabled")]
		public System.Nullable<System.Boolean> RefreshDisabled { get; set; }
		
		/// <summary>
		/// A set of columns or SQL expressions used to define row uniqueness. If any duplicates are discovered (as defined by `unique_key_parts`), only the newly selected rows (as defined by `incremental_select_query`) will be included in the relation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uniqueKeyParts")]
		public string[] UniqueKeyParts { get; set; }
		
		/// <summary>
		/// A SQL expression conditional used to limit the set of existing rows considered for a merge operation (see `unique_key_parts` for more information).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updatePartitionFilter")]
		public string UpdatePartitionFilter { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RelationRelationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RELATION_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TABLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIEW = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCREMENTAL_TABLE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MATERIALIZED_VIEW = 4,
	}
	
	/// <summary>
	/// `ComputeRepositoryAccessTokenStatus` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ComputeRepositoryAccessTokenStatusResponse
	{
		
		/// <summary>
		/// Indicates the status of the Git access token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenStatus")]
		public System.Nullable<ComputeRepositoryAccessTokenStatusResponseTokenStatus> TokenStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ComputeRepositoryAccessTokenStatusResponseTokenStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TOKEN_STATUS_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_FOUND = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VALID = 3,
	}
	
	/// <summary>
	/// Represents a single entry in a directory.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DirectoryEntry
	{
		
		/// <summary>
		/// A child directory in the directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="directory")]
		public string Directory { get; set; }
		
		/// <summary>
		/// A file in the directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file")]
		public string File { get; set; }
	}
	
	/// <summary>
	/// Client-facing representation of a directory entry in search results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DirectorySearchResult
	{
		
		/// <summary>
		/// File system path relative to the workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Empty
	{
	}
	
	/// <summary>
	/// `FetchFileDiff` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FetchFileDiffResponse
	{
		
		/// <summary>
		/// The raw formatted Git diff for the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="formattedDiff")]
		public string FormattedDiff { get; set; }
	}
	
	/// <summary>
	/// `FetchFileGitStatuses` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FetchFileGitStatusesResponse
	{
		
		/// <summary>
		/// A list of all files which have uncommitted Git changes. There will only be a single entry for any given file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uncommittedFileChanges")]
		public UncommittedFileChange[] UncommittedFileChanges { get; set; }
	}
	
	/// <summary>
	/// Represents the Git state of a file with uncommitted changes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UncommittedFileChange
	{
		
		/// <summary>
		/// The file's full path including filename, relative to the workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Indicates the status of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<UncommittedFileChangeState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UncommittedFileChangeState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADDED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODIFIED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HAS_CONFLICTS = 4,
	}
	
	/// <summary>
	/// `FetchGitAheadBehind` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FetchGitAheadBehindResponse
	{
		
		/// <summary>
		/// The number of commits in the remote branch that are not in the workspace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitsAhead")]
		public System.Nullable<System.Int32> CommitsAhead { get; set; }
		
		/// <summary>
		/// The number of commits in the workspace that are not in the remote branch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitsBehind")]
		public System.Nullable<System.Int32> CommitsBehind { get; set; }
	}
	
	/// <summary>
	/// `FetchRemoteBranches` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FetchRemoteBranchesResponse
	{
		
		/// <summary>
		/// The remote repository's branch names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="branches")]
		public string[] Branches { get; set; }
	}
	
	/// <summary>
	/// `FetchRepositoryHistory` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FetchRepositoryHistoryResponse
	{
		
		/// <summary>
		/// A list of commit logs, ordered by 'git log' default order.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commits")]
		public CommitLogEntry[] Commits { get; set; }
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Client-facing representation of a file entry in search results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FileSearchResult
	{
		
		/// <summary>
		/// File system path relative to the workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// Controls Git remote configuration for a repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GitRemoteSettings
	{
		
		/// <summary>
		/// Optional. The name of the Secret Manager secret version to use as an authentication token for Git operations. Must be in the format `projects/*/secrets/*/versions/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticationTokenSecretVersion")]
		public string AuthenticationTokenSecretVersion { get; set; }
		
		/// <summary>
		/// Required. The Git remote's default branch name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultBranch")]
		public string DefaultBranch { get; set; }
		
		/// <summary>
		/// Configures fields for performing SSH authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sshAuthenticationConfig")]
		public SshAuthenticationConfig SshAuthenticationConfig { get; set; }
		
		/// <summary>
		/// Output only. Deprecated: The field does not contain any token status information. Instead use https://cloud.google.com/dataform/reference/rest/v1beta1/projects.locations.repositories/computeAccessTokenStatus
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tokenStatus")]
		public ComputeRepositoryAccessTokenStatusResponseTokenStatus TokenStatus { get; set; }
		
		/// <summary>
		/// Required. The Git remote's URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Configures fields for performing SSH authentication.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SshAuthenticationConfig
	{
		
		/// <summary>
		/// Required. Content of a public SSH key to verify an identity of a remote Git host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostPublicKey")]
		public string HostPublicKey { get; set; }
		
		/// <summary>
		/// Required. The name of the Secret Manager secret version to use as a ssh private key for Git operations. Must be in the format `projects/*/secrets/*/versions/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userPrivateKeySecretVersion")]
		public string UserPrivateKeySecretVersion { get; set; }
	}
	
	/// <summary>
	/// `InstallNpmPackages` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InstallNpmPackagesRequest
	{
	}
	
	/// <summary>
	/// `InstallNpmPackages` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InstallNpmPackagesResponse
	{
	}
	
	/// <summary>
	/// Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Interval
	{
		
		/// <summary>
		/// Optional. Exclusive end of the interval. If specified, a Timestamp matching this interval will have to be before the end.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Optional. Inclusive start of the interval. If specified, a Timestamp matching this interval will have to be the same or after the start.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	/// <summary>
	/// Includes various configuration options for a workflow invocation. If both `included_targets` and `included_tags` are unset, all actions will be included.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InvocationConfig
	{
		
		/// <summary>
		/// Optional. When set to true, any incremental tables will be fully refreshed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullyRefreshIncrementalTablesEnabled")]
		public System.Nullable<System.Boolean> FullyRefreshIncrementalTablesEnabled { get; set; }
		
		/// <summary>
		/// Optional. The set of tags to include.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includedTags")]
		public string[] IncludedTags { get; set; }
		
		/// <summary>
		/// Optional. The set of action identifiers to include.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includedTargets")]
		public Target[] IncludedTargets { get; set; }
		
		/// <summary>
		/// Optional. The service account to run workflow invocations under.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccount")]
		public string ServiceAccount { get; set; }
		
		/// <summary>
		/// Optional. When set to true, transitive dependencies of included actions will be executed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transitiveDependenciesIncluded")]
		public System.Nullable<System.Boolean> TransitiveDependenciesIncluded { get; set; }
		
		/// <summary>
		/// Optional. When set to true, transitive dependents of included actions will be executed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transitiveDependentsIncluded")]
		public System.Nullable<System.Boolean> TransitiveDependentsIncluded { get; set; }
	}
	
	/// <summary>
	/// `ListCompilationResults` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListCompilationResultsResponse
	{
		
		/// <summary>
		/// List of compilation results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compilationResults")]
		public CompilationResult[] CompilationResults { get; set; }
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations which could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// The response message for Locations.ListLocations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListLocationsResponse
	{
		
		/// <summary>
		/// A list of locations that matches the specified filter in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public Location[] Locations { get; set; }
		
		/// <summary>
		/// The standard List next-page token.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A resource that represents a Google Cloud location.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Location
	{
		
		/// <summary>
		/// The friendly name for this location, typically a nearby city name. For example, "Tokyo".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Cross-service attributes for the location. For example {"cloud.googleapis.com/region": "us-east1"}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// The canonical id for this location. For example: `"us-east1"`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationId")]
		public string LocationId { get; set; }
		
		/// <summary>
		/// Service-specific metadata. For example the available capacity at the given location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// Resource name for the location, which may vary between implementations. For example: `"projects/example-project/locations/us-east1"`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// `ListReleaseConfigs` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListReleaseConfigsResponse
	{
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// List of release configs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseConfigs")]
		public ReleaseConfig[] ReleaseConfigs { get; set; }
		
		/// <summary>
		/// Locations which could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Represents a Dataform release configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReleaseConfig
	{
		
		/// <summary>
		/// Configures various aspects of Dataform code compilation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="codeCompilationConfig")]
		public CodeCompilationConfig CodeCompilationConfig { get; set; }
		
		/// <summary>
		/// Optional. Optional schedule (in cron format) for automatic creation of compilation results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cronSchedule")]
		public string CronSchedule { get; set; }
		
		/// <summary>
		/// Optional. Disables automatic creation of compilation results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// Required. Git commit/tag/branch name at which the repository should be compiled. Must exist in the remote repository. Examples: - a commit SHA: `12ade345` - a tag: `tag1` - a branch name: `branch1`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gitCommitish")]
		public string GitCommitish { get; set; }
		
		/// <summary>
		/// Output only. The release config's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Records of the 10 most recent scheduled release attempts, ordered in in descending order of `release_time`. Updated whenever automatic creation of a compilation result is triggered by cron_schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentScheduledReleaseRecords")]
		public ScheduledReleaseRecord[] RecentScheduledReleaseRecords { get; set; }
		
		/// <summary>
		/// Optional. The name of the currently released compilation result for this release config. This value is updated when a compilation result is created from this release config, or when this resource is updated by API call (perhaps to roll back to an earlier release). The compilation result must have been created using this release config. Must be in the format `projects/*/locations/*/repositories/*/compilationResults/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseCompilationResult")]
		public string ReleaseCompilationResult { get; set; }
		
		/// <summary>
		/// Optional. Specifies the time zone to be used when interpreting cron_schedule. Must be a time zone name from the time zone database (https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). If left unspecified, the default is UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
	}
	
	/// <summary>
	/// A record of an attempt to create a compilation result for this release config.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScheduledReleaseRecord
	{
		
		/// <summary>
		/// The name of the created compilation result, if one was successfully created. Must be in the format `projects/*/locations/*/repositories/*/compilationResults/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compilationResult")]
		public string CompilationResult { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorStatus")]
		public Status ErrorStatus { get; set; }
		
		/// <summary>
		/// The timestamp of this release attempt.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseTime")]
		public string ReleaseTime { get; set; }
	}
	
	/// <summary>
	/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Status
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// `ListRepositories` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListRepositoriesResponse
	{
		
		/// <summary>
		/// A token which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// List of repositories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repositories")]
		public Repository[] Repositories { get; set; }
		
		/// <summary>
		/// Locations which could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	/// <summary>
	/// Represents a Dataform Git repository.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Repository
	{
		
		/// <summary>
		/// Optional. The repository's user-friendly name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Controls Git remote configuration for a repository.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gitRemoteSettings")]
		public GitRemoteSettings GitRemoteSettings { get; set; }
		
		/// <summary>
		/// Optional. Repository user labels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Output only. The repository's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Optional. The name of the Secret Manager secret version to be used to interpolate variables into the .npmrc file for package installation operations. Must be in the format `projects/*/secrets/*/versions/*`. The file itself must be in a JSON format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="npmrcEnvironmentVariablesSecretVersion")]
		public string NpmrcEnvironmentVariablesSecretVersion { get; set; }
		
		/// <summary>
		/// Optional. The service account to run workflow invocations under.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccount")]
		public string ServiceAccount { get; set; }
		
		/// <summary>
		/// Optional. Input only. If set to true, the authenticated user will be granted the roles/dataform.admin role on the created repository. To modify access to the created repository later apply setIamPolicy from https://cloud.google.com/dataform/reference/rest#rest-resource:-v1beta1.projects.locations.repositories
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="setAuthenticatedUserAdmin")]
		public System.Nullable<System.Boolean> SetAuthenticatedUserAdmin { get; set; }
		
		/// <summary>
		/// Configures workspace compilation overrides for a repository. Primarily used by the UI (`console.cloud.google.com`). `schema_suffix` and `table_prefix` can have a special expression - `${workspaceName}`, which refers to the workspace name from which the compilation results will be created. API callers are expected to resolve the expression in these overrides and provide them explicitly in `code_compilation_config` (https://cloud.google.com/dataform/reference/rest/v1beta1/projects.locations.repositories.compilationResults#codecompilationconfig) when creating workspace-scoped compilation results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workspaceCompilationOverrides")]
		public WorkspaceCompilationOverrides WorkspaceCompilationOverrides { get; set; }
	}
	
	/// <summary>
	/// Configures workspace compilation overrides for a repository. Primarily used by the UI (`console.cloud.google.com`). `schema_suffix` and `table_prefix` can have a special expression - `${workspaceName}`, which refers to the workspace name from which the compilation results will be created. API callers are expected to resolve the expression in these overrides and provide them explicitly in `code_compilation_config` (https://cloud.google.com/dataform/reference/rest/v1beta1/projects.locations.repositories.compilationResults#codecompilationconfig) when creating workspace-scoped compilation results.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkspaceCompilationOverrides
	{
		
		/// <summary>
		/// Optional. The default database (Google Cloud project ID).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultDatabase")]
		public string DefaultDatabase { get; set; }
		
		/// <summary>
		/// Optional. The suffix that should be appended to all schema (BigQuery dataset ID) names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schemaSuffix")]
		public string SchemaSuffix { get; set; }
		
		/// <summary>
		/// Optional. The prefix that should be prepended to all table names.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tablePrefix")]
		public string TablePrefix { get; set; }
	}
	
	/// <summary>
	/// `ListWorkflowConfigs` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListWorkflowConfigsResponse
	{
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations which could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
		
		/// <summary>
		/// List of workflow configs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workflowConfigs")]
		public WorkflowConfig[] WorkflowConfigs { get; set; }
	}
	
	/// <summary>
	/// Represents a Dataform workflow configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkflowConfig
	{
		
		/// <summary>
		/// Optional. Optional schedule (in cron format) for automatic execution of this workflow config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cronSchedule")]
		public string CronSchedule { get; set; }
		
		/// <summary>
		/// Includes various configuration options for a workflow invocation. If both `included_targets` and `included_tags` are unset, all actions will be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invocationConfig")]
		public InvocationConfig InvocationConfig { get; set; }
		
		/// <summary>
		/// Output only. The workflow config's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Records of the 10 most recent scheduled execution attempts, ordered in in descending order of `execution_time`. Updated whenever automatic creation of a workflow invocation is triggered by cron_schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recentScheduledExecutionRecords")]
		public ScheduledExecutionRecord[] RecentScheduledExecutionRecords { get; set; }
		
		/// <summary>
		/// Required. The name of the release config whose release_compilation_result should be executed. Must be in the format `projects/*/locations/*/repositories/*/releaseConfigs/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseConfig")]
		public string ReleaseConfig { get; set; }
		
		/// <summary>
		/// Optional. Specifies the time zone to be used when interpreting cron_schedule. Must be a time zone name from the time zone database (https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). If left unspecified, the default is UTC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
	}
	
	/// <summary>
	/// A record of an attempt to create a workflow invocation for this workflow config.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ScheduledExecutionRecord
	{
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorStatus")]
		public Status ErrorStatus { get; set; }
		
		/// <summary>
		/// The timestamp of this execution attempt.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionTime")]
		public string ExecutionTime { get; set; }
		
		/// <summary>
		/// The name of the created workflow invocation, if one was successfully created. Must be in the format `projects/*/locations/*/repositories/*/workflowInvocations/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workflowInvocation")]
		public string WorkflowInvocation { get; set; }
	}
	
	/// <summary>
	/// `ListWorkflowInvocations` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListWorkflowInvocationsResponse
	{
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations which could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
		
		/// <summary>
		/// List of workflow invocations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workflowInvocations")]
		public WorkflowInvocation[] WorkflowInvocations { get; set; }
	}
	
	/// <summary>
	/// Represents a single invocation of a compilation result.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkflowInvocation
	{
		
		/// <summary>
		/// Immutable. The name of the compilation result to use for this invocation. Must be in the format `projects/*/locations/*/repositories/*/compilationResults/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compilationResult")]
		public string CompilationResult { get; set; }
		
		/// <summary>
		/// Includes various configuration options for a workflow invocation. If both `included_targets` and `included_tags` are unset, all actions will be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invocationConfig")]
		public InvocationConfig InvocationConfig { get; set; }
		
		/// <summary>
		/// Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invocationTiming")]
		public Interval InvocationTiming { get; set; }
		
		/// <summary>
		/// Output only. The workflow invocation's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. The resolved compilation result that was used to create this invocation. Will be in the format `projects/*/locations/*/repositories/*/compilationResults/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resolvedCompilationResult")]
		public string ResolvedCompilationResult { get; set; }
		
		/// <summary>
		/// Output only. This workflow invocation's current state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<WorkflowInvocationState> State { get; set; }
		
		/// <summary>
		/// Immutable. The name of the workflow config to invoke. Must be in the format `projects/*/locations/*/repositories/*/workflowConfigs/*`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workflowConfig")]
		public string WorkflowConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum WorkflowInvocationState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELING = 5,
	}
	
	/// <summary>
	/// `ListWorkspaces` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListWorkspacesResponse
	{
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Locations which could not be reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
		
		/// <summary>
		/// List of workspaces.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workspaces")]
		public Workspace[] Workspaces { get; set; }
	}
	
	/// <summary>
	/// Represents a Dataform Git workspace.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Workspace
	{
		
		/// <summary>
		/// Output only. The workspace's name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// `MakeDirectory` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MakeDirectoryRequest
	{
		
		/// <summary>
		/// Required. The directory's full path including directory name, relative to the workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// `MakeDirectory` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MakeDirectoryResponse
	{
	}
	
	/// <summary>
	/// `MoveDirectory` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MoveDirectoryRequest
	{
		
		/// <summary>
		/// Required. The new path for the directory including directory name, rooted at workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newPath")]
		public string NewPath { get; set; }
		
		/// <summary>
		/// Required. The directory's full path including directory name, relative to the workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// `MoveDirectory` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MoveDirectoryResponse
	{
	}
	
	/// <summary>
	/// `MoveFile` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MoveFileRequest
	{
		
		/// <summary>
		/// Required. The file's new path including filename, relative to the workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="newPath")]
		public string NewPath { get; set; }
		
		/// <summary>
		/// Required. The file's full path including filename, relative to the workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// `MoveFile` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class MoveFileResponse
	{
	}
	
	/// <summary>
	/// Represents the metadata of the long-running operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationMetadata
	{
		
		/// <summary>
		/// Output only. API version used to start the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="apiVersion")]
		public string ApiVersion { get; set; }
		
		/// <summary>
		/// Output only. Identifies whether the user has requested cancellation of the operation. Operations that have been cancelled successfully have Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cancelRequested")]
		public System.Nullable<System.Boolean> CancelRequested { get; set; }
		
		/// <summary>
		/// Output only. The time the operation was created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// Output only. The time the operation finished running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Output only. Human-readable status of the operation, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusDetail")]
		public string StatusDetail { get; set; }
		
		/// <summary>
		/// Output only. Server-defined resource path for the target of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// Output only. Name of the verb executed by the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verb")]
		public string Verb { get; set; }
	}
	
	/// <summary>
	/// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Policy
	{
		
		/// <summary>
		/// Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindings")]
		public Binding[] Bindings { get; set; }
		
		/// <summary>
		/// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<System.Int32> Version { get; set; }
	}
	
	/// <summary>
	/// `PullGitCommits` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PullGitCommitsRequest
	{
		
		/// <summary>
		/// Represents the author of a Git commit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="author")]
		public CommitAuthor Author { get; set; }
		
		/// <summary>
		/// Optional. The name of the branch in the Git remote from which to pull commits. If left unset, the repository's default branch name will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteBranch")]
		public string RemoteBranch { get; set; }
	}
	
	/// <summary>
	/// `PushGitCommits` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PushGitCommitsRequest
	{
		
		/// <summary>
		/// Optional. The name of the branch in the Git remote to which commits should be pushed. If left unset, the repository's default branch name will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteBranch")]
		public string RemoteBranch { get; set; }
	}
	
	/// <summary>
	/// `QueryCompilationResultActions` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QueryCompilationResultActionsResponse
	{
		
		/// <summary>
		/// List of compilation result actions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compilationResultActions")]
		public CompilationResultAction[] CompilationResultActions { get; set; }
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// `QueryDirectoryContents` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QueryDirectoryContentsResponse
	{
		
		/// <summary>
		/// List of entries in the directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="directoryEntries")]
		public DirectoryEntry[] DirectoryEntries { get; set; }
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// `QueryRepositoryDirectoryContents` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QueryRepositoryDirectoryContentsResponse
	{
		
		/// <summary>
		/// List of entries in the directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="directoryEntries")]
		public DirectoryEntry[] DirectoryEntries { get; set; }
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// `QueryWorkflowInvocationActions` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class QueryWorkflowInvocationActionsResponse
	{
		
		/// <summary>
		/// A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// List of workflow invocation actions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workflowInvocationActions")]
		public WorkflowInvocationAction[] WorkflowInvocationActions { get; set; }
	}
	
	/// <summary>
	/// Represents a single action in a workflow invocation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkflowInvocationAction
	{
		
		/// <summary>
		/// Represents a workflow action that will run against BigQuery.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bigqueryAction")]
		public BigQueryAction BigqueryAction { get; set; }
		
		/// <summary>
		/// Represents an action identifier. If the action writes output, the output will be written to the referenced database object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canonicalTarget")]
		public Target CanonicalTarget { get; set; }
		
		/// <summary>
		/// Output only. If and only if action's state is FAILED a failure reason is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failureReason")]
		public string FailureReason { get; set; }
		
		/// <summary>
		/// Represents a time interval, encoded as a Timestamp start (inclusive) and a Timestamp end (exclusive). The start must be less than or equal to the end. When the start equals the end, the interval is empty (matches no time). When both start and end are unspecified, the interval matches any time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invocationTiming")]
		public Interval InvocationTiming { get; set; }
		
		/// <summary>
		/// Output only. This action's current state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<WorkflowInvocationActionState> State { get; set; }
		
		/// <summary>
		/// Represents an action identifier. If the action writes output, the output will be written to the referenced database object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public Target Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum WorkflowInvocationActionState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SKIPPED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCEEDED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 6,
	}
	
	/// <summary>
	/// `ReadFile` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReadFileResponse
	{
		
		/// <summary>
		/// The file's contents.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileContents")]
		public string FileContents { get; set; }
	}
	
	/// <summary>
	/// `ReadRepositoryFile` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ReadRepositoryFileResponse
	{
		
		/// <summary>
		/// The file's contents.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
	}
	
	/// <summary>
	/// `RemoveDirectory` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RemoveDirectoryRequest
	{
		
		/// <summary>
		/// Required. The directory's full path including directory name, relative to the workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// `RemoveFile` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RemoveFileRequest
	{
		
		/// <summary>
		/// Required. The file's full path including filename, relative to the workspace root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// `ResetWorkspaceChanges` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResetWorkspaceChangesRequest
	{
		
		/// <summary>
		/// Optional. If set to true, untracked files will be deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clean")]
		public System.Nullable<System.Boolean> Clean { get; set; }
		
		/// <summary>
		/// Optional. Full file paths to reset back to their committed state including filename, rooted at workspace root. If left empty, all files will be reset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="paths")]
		public string[] Paths { get; set; }
	}
	
	/// <summary>
	/// Client-facing representation of a file search response.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchFilesResponse
	{
		
		/// <summary>
		/// Optional. A token, which can be sent as `page_token` to retrieve the next page. If this field is omitted, there are no subsequent pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// List of matched results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="searchResults")]
		public SearchResult[] SearchResults { get; set; }
	}
	
	/// <summary>
	/// Client-facing representation of a search result entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchResult
	{
		
		/// <summary>
		/// Client-facing representation of a directory entry in search results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="directory")]
		public DirectorySearchResult Directory { get; set; }
		
		/// <summary>
		/// Client-facing representation of a file entry in search results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file")]
		public FileSearchResult File { get; set; }
	}
	
	/// <summary>
	/// Request message for `SetIamPolicy` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SetIamPolicyRequest
	{
		
		/// <summary>
		/// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public Policy Policy { get; set; }
	}
	
	/// <summary>
	/// Request message for `TestIamPermissions` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestIamPermissionsRequest
	{
		
		/// <summary>
		/// The set of permissions to check for the `resource`. Permissions with wildcards (such as `*` or `storage.*`) are not allowed. For more information see [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public string[] Permissions { get; set; }
	}
	
	/// <summary>
	/// Response message for `TestIamPermissions` method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestIamPermissionsResponse
	{
		
		/// <summary>
		/// A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public string[] Permissions { get; set; }
	}
	
	/// <summary>
	/// `WriteFile` request message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WriteFileRequest
	{
		
		/// <summary>
		/// Required. The file's contents.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// Required. The file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// `WriteFile` response message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WriteFileResponse
	{
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Deletes a single Workspace.
		/// Dataform_projects_locations_repositories_workspaces_delete v1beta1/{name}
		/// </summary>
		/// <param name="name">Required. The workspace resource's name.</param>
		/// <param name="force">If set to true, any child resources of this repository will also be deleted. (Otherwise, the request will only succeed if the repository has no child resources.)</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Dataform_projects_locations_repositories_workspaces_deleteAsync(string name, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&force="+force;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetches a single Workspace.
		/// Dataform_projects_locations_repositories_workspaces_get v1beta1/{name}
		/// </summary>
		/// <param name="name">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<Workspace> Dataform_projects_locations_repositories_workspaces_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Workspace>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a single WorkflowConfig.
		/// Dataform_projects_locations_repositories_workflowConfigs_patch v1beta1/{name}
		/// </summary>
		/// <param name="name">Output only. The workflow config's name.</param>
		/// <param name="updateMask">Optional. Specifies the fields to be updated in the workflow config. If left unset, all fields will be updated.</param>
		/// <returns>Successful response</returns>
		public async Task<WorkflowConfig> Dataform_projects_locations_repositories_workflowConfigs_patchAsync(string name, string updateMask, WorkflowConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WorkflowConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists information about the supported locations for this service.
		/// Dataform_projects_locations_list v1beta1/{name}/locations
		/// </summary>
		/// <param name="name">The resource that owns the locations collection, if applicable.</param>
		/// <param name="filter">A filter to narrow down results to a preferred subset. The filtering language accepts strings like `"displayName=tokyo"`, and is documented in more detail in [AIP-160](https://google.aip.dev/160).</param>
		/// <param name="pageSize">The maximum number of results to return. If not set, the service selects a default.</param>
		/// <param name="pageToken">A page token received from the `next_page_token` field in the response. Send that page token to receive the subsequent page.</param>
		/// <returns>Successful response</returns>
		public async Task<ListLocationsResponse> Dataform_projects_locations_listAsync(string name, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"/locations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListLocationsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Requests cancellation of a running WorkflowInvocation.
		/// Dataform_projects_locations_repositories_workflowInvocations_cancel v1beta1/{name}:cancel
		/// </summary>
		/// <param name="name">Required. The workflow invocation resource's name.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Dataform_projects_locations_repositories_workflowInvocations_cancelAsync(string name, CancelWorkflowInvocationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Applies a Git commit for uncommitted files in a Workspace.
		/// Dataform_projects_locations_repositories_workspaces_commit v1beta1/{name}:commit
		/// </summary>
		/// <param name="name">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Dataform_projects_locations_repositories_workspaces_commitAsync(string name, CommitWorkspaceChangesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":commit";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Computes a Repository's Git access token status.
		/// Dataform_projects_locations_repositories_computeAccessTokenStatus v1beta1/{name}:computeAccessTokenStatus
		/// </summary>
		/// <param name="name">Required. The repository's name.</param>
		/// <returns>Successful response</returns>
		public async Task<ComputeRepositoryAccessTokenStatusResponse> Dataform_projects_locations_repositories_computeAccessTokenStatusAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":computeAccessTokenStatus";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ComputeRepositoryAccessTokenStatusResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetches Git statuses for the files in a Workspace.
		/// Dataform_projects_locations_repositories_workspaces_fetchFileGitStatuses v1beta1/{name}:fetchFileGitStatuses
		/// </summary>
		/// <param name="name">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<FetchFileGitStatusesResponse> Dataform_projects_locations_repositories_workspaces_fetchFileGitStatusesAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":fetchFileGitStatuses";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<FetchFileGitStatusesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetches Git ahead/behind against a remote branch.
		/// Dataform_projects_locations_repositories_workspaces_fetchGitAheadBehind v1beta1/{name}:fetchGitAheadBehind
		/// </summary>
		/// <param name="name">Required. The workspace's name.</param>
		/// <param name="remoteBranch">Optional. The name of the branch in the Git remote against which this workspace should be compared. If left unset, the repository's default branch name will be used.</param>
		/// <returns>Successful response</returns>
		public async Task<FetchGitAheadBehindResponse> Dataform_projects_locations_repositories_workspaces_fetchGitAheadBehindAsync(string name, string remoteBranch, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":fetchGitAheadBehind&remoteBranch=" + (remoteBranch==null? "" : System.Uri.EscapeDataString(remoteBranch));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<FetchGitAheadBehindResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetches a Repository's history of commits. The Repository must not have a value for `git_remote_settings.url`.
		/// Dataform_projects_locations_repositories_fetchHistory v1beta1/{name}:fetchHistory
		/// </summary>
		/// <param name="name">Required. The repository's name.</param>
		/// <param name="pageSize">Optional. Maximum number of commits to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `FetchRepositoryHistory` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `FetchRepositoryHistory` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<FetchRepositoryHistoryResponse> Dataform_projects_locations_repositories_fetchHistoryAsync(string name, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":fetchHistory&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<FetchRepositoryHistoryResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetches a Repository's remote branches.
		/// Dataform_projects_locations_repositories_fetchRemoteBranches v1beta1/{name}:fetchRemoteBranches
		/// </summary>
		/// <param name="name">Required. The repository's name.</param>
		/// <returns>Successful response</returns>
		public async Task<FetchRemoteBranchesResponse> Dataform_projects_locations_repositories_fetchRemoteBranchesAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":fetchRemoteBranches";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<FetchRemoteBranchesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Pulls Git commits from the Repository's remote into a Workspace.
		/// Dataform_projects_locations_repositories_workspaces_pull v1beta1/{name}:pull
		/// </summary>
		/// <param name="name">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Dataform_projects_locations_repositories_workspaces_pullAsync(string name, PullGitCommitsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":pull";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Pushes Git commits from a Workspace to the Repository's remote.
		/// Dataform_projects_locations_repositories_workspaces_push v1beta1/{name}:push
		/// </summary>
		/// <param name="name">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Dataform_projects_locations_repositories_workspaces_pushAsync(string name, PushGitCommitsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":push";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns WorkflowInvocationActions in a given WorkflowInvocation.
		/// Dataform_projects_locations_repositories_workflowInvocations_query v1beta1/{name}:query
		/// </summary>
		/// <param name="name">Required. The workflow invocation's name.</param>
		/// <param name="pageSize">Optional. Maximum number of workflow invocations to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `QueryWorkflowInvocationActions` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `QueryWorkflowInvocationActions` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<QueryWorkflowInvocationActionsResponse> Dataform_projects_locations_repositories_workflowInvocations_queryAsync(string name, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":query&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<QueryWorkflowInvocationActionsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the contents of a given Repository directory. The Repository must not have a value for `git_remote_settings.url`.
		/// Dataform_projects_locations_repositories_queryDirectoryContents v1beta1/{name}:queryDirectoryContents
		/// </summary>
		/// <param name="name">Required. The repository's name.</param>
		/// <param name="commitSha">Optional. The Commit SHA for the commit to query from. If unset, the directory will be queried from HEAD.</param>
		/// <param name="pageSize">Optional. Maximum number of paths to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `QueryRepositoryDirectoryContents` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `QueryRepositoryDirectoryContents` must match the call that provided the page token.</param>
		/// <param name="path">Optional. The directory's full path including directory name, relative to root. If left unset, the root is used.</param>
		/// <returns>Successful response</returns>
		public async Task<QueryRepositoryDirectoryContentsResponse> Dataform_projects_locations_repositories_queryDirectoryContentsAsync(string name, string commitSha, int pageSize, string pageToken, string path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":queryDirectoryContents&commitSha=" + (commitSha==null? "" : System.Uri.EscapeDataString(commitSha))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<QueryRepositoryDirectoryContentsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the contents of a file (inside a Repository). The Repository must not have a value for `git_remote_settings.url`.
		/// Dataform_projects_locations_repositories_readFile v1beta1/{name}:readFile
		/// </summary>
		/// <param name="name">Required. The repository's name.</param>
		/// <param name="commitSha">Optional. The commit SHA for the commit to read from. If unset, the file will be read from HEAD.</param>
		/// <param name="path">Required. Full file path to read including filename, from repository root.</param>
		/// <returns>Successful response</returns>
		public async Task<ReadRepositoryFileResponse> Dataform_projects_locations_repositories_readFileAsync(string name, string commitSha, string path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":readFile&commitSha=" + (commitSha==null? "" : System.Uri.EscapeDataString(commitSha))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ReadRepositoryFileResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Performs a Git reset for uncommitted files in a Workspace.
		/// Dataform_projects_locations_repositories_workspaces_reset v1beta1/{name}:reset
		/// </summary>
		/// <param name="name">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Dataform_projects_locations_repositories_workspaces_resetAsync(string name, ResetWorkspaceChangesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":reset";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists CompilationResults in a given Repository.
		/// Dataform_projects_locations_repositories_compilationResults_list v1beta1/{parent}/compilationResults
		/// </summary>
		/// <param name="parent">Required. The repository in which to list compilation results. Must be in the format `projects/*/locations/*/repositories/*`.</param>
		/// <param name="pageSize">Optional. Maximum number of compilation results to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `ListCompilationResults` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListCompilationResults` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListCompilationResultsResponse> Dataform_projects_locations_repositories_compilationResults_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/compilationResults&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListCompilationResultsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new CompilationResult in a given project and location.
		/// Dataform_projects_locations_repositories_compilationResults_create v1beta1/{parent}/compilationResults
		/// </summary>
		/// <param name="parent">Required. The repository in which to create the compilation result. Must be in the format `projects/*/locations/*/repositories/*`.</param>
		/// <returns>Successful response</returns>
		public async Task<CompilationResult> Dataform_projects_locations_repositories_compilationResults_createAsync(string parent, CompilationResult requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/compilationResults";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CompilationResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists ReleaseConfigs in a given Repository.
		/// Dataform_projects_locations_repositories_releaseConfigs_list v1beta1/{parent}/releaseConfigs
		/// </summary>
		/// <param name="parent">Required. The repository in which to list release configs. Must be in the format `projects/*/locations/*/repositories/*`.</param>
		/// <param name="pageSize">Optional. Maximum number of release configs to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `ListReleaseConfigs` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListReleaseConfigs` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListReleaseConfigsResponse> Dataform_projects_locations_repositories_releaseConfigs_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/releaseConfigs&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListReleaseConfigsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new ReleaseConfig in a given Repository.
		/// Dataform_projects_locations_repositories_releaseConfigs_create v1beta1/{parent}/releaseConfigs
		/// </summary>
		/// <param name="parent">Required. The repository in which to create the release config. Must be in the format `projects/*/locations/*/repositories/*`.</param>
		/// <param name="releaseConfigId">Required. The ID to use for the release config, which will become the final component of the release config's resource name.</param>
		/// <returns>Successful response</returns>
		public async Task<ReleaseConfig> Dataform_projects_locations_repositories_releaseConfigs_createAsync(string parent, string releaseConfigId, ReleaseConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/releaseConfigs&releaseConfigId=" + (releaseConfigId==null? "" : System.Uri.EscapeDataString(releaseConfigId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ReleaseConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists Repositories in a given project and location.
		/// Dataform_projects_locations_repositories_list v1beta1/{parent}/repositories
		/// </summary>
		/// <param name="parent">Required. The location in which to list repositories. Must be in the format `projects/*/locations/*`.</param>
		/// <param name="filter">Optional. Filter for the returned list.</param>
		/// <param name="orderBy">Optional. This field only supports ordering by `name`. If unspecified, the server will choose the ordering. If specified, the default order is ascending for the `name` field.</param>
		/// <param name="pageSize">Optional. Maximum number of repositories to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `ListRepositories` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListRepositories` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListRepositoriesResponse> Dataform_projects_locations_repositories_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/repositories&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListRepositoriesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new Repository in a given project and location.
		/// Dataform_projects_locations_repositories_create v1beta1/{parent}/repositories
		/// </summary>
		/// <param name="parent">Required. The location in which to create the repository. Must be in the format `projects/*/locations/*`.</param>
		/// <param name="repositoryId">Required. The ID to use for the repository, which will become the final component of the repository's resource name.</param>
		/// <returns>Successful response</returns>
		public async Task<Repository> Dataform_projects_locations_repositories_createAsync(string parent, string repositoryId, Repository requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/repositories&repositoryId=" + (repositoryId==null? "" : System.Uri.EscapeDataString(repositoryId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Repository>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists WorkflowConfigs in a given Repository.
		/// Dataform_projects_locations_repositories_workflowConfigs_list v1beta1/{parent}/workflowConfigs
		/// </summary>
		/// <param name="parent">Required. The repository in which to list workflow configs. Must be in the format `projects/*/locations/*/repositories/*`.</param>
		/// <param name="pageSize">Optional. Maximum number of workflow configs to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `ListWorkflowConfigs` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListWorkflowConfigs` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListWorkflowConfigsResponse> Dataform_projects_locations_repositories_workflowConfigs_listAsync(string parent, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/workflowConfigs&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListWorkflowConfigsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new WorkflowConfig in a given Repository.
		/// Dataform_projects_locations_repositories_workflowConfigs_create v1beta1/{parent}/workflowConfigs
		/// </summary>
		/// <param name="parent">Required. The repository in which to create the workflow config. Must be in the format `projects/*/locations/*/repositories/*`.</param>
		/// <param name="workflowConfigId">Required. The ID to use for the workflow config, which will become the final component of the workflow config's resource name.</param>
		/// <returns>Successful response</returns>
		public async Task<WorkflowConfig> Dataform_projects_locations_repositories_workflowConfigs_createAsync(string parent, string workflowConfigId, WorkflowConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/workflowConfigs&workflowConfigId=" + (workflowConfigId==null? "" : System.Uri.EscapeDataString(workflowConfigId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WorkflowConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists WorkflowInvocations in a given Repository.
		/// Dataform_projects_locations_repositories_workflowInvocations_list v1beta1/{parent}/workflowInvocations
		/// </summary>
		/// <param name="parent">Required. The parent resource of the WorkflowInvocation type. Must be in the format `projects/*/locations/*/repositories/*`.</param>
		/// <param name="filter">Optional. Filter for the returned list.</param>
		/// <param name="orderBy">Optional. This field only supports ordering by `name`. If unspecified, the server will choose the ordering. If specified, the default order is ascending for the `name` field.</param>
		/// <param name="pageSize">Optional. Maximum number of workflow invocations to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `ListWorkflowInvocations` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListWorkflowInvocations` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListWorkflowInvocationsResponse> Dataform_projects_locations_repositories_workflowInvocations_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/workflowInvocations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListWorkflowInvocationsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new WorkflowInvocation in a given Repository.
		/// Dataform_projects_locations_repositories_workflowInvocations_create v1beta1/{parent}/workflowInvocations
		/// </summary>
		/// <param name="parent">Required. The repository in which to create the workflow invocation. Must be in the format `projects/*/locations/*/repositories/*`.</param>
		/// <returns>Successful response</returns>
		public async Task<WorkflowInvocation> Dataform_projects_locations_repositories_workflowInvocations_createAsync(string parent, WorkflowInvocation requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/workflowInvocations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WorkflowInvocation>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists Workspaces in a given Repository.
		/// Dataform_projects_locations_repositories_workspaces_list v1beta1/{parent}/workspaces
		/// </summary>
		/// <param name="parent">Required. The repository in which to list workspaces. Must be in the format `projects/*/locations/*/repositories/*`.</param>
		/// <param name="filter">Optional. Filter for the returned list.</param>
		/// <param name="orderBy">Optional. This field only supports ordering by `name`. If unspecified, the server will choose the ordering. If specified, the default order is ascending for the `name` field.</param>
		/// <param name="pageSize">Optional. Maximum number of workspaces to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `ListWorkspaces` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `ListWorkspaces` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<ListWorkspacesResponse> Dataform_projects_locations_repositories_workspaces_listAsync(string parent, string filter, string orderBy, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/workspaces&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListWorkspacesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new Workspace in a given Repository.
		/// Dataform_projects_locations_repositories_workspaces_create v1beta1/{parent}/workspaces
		/// </summary>
		/// <param name="parent">Required. The repository in which to create the workspace. Must be in the format `projects/*/locations/*/repositories/*`.</param>
		/// <param name="workspaceId">Required. The ID to use for the workspace, which will become the final component of the workspace's resource name.</param>
		/// <returns>Successful response</returns>
		public async Task<Workspace> Dataform_projects_locations_repositories_workspaces_createAsync(string parent, string workspaceId, Workspace requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/workspaces&workspaceId=" + (workspaceId==null? "" : System.Uri.EscapeDataString(workspaceId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Workspace>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. Returns an empty policy if the resource exists and does not have a policy set.
		/// Dataform_projects_locations_repositories_workspaces_getIamPolicy v1beta1/{resource}:getIamPolicy
		/// </summary>
		/// <param name="resource">REQUIRED: The resource for which the policy is being requested. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field.</param>
		/// <param name="options_requestedPolicyVersion">Optional. The maximum policy version that will be used to format the policy. Valid values are 0, 1, and 3. Requests specifying an invalid value will be rejected. Requests for policies with any conditional role bindings must specify version 3. Policies with no conditional role bindings may specify any valid value or leave the field unset. The policy in the response might use the policy version that you specified, or it might use a lower policy version. For example, if you specify version 3, but the policy has no conditional role bindings, the response uses version 1. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Dataform_projects_locations_repositories_workspaces_getIamPolicyAsync(string resource, int options_requestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+":getIamPolicy&options.requestedPolicyVersion="+options_requestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Policy>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy. Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
		/// Dataform_projects_locations_repositories_workspaces_setIamPolicy v1beta1/{resource}:setIamPolicy
		/// </summary>
		/// <param name="resource">REQUIRED: The resource for which the policy is being specified. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Dataform_projects_locations_repositories_workspaces_setIamPolicyAsync(string resource, SetIamPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+":setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Policy>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource. If the resource does not exist, this will return an empty set of permissions, not a `NOT_FOUND` error. Note: This operation is designed to be used for building permission-aware UIs and command-line tools, not for authorization checking. This operation may "fail open" without warning.
		/// Dataform_projects_locations_repositories_workspaces_testIamPermissions v1beta1/{resource}:testIamPermissions
		/// </summary>
		/// <param name="resource">REQUIRED: The resource for which the policy detail is being requested. See [Resource names](https://cloud.google.com/apis/design/resource_names) for the appropriate value for this field.</param>
		/// <returns>Successful response</returns>
		public async Task<TestIamPermissionsResponse> Dataform_projects_locations_repositories_workspaces_testIamPermissionsAsync(string resource, TestIamPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+":testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TestIamPermissionsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetches Git diff for an uncommitted file in a Workspace.
		/// Dataform_projects_locations_repositories_workspaces_fetchFileDiff v1beta1/{workspace}:fetchFileDiff
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <param name="path">Required. The file's full path including filename, relative to the workspace root.</param>
		/// <returns>Successful response</returns>
		public async Task<FetchFileDiffResponse> Dataform_projects_locations_repositories_workspaces_fetchFileDiffAsync(string workspace, string path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":fetchFileDiff&path=" + (path==null? "" : System.Uri.EscapeDataString(path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<FetchFileDiffResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Installs dependency NPM packages (inside a Workspace).
		/// Dataform_projects_locations_repositories_workspaces_installNpmPackages v1beta1/{workspace}:installNpmPackages
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<InstallNpmPackagesResponse> Dataform_projects_locations_repositories_workspaces_installNpmPackagesAsync(string workspace, InstallNpmPackagesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":installNpmPackages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<InstallNpmPackagesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a directory inside a Workspace.
		/// Dataform_projects_locations_repositories_workspaces_makeDirectory v1beta1/{workspace}:makeDirectory
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<MakeDirectoryResponse> Dataform_projects_locations_repositories_workspaces_makeDirectoryAsync(string workspace, MakeDirectoryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":makeDirectory";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<MakeDirectoryResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Moves a directory (inside a Workspace), and all of its contents, to a new location.
		/// Dataform_projects_locations_repositories_workspaces_moveDirectory v1beta1/{workspace}:moveDirectory
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<MoveDirectoryResponse> Dataform_projects_locations_repositories_workspaces_moveDirectoryAsync(string workspace, MoveDirectoryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":moveDirectory";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<MoveDirectoryResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Moves a file (inside a Workspace) to a new location.
		/// Dataform_projects_locations_repositories_workspaces_moveFile v1beta1/{workspace}:moveFile
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<MoveFileResponse> Dataform_projects_locations_repositories_workspaces_moveFileAsync(string workspace, MoveFileRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":moveFile";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<MoveFileResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the contents of a given Workspace directory.
		/// Dataform_projects_locations_repositories_workspaces_queryDirectoryContents v1beta1/{workspace}:queryDirectoryContents
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <param name="pageSize">Optional. Maximum number of paths to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `QueryDirectoryContents` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `QueryDirectoryContents` must match the call that provided the page token.</param>
		/// <param name="path">Optional. The directory's full path including directory name, relative to the workspace root. If left unset, the workspace root is used.</param>
		/// <returns>Successful response</returns>
		public async Task<QueryDirectoryContentsResponse> Dataform_projects_locations_repositories_workspaces_queryDirectoryContentsAsync(string workspace, int pageSize, string pageToken, string path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":queryDirectoryContents&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<QueryDirectoryContentsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the contents of a file (inside a Workspace).
		/// Dataform_projects_locations_repositories_workspaces_readFile v1beta1/{workspace}:readFile
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <param name="path">Required. The file's full path including filename, relative to the workspace root.</param>
		/// <returns>Successful response</returns>
		public async Task<ReadFileResponse> Dataform_projects_locations_repositories_workspaces_readFileAsync(string workspace, string path, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":readFile&path=" + (path==null? "" : System.Uri.EscapeDataString(path));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ReadFileResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a directory (inside a Workspace) and all of its contents.
		/// Dataform_projects_locations_repositories_workspaces_removeDirectory v1beta1/{workspace}:removeDirectory
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Dataform_projects_locations_repositories_workspaces_removeDirectoryAsync(string workspace, RemoveDirectoryRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":removeDirectory";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a file (inside a Workspace).
		/// Dataform_projects_locations_repositories_workspaces_removeFile v1beta1/{workspace}:removeFile
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Dataform_projects_locations_repositories_workspaces_removeFileAsync(string workspace, RemoveFileRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":removeFile";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Finds the contents of a given Workspace directory by filter.
		/// Dataform_projects_locations_repositories_workspaces_searchFiles v1beta1/{workspace}:searchFiles
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <param name="filter">Optional. Optional filter for the returned list in filtering format. Filtering is only currently supported on the `path` field. See https://google.aip.dev/160 for details.</param>
		/// <param name="pageSize">Optional. Maximum number of search results to return. The server may return fewer items than requested. If unspecified, the server will pick an appropriate default.</param>
		/// <param name="pageToken">Optional. Page token received from a previous `SearchFilesRequest` call. Provide this to retrieve the subsequent page. When paginating, all other parameters provided to `SearchFilesRequest` must match the call that provided the page token.</param>
		/// <returns>Successful response</returns>
		public async Task<SearchFilesResponse> Dataform_projects_locations_repositories_workspaces_searchFilesAsync(string workspace, string filter, int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":searchFiles&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SearchFilesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Writes to a file (inside a Workspace).
		/// Dataform_projects_locations_repositories_workspaces_writeFile v1beta1/{workspace}:writeFile
		/// </summary>
		/// <param name="workspace">Required. The workspace's name.</param>
		/// <returns>Successful response</returns>
		public async Task<WriteFileResponse> Dataform_projects_locations_repositories_workspaces_writeFileAsync(string workspace, WriteFileRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1/"+ (workspace==null? "" : System.Uri.EscapeDataString(workspace))+":writeFile";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WriteFileResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
