//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A login credential mapped to a user identity. For password credentials, the username to present for Basic auth is the user's username from the user record
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessCredential
	{
		
		/// <summary>
		/// The timestamp of creation of the credential
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public string Created_at { get; set; }
		
		/// <summary>
		/// The type of credential
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public AccessCredentialType Type { get; set; }
		
		/// <summary>
		/// The credential value (e.g. the password)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AccessCredentialType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		password = 0,
	}
	
	/// <summary>
	/// Account information
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Account
	{
		
		/// <summary>
		/// The timestamp when the account was created
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Optional email address associated with the account
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The timestamp of the last update to the account metadata itself (not users or creds)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// The account identifier, not updatable after creation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// State of the account. Disabled accounts prevent member users from logging in, deleting accounts are disabled and pending deletion and will be removed once all owned resources are garbage collected by the system
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<AccountState> State { get; set; }
		
		/// <summary>
		/// The user type (admin vs user). If not specified in a POST request, 'user' is default
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<AccountType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AccountState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleting = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AccountType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		user = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		admin = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		service = 2,
	}
	
	/// <summary>
	/// An account to create/add to the system. If already exists will return 400.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccountCreationRequest
	{
		
		/// <summary>
		/// An optional email to associate with the account for contact purposes
		/// Pattern: [a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?")]
		public string Email { get; set; }
		
		/// <summary>
		/// The account name to use. This will identify the account and must be globally unique in the system.
		/// Required
		/// Pattern: ^[a-zA-Z0-9][a-zA-Z0-9@.!#$+-=^_`~;]{1,126}[a-zA-Z0-9]$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9][a-zA-Z0-9@.!#$+-=^_`~;]{1,126}[a-zA-Z0-9]$")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A summary of account status
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccountStatus
	{
		
		/// <summary>
		/// The status of the account
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<AccountStatusState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AccountStatusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		enabled = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 1,
	}
	
	/// <summary>
	/// The result of adding a single digest to the archive
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisArchiveAddResult
	{
		
		/// <summary>
		/// Details on the status, e.g. the error message
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		/// <summary>
		/// The image digest requested to be added
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
		
		/// <summary>
		/// The status of the archive add operation. Typically either 'archived' or 'error'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<AnalysisArchiveAddResultStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AnalysisArchiveAddResultStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archived = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archiving = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		error = 2,
	}
	
	/// <summary>
	/// A rule for auto-archiving image analysis by time and/or tag-history
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisArchiveTransitionRule
	{
		
		/// <summary>
		/// Matches if the analysis is strictly older than this number of days
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="analysis_age_days")]
		public System.Nullable<System.Int32> Analysis_age_days { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// Which Images to exclude from auto-archiving logic
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclude")]
		public AnalysisArchiveTransitionRuleExclude Exclude { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// This is the maximum number of image analyses an account can have. Can only be set on system_global rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="max_images_per_account")]
		public System.Nullable<System.Int32> Max_images_per_account { get; set; }
		
		/// <summary>
		/// Unique identifier for archive rule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rule_id")]
		public string Rule_id { get; set; }
		
		/// <summary>
		/// A set of selection criteria to match an image by a tagged pullstring based on its components, with regex support in each field
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public ImageSelector Selector { get; set; }
		
		/// <summary>
		/// True if the rule applies to all accounts in the system. This is only available to admin users to update/modify, but all users with permission to list rules can see them
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="system_global")]
		public System.Nullable<System.Boolean> System_global { get; set; }
		
		/// <summary>
		/// Number of images mapped to the tag that are newer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag_versions_newer")]
		public System.Nullable<System.Int32> Tag_versions_newer { get; set; }
		
		/// <summary>
		/// The type of transition to make. If "archive", then archive an image from the working set and remove it from the working set. If "delete", then match against archived images and delete from the archive if match.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transition")]
		public AnalysisArchiveTransitionRuleTransition Transition { get; set; }
	}
	
	/// <summary>
	/// Which Images to exclude from auto-archiving logic
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisArchiveTransitionRuleExclude
	{
		
		/// <summary>
		/// How long the image selected will be excluded from the archive transition
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expiration_days")]
		public System.Nullable<System.Int32> Expiration_days { get; set; }
		
		/// <summary>
		/// A set of selection criteria to match an image by a tagged pullstring based on its components, with regex support in each field
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selector")]
		public ImageSelector Selector { get; set; }
	}
	
	/// <summary>
	/// A set of selection criteria to match an image by a tagged pullstring based on its components, with regex support in each field
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageSelector
	{
		
		/// <summary>
		/// The registry section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "docker.io"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry")]
		public string Registry { get; set; }
		
		/// <summary>
		/// The repository section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "anchore/anchore-engine"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public string Repository { get; set; }
		
		/// <summary>
		/// The tag-only section of a pull string. e.g. with "docker.io/anchore/anchore-engine:latest", this is "latest"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AnalysisArchiveTransitionRuleTransition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archive = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		delete = 1,
	}
	
	/// <summary>
	/// Summary of the transition rule set
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisArchiveRulesSummary
	{
		
		/// <summary>
		/// The number of rules for this account
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// The newest last_updated timestamp from the set of rules
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
	}
	
	/// <summary>
	/// An image reference in the analysis archive for the purposes of loading analysis from the archive into th working set
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisArchiveSource
	{
		
		/// <summary>
		/// The image digest identify the analysis. Archived analyses are based on digest, tag records are restored as analysis is restored.
		/// Required
		/// Pattern: ^sha256:[a-fA-F0-9]{64}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="digest")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^sha256:[a-fA-F0-9]{64}$")]
		public string Digest { get; set; }
	}
	
	/// <summary>
	/// A summarization of the analysis archive, including size, counts, etc. This archive stores image analysis only, never the actual image content or layers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisArchiveSummary
	{
		
		/// <summary>
		/// The timestamp of the most recent archived image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// The total sum of all the bytes stored to the backing storage. Accounts for anchore-applied compression, but not compression by the underlying storage system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_data_bytes")]
		public System.Nullable<System.Int32> Total_data_bytes { get; set; }
		
		/// <summary>
		/// The number of unique images (digests) in the archive
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_image_count")]
		public System.Nullable<System.Int32> Total_image_count { get; set; }
		
		/// <summary>
		/// The number of tag records (registry/repo:tag pull strings) in the archive. This may include repeated tags but will always have a unique tag->digest mapping per record.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_tag_count")]
		public System.Nullable<System.Int32> Total_tag_count { get; set; }
	}
	
	/// <summary>
	/// A rule for auto-archiving image analysis by time and/or tag-history
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisArchiveTransitionHistory
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rule_id")]
		public string Rule_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="transition")]
		public AnalysisArchiveTransitionRuleTransition Transition { get; set; }
		
		/// <summary>
		/// The task that created & updated this entry
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transition_task_id")]
		public string Transition_task_id { get; set; }
	}
	
	/// <summary>
	/// Evaluation Results for an entity (current or last)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisUpdateEval
	{
		
		[System.Runtime.Serialization.DataMember(Name="analysis_status")]
		public string Analysis_status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public string Annotations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="image_digest")]
		public string Image_digest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisUpdateNotification : NotificationBase
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AnalysisUpdateNotificationData Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisUpdateNotificationData : BaseNotificationData
	{
		
		[System.Runtime.Serialization.DataMember(Name="notification_payload")]
		public AnalysisUpdateNotificationPayload Notification_payload { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnalysisUpdateNotificationPayload : GenericNotificationPayload
	{
		
		/// <summary>
		/// List of Corresponding Image Annotations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public string Annotations { get; set; }
		
		/// <summary>
		/// Evaluation Results for an entity (current or last)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="curr_eval")]
		public AnalysisUpdateEval Curr_eval { get; set; }
		
		/// <summary>
		/// Evaluation Results for an entity (current or last)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_eval")]
		public AnalysisUpdateEval Last_eval { get; set; }
	}
	
	/// <summary>
	/// A description of an anchore error code (name, description)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnchoreErrorCode
	{
		
		/// <summary>
		/// Description of the error code
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Error code name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A unique image in the engine. May have multiple tags or references. Unique to an image content across registries or repositories.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnchoreImage
	{
		
		/// <summary>
		/// A state value for the current status of the analysis progress of the image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="analysis_status")]
		public System.Nullable<AnchoreImageAnalysis_status> Analysis_status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public string Annotations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
		
		/// <summary>
		/// A metadata content record for a specific image, containing different content type entries
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image_content")]
		public ImageContent Image_content { get; set; }
		
		/// <summary>
		/// Details specific to an image reference and type such as tag and image source
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image_detail")]
		public ImageDetail[] Image_detail { get; set; }
		
		/// <summary>
		/// State of the image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image_status")]
		public System.Nullable<AnchoreImageImage_status> Image_status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// The version of the record, used for internal schema updates and data migrations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="record_version")]
		public string Record_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AnchoreImageAnalysis_status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_analyzed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analyzing = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analyzed = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analysis_failed = 3,
	}
	
	/// <summary>
	/// A metadata content record for a specific image, containing different content type entries
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageContent
	{
	}
	
	/// <summary>
	/// A metadata detail record for a specific image. Multiple detail records may map a single catalog image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageDetail
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dockerfile")]
		public string Dockerfile { get; set; }
		
		/// <summary>
		/// Full docker-pullable digest string including the registry url and repository necessary get the image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fulldigest")]
		public string Fulldigest { get; set; }
		
		/// <summary>
		/// Full docker-pullable tag string referencing the image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fulltag")]
		public string Fulltag { get; set; }
		
		/// <summary>
		/// The parent Anchore Image record to which this detail maps
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageId")]
		public string ImageId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registry")]
		public string Registry { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="repo")]
		public string Repo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AnchoreImageImage_status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		inactive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disabled = 2,
	}
	
	/// <summary>
	/// A unique image in the engine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AnchoreImageTagSummary
	{
		
		[System.Runtime.Serialization.DataMember(Name="analysis_status")]
		public string Analysis_status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="analyzed_at")]
		public System.Nullable<System.Int32> Analyzed_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.Int32> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fulltag")]
		public string Fulltag { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageId")]
		public string ImageId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="image_status")]
		public string Image_status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="parentDigest")]
		public string ParentDigest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tag_detected_at")]
		public System.Nullable<System.Int32> Tag_detected_at { get; set; }
	}
	
	/// <summary>
	/// Simple key/value pairs where the value may be optional
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Annotations
	{
	}
	
	/// <summary>
	/// Generic HTTP API error response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ApiErrorResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// Details structure for additional information about the error if available. Content and structure will be error specific.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="error_type")]
		public string Error_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// A summarization of the available archives, a place to for long-term storage of audit, analysis, or other data to remove it from the system's working set but keep it available.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArchiveSummary
	{
		
		/// <summary>
		/// A summarization of the analysis archive, including size, counts, etc. This archive stores image analysis only, never the actual image content or layers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="images")]
		public AnalysisArchiveSummary Images { get; set; }
		
		/// <summary>
		/// Summary of the transition rule set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public AnalysisArchiveRulesSummary Rules { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArchivedAnalysis
	{
		
		[System.Runtime.Serialization.DataMember(Name="analyzed_at")]
		public System.Nullable<System.DateTimeOffset> Analyzed_at { get; set; }
		
		/// <summary>
		/// User provided annotations as key-value pairs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public string Annotations { get; set; }
		
		/// <summary>
		/// The size, in bytes, of the analysis archive file
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archive_size_bytes")]
		public System.Nullable<System.Int32> Archive_size_bytes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The image digest (digest of the manifest describing the image, per docker spec)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
		
		/// <summary>
		/// List of tags associated with the image digest
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image_detail")]
		public TagEntry[] Image_detail { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// The digest of a parent manifest (for manifest-list images)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentDigest")]
		public string ParentDigest { get; set; }
		
		/// <summary>
		/// The archival status
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ArchivedAnalysisStatus> Status { get; set; }
	}
	
	/// <summary>
	/// A docker-pullable tag value as well as deconstructed components
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagEntry
	{
		
		/// <summary>
		/// The timestamp at which the Anchore Engine detected this tag was mapped to the image digest. Does not necessarily indicate when the tag was actually pushed to the registry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detected_at")]
		public System.Nullable<System.DateTimeOffset> Detected_at { get; set; }
		
		/// <summary>
		/// The pullable string for the tag. E.g. "docker.io/library/node:latest"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pullstring")]
		public string Pullstring { get; set; }
		
		/// <summary>
		/// The registry hostname:port section of the pull string
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry")]
		public string Registry { get; set; }
		
		/// <summary>
		/// The repository section of the pull string
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public string Repository { get; set; }
		
		/// <summary>
		/// The tag-only section of the pull string
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ArchivedAnalysisStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archiving = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		archived = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleting = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleted = 3,
	}
	
	/// <summary>
	/// Every notification has a payload, which follows this basic structure
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BaseNotificationData
	{
		
		[System.Runtime.Serialization.DataMember(Name="notification_type")]
		public string Notification_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notification_user")]
		public string Notification_user { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notification_user_email")]
		public string Notification_user_email { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CVSSV2Scores
	{
		
		[System.Runtime.Serialization.DataMember(Name="base_score")]
		public System.Nullable<System.Double> Base_score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exploitability_score")]
		public System.Nullable<System.Double> Exploitability_score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="impact_score")]
		public System.Nullable<System.Double> Impact_score { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CVSSV3Scores
	{
		
		[System.Runtime.Serialization.DataMember(Name="base_score")]
		public System.Nullable<System.Double> Base_score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exploitability_score")]
		public System.Nullable<System.Double> Exploitability_score { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="impact_score")]
		public System.Nullable<System.Double> Impact_score { get; set; }
	}
	
	/// <summary>
	/// File content listings from images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ContentFilesResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ContentFilesResponseContent[] ContentFilesResponseContent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
	}
	
	public class ContentFilesResponseContent
	{
		
		[System.Runtime.Serialization.DataMember(Name="filename")]
		public string Filename { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gid")]
		public System.Nullable<System.Int32> Gid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="linkdest")]
		public string Linkdest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public string Mode { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sha256")]
		public string Sha256 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uid")]
		public System.Nullable<System.Int32> Uid { get; set; }
	}
	
	/// <summary>
	/// Java package content listings from images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ContentJAVAPackageResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ContentJAVAPackageResponseContent[] ContentJAVAPackageResponseContent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
	}
	
	public class ContentJAVAPackageResponseContent
	{
		
		/// <summary>
		/// A list of Common Platform Enumerations that may uniquely identify the package
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpes")]
		public string[] Cpes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="implementation-version")]
		public string Implementation_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maven-version")]
		public string Maven_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="package")]
		public string Package { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="specification-version")]
		public string Specification_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Malware listing response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ContentMalwareResponse
	{
		
		/// <summary>
		/// List of malware scan results, one per scanner configured to run
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public MalwareScan[] Content { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
	}
	
	/// <summary>
	/// A single scan from a scanner
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MalwareScan
	{
		
		/// <summary>
		/// Indicates if the scanner is enabled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="findings")]
		public MalwareScanFindings[] MalwareScanFindings { get; set; }
		
		/// <summary>
		/// Open schema for scanner-specific metadata related to the scan result
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// The name of the scanner that produced the finding
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scanner")]
		public string Scanner { get; set; }
	}
	
	public class MalwareScanFindings
	{
		
		/// <summary>
		/// A path for a file in the image's rootfs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The malware signature found at the path
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signature")]
		public string Signature { get; set; }
	}
	
	/// <summary>
	/// Package content listings from images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ContentPackageResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public ContentPackageResponseContent[] ContentPackageResponseContent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
	}
	
	public class ContentPackageResponseContent
	{
		
		/// <summary>
		/// A list of Common Platform Enumerations that may uniquely identify the package
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpes")]
		public string[] Cpes { get; set; }
		
		/// <summary>
		/// Deprecated in favor of the 'licenses' field"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="license")]
		public string License { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public string[] Licenses { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="origin")]
		public string Origin { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="package")]
		public string Package { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="size")]
		public string Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Generic wrapper for content listings from images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ContentResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string[] Content { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="content_type")]
		public string Content_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
	}
	
	/// <summary>
	/// Image deletion response containing status and details
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteImageResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
		
		/// <summary>
		/// Current status of the image deletion
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public DeleteImageResponseStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DeleteImageResponseStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_found = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleting = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		delete_failed = 2,
	}
	
	/// <summary>
	/// A collection of event subcategories
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventCategory
	{
		
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subcategories")]
		public EventSubcategory[] Subcategories { get; set; }
	}
	
	/// <summary>
	/// A collection of events related to each other
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventSubcategory
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="events")]
		public EventDescription[] Events { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A description of an event type
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventDescription
	{
		
		/// <summary>
		/// The message associated with the event type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The event type. The last component of the fully-qualified event_type (category.subcategory.event)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The type of resource this event is generated from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resource_type")]
		public string Resource_type { get; set; }
		
		/// <summary>
		/// The fully qualified event type as would be seen in the event payload
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A record of occurance of an asynchronous event triggered either by system or by user activity
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="event")]
		public EventResponseEvent Event { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="generated_uuid")]
		public string Generated_uuid { get; set; }
	}
	
	public class EventResponseEvent
	{
		
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string Details { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="level")]
		public string Level { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public EventResponseEventResource Resource { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public EventResponseEventSource Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public System.Nullable<System.DateTimeOffset> Timestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class EventResponseEventResource
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="user_id")]
		public string User_id { get; set; }
	}
	
	public class EventResponseEventSource
	{
		
		[System.Runtime.Serialization.DataMember(Name="base_url")]
		public string Base_url { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hostid")]
		public string Hostid { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="request_id")]
		public string Request_id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="servicename")]
		public string Servicename { get; set; }
	}
	
	/// <summary>
	/// Response envelope for paginated listing of events
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EventsList
	{
		
		/// <summary>
		/// Number of events in this page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="item_count")]
		public System.Nullable<System.Int32> Item_count { get; set; }
		
		/// <summary>
		/// Boolean flag, True indicates there are more events and False otherwise
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public System.Nullable<System.Boolean> Next_page { get; set; }
		
		/// <summary>
		/// Page number of this result set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public System.Nullable<System.Int32> Page { get; set; }
		
		/// <summary>
		/// List of events
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public EventResponse[] Results { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FeedGroupMetadata
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_sync")]
		public System.Nullable<System.DateTimeOffset> Last_sync { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="record_count")]
		public System.Nullable<System.Int32> Record_count { get; set; }
	}
	
	/// <summary>
	/// Metadata on a single feed based on what the engine finds from querying the endpoints
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FeedMetadata
	{
		
		/// <summary>
		/// Date the metadata record was created in engine (first seen on source)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public FeedGroupMetadata[] Groups { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_full_sync")]
		public System.Nullable<System.DateTimeOffset> Last_full_sync { get; set; }
		
		/// <summary>
		/// name of the feed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Date the metadata was last updated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_at")]
		public System.Nullable<System.DateTimeOffset> Updated_at { get; set; }
	}
	
	/// <summary>
	/// The result of a sync of a single feed
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FeedSyncResult
	{
		
		/// <summary>
		/// The name of the feed synced
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="feed")]
		public string Feed { get; set; }
		
		/// <summary>
		/// Array of group sync results
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groups")]
		public GroupSyncResult[] Groups { get; set; }
		
		/// <summary>
		/// The result of the sync operations, either co
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GroupSyncResultStatus Status { get; set; }
		
		/// <summary>
		/// The duratin, in seconds, of the sync of the feed, the sum of all the group syncs
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_time_seconds")]
		public System.Nullable<System.Double> Total_time_seconds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GroupSyncResult
	{
		
		/// <summary>
		/// The name of the group
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<GroupSyncResultStatus> Status { get; set; }
		
		/// <summary>
		/// The duration of the group sync in seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total_time_seconds")]
		public System.Nullable<System.Double> Total_time_seconds { get; set; }
		
		/// <summary>
		/// The number of images updated by the this group sync, across all accounts. This is typically only non-zero for vulnerability feeds which update images' vulnerability results during the sync.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_image_count")]
		public System.Nullable<System.Int32> Updated_image_count { get; set; }
		
		/// <summary>
		/// The number of feed data records synced down as either updates or new records
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updated_record_count")]
		public System.Nullable<System.Int32> Updated_record_count { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GroupSyncResultStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failure = 1,
	}
	
	/// <summary>
	/// The retrieved file entry including content (b64 encoded)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FileContentSearchResult
	{
		
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public RegexContentMatch[] Matches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// Match of a named regex on a file
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegexContentMatch
	{
		
		/// <summary>
		/// A list of line numbers in the file that matched the regex
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lines")]
		public int[] Lines { get; set; }
		
		/// <summary>
		/// The name associated with the regular expression
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The regular expression used for the match
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regex")]
		public string Regex { get; set; }
	}
	
	/// <summary>
	/// A description of the set of gates available in this engine and the triggers and parameters supported
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GateSpec
	{
		
		/// <summary>
		/// Description of the gate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Gate name, as it would appear in a policy document
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// State of the gate and transitively all triggers it contains if not 'active'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<GateSpecState> State { get; set; }
		
		/// <summary>
		/// The name of another trigger that supercedes this on functionally if this is deprecated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="superceded_by")]
		public string Superceded_by { get; set; }
		
		/// <summary>
		/// List of the triggers that can fire for this Gate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="triggers")]
		public TriggerSpec[] Triggers { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GateSpecState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deprecated = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eol = 2,
	}
	
	/// <summary>
	/// Definition of a trigger and its parameters
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TriggerSpec
	{
		
		/// <summary>
		/// Trigger description for what it tests and when it will fire during evaluation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Name of the trigger as it would appear in a policy document
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of parameters that are valid for this trigger
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameters")]
		public TriggerParamSpec[] Parameters { get; set; }
		
		/// <summary>
		/// State of the trigger
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public GateSpecState State { get; set; }
		
		/// <summary>
		/// The name of another trigger that supercedes this on functionally if this is deprecated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="superceded_by")]
		public string Superceded_by { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TriggerParamSpec
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// An example value for the parameter (encoded as a string if the parameter is an object or list type)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="example")]
		public string Example { get; set; }
		
		/// <summary>
		/// Parameter name as it appears in policy document
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Is this a required parameter or optional
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required")]
		public System.Nullable<System.Boolean> Required { get; set; }
		
		/// <summary>
		/// State of the trigger parameter
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public GateSpecState State { get; set; }
		
		/// <summary>
		/// The name of another trigger that supercedes this on functionally if this is deprecated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="superceded_by")]
		public string Superceded_by { get; set; }
		
		/// <summary>
		/// If present, a definition for validation of input. Typically a jsonschema object that can be used to validate an input against.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validator")]
		public string Validator { get; set; }
	}
	
	/// <summary>
	/// Parent class for Notification Payloads
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GenericNotificationPayload
	{
		
		[System.Runtime.Serialization.DataMember(Name="notificationId")]
		public string NotificationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscription_key")]
		public string Subscription_key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscription_type")]
		public string Subscription_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
	}
	
	/// <summary>
	/// Analysis report json to be imported
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageAnalysisReport
	{
	}
	
	/// <summary>
	/// A request to add an image to be watched and analyzed by the engine. Optionally include the dockerfile content. Either source, digest or tag must be present.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageAnalysisRequest
	{
		
		/// <summary>
		/// Annotations to be associated with the added image in key/value form
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public string Annotations { get; set; }
		
		/// <summary>
		/// Optional override of the image creation time, only honored when both tag and digest are also supplied  e.g. 2018-10-17T18:14:00Z. Deprecated in favor of the 'source' field
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// A digest string for an image, maybe a pull string or just a digest. e.g. nginx@sha256:123 or sha256:abc123. If a pull string, it must have same regisry/repo as the tag field. Deprecated in favor of the 'source' field
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
		
		/// <summary>
		/// Base64 encoded content of the dockerfile for the image, if available. Deprecated in favor of the 'source' field.
		/// Pattern: ^[a-zA-Z0-9+/=]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerfile")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9+/=]+$")]
		public string Dockerfile { get; set; }
		
		/// <summary>
		/// Optional. The type of image this is adding, defaults to "docker". This can be ommitted until multiple image types are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image_type")]
		public string Image_type { get; set; }
		
		/// <summary>
		/// A set of analysis source types. Only one may be set in any given request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public ImageSource Source { get; set; }
		
		/// <summary>
		/// Full pullable tag reference for image. e.g. docker.io/nginx:latest. Deprecated in favor of the 'source' field
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	/// <summary>
	/// A set of analysis source types. Only one may be set in any given request.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageSource
	{
		
		/// <summary>
		/// An image reference in the analysis archive for the purposes of loading analysis from the archive into th working set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archive")]
		public AnalysisArchiveSource Archive { get; set; }
		
		/// <summary>
		/// An image reference using a digest in a registry, includes some extra tag and timestamp info in addition to the pull string to allow proper tag history reconstruction.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public RegistryDigestSource Digest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="import")]
		public ImageImportManifest Import { get; set; }
		
		/// <summary>
		/// An image reference using a tag in a registry, this is the most common source type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public RegistryTagSource Tag { get; set; }
	}
	
	/// <summary>
	/// An image reference using a digest in a registry, includes some extra tag and timestamp info in addition to the pull string to allow proper tag history reconstruction.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegistryDigestSource
	{
		
		/// <summary>
		/// Optional override of the image creation time to support proper tag history construction in cases of out-of-order analysis compared to registry history for the tag
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creation_timestamp_override")]
		public System.Nullable<System.DateTimeOffset> Creation_timestamp_override { get; set; }
		
		/// <summary>
		/// Base64 encoded content of the dockerfile used to build the image, if available.
		/// Pattern: ^[a-zA-Z0-9+/=]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerfile")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9+/=]+$")]
		public string Dockerfile { get; set; }
		
		/// <summary>
		/// A digest-based pullstring (e.g. docker.io/nginx@sha256:123abc)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pullstring")]
		public string Pullstring { get; set; }
		
		/// <summary>
		/// A valid docker tag reference (e.g. docker.io/nginx:latest) that will be associated with the image but not used to pull the image.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageImportManifest
	{
		
		/// <summary>
		/// Digest of content to use in the final import
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public ImportContentDigests Contents { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
		
		/// <summary>
		/// An "imageId" as used by Docker if available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="local_image_id")]
		public string Local_image_id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operation_uuid")]
		public string Operation_uuid { get; set; }
		
		/// <summary>
		/// The digest of the images's manifest-list parent if it was accessed from a multi-arch tag where the tag pointed to a manifest-list. This allows preservation of that relationship in the data
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent_digest")]
		public string Parent_digest { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	/// <summary>
	/// Digest of content to use in the final import
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportContentDigests
	{
		
		/// <summary>
		/// Digest for reference content for dockerfile
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerfile")]
		public string Dockerfile { get; set; }
		
		/// <summary>
		/// Digest for reference content for image config
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image_config")]
		public string Image_config { get; set; }
		
		/// <summary>
		/// Digest to reference content for the image manifest
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="manifest")]
		public string Manifest { get; set; }
		
		/// <summary>
		/// Digest to use for the packages content
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="packages")]
		public string Packages { get; set; }
		
		/// <summary>
		/// Digest for reference content for parent manifest
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent_manifest")]
		public string Parent_manifest { get; set; }
	}
	
	/// <summary>
	/// An image reference using a tag in a registry, this is the most common source type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegistryTagSource
	{
		
		/// <summary>
		/// Base64 encoded content of the dockerfile used to build the image, if available.
		/// Pattern: ^[a-zA-Z0-9+/=]+$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerfile")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9+/=]+$")]
		public string Dockerfile { get; set; }
		
		/// <summary>
		/// A docker pull string (e.g. docker.io/nginx:latest, or docker.io/nginx@sha256:abd) to retrieve the image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pullstring")]
		public string Pullstring { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageContentDeleteResponse
	{
	}
	
	/// <summary>
	/// Filter for an image list by id, tag, or digest, but not both
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageFilter
	{
		
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageImportContentResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
	}
	
	/// <summary>
	/// An import record, creating a unique identifier for referencing the operation as well as its state
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageImportOperation
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expires_at")]
		public System.Nullable<System.DateTimeOffset> Expires_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ImageImportOperationStatus> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="uuid")]
		public string Uuid { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ImageImportOperationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		queued = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		processing = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		complete = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		expired = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImagePackageManifest
	{
		
		[System.Runtime.Serialization.DataMember(Name="artifactRelationships")]
		public ImportPackageRelationship[] ArtifactRelationships { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="artifacts")]
		public ImportPackage[] Artifacts { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="descriptor")]
		public ImportDescriptor Descriptor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="distro")]
		public ImportDistribution Distro { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public ImportSchema Schema { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public ImportSource Source { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportPackageRelationship
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="child")]
		public string Child { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public string Parent { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportPackage
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cpes")]
		public string[] Cpes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="foundBy")]
		public string FoundBy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public string[] Licenses { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public ImportPackageLocation[] Locations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="metadataType")]
		public string MetadataType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="purl")]
		public string Purl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportPackageLocation
	{
		
		[System.Runtime.Serialization.DataMember(Name="layerID")]
		public string LayerID { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportDescriptor
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportDistribution
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="idLike")]
		public string IdLike { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportSchema
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportSource
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="target")]
		public object Target { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// A reference to an image
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageRef
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ImageRefType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ImageRefType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tag = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		digest = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		id = 2,
	}
	
	/// <summary>
	/// A summary of an image identity, including digest, id (if available), and any tags known to have ever been mapped to the digest
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageReference
	{
		
		/// <summary>
		/// Timestamp, in rfc3339 format, indicating when the image state became 'analyzed' in Anchore Engine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="analyzed_at")]
		public string Analyzed_at { get; set; }
		
		/// <summary>
		/// The image digest
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
		
		/// <summary>
		/// The image id if available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tag_history")]
		public TagEntry[] Tag_history { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageSelectionRule
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A reference to an image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image")]
		public ImageRef Image { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="registry")]
		public string Registry { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public string Repository { get; set; }
	}
	
	/// <summary>
	/// An image record that contains packages
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageWithPackages
	{
		
		/// <summary>
		/// A summary of an image identity, including digest, id (if available), and any tags known to have ever been mapped to the digest
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public ImageReference Image { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="packages")]
		public PackageReference[] Packages { get; set; }
	}
	
	/// <summary>
	/// A record of a software item which is vulnerable or carries a fix for a vulnerability
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PackageReference
	{
		
		/// <summary>
		/// Package name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Package type (e.g. package, rpm, deb, apk, jar, npm, gem, ...)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// A version for the package. If null, then references all versions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		/// <summary>
		/// Whether a vendor will or will not fix a vulnerabitlity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="will_not_fix")]
		public System.Nullable<System.Boolean> Will_not_fix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocalAnalysisSource
	{
		
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public string Digest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MappingRule
	{
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A reference to an image
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="image")]
		public ImageRef Image { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Optional single policy to evalute, if set will override any value in policy_ids, for backwards compatibility. Generally, policy_ids should be used even with a array of length 1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy_id")]
		public string Policy_id { get; set; }
		
		/// <summary>
		/// List of policyIds to evaluate in order, to completion
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy_ids")]
		public string[] Policy_ids { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="registry")]
		public string Registry { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repository")]
		public string Repository { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="whitelist_ids")]
		public string[] Whitelist_ids { get; set; }
	}
	
	/// <summary>
	/// Generic wrapper for metadata listings from images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MetadataResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public object Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="metadata_type")]
		public string Metadata_type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NativeSbom
	{
	}
	
	/// <summary>
	/// base object for Notifications (every notification has this basic structure)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationBase
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.Int32> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dataId")]
		public string DataId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.Int32> Last_updated { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="max_tries")]
		public System.Nullable<System.Int32> Max_tries { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="queueId")]
		public string QueueId { get; set; }
		
		[System.ComponentModel.DefaultValue("active")]
		[System.Runtime.Serialization.DataMember(Name="record_state_key")]
		public string Record_state_key { get; set; } = "active";
		
		[System.Runtime.Serialization.DataMember(Name="record_state_val")]
		public string Record_state_val { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tries")]
		public System.Nullable<System.Int32> Tries { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NvdDataObject
	{
		
		[System.Runtime.Serialization.DataMember(Name="cvss_v2")]
		public CVSSV2Scores Cvss_v2 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cvss_v3")]
		public CVSSV3Scores Cvss_v3 { get; set; }
		
		/// <summary>
		/// NVD Vulnerability ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Pagination wrapped list of images that match some filter
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PaginatedImageList : PaginationProperties
	{
		
		[System.Runtime.Serialization.DataMember(Name="images")]
		public ImageWithPackages[] Images { get; set; }
	}
	
	/// <summary>
	/// A paginated listing of vulnerability records sorted by ID in descending order
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PaginatedVulnerabilityList : PaginationProperties
	{
		
		/// <summary>
		/// The listing of matching vulnerabilities for the query subject to pagination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vulnerabilities")]
		public StandaloneVulnerability[] Vulnerabilities { get; set; }
	}
	
	/// <summary>
	/// A single vulnerability record in a single namespace, the unique key is the combination of the id and namespace
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StandaloneVulnerability
	{
		
		/// <summary>
		/// The array of packages (typically packages) that are vulnerable-to or provide fixes-for this vulnerability
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="affected_packages")]
		public PackageReference[] Affected_packages { get; set; }
		
		/// <summary>
		/// Description of the vulnerability if available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Vulnerability identifier. May be CVE-X, RHSA-X, etc. Not necessarily unique across namespaces
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// URL for the upstream CVE record in the reporting source (e.g. ubuntu security tracker)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="link")]
		public string Link { get; set; }
		
		/// <summary>
		/// The namespace for the vulnerability record to avoid conflicts for the same id in different distros or sources (e.g. deb vs ubuntu for same CVE)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespace")]
		public string Namespace { get; set; }
		
		/// <summary>
		/// List of Nvd Data objects
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nvd_data")]
		public NvdDataObject[] Nvd_data { get; set; }
		
		/// <summary>
		/// List of references including
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="references")]
		public VulnerabilityReference[] References { get; set; }
		
		/// <summary>
		/// Severity label specific to the namepsace
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public System.Nullable<StandaloneVulnerabilitySeverity> Severity { get; set; }
		
		/// <summary>
		/// List of Vendor Data objects
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vendor_data")]
		public VendorDataObject[] Vendor_data { get; set; }
	}
	
	/// <summary>
	/// An external link/reference
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VulnerabilityReference
	{
		
		/// <summary>
		/// The reference source
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// The reference url
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum StandaloneVulnerabilitySeverity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Unknown = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Negligible = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Low = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Medium = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		High = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		Critical = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VendorDataObject
	{
		
		[System.Runtime.Serialization.DataMember(Name="cvss_v2")]
		public CVSSV2Scores Cvss_v2 { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cvss_v3")]
		public CVSSV3Scores Cvss_v3 { get; set; }
		
		/// <summary>
		/// Vendor Vulnerability ID
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	/// <summary>
	/// Pagination wrapped list of images with vulnerabilties that match some filter
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PaginatedVulnerableImageList : PaginationProperties
	{
		
		[System.Runtime.Serialization.DataMember(Name="images")]
		public VulnerableImage[] Images { get; set; }
	}
	
	/// <summary>
	/// A record of an image vulnerable to some known vulnerability. Includes vulnerable package information
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VulnerableImage
	{
		
		[System.Runtime.Serialization.DataMember(Name="affected_packages")]
		public VulnerablePackageReference[] Affected_packages { get; set; }
		
		/// <summary>
		/// A summary of an image identity, including digest, id (if available), and any tags known to have ever been mapped to the digest
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public ImageReference Image { get; set; }
	}
	
	/// <summary>
	/// A record of a software item which is vulnerable or carries a fix for a vulnerability
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VulnerablePackageReference
	{
		
		/// <summary>
		/// Package name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Vulnerability namespace of affected package
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespace")]
		public string Namespace { get; set; }
		
		/// <summary>
		/// Severity of vulnerability affecting package
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public string Severity { get; set; }
		
		/// <summary>
		/// Package type (e.g. package, rpm, deb, apk, jar, npm, gem, ...)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// A version for the package. If null, then references all versions
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Properties for common pagination handling to be included in any wrapping object that needs pagination elements
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PaginationProperties
	{
		
		/// <summary>
		/// True if additional pages exist (page + 1) or False if this is the last page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next_page")]
		public string Next_page { get; set; }
		
		/// <summary>
		/// The page number returned (should match the requested page query string param)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="page")]
		public string Page { get; set; }
		
		/// <summary>
		/// The number of items sent in this response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="returned_count")]
		public System.Nullable<System.Int32> Returned_count { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Policy
	{
		
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public PolicyRule[] Rules { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// A rule that defines and decision value if the match is found true for a given image.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PolicyRule
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="action")]
		public PolicyRuleAction Action { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gate")]
		public string Gate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="params")]
		public PolicyRuleParams[] PolicyRuleParams { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trigger")]
		public string Trigger { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PolicyRuleAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GO = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WARN = 2,
	}
	
	public class PolicyRuleParams
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A bundle containing a set of policies, whitelists, and rules for mapping them to specific images
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PolicyBundle
	{
		
		/// <summary>
		/// List of mapping rules that define which images should always result in a STOP/FAIL policy result regardless of policy content or presence in whitelisted_images
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blacklisted_images")]
		public ImageSelectionRule[] Blacklisted_images { get; set; }
		
		/// <summary>
		/// Description of the bundle, human readable
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Id of the bundle
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Mapping rules for defining which policy and whitelist(s) to apply to an image based on a match of the image tag or id. Evaluated in order.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mappings")]
		public MappingRule[] Mappings { get; set; }
		
		/// <summary>
		/// Human readable name for the bundle
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Policies which define the go/stop/warn status of an image using rule matches on image properties
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policies")]
		public Policy[] Policies { get; set; }
		
		/// <summary>
		/// Version id for this bundle format
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		/// <summary>
		/// List of mapping rules that define which images should always be passed (unless also on the blacklist), regardless of policy result.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="whitelisted_images")]
		public ImageSelectionRule[] Whitelisted_images { get; set; }
		
		/// <summary>
		/// Whitelists which define which policy matches to disregard explicitly in the final policy decision
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="whitelists")]
		public Whitelist[] Whitelists { get; set; }
	}
	
	/// <summary>
	/// A collection of whitelist items to match a policy evaluation against.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Whitelist
	{
		
		[System.Runtime.Serialization.DataMember(Name="comment")]
		public string Comment { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public WhitelistItem[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Identifies a specific gate and trigger match from a policy against an image and indicates it should be ignored in final policy decisions
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WhitelistItem
	{
		
		/// <summary>
		/// Pattern: ^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:\:\d+)?[A-Z]?$
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expires_on")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:\:\d+)?[A-Z]?$")]
		public System.Nullable<System.DateTimeOffset> Expires_on { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gate")]
		public string Gate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trigger_id")]
		public string Trigger_id { get; set; }
	}
	
	/// <summary>
	/// A policy bundle plus some metadata
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PolicyBundleRecord
	{
		
		/// <summary>
		/// True if the bundle is currently defined to be used automatically
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// The bundle's identifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policyId")]
		public string PolicyId { get; set; }
		
		/// <summary>
		/// Source location of where the policy bundle originated
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy_source")]
		public string Policy_source { get; set; }
		
		/// <summary>
		/// A bundle containing a set of policies, whitelists, and rules for mapping them to specific images
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policybundle")]
		public PolicyBundle Policybundle { get; set; }
		
		/// <summary>
		/// UserId of the user that owns the bundle
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PolicyEvalNotification : NotificationBase
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PolicyEvalNotificationData Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PolicyEvalNotificationData : BaseNotificationData
	{
		
		[System.Runtime.Serialization.DataMember(Name="notification_payload")]
		public PolicyEvalNotificationPayload Notification_payload { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PolicyEvalNotificationPayload : GenericNotificationPayload
	{
		
		/// <summary>
		/// List of Corresponding Image Annotations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public string Annotations { get; set; }
		
		/// <summary>
		/// The Current Policy Evaluation result
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="curr_eval")]
		public string Curr_eval { get; set; }
		
		/// <summary>
		/// The Previous Policy Evaluation result
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_eval")]
		public string Last_eval { get; set; }
	}
	
	/// <summary>
	/// Evaluation response object
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PolicyEvaluation
	{
	}
	
	/// <summary>
	/// A registry entry describing the endpoint and credentials for a registry to pull images from
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegistryConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="last_upated")]
		public System.Nullable<System.DateTimeOffset> Last_upated { get; set; }
		
		/// <summary>
		/// hostname:port string for accessing the registry, as would be used in a docker pull operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry")]
		public string Registry { get; set; }
		
		/// <summary>
		/// human readable name associated with registry record
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_name")]
		public string Registry_name { get; set; }
		
		/// <summary>
		/// Type of registry
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_type")]
		public string Registry_type { get; set; }
		
		/// <summary>
		/// Username portion of credential to use for this registry
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_user")]
		public string Registry_user { get; set; }
		
		/// <summary>
		/// Use TLS/SSL verification for the registry URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_verify")]
		public System.Nullable<System.Boolean> Registry_verify { get; set; }
		
		/// <summary>
		/// Engine user that owns this registry entry
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
	}
	
	/// <summary>
	/// A registry record describing the endpoint and credentials for a registry
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegistryConfigurationRequest
	{
		
		/// <summary>
		/// hostname:port string for accessing the registry, as would be used in a docker pull operation. May include some or all of a repository and wildcards (e.g. docker.io/library/* or gcr.io/myproject/myrepository)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry")]
		public string Registry { get; set; }
		
		/// <summary>
		/// human readable name associated with registry record
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_name")]
		public string Registry_name { get; set; }
		
		/// <summary>
		/// Password portion of credential to use for this registry
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_pass")]
		public string Registry_pass { get; set; }
		
		/// <summary>
		/// Type of registry
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_type")]
		public string Registry_type { get; set; }
		
		/// <summary>
		/// Username portion of credential to use for this registry
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_user")]
		public string Registry_user { get; set; }
		
		/// <summary>
		/// Use TLS/SSL verification for the registry URL
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registry_verify")]
		public System.Nullable<System.Boolean> Registry_verify { get; set; }
	}
	
	/// <summary>
	/// The retrieved file entry including content (b64 encoded)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RetrievedFile
	{
		
		[System.Runtime.Serialization.DataMember(Name="b64_content")]
		public string B64_content { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// The retrieved file entry including content (b64 encoded)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecretSearchResult
	{
		
		[System.Runtime.Serialization.DataMember(Name="matches")]
		public RegexContentMatch[] Matches { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// A service status record
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Service
	{
		
		/// <summary>
		/// The url to reach the service, including port as needed
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="base_url")]
		public string Base_url { get; set; }
		
		/// <summary>
		/// The unique id of the host on which the service is executing
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostid")]
		public string Hostid { get; set; }
		
		/// <summary>
		/// System status response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service_detail")]
		public StatusResponse Service_detail { get; set; }
		
		/// <summary>
		/// Registered service name
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="servicename")]
		public string Servicename { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<System.Boolean> Status { get; set; }
		
		/// <summary>
		/// A state indicating the condition of the service. Normal operation is 'registered'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status_message")]
		public string Status_message { get; set; }
		
		/// <summary>
		/// The version of the service as reported by the service implementation on registration
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// System status response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatusResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="available")]
		public System.Nullable<System.Boolean> Available { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="busy")]
		public System.Nullable<System.Boolean> Busy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="db_version")]
		public string Db_version { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="up")]
		public System.Nullable<System.Boolean> Up { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Version information for a service
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceVersion
	{
		
		/// <summary>
		/// Api Version string
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="api")]
		public ServiceVersionApi Api { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="db")]
		public ServiceVersionDb Db { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="service")]
		public ServiceVersionService Service { get; set; }
	}
	
	public class ServiceVersionApi
	{
		
		/// <summary>
		/// Semantic version of the api
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	public class ServiceVersionDb
	{
		
		/// <summary>
		/// Semantic version of the db schema
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema_version")]
		public string Schema_version { get; set; }
	}
	
	public class ServiceVersionService
	{
		
		/// <summary>
		/// Semantic Version string of the service implementation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Subscription entry
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Subscription
	{
		
		/// <summary>
		/// Is the subscription currently active
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// the unique id for this subscription record
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription_id")]
		public string Subscription_id { get; set; }
		
		/// <summary>
		/// The key value that the subscription references. E.g. a tag value or a repo name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription_key")]
		public string Subscription_key { get; set; }
		
		/// <summary>
		/// The type of the subscription
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription_type")]
		public string Subscription_type { get; set; }
		
		/// <summary>
		/// The value of the subscription target
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription_value")]
		public string Subscription_value { get; set; }
		
		/// <summary>
		/// The userId of the subscribed user
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userId")]
		public string UserId { get; set; }
	}
	
	/// <summary>
	/// A subscription entry to add to the system
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubscriptionRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="subscription_key")]
		public string Subscription_key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscription_type")]
		public string Subscription_type { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subscription_value")]
		public string Subscription_value { get; set; }
	}
	
	/// <summary>
	/// A modification to a subscription entry to change its status or value
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubscriptionUpdate
	{
		
		/// <summary>
		/// Toggle the subscription processing on or off
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// The new subscription value, e.g. the new tag to be subscribed to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription_value")]
		public string Subscription_value { get; set; }
	}
	
	/// <summary>
	/// System status response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SystemStatusResponse
	{
		
		/// <summary>
		/// A list of service objects
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service_states")]
		public Service[] Service_states { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagUpdateNotification : NotificationBase
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TagUpdateNotificationData Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagUpdateNotificationData : BaseNotificationData
	{
		
		[System.Runtime.Serialization.DataMember(Name="notification_payload")]
		public TagUpdateNotificationPayload Notification_payload { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagUpdateNotificationPayload : GenericNotificationPayload
	{
		
		/// <summary>
		/// List of Corresponding Image Annotations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public string Annotations { get; set; }
		
		/// <summary>
		/// A list containing the current image digest
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="curr_eval")]
		public string[] Curr_eval { get; set; }
		
		/// <summary>
		/// A list containing the previous image digests
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_eval")]
		public string[] Last_eval { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TokenResponse
	{
		
		/// <summary>
		/// The token content
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
	}
	
	/// <summary>
	/// A username for authenticating with one or more types of credentials. User type defines the expected credentials allowed for the user. Native users have passwords, External users have no credential internally. Internal users are service/system users for inter-service communication.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class User
	{
		
		/// <summary>
		/// The timestampt the user record was created
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="created_at")]
		public System.Nullable<System.DateTimeOffset> Created_at { get; set; }
		
		/// <summary>
		/// The timestamp of the last update to this record
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last_updated")]
		public System.Nullable<System.DateTimeOffset> Last_updated { get; set; }
		
		/// <summary>
		/// If the user is external, this is the source that the user was initialized from. All other user types have this set to null
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// The user's type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<UserType> Type { get; set; }
		
		/// <summary>
		/// The username to authenticate with
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UserType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		native = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="internal")]
		_internal = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		external = 2,
	}
	
	/// <summary>
	/// A payload for creating a new user, includes the username and password in a single request
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserCreationRequest
	{
		
		/// <summary>
		/// The initial password for the user, must be at least 6 characters, up to 128
		/// Required
		/// Pattern: .{6,128}$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="password")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@".{6,128}$")]
		public string Password { get; set; }
		
		/// <summary>
		/// The username to create
		/// Required
		/// Pattern: ^[a-zA-Z0-9][a-zA-Z0-9@.!#$+-=^_`~;]{1,126}[a-zA-Z0-9]$
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="username")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"^[a-zA-Z0-9][a-zA-Z0-9@.!#$+-=^_`~;]{1,126}[a-zA-Z0-9]$")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// The results of the comparing two vulnerability records during an update
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VulnDiffResult
	{
		
		[System.Runtime.Serialization.DataMember(Name="added")]
		public string[] Added { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="removed")]
		public string[] Removed { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updated")]
		public string[] Updated { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VulnUpdateNotification : NotificationBase
	{
		
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VulnUpdateNotificationData Data { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VulnUpdateNotificationData : BaseNotificationData
	{
		
		[System.Runtime.Serialization.DataMember(Name="notification_payload")]
		public VulnUpdateNotificationPayload Notification_payload { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VulnUpdateNotificationPayload : GenericNotificationPayload
	{
		
		/// <summary>
		/// List of Corresponding Image Annotations
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public string Annotations { get; set; }
		
		/// <summary>
		/// The results of the comparing two vulnerability records during an update
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diff_vulnerability_result")]
		public VulnDiffResult Diff_vulnerability_result { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Vulnerability
	{
		
		/// <summary>
		/// The name of the feed where vulnerability match was made
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="feed")]
		public string Feed { get; set; }
		
		/// <summary>
		/// The name of the feed group where vulnerability match was made
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="feed_group")]
		public string Feed_group { get; set; }
		
		/// <summary>
		/// The package containing a fix, if available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fix")]
		public string Fix { get; set; }
		
		/// <summary>
		/// List of Nvd Data objects
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nvd_data")]
		public NvdDataObject[] Nvd_data { get; set; }
		
		/// <summary>
		/// The package name and version that are vulnerable in the image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="package")]
		public string Package { get; set; }
		
		/// <summary>
		/// The CPE string (if applicable) describing the package to vulnerability match
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="package_cpe")]
		public string Package_cpe { get; set; }
		
		/// <summary>
		/// The name of the vulnerable package artifact
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="package_name")]
		public string Package_name { get; set; }
		
		/// <summary>
		/// The location (if applicable) of the vulnerable package in the container filesystem
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="package_path")]
		public string Package_path { get; set; }
		
		/// <summary>
		/// The type of vulnerable package
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="package_type")]
		public string Package_type { get; set; }
		
		/// <summary>
		/// The version of the vulnerable package artifact
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="package_version")]
		public string Package_version { get; set; }
		
		/// <summary>
		/// The severity of the vulnerability
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="severity")]
		public string Severity { get; set; }
		
		/// <summary>
		/// The url for more information about the vulnerability
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// List of Vendor Data objects
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vendor_data")]
		public VendorDataObject[] Vendor_data { get; set; }
		
		/// <summary>
		/// The vulnerability identifier, such as CVE-2017-100, or RHSA-2017123
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vuln")]
		public string Vuln { get; set; }
		
		/// <summary>
		/// Whether a vendor will fix or not fix the vulnerability
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="will_not_fix")]
		public System.Nullable<System.Boolean> Will_not_fix { get; set; }
	}
	
	/// <summary>
	/// envelope containing list of vulnerabilities
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VulnerabilityResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="imageDigest")]
		public string ImageDigest { get; set; }
		
		/// <summary>
		/// List of Vulnerability objects
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vulnerabilities")]
		public Vulnerability[] Vulnerabilities { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="vulnerability_type")]
		public string Vulnerability_type { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Simple status check
		/// Ping 
		/// </summary>
		/// <returns>Version check response, returns the api version prefix (e.g. 'v1')</returns>
		public async Task<string> PingAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				return jsonReader.ReadAsString();
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the account for the authenticated user
		/// Get_users_account account
		/// </summary>
		/// <returns>User details for caller's user</returns>
		public async Task<Account> Get_users_accountAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "account";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List user summaries. Only available to the system admin user.
		/// List_accounts accounts
		/// </summary>
		/// <param name="state">Filter accounts by state</param>
		/// <returns>Accound summary listing</returns>
		public async Task<Account[]> List_accountsAsync(AccountState state, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts?state=" + state;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new user. Only avaialble to admin user.
		/// Create_account accounts
		/// </summary>
		/// <returns>Account Record</returns>
		public async Task<Account> Create_accountAsync(AccountCreationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete the specified account, only allowed if the account is in the disabled state. All users will be deleted along with the account and all resources will be garbage collected
		/// Delete_account accounts/{accountname}
		/// </summary>
		public async Task Delete_accountAsync(string accountname, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : System.Uri.EscapeDataString(accountname));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get info about an user. Only available to admin user. Uses the main user Id, not a username.
		/// Get_account accounts/{accountname}
		/// </summary>
		/// <returns>Get user information</returns>
		public async Task<Account> Get_accountAsync(string accountname, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : System.Uri.EscapeDataString(accountname));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Account>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the state of an account to either enabled or disabled. For deletion use the DELETE route
		/// Update_account_state accounts/{accountname}/state
		/// </summary>
		/// <returns>Updated state of the account</returns>
		public async Task<AccountStatus> Update_account_stateAsync(string accountname, AccountStatus requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : System.Uri.EscapeDataString(accountname))+"/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AccountStatus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List accounts for the user
		/// List_users accounts/{accountname}/users
		/// </summary>
		/// <returns>User listing</returns>
		public async Task<User[]> List_usersAsync(string accountname, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : System.Uri.EscapeDataString(accountname))+"/users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<User[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new user
		/// Create_user accounts/{accountname}/users
		/// </summary>
		/// <returns>Credential summary</returns>
		public async Task<User> Create_userAsync(string accountname, UserCreationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : System.Uri.EscapeDataString(accountname))+"/users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a specific user credential by username of the credential. Cannot be the credential used to authenticate the request.
		/// Delete_user accounts/{accountname}/users/{username}
		/// </summary>
		public async Task Delete_userAsync(string accountname, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : System.Uri.EscapeDataString(accountname))+"/users/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific user in the specified account
		/// Get_account_user accounts/{accountname}/users/{username}
		/// </summary>
		/// <returns>User record</returns>
		public async Task<User> Get_account_userAsync(string accountname, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : System.Uri.EscapeDataString(accountname))+"/users/"+ (username==null? "" : System.Uri.EscapeDataString(username));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a credential by type
		/// Delete_user_credential accounts/{accountname}/users/{username}/credentials
		/// </summary>
		public async Task Delete_user_credentialAsync(string accountname, string username, AccessCredentialType credential_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : System.Uri.EscapeDataString(accountname))+"/users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/credentials&credential_type=" + credential_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get current credential summary
		/// List_user_credentials accounts/{accountname}/users/{username}/credentials
		/// </summary>
		/// <returns>User credential listing</returns>
		public async Task<AccessCredential[]> List_user_credentialsAsync(string accountname, string username, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : System.Uri.EscapeDataString(accountname))+"/users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/credentials";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AccessCredential[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// add/replace credential
		/// Create_user_credential accounts/{accountname}/users/{username}/credentials
		/// </summary>
		/// <returns>Add a credential, overwritting if already exists</returns>
		public async Task<User> Create_user_credentialAsync(string accountname, string username, AccessCredential requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "accounts/"+ (accountname==null? "" : System.Uri.EscapeDataString(accountname))+"/users/"+ (username==null? "" : System.Uri.EscapeDataString(username))+"/credentials";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List_archives archives
		/// </summary>
		/// <returns>Archive summary listing</returns>
		public async Task<ArchiveSummary> List_archivesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArchiveSummary>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List_analysis_archive archives/images
		/// </summary>
		/// <returns>Image analysis archive listing for the requesting account (not the whole system)</returns>
		public async Task<ArchivedAnalysis[]> List_analysis_archiveAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/images";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArchivedAnalysis[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Archive_image_analysis archives/images
		/// </summary>
		/// <returns>Archive statuses</returns>
		public async Task<AnalysisArchiveAddResult[]> Archive_image_analysisAsync(string[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/images";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AnalysisArchiveAddResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Performs a synchronous archive deletion
		/// Delete_archived_analysis archives/images/{imageDigest}
		/// </summary>
		/// <returns>ArchivdImageAnalysis successfully deleted</returns>
		public async Task Delete_archived_analysisAsync(string imageDigest, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"&force="+force;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the archive metadata record identifying the image and tags for the analysis in the archive.
		/// Get_archived_analysis archives/images/{imageDigest}
		/// </summary>
		/// <param name="imageDigest">The image digest to identify the image analysis</param>
		/// <returns>Archived Image</returns>
		public async Task<ArchivedAnalysis> Get_archived_analysisAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ArchivedAnalysis>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List_analysis_archive_rules archives/rules
		/// </summary>
		/// <param name="system_global">If true include system global rules (owned by admin) even for non-admin users. Defaults to true if not set. Can be set to false to exclude globals</param>
		/// <returns>Archive transition rules</returns>
		public async Task<AnalysisArchiveTransitionRule[]> List_analysis_archive_rulesAsync(bool system_global, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/rules?system_global="+system_global;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AnalysisArchiveTransitionRule[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create_analysis_archive_rule archives/rules
		/// </summary>
		/// <returns>Archive transition rule</returns>
		public async Task<AnalysisArchiveTransitionRule> Create_analysis_archive_ruleAsync(AnalysisArchiveTransitionRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AnalysisArchiveTransitionRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete_analysis_archive_rule archives/rules/{ruleId}
		/// </summary>
		/// <returns>Analysis archive rule succesfuly deleted</returns>
		public async Task Delete_analysis_archive_ruleAsync(string ruleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/rules/"+ (ruleId==null? "" : System.Uri.EscapeDataString(ruleId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get_analysis_archive_rule archives/rules/{ruleId}
		/// </summary>
		/// <returns>Archive transition rule</returns>
		public async Task<AnalysisArchiveTransitionRule> Get_analysis_archive_ruleAsync(string ruleId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "archives/rules/"+ (ruleId==null? "" : System.Uri.EscapeDataString(ruleId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AnalysisArchiveTransitionRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List Event Types
		/// Returns list of event types in the category hierarchy
		/// List_event_types event_types
		/// </summary>
		/// <returns>List of event types</returns>
		public async Task<EventCategory[]> List_event_typesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "event_types";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventCategory[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete Events
		/// Delete all or a subset of events filtered using the optional query parameters
		/// Delete_events events
		/// </summary>
		/// <param name="before">Delete events that occurred before the timestamp</param>
		/// <param name="since">Delete events that occurred after the timestamp</param>
		/// <param name="level">Delete events that match the level - INFO or ERROR</param>
		/// <returns>List of deleted event IDs</returns>
		public async Task<string[]> Delete_eventsAsync(string before, string since, string level, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "events?before=" + (before==null? "" : System.Uri.EscapeDataString(before))+"&since=" + (since==null? "" : System.Uri.EscapeDataString(since))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List Events
		/// Returns a paginated list of events in the descending order of their occurrence. Optional query parameters may be used for filtering results
		/// List_events events
		/// </summary>
		/// <param name="source_servicename">Filter events by the originating service</param>
		/// <param name="source_hostid">Filter events by the originating host ID</param>
		/// <param name="event_type">Filter events by a prefix match on the event type (e.g. "user.image.")</param>
		/// <param name="resource_type">Filter events by the type of resource - tag, imageDigest, repository etc</param>
		/// <param name="resource_id">Filter events by the id of the resource</param>
		/// <param name="level">Filter events by the level - INFO or ERROR</param>
		/// <param name="since">Return events that occurred after the timestamp</param>
		/// <param name="before">Return events that occurred before the timestamp</param>
		/// <param name="page">Pagination controls - return the nth page of results. Defaults to first page if left empty</param>
		/// <param name="limit">Number of events in the result set. Defaults to 100 if left empty</param>
		/// <returns>Paginated list of event records and the next token</returns>
		public async Task<EventsList> List_eventsAsync(string source_servicename, string source_hostid, string event_type, string resource_type, string resource_id, string level, string since, string before, int page, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "events?source_servicename=" + (source_servicename==null? "" : System.Uri.EscapeDataString(source_servicename))+"&source_hostid=" + (source_hostid==null? "" : System.Uri.EscapeDataString(source_hostid))+"&event_type=" + (event_type==null? "" : System.Uri.EscapeDataString(event_type))+"&resource_type=" + (resource_type==null? "" : System.Uri.EscapeDataString(resource_type))+"&resource_id=" + (resource_id==null? "" : System.Uri.EscapeDataString(resource_id))+"&level=" + (level==null? "" : System.Uri.EscapeDataString(level))+"&since=" + (since==null? "" : System.Uri.EscapeDataString(since))+"&before=" + (before==null? "" : System.Uri.EscapeDataString(before))+"&page="+page+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventsList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete Event
		/// Delete an event by its event ID
		/// Delete_event events/{eventId}
		/// </summary>
		/// <param name="eventId">Event ID of the event to be deleted</param>
		/// <returns>Delete success</returns>
		public async Task Delete_eventAsync(string eventId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "events/"+ (eventId==null? "" : System.Uri.EscapeDataString(eventId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Event
		/// Lookup an event by its event ID
		/// Get_event events/{eventId}
		/// </summary>
		/// <param name="eventId">Event ID of the event for lookup</param>
		/// <returns>Single event record</returns>
		public async Task<EventResponse> Get_eventAsync(string eventId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "events/"+ (eventId==null? "" : System.Uri.EscapeDataString(eventId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<EventResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Health check, returns 200 and no body if service is running
		/// Health_check health
		/// </summary>
		/// <returns>Empty body on success</returns>
		public async Task Health_checkAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "health";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Bulk mark images for deletion
		/// Delete analysis for image digests in the list asynchronously
		/// Delete_images_async images
		/// </summary>
		/// <returns>successful operation</returns>
		public async Task<DeleteImageResponse[]> Delete_images_asyncAsync(string[] imageDigests, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images?"+string.Join("&", imageDigests.Select(z => $"imageDigests={System.Uri.EscapeDataString(z.ToString())}"))+"&force="+force;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteImageResponse[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all visible images
		/// List all images visible to the user
		/// List_images images
		/// </summary>
		/// <param name="history">Include image history in the response</param>
		/// <param name="fulltag">Full docker-pull string to filter results by (e.g. docker.io/library/nginx:latest, or myhost.com:5000/testimages:v1.1.1)</param>
		/// <param name="image_status">Filter by image_status value on the record. Default if omitted is 'active'.</param>
		/// <param name="analysis_status">Filter by analysis_status value on the record.</param>
		/// <returns>successful operation</returns>
		public async Task<AnchoreImage[]> List_imagesAsync(bool history, string fulltag, List_imagesImage_status image_status, List_imagesAnalysis_status analysis_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images?history="+history+"&fulltag=" + (fulltag==null? "" : System.Uri.EscapeDataString(fulltag))+"&image_status=" + image_status+"&analysis_status=" + analysis_status;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AnchoreImage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Submit a new image for analysis by the engine
		/// Creates a new analysis task that is executed asynchronously
		/// Add_image images
		/// </summary>
		/// <param name="force">Override any existing entry in the system</param>
		/// <param name="autosubscribe">Instruct engine to automatically begin watching the added tag for updates from registry</param>
		/// <returns>Successfully added image to analysis queue</returns>
		public async Task<AnchoreImage[]> Add_imageAsync(bool force, bool autosubscribe, ImageAnalysisRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images?force="+force+"&autosubscribe="+autosubscribe;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AnchoreImage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete image by docker imageId
		/// Delete_image_by_imageId images/by_id/{imageId}
		/// </summary>
		/// <returns>Image deletion success</returns>
		public async Task<DeleteImageResponse> Delete_image_by_imageIdAsync(string imageId, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : System.Uri.EscapeDataString(imageId))+"&force="+force;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteImageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lookup image by docker imageId
		/// Get_image_by_imageId images/by_id/{imageId}
		/// </summary>
		/// <returns>Image lookup success</returns>
		public async Task<AnchoreImage[]> Get_image_by_imageIdAsync(string imageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : System.Uri.EscapeDataString(imageId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AnchoreImage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check policy evaluation status for image
		/// Get the policy evaluation for the given image
		/// Get_image_policy_check_by_imageId images/by_id/{imageId}/check
		/// </summary>
		/// <returns>Policy evaluation success</returns>
		public async Task<PolicyEvaluation[]> Get_image_policy_check_by_imageIdAsync(string imageId, string policyId, string tag, bool detail, bool history, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : System.Uri.EscapeDataString(imageId))+"/check&policyId=" + (policyId==null? "" : System.Uri.EscapeDataString(policyId))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&detail="+detail+"&history="+history;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PolicyEvaluation[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List image content types
		/// List_image_content_by_imageid images/by_id/{imageId}/content
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<string[]> List_image_content_by_imageidAsync(string imageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : System.Uri.EscapeDataString(imageId))+"/content";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type files
		/// Get_image_content_by_type_imageId_files images/by_id/{imageId}/content/files
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentFilesResponse> Get_image_content_by_type_imageId_filesAsync(string imageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : System.Uri.EscapeDataString(imageId))+"/content/files";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ContentFilesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type java
		/// Get_image_content_by_type_imageId_javapackage images/by_id/{imageId}/content/java
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentJAVAPackageResponse> Get_image_content_by_type_imageId_javapackageAsync(string imageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : System.Uri.EscapeDataString(imageId))+"/content/java";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ContentJAVAPackageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type
		/// Get_image_content_by_type_imageId images/by_id/{imageId}/content/{ctype}
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentPackageResponse> Get_image_content_by_type_imageIdAsync(string imageId, string ctype, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : System.Uri.EscapeDataString(imageId))+"/content/"+ (ctype==null? "" : System.Uri.EscapeDataString(ctype));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ContentPackageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vulnerability types
		/// Get_image_vulnerability_types_by_imageId images/by_id/{imageId}/vuln
		/// </summary>
		/// <returns>Vulnerability listing for the image</returns>
		public async Task<string[]> Get_image_vulnerability_types_by_imageIdAsync(string imageId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : System.Uri.EscapeDataString(imageId))+"/vuln";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vulnerabilities by type
		/// Get_image_vulnerabilities_by_type_imageId images/by_id/{imageId}/vuln/{vtype}
		/// </summary>
		/// <returns>Vulnerability listing for the image</returns>
		public async Task<VulnerabilityResponse> Get_image_vulnerabilities_by_type_imageIdAsync(string imageId, string vtype, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/by_id/"+ (imageId==null? "" : System.Uri.EscapeDataString(imageId))+"/vuln/"+ (vtype==null? "" : System.Uri.EscapeDataString(vtype));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VulnerabilityResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an image analysis
		/// Delete_image images/{imageDigest}
		/// </summary>
		/// <returns>Image deletion success</returns>
		public async Task<DeleteImageResponse> Delete_imageAsync(string imageDigest, bool force, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"&force="+force;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteImageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get image metadata
		/// Get_image images/{imageDigest}
		/// </summary>
		/// <returns>Image lookup success</returns>
		public async Task<AnchoreImage[]> Get_imageAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AnchoreImage[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of analyzer artifacts of the specified type
		/// List_file_content_search_results images/{imageDigest}/artifacts/file_content_search
		/// </summary>
		/// <returns>List of file metadata objects</returns>
		public async Task<FileContentSearchResult[]> List_file_content_search_resultsAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/artifacts/file_content_search";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FileContentSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of analyzer artifacts of the specified type
		/// List_retrieved_files images/{imageDigest}/artifacts/retrieved_files
		/// </summary>
		/// <returns>List of file metadata objects</returns>
		public async Task<RetrievedFile[]> List_retrieved_filesAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/artifacts/retrieved_files";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetrievedFile[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Return a list of analyzer artifacts of the specified type
		/// List_secret_search_results images/{imageDigest}/artifacts/secret_search
		/// </summary>
		/// <returns>List of file metadata objects</returns>
		public async Task<SecretSearchResult[]> List_secret_search_resultsAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/artifacts/secret_search";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SecretSearchResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check policy evaluation status for image
		/// Get the policy evaluation for the given image
		/// Get_image_policy_check images/{imageDigest}/check
		/// </summary>
		/// <returns>Policy evaluation success</returns>
		public async Task<PolicyEvaluation[]> Get_image_policy_checkAsync(string imageDigest, string policyId, string tag, bool detail, bool history, bool interactive, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/check&policyId=" + (policyId==null? "" : System.Uri.EscapeDataString(policyId))+"&tag=" + (tag==null? "" : System.Uri.EscapeDataString(tag))+"&detail="+detail+"&history="+history+"&interactive="+interactive;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PolicyEvaluation[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List image content types
		/// List_image_content images/{imageDigest}/content
		/// </summary>
		/// <returns>Content listing for the image</returns>
		public async Task<string[]> List_image_contentAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/content";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type files
		/// Get_image_content_by_type_files images/{imageDigest}/content/files
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentFilesResponse> Get_image_content_by_type_filesAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/content/files";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ContentFilesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type java
		/// Get_image_content_by_type_javapackage images/{imageDigest}/content/java
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentJAVAPackageResponse> Get_image_content_by_type_javapackageAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/content/java";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ContentJAVAPackageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type malware
		/// Get_image_content_by_type_malware images/{imageDigest}/content/malware
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentMalwareResponse> Get_image_content_by_type_malwareAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/content/malware";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ContentMalwareResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the content of an image by type
		/// Get_image_content_by_type images/{imageDigest}/content/{ctype}
		/// </summary>
		/// <returns>Content of specified type from the image</returns>
		public async Task<ContentPackageResponse> Get_image_content_by_typeAsync(string imageDigest, string ctype, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/content/"+ (ctype==null? "" : System.Uri.EscapeDataString(ctype));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ContentPackageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List image metadata types
		/// List_image_metadata images/{imageDigest}/metadata
		/// </summary>
		/// <returns>Metadata listing for the image</returns>
		public async Task<string[]> List_image_metadataAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/metadata";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the metadata of an image by type
		/// Get_image_metadata_by_type images/{imageDigest}/metadata/{mtype}
		/// </summary>
		/// <returns>Metadata of specified type from the image</returns>
		public async Task<MetadataResponse> Get_image_metadata_by_typeAsync(string imageDigest, string mtype, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/metadata/"+ (mtype==null? "" : System.Uri.EscapeDataString(mtype));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MetadataResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get image sbom in the native Anchore format
		/// Get_image_sbom_native images/{imageDigest}/sboms/native
		/// </summary>
		/// <returns>Image lookup success</returns>
		public async Task Get_image_sbom_nativeAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/sboms/native";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vulnerability types
		/// Get_image_vulnerability_types images/{imageDigest}/vuln
		/// </summary>
		/// <returns>Vulnerability listing for the image</returns>
		public async Task<string[]> Get_image_vulnerability_typesAsync(string imageDigest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/vuln";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get vulnerabilities by type
		/// Get_image_vulnerabilities_by_type images/{imageDigest}/vuln/{vtype}
		/// </summary>
		/// <param name="vendor_only">Filter results to include only vulnerabilities that are not marked as invalid by upstream OS vendor data. When set to true, it will filter out all vulnerabilities where `will_not_fix` is False. If false all vulnerabilities are returned regardless of `will_not_fix`</param>
		/// <returns>Vulnerability listing for the image</returns>
		public async Task<VulnerabilityResponse> Get_image_vulnerabilities_by_typeAsync(string imageDigest, string vtype, bool force_refresh, bool vendor_only, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "images/"+ (imageDigest==null? "" : System.Uri.EscapeDataString(imageDigest))+"/vuln/"+ (vtype==null? "" : System.Uri.EscapeDataString(vtype))+"&force_refresh="+force_refresh+"&vendor_only="+vendor_only;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VulnerabilityResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists in-progress imports
		/// List_operations imports/images
		/// </summary>
		/// <returns>success</returns>
		public async Task<ImageImportOperation[]> List_operationsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageImportOperation[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Begin the import of an image analyzed by Syft into the system
		/// Create_operation imports/images
		/// </summary>
		/// <returns>success</returns>
		public async Task<ImageImportOperation> Create_operationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageImportOperation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Invalidate operation ID so it can be garbage collected
		/// Invalidate_operation imports/images/{operation_id}
		/// </summary>
		/// <returns>success</returns>
		public async Task<ImageImportOperation> Invalidate_operationAsync(string operation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images/"+ (operation_id==null? "" : System.Uri.EscapeDataString(operation_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageImportOperation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get detail on a single import
		/// Get_operation imports/images/{operation_id}
		/// </summary>
		/// <returns>success</returns>
		public async Task<ImageImportOperation> Get_operationAsync(string operation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images/"+ (operation_id==null? "" : System.Uri.EscapeDataString(operation_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageImportOperation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List uploaded dockerfiles
		/// List_import_dockerfiles imports/images/{operation_id}/dockerfile
		/// </summary>
		/// <returns>success</returns>
		public async Task<string[]> List_import_dockerfilesAsync(string operation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images/"+ (operation_id==null? "" : System.Uri.EscapeDataString(operation_id))+"/dockerfile";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List uploaded image configs
		/// List_import_image_configs imports/images/{operation_id}/image_config
		/// </summary>
		/// <returns>success</returns>
		public async Task<string[]> List_import_image_configsAsync(string operation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images/"+ (operation_id==null? "" : System.Uri.EscapeDataString(operation_id))+"/image_config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Import a docker or OCI image config to associate with the image
		/// Import_image_config imports/images/{operation_id}/image_config
		/// </summary>
		/// <returns>success</returns>
		public async Task<ImageImportContentResponse> Import_image_configAsync(string operation_id, string requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images/"+ (operation_id==null? "" : System.Uri.EscapeDataString(operation_id))+"/image_config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageImportContentResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List uploaded image manifests
		/// List_import_image_manifests imports/images/{operation_id}/manifest
		/// </summary>
		/// <returns>success</returns>
		public async Task<string[]> List_import_image_manifestsAsync(string operation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images/"+ (operation_id==null? "" : System.Uri.EscapeDataString(operation_id))+"/manifest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List uploaded package manifests
		/// List_import_packages imports/images/{operation_id}/packages
		/// </summary>
		/// <returns>success</returns>
		public async Task<string[]> List_import_packagesAsync(string operation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images/"+ (operation_id==null? "" : System.Uri.EscapeDataString(operation_id))+"/packages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Begin the import of an image analyzed by Syft into the system
		/// Import_image_packages imports/images/{operation_id}/packages
		/// </summary>
		/// <returns>success</returns>
		public async Task<ImageImportContentResponse> Import_image_packagesAsync(string operation_id, ImagePackageManifest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images/"+ (operation_id==null? "" : System.Uri.EscapeDataString(operation_id))+"/packages";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageImportContentResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List uploaded parent manifests (manifest lists for a tag)
		/// List_import_parent_manifests imports/images/{operation_id}/parent_manifest
		/// </summary>
		/// <returns>success</returns>
		public async Task<string[]> List_import_parent_manifestsAsync(string operation_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "imports/images/"+ (operation_id==null? "" : System.Uri.EscapeDataString(operation_id))+"/parent_manifest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List policies
		/// List all saved policy bundles
		/// List_policies policies
		/// </summary>
		/// <param name="detail">Include policy bundle detail in the form of the full bundle content for each entry</param>
		/// <returns>Policy listing</returns>
		public async Task<PolicyBundleRecord[]> List_policiesAsync(bool detail, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policies?detail="+detail;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PolicyBundleRecord[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a new policy
		/// Adds a new policy bundle to the system
		/// Add_policy policies
		/// </summary>
		/// <returns>Saved bundle</returns>
		public async Task<PolicyBundleRecord> Add_policyAsync(PolicyBundle requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policies";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PolicyBundleRecord>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete policy
		/// Delete the specified policy
		/// Delete_policy policies/{policyId}
		/// </summary>
		/// <returns>Delete success</returns>
		public async Task Delete_policyAsync(string policyId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policies/"+ (policyId==null? "" : System.Uri.EscapeDataString(policyId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get specific policy
		/// Get the policy bundle content
		/// Get_policy policies/{policyId}
		/// </summary>
		/// <param name="detail">Include policy bundle detail in the form of the full bundle content for each entry</param>
		/// <returns>A list with a single fetched policy bundle record</returns>
		public async Task<PolicyBundleRecord[]> Get_policyAsync(string policyId, bool detail, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policies/"+ (policyId==null? "" : System.Uri.EscapeDataString(policyId))+"&detail="+detail;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PolicyBundleRecord[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update policy
		/// Update/replace and existing policy
		/// Update_policy policies/{policyId}
		/// </summary>
		/// <param name="active">Mark policy as active</param>
		/// <returns>A list with a single updated policy bundle record</returns>
		public async Task<PolicyBundleRecord[]> Update_policyAsync(string policyId, bool active, PolicyBundleRecord requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "policies/"+ (policyId==null? "" : System.Uri.EscapeDataString(policyId))+"&active="+active;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PolicyBundleRecord[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List of images containing given package
		/// Filterable query interface to search for images containing specified package
		/// Query_images_by_package query/images/by_package
		/// </summary>
		/// <param name="name">Name of package to search for (e.g. sed)</param>
		/// <param name="package_type">Type of package to filter on (e.g. dpkg)</param>
		/// <param name="version">Version of named package to filter on (e.g. 4.4-1)</param>
		/// <param name="page">The page of results to fetch. Pages start at 1</param>
		/// <param name="limit">Limit the number of records for the requested page. If omitted or set to 0, return all results in a single page</param>
		/// <returns>Image listing</returns>
		public async Task<PaginatedImageList> Query_images_by_packageAsync(string name, string package_type, string version, string page, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "query/images/by_package?name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&package_type=" + (package_type==null? "" : System.Uri.EscapeDataString(package_type))+"&version=" + (version==null? "" : System.Uri.EscapeDataString(version))+"&page=" + (page==null? "" : System.Uri.EscapeDataString(page))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PaginatedImageList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List images vulnerable to the specific vulnerability ID.
		/// Returns a listing of images and their respective packages vulnerable to the given vulnerability ID
		/// Query_images_by_vulnerability query/images/by_vulnerability
		/// </summary>
		/// <param name="vulnerability_id">The ID of the vulnerability to search for within all images stored in anchore-engine (e.g. CVE-1999-0001)</param>
		/// <param name="_namespace">Filter results to images within the given vulnerability namespace (e.g. debian:8, ubuntu:14.04)</param>
		/// <param name="affected_package">Filter results to images with vulnable packages with the given package name (e.g. libssl)</param>
		/// <param name="severity">Filter results to vulnerable package/vulnerability with the given severity</param>
		/// <param name="vendor_only">Filter results to include only vulnerabilities that are not marked as invalid by upstream OS vendor data</param>
		/// <param name="page">The page of results to fetch. Pages start at 1</param>
		/// <param name="limit">Limit the number of records for the requested page. If omitted or set to 0, return all results in a single page</param>
		/// <returns>Image lookup success</returns>
		public async Task<PaginatedVulnerableImageList> Query_images_by_vulnerabilityAsync(string vulnerability_id, string _namespace, string affected_package, StandaloneVulnerabilitySeverity severity, bool vendor_only, int page, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "query/images/by_vulnerability?vulnerability_id=" + (vulnerability_id==null? "" : System.Uri.EscapeDataString(vulnerability_id))+"&namespace=" + (_namespace==null? "" : System.Uri.EscapeDataString(_namespace))+"&affected_package=" + (affected_package==null? "" : System.Uri.EscapeDataString(affected_package))+"&severity=" + severity+"&vendor_only="+vendor_only+"&page="+page+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PaginatedVulnerableImageList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Listing information about given vulnerability
		/// List (w/filters) vulnerability records known by the system, with affected packages information if present
		/// Query_vulnerabilities query/vulnerabilities
		/// </summary>
		/// <param name="id">The ID of the vulnerability (e.g. CVE-1999-0001)</param>
		/// <param name="affected_package">Filter results by specified package name (e.g. sed)</param>
		/// <param name="affected_package_version">Filter results by specified package version (e.g. 4.4-1)</param>
		/// <param name="page">The page of results to fetch. Pages start at 1</param>
		/// <param name="limit">Limit the number of records for the requested page. If omitted or set to 0, return all results in a single page</param>
		/// <param name="_namespace">Namespace(s) to filter vulnerability records by</param>
		/// <returns>Vulnerability listing paginated</returns>
		public async Task<PaginatedVulnerabilityList> Query_vulnerabilitiesAsync(string[] id, string affected_package, string affected_package_version, string page, int limit, string[] _namespace, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "query/vulnerabilities?"+string.Join("&", id.Select(z => $"id={System.Uri.EscapeDataString(z.ToString())}"))+"&affected_package=" + (affected_package==null? "" : System.Uri.EscapeDataString(affected_package))+"&affected_package_version=" + (affected_package_version==null? "" : System.Uri.EscapeDataString(affected_package_version))+"&page=" + (page==null? "" : System.Uri.EscapeDataString(page))+"&limit="+limit+"&"+string.Join("&", _namespace.Select(z => $"namespace={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PaginatedVulnerabilityList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List configured registries
		/// List all configured registries the system can/will watch
		/// List_registries registries
		/// </summary>
		/// <returns>Registry listing</returns>
		public async Task<RegistryConfiguration[]> List_registriesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registries";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegistryConfiguration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a new registry
		/// Adds a new registry to the system
		/// Create_registry registries
		/// </summary>
		/// <param name="validate">flag to determine whether or not to validate registry/credential at registry add time</param>
		/// <returns>Saved registry configuration</returns>
		public async Task<RegistryConfiguration[]> Create_registryAsync(bool validate, RegistryConfigurationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registries?validate="+validate;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegistryConfiguration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete a registry configuration
		/// Delete a registry configuration record from the system. Does not remove any images.
		/// Delete_registry registries/{registry}
		/// </summary>
		/// <returns>Delete success</returns>
		public async Task Delete_registryAsync(string registry, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registries/"+ (registry==null? "" : System.Uri.EscapeDataString(registry));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific registry configuration
		/// Get information on a specific registry
		/// Get_registry registries/{registry}
		/// </summary>
		/// <returns>Registry configuration</returns>
		public async Task<RegistryConfiguration[]> Get_registryAsync(string registry, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registries/"+ (registry==null? "" : System.Uri.EscapeDataString(registry));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegistryConfiguration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update/replace a registry configuration
		/// Replaces an existing registry record with the given record
		/// Update_registry registries/{registry}
		/// </summary>
		/// <param name="validate">flag to determine whether or not to validate registry/credential at registry update time</param>
		/// <returns>Updated registry configuration</returns>
		public async Task<RegistryConfiguration[]> Update_registryAsync(string registry, bool validate, RegistryConfigurationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registries/"+ (registry==null? "" : System.Uri.EscapeDataString(registry))+"&validate="+validate;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegistryConfiguration[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Add repository to watch
		/// Add_repository repositories
		/// </summary>
		/// <param name="repository">full repository to add e.g. docker.io/library/alpine</param>
		/// <param name="autosubscribe">flag to enable/disable auto tag_update activation when new images from a repo are added</param>
		/// <param name="dryrun">flag to return tags in the repository without actually watching the repository, default is false</param>
		/// <returns>Repository and discovered tags added</returns>
		public async Task<Subscription[]> Add_repositoryAsync(string repository, bool autosubscribe, bool dryrun, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "repositories?repository=" + (repository==null? "" : System.Uri.EscapeDataString(repository))+"&autosubscribe="+autosubscribe+"&dryrun="+dryrun;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Subscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Service status
		/// Get the API service status
		/// Get_status status
		/// </summary>
		/// <returns>Status listing</returns>
		public async Task<StatusResponse> Get_statusAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StatusResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all subscriptions
		/// List_subscriptions subscriptions
		/// </summary>
		/// <param name="subscription_key">filter only subscriptions matching key</param>
		/// <param name="subscription_type">filter only subscriptions matching type</param>
		/// <returns>Subscription listing</returns>
		public async Task<Subscription[]> List_subscriptionsAsync(string subscription_key, string subscription_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions?subscription_key=" + (subscription_key==null? "" : System.Uri.EscapeDataString(subscription_key))+"&subscription_type=" + (subscription_type==null? "" : System.Uri.EscapeDataString(subscription_type));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Subscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add a subscription of a specific type
		/// Create a new subscription to watch a tag and get notifications of changes
		/// Add_subscription subscriptions
		/// </summary>
		/// <returns>Subscription add success</returns>
		public async Task<Subscription[]> Add_subscriptionAsync(SubscriptionRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Subscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete subscriptions of a specific type
		/// Delete_subscription subscriptions/{subscriptionId}
		/// </summary>
		/// <returns>Delete success</returns>
		public async Task Delete_subscriptionAsync(string subscriptionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a specific subscription set
		/// Get_subscription subscriptions/{subscriptionId}
		/// </summary>
		/// <returns>Filtered subscription list by type</returns>
		public async Task<Subscription[]> Get_subscriptionAsync(string subscriptionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Subscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an existing and specific subscription
		/// Update_subscription subscriptions/{subscriptionId}
		/// </summary>
		/// <returns>Subscription add success</returns>
		public async Task<Subscription[]> Update_subscriptionAsync(string subscriptionId, SubscriptionUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "subscriptions/"+ (subscriptionId==null? "" : System.Uri.EscapeDataString(subscriptionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Subscription[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List all visible image digests and tags
		/// List all image tags visible to the user
		/// List_imagetags summaries/imagetags
		/// </summary>
		/// <param name="image_status">Filter images in one or more states such as active, deleting. Defaults to active images only if unspecified</param>
		/// <returns>successful operation</returns>
		public async Task<AnchoreImageTagSummary[]> List_imagetagsAsync(List_imagesImage_status[] image_status, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "summaries/imagetags?"+string.Join("&", image_status.Select(z => $"image_status={z}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AnchoreImageTagSummary[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// System status
		/// Get the system status including queue lengths
		/// Get_service_detail system
		/// </summary>
		/// <returns>Status listing</returns>
		public async Task<SystemStatusResponse> Get_service_detailAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SystemStatusResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describe anchore engine error codes.
		/// Describe anchore engine error codes.
		/// Describe_error_codes system/error_codes
		/// </summary>
		/// <returns>Error Codes Description</returns>
		public async Task<AnchoreErrorCode[]> Describe_error_codesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/error_codes";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AnchoreErrorCode[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// list feeds operations and information
		/// Return a list of feed and their groups along with update and record count information. This data reflects the state of the policy engine, not the upstream feed service itself.
		/// Get_system_feeds system/feeds
		/// </summary>
		/// <returns>success</returns>
		public async Task<FeedMetadata[]> Get_system_feedsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/feeds";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FeedMetadata[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// trigger feeds operations
		/// Execute a synchronous feed sync operation. The response will block until complete, then return the result summary.
		/// Post_system_feeds system/feeds
		/// </summary>
		/// <param name="flush">instruct system to flush existing data feeds records from anchore-engine</param>
		/// <param name="sync">instruct system to re-sync data feeds</param>
		/// <returns>Feeds operation success</returns>
		public async Task<FeedSyncResult[]> Post_system_feedsAsync(bool flush, bool sync, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/feeds?flush="+flush+"&sync="+sync;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FeedSyncResult[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete the groups and data for the feed and disable the feed itself
		/// Delete_feed system/feeds/{feed}
		/// </summary>
		/// <returns>Successfully deleted</returns>
		public async Task Delete_feedAsync(string feed, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/feeds/"+ (feed==null? "" : System.Uri.EscapeDataString(feed));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable the feed so that it does not sync on subsequent sync operations
		/// Toggle_feed_enabled system/feeds/{feed}
		/// </summary>
		/// <returns>FeedInfo</returns>
		public async Task<FeedMetadata> Toggle_feed_enabledAsync(string feed, bool enabled, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/feeds/"+ (feed==null? "" : System.Uri.EscapeDataString(feed))+"&enabled="+enabled;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FeedMetadata>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete the group data and disable the group itself
		/// Delete_feed_group system/feeds/{feed}/{group}
		/// </summary>
		/// <returns>Successfully deleted</returns>
		public async Task Delete_feed_groupAsync(string feed, string group, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/feeds/"+ (feed==null? "" : System.Uri.EscapeDataString(feed))+"/"+ (group==null? "" : System.Uri.EscapeDataString(group));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable a specific group within a feed to not sync
		/// Toggle_group_enabled system/feeds/{feed}/{group}
		/// </summary>
		/// <returns>FeedInfo listing</returns>
		public async Task<FeedMetadata[]> Toggle_group_enabledAsync(string feed, string group, bool enabled, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/feeds/"+ (feed==null? "" : System.Uri.EscapeDataString(feed))+"/"+ (group==null? "" : System.Uri.EscapeDataString(group))+"&enabled="+enabled;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FeedMetadata[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describe the policy language spec implemented by this service.
		/// Get the policy language spec for this service
		/// Describe_policy system/policy_spec
		/// </summary>
		/// <returns>Policy Language Description</returns>
		public async Task<GateSpec[]> Describe_policyAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/policy_spec";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GateSpec[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List system services
		/// List_services system/services
		/// </summary>
		/// <returns>Service listing</returns>
		public async Task<Service[]> List_servicesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/services";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Service[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a service configuration and state
		/// Get_services_by_name system/services/{servicename}
		/// </summary>
		/// <returns>Service Info</returns>
		public async Task<Service[]> Get_services_by_nameAsync(string servicename, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/services/"+ (servicename==null? "" : System.Uri.EscapeDataString(servicename));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Service[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete the service config
		/// Delete_service system/services/{servicename}/{hostid}
		/// </summary>
		/// <returns>Delete success</returns>
		public async Task Delete_serviceAsync(string servicename, string hostid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/services/"+ (servicename==null? "" : System.Uri.EscapeDataString(servicename))+"/"+ (hostid==null? "" : System.Uri.EscapeDataString(hostid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get service config for a specific host
		/// Get_services_by_name_and_host system/services/{servicename}/{hostid}
		/// </summary>
		/// <returns>Listing of registered services</returns>
		public async Task<Service[]> Get_services_by_name_and_hostAsync(string servicename, string hostid, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/services/"+ (servicename==null? "" : System.Uri.EscapeDataString(servicename))+"/"+ (hostid==null? "" : System.Uri.EscapeDataString(hostid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Service[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds the capabilities to test a webhook delivery for the given notification type
		/// Loads the Webhook configuration for webhook_type, and sends the notification out as a test
		/// Test_webhook system/webhooks/{webhook_type}/test
		/// </summary>
		/// <param name="webhook_type">The Webhook Type that we should test</param>
		/// <param name="notification_type">What kind of Notification to send</param>
		/// <returns>The Webhook was sent successfully. Schemas may be found under Models (PolicyEvalNotification, TagUpdateNotification, VulnUpdateNotification, AnalysisUpdateNotification)</returns>
		public async Task Test_webhookAsync(string webhook_type, Test_webhookNotification_type notification_type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "system/webhooks/"+ (webhook_type==null? "" : System.Uri.EscapeDataString(webhook_type))+"/test&notification_type=" + notification_type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List authenticated user info
		/// Get_user user
		/// </summary>
		/// <returns>User details for caller's user</returns>
		public async Task<User> Get_userAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get current credential summary
		/// Get_credentials user/credentials
		/// </summary>
		/// <returns>User credential listing</returns>
		public async Task<AccessCredential[]> Get_credentialsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/credentials";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AccessCredential[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// add/replace credential
		/// Add_credential user/credentials
		/// </summary>
		/// <returns>Add a credential, overwritting if already exists</returns>
		public async Task<User> Add_credentialAsync(AccessCredential requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "user/credentials";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<User>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the version object for the service, including db schema version info
		/// Version_check version
		/// </summary>
		/// <returns>Version object describing version state</returns>
		public async Task<ServiceVersion> Version_checkAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "version";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ServiceVersion>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum List_imagesImage_status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		all = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleting = 2,
	}
	
	public enum List_imagesAnalysis_status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_analyzed = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analyzed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analyzing = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analysis_failed = 3,
	}
	
	public enum Test_webhookNotification_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		tag_update = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		analysis_update = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		vuln_update = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		policy_eval = 3,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
