//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EntityNotExistsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ProhibitedStateException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UnauthorizedOperationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UnauthorizedResourceAccessException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FailedDependencyException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceUnavailableException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConcurrentModificationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ActivateUserResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public User User { get; set; }
	}
	
	/// <summary>
	/// Describes a user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class User
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Username { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EmailAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string GivenName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Surname { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OrganizationId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RootFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RecycleBinFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserStatusType Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ModifiedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TimeZoneId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LocaleType Locale { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserStorageMetadata Storage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UserStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UserType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POWERUSER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MINIMALUSER = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WORKSPACESUSER = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LocaleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fr = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ko = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		de = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		es = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ja = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ru = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zh_CN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zh_TW = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pt_BR = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 10,
	}
	
	/// <summary>
	/// Describes the storage for a user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UserStorageMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StorageUtilizedInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageRuleType StorageRule { get; set; }
	}
	
	/// <summary>
	/// Describes the storage for a user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StorageRuleType
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StorageAllocatedInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageType StorageType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum StorageType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNLIMITED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QUOTA = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AddResourcePermissionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ShareResult[] ShareResults { get; set; }
	}
	
	/// <summary>
	/// Describes the share results of a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ShareResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string PrincipalId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string InviteePrincipalId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RoleType Role { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ShareStatusType Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ShareId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StatusMessage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RoleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIEWER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTRIBUTOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COOWNER = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ShareStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILURE = 1,
	}
	
	/// <summary>
	/// Describes the recipient type and ID, if available.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SharePrincipal
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PrincipalType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public RoleType Role { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PrincipalType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GROUP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVITE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANONYMOUS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateCommentResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Comment Comment { get; set; }
	}
	
	/// <summary>
	/// Describes a comment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Comment
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CommentId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ThreadId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Text { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public User Contributor { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CommentStatusType Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CommentVisibilityType Visibility { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RecipientId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CommentStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DRAFT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLISHED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CommentVisibilityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentLockedForCommentsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InvalidCommentOperationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateCustomMetadataResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CustomMetadataLimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateFolderResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata Metadata { get; set; }
	}
	
	/// <summary>
	/// Describes a folder.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FolderMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ModifiedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceStateType ResourceState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Signature { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> LatestVersionSize { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ResourceStateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECYCLED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EntityAlreadyExistsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConflictingOperationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateLabelsResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TooManyLabelsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateNotificationSubscriptionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Subscription Subscription { get; set; }
	}
	
	/// <summary>
	/// Describes a subscription.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Subscription
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SubscriptionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EndPoint { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SubscriptionProtocolType Protocol { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SubscriptionProtocolType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTPS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SQS = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TooManySubscriptionsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InvalidArgumentException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateUserResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public User User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteCustomMetadataResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InvalidOperationException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteLabelsResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeActivitiesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Activity[] UserActivities { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	/// <summary>
	/// Describes the activity information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Activity
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ActivityType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset TimeStamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> IsIndirectActivity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OrganizationId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserMetadata Initiator { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Participants Participants { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceMetadata ResourceMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceMetadata OriginalParent { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CommentMetadata CommentMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ActivityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_CHECKED_IN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_CHECKED_OUT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_RENAMED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_UPLOADED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_DELETED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_VIEWED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION_DOWNLOADED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_RECYCLED = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_RESTORED = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_REVERTED = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHARED = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_UNSHARED = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHARE_PERMISSION_CHANGED = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHAREABLE_LINK_CREATED = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHAREABLE_LINK_REMOVED = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_MOVED = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_COMMENT_ADDED = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_COMMENT_DELETED = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_ANNOTATION_ADDED = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_ANNOTATION_DELETED = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_CREATED = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_DELETED = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_RENAMED = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_RECYCLED = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_RESTORED = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHARED = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_UNSHARED = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHARE_PERMISSION_CHANGED = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHAREABLE_LINK_CREATED = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHAREABLE_LINK_REMOVED = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER_MOVED = 32,
	}
	
	/// <summary>
	/// Describes the metadata of the user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UserMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Username { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string GivenName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Surname { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EmailAddress { get; set; }
	}
	
	/// <summary>
	/// Describes the users or user groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Participants
	{
		
		[System.Runtime.Serialization.DataMember()]
		public UserMetadata[] Users { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public GroupMetadata[] Groups { get; set; }
	}
	
	/// <summary>
	/// Describes the metadata of a user group.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GroupMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Describes the metadata of a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResourceMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OriginalName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VersionId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserMetadata Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT = 1,
	}
	
	/// <summary>
	/// Describes the metadata of a comment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CommentMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CommentId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public User Contributor { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CommentStatusType CommentStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string RecipientId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContributorId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeCommentsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Comment[] Comments { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeDocumentVersionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentVersionMetadata[] DocumentVersions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	/// <summary>
	/// Describes a version of a document.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentVersionMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Signature { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentStatusType Status { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ModifiedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ContentCreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ContentModifiedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentThumbnailUrlMap Thumbnail { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentSourceUrlMap Source { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DocumentStatusType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INITIALIZED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentThumbnailUrlMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentSourceUrlMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InvalidPasswordException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeFolderContentsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata[] Folders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentMetadata[] Documents { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	/// <summary>
	/// Describes the document.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DocumentMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CreatorId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ModifiedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentVersionMetadata LatestVersionMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceStateType ResourceState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Labels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeGroupsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public GroupMetadata[] Groups { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeNotificationSubscriptionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Subscription[] Subscriptions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeResourcePermissionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Principal[] Principals { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	/// <summary>
	/// Describes a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Principal
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PrincipalType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PermissionInfo[] Roles { get; set; }
	}
	
	/// <summary>
	/// Describes the permissions.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PermissionInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public RoleType Role { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public RolePermissionType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RolePermissionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INHERITED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeRootFoldersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata[] Folders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeUsersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public User[] Users { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> TotalNumberOfUsers { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RequestedEntityTooLargeException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetCurrentUserResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public User User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDocumentResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentMetadata Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CustomMetadataMap CustomMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CustomMetadataMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDocumentPathResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResourcePath Path { get; set; }
	}
	
	/// <summary>
	/// Describes the path information of a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResourcePath
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResourcePathComponent[] Components { get; set; }
	}
	
	/// <summary>
	/// Describes the resource path.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResourcePathComponent
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDocumentVersionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentVersionMetadata Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CustomMetadataMap CustomMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetFolderResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CustomMetadataMap CustomMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetFolderPathResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResourcePath Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetResourcesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata[] Folders { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentMetadata[] Documents { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InitiateDocumentVersionUploadResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentMetadata Metadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UploadMetadata UploadMetadata { get; set; }
	}
	
	/// <summary>
	/// Describes the upload.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UploadMetadata
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string UploadUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SignedHeaderMap SignedHeaders { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SignedHeaderMap
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StorageLimitExceededException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StorageLimitWillExceedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DraftUploadOutOfSyncException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResourceAlreadyCheckedOutException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchResourcesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResponseItem[] Items { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	/// <summary>
	/// List of Documents, Folders, Comments, and Document Versions matching the query.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResponseItem
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ResponseItemType ResourceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string WebUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentMetadata DocumentMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public FolderMetadata FolderMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CommentMetadata CommentMetadata { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentVersionMetadata DocumentVersionMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ResponseItemType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMENT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SearchQueryScopeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NAME = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTENT = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AdditionalResponseFieldType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEBURL = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LanguageCodeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AR = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BG = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DA = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CS = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EL = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ES = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FA = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FI = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FR = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HI = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HU = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ID = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IT = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JA = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KO = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LT = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LV = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NL = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PT = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RO = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RU = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SV = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SW = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TH = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TR = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZH = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 30,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ContentCategoryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IMAGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PDF = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SPREADSHEET = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRESENTATION = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUDIO = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIDEO = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOURCE_CODE = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OTHER = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SearchResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMENT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT_VERSION = 3,
	}
	
	/// <summary>
	/// Filter based on UserIds or GroupIds.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchPrincipalType
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public PrincipalRoleType[] Roles { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum PrincipalRoleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIEWER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTRIBUTOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COOWNER = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SearchCollectionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OWNED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHARED_WITH_ME = 1,
	}
	
	/// <summary>
	/// Filter based on size (in bytes).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LongRangeType
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StartValue { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> EndValue { get; set; }
	}
	
	/// <summary>
	/// Filters results based on timestamp range (in epochs).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DateRangeType
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartValue { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndValue { get; set; }
	}
	
	/// <summary>
	/// The result of the sort operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchSortResult
	{
		
		[System.Runtime.Serialization.DataMember()]
		public OrderByFieldType Field { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SortOrder Order { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OrderByFieldType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RELEVANCE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NAME = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SIZE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATED_TIMESTAMP = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODIFIED_TIMESTAMP = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SortOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DESC = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateUserResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public User User { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class IllegalUserStateException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeactivatingLastSystemUserException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AbortDocumentVersionUploadRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ActivateUserRequest
	{
	}
	
	/// <summary>
	/// Set of options which defines notification preferences of given action.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NotificationOptions
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SendEmail { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EmailMessage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AddResourcePermissionsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SharePrincipal[] Principals { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public NotificationOptions NotificationOptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum BooleanEnumType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRUE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FALSE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateCommentRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ThreadId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Text { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public CommentVisibilityType Visibility { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> NotifyCollaborators { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateCustomMetadataRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public CustomMetadataMap CustomMetadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateFolderRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ParentFolderId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateLabelsRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] Labels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SubscriptionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateNotificationSubscriptionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Endpoint { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SubscriptionProtocolType Protocol { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SubscriptionType SubscriptionType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CreateUserRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Username { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EmailAddress { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string GivenName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Surname { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Password { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TimeZoneId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageRuleType StorageRule { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeactivateUserRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteCommentRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteCustomMetadataRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteDocumentRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteDocumentVersionRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteFolderContentsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteFolderRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteLabelsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteNotificationSubscriptionRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DeleteUserRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeActivitiesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeCommentsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeDocumentVersionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ResourceSortType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NAME = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OrderType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASCENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DESCENDING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FolderContentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCUMENT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOLDER = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeFolderContentsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeGroupsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeNotificationSubscriptionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeResourcePermissionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeRootFoldersRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UserFilterType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE_PENDING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UserSortType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER_NAME = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FULL_NAME = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STORAGE_LIMIT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER_STATUS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STORAGE_USED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DescribeUsersRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DocumentSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORIGINAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WITH_COMMENTS = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DocumentThumbnailType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SMALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SMALL_HQ = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LARGE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DocumentVersionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
	}
	
	/// <summary>
	/// Filters results based on entity metadata.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Filters
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LanguageCodeType[] TextLocales { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ContentCategoryType[] ContentCategories { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SearchResourceType[] ResourceTypes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SearchPrincipalType[] Principals { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] AncestorIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SearchCollectionType[] SearchCollectionTypes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LongRangeType SizeRange { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DateRangeType CreatedRange { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DateRangeType ModifiedRange { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetCurrentUserRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDocumentPathRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDocumentRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetDocumentVersionRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetFolderPathRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetFolderRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ResourceCollectionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHARED_WITH_ME = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GetResourcesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InitiateDocumentVersionUploadRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ContentCreatedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset ContentModifiedTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ContentType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DocumentSizeInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentFolderId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RemoveAllResourcePermissionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RemoveResourcePermissionRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RestoreDocumentVersionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchResourcesRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string QueryText { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SearchQueryScopeType[] QueryScopes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OrganizationId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public AdditionalResponseFieldType[] AdditionalResponseFields { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Filters Filters { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SearchSortResult[] OrderBy { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Marker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateDocumentRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceStateType ResourceState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateDocumentVersionRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public DocumentVersionStatus VersionStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateFolderRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ParentFolderId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ResourceStateType ResourceState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateUserRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string GivenName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Surname { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageRuleType StorageRule { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TimeZoneId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LocaleType Locale { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BooleanEnumType GrantPoweruserPrivileges { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Aborts the upload of the specified document version that was previously initiated by <a>InitiateDocumentVersionUpload</a>. The client should make this call only when it no longer intends to upload the document version, or fails to do so.
		/// AbortDocumentVersionUpload api/v1/documents/{DocumentId}/versions/{VersionId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="VersionId">The ID of the version.
		/// Min length: 1
		/// Max length: 128
		// </param>
		public async Task AbortDocumentVersionUploadAsync(string DocumentId, string VersionId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : System.Uri.EscapeDataString(VersionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves version metadata for the specified document.
		/// GetDocumentVersion api/v1/documents/{DocumentId}/versions/{VersionId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="VersionId">The version ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="fields">A comma-separated list of values. Specify "SOURCE" to include a URL for the source document.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="includeCustomMetadata">Set this to TRUE to include custom metadata in the response.</param>
		/// <returns>Success</returns>
		public async Task<GetDocumentVersionResponse> GetDocumentVersionAsync(string DocumentId, string VersionId, string fields, bool includeCustomMetadata, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : System.Uri.EscapeDataString(VersionId))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields))+"&includeCustomMetadata="+includeCustomMetadata;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetDocumentVersionResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Changes the status of the document version to ACTIVE. </p> <p>Amazon WorkDocs also sets its document container to ACTIVE. This is the last step in a document upload, after the client uploads the document to an S3-presigned URL returned by <a>InitiateDocumentVersionUpload</a>. </p>
		/// UpdateDocumentVersion api/v1/documents/{DocumentId}/versions/{VersionId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="VersionId">The version ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <returns>Success</returns>
		public async Task UpdateDocumentVersionAsync(string DocumentId, string VersionId, UpdateDocumentVersionPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : System.Uri.EscapeDataString(VersionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Activates the specified user. Only active users can access Amazon WorkDocs.
		/// ActivateUser api/v1/users/{UserId}/activation
		/// </summary>
		/// <param name="UserId">The ID of the user.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <returns>Success</returns>
		public async Task<ActivateUserResponse> ActivateUserAsync(string UserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/users/"+ (UserId==null? "" : System.Uri.EscapeDataString(UserId))+"/activation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ActivateUserResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deactivates the specified user, which revokes the user's access to Amazon WorkDocs.
		/// DeactivateUser api/v1/users/{UserId}/activation
		/// </summary>
		/// <param name="UserId">The ID of the user.
		/// Min length: 1
		/// Max length: 256
		// </param>
		public async Task DeactivateUserAsync(string UserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/users/"+ (UserId==null? "" : System.Uri.EscapeDataString(UserId))+"/activation";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a set of permissions for the specified folder or document. The resource permissions are overwritten if the principals already have different permissions.
		/// AddResourcePermissions api/v1/resources/{ResourceId}/permissions
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.
		/// Min length: 1
		/// Max length: 128
		// </param>
		public async Task AddResourcePermissionsAsync(string ResourceId, AddResourcePermissionsPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/resources/"+ (ResourceId==null? "" : System.Uri.EscapeDataString(ResourceId))+"/permissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes the permissions of a specified resource.
		/// DescribeResourcePermissions api/v1/resources/{ResourceId}/permissions
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="principalId">The ID of the principal to filter permissions by.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="limit">The maximum number of items to return with this call.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call)
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeResourcePermissionsResponse> DescribeResourcePermissionsAsync(string ResourceId, string principalId, int limit, string marker, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/resources/"+ (ResourceId==null? "" : System.Uri.EscapeDataString(ResourceId))+"/permissions&principalId=" + (principalId==null? "" : System.Uri.EscapeDataString(principalId))+"&limit="+limit+"&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeResourcePermissionsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes all the permissions from the specified resource.
		/// RemoveAllResourcePermissions api/v1/resources/{ResourceId}/permissions
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.
		/// Min length: 1
		/// Max length: 128
		// </param>
		public async Task RemoveAllResourcePermissionsAsync(string ResourceId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/resources/"+ (ResourceId==null? "" : System.Uri.EscapeDataString(ResourceId))+"/permissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a new comment to the specified document version.
		/// CreateComment api/v1/documents/{DocumentId}/versions/{VersionId}/comment
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="VersionId">The ID of the document version.
		/// Min length: 1
		/// Max length: 128
		// </param>
		public async Task CreateCommentAsync(string DocumentId, string VersionId, CreateCommentPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : System.Uri.EscapeDataString(VersionId))+"/comment";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds one or more custom properties to the specified resource (a folder, document, or version).
		/// CreateCustomMetadata api/v1/resources/{ResourceId}/customMetadata
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="versionid">The ID of the version, if the custom metadata is being added to a document version.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateCustomMetadataResponse> CreateCustomMetadataAsync(string ResourceId, string versionid, CreateCustomMetadataPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/resources/"+ (ResourceId==null? "" : System.Uri.EscapeDataString(ResourceId))+"/customMetadata&versionid=" + (versionid==null? "" : System.Uri.EscapeDataString(versionid));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateCustomMetadataResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes custom metadata from the specified resource.
		/// DeleteCustomMetadata api/v1/resources/{ResourceId}/customMetadata
		/// </summary>
		/// <param name="ResourceId">The ID of the resource, either a document or folder.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="versionId">The ID of the version, if the custom metadata is being deleted from a document version.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="keys">List of properties to remove.
		/// Maximum items: 8
		// </param>
		/// <param name="deleteAll">Flag to indicate removal of all custom metadata properties from the specified resource.</param>
		/// <returns>Success</returns>
		public async Task<DeleteCustomMetadataResponse> DeleteCustomMetadataAsync(string ResourceId, string versionId, string[] keys, bool deleteAll, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/resources/"+ (ResourceId==null? "" : System.Uri.EscapeDataString(ResourceId))+"/customMetadata&versionId=" + (versionId==null? "" : System.Uri.EscapeDataString(versionId))+"&"+string.Join("&", keys.Select(z => $"keys={System.Uri.EscapeDataString(z.ToString())}"))+"&deleteAll="+deleteAll;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DeleteCustomMetadataResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a folder with the specified name and parent folder.
		/// CreateFolder api/v1/folders
		/// </summary>
		public async Task CreateFolderAsync(CreateFolderPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/folders";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds the specified list of labels to the given resource (a document or folder)
		/// CreateLabels api/v1/resources/{ResourceId}/labels
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateLabelsResponse> CreateLabelsAsync(string ResourceId, CreateLabelsPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/resources/"+ (ResourceId==null? "" : System.Uri.EscapeDataString(ResourceId))+"/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateLabelsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified list of labels from a resource.
		/// DeleteLabels api/v1/resources/{ResourceId}/labels
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="labels">List of labels to delete from the resource.
		/// Maximum items: 20
		// </param>
		/// <param name="deleteAll">Flag to request removal of all labels from the specified resource.</param>
		/// <returns>Success</returns>
		public async Task<DeleteLabelsResponse> DeleteLabelsAsync(string ResourceId, string[] labels, bool deleteAll, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/resources/"+ (ResourceId==null? "" : System.Uri.EscapeDataString(ResourceId))+"/labels&"+string.Join("&", labels.Select(z => $"labels={System.Uri.EscapeDataString(z.ToString())}"))+"&deleteAll="+deleteAll;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DeleteLabelsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Configure Amazon WorkDocs to use Amazon SNS notifications. The endpoint receives a confirmation message, and must confirm the subscription.</p> <p>For more information, see <a href="https://docs.aws.amazon.com/workdocs/latest/developerguide/manage-notifications.html">Setting up notifications for an IAM user or role</a> in the <i>Amazon WorkDocs Developer Guide</i>.</p>
		/// CreateNotificationSubscription api/v1/organizations/{OrganizationId}/subscriptions
		/// </summary>
		/// <param name="OrganizationId">The ID of the organization.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <returns>Success</returns>
		public async Task<CreateNotificationSubscriptionResponse> CreateNotificationSubscriptionAsync(string OrganizationId, CreateNotificationSubscriptionPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/organizations/"+ (OrganizationId==null? "" : System.Uri.EscapeDataString(OrganizationId))+"/subscriptions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CreateNotificationSubscriptionResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the specified notification subscriptions.
		/// DescribeNotificationSubscriptions api/v1/organizations/{OrganizationId}/subscriptions
		/// </summary>
		/// <param name="OrganizationId">The ID of the organization.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call.)
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="limit">The maximum number of items to return with this call.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeNotificationSubscriptionsResponse> DescribeNotificationSubscriptionsAsync(string OrganizationId, string marker, int limit, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/organizations/"+ (OrganizationId==null? "" : System.Uri.EscapeDataString(OrganizationId))+"/subscriptions&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&limit="+limit+"&Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeNotificationSubscriptionsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a user in a Simple AD or Microsoft AD directory. The status of a newly created user is "ACTIVE". New users can access Amazon WorkDocs.
		/// CreateUser api/v1/users
		/// </summary>
		public async Task CreateUserAsync(CreateUserPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/users";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Describes the specified users. You can describe all users or filter the results (for example, by status or organization).</p> <p>By default, Amazon WorkDocs returns the first 24 active or pending users. If there are more results, the response includes a marker that you can use to request the next set of results.</p>
		/// DescribeUsers api/v1/users
		/// </summary>
		/// <param name="organizationId">The ID of the organization.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="userIds">The IDs of the users.
		/// Min length: 1
		/// Max length: 2000
		// </param>
		/// <param name="query"><p>A query to filter users by user name. Remember the following about the <code>Userids</code> and <code>Query</code> parameters:</p> <ul> <li> <p>If you don't use either parameter, the API returns a paginated list of all users on the site.</p> </li> <li> <p>If you use both parameters, the API ignores the <code>Query</code> parameter.</p> </li> <li> <p>The <code>Userid</code> parameter only returns user names that match a corresponding user ID.</p> </li> <li> <p>The <code>Query</code> parameter runs a "prefix" search for users by the <code>GivenName</code>, <code>SurName</code>, or <code>UserName</code> fields included in a <a href="https://docs.aws.amazon.com/workdocs/latest/APIReference/API_CreateUser.html">CreateUser</a> API call. For example, querying on <code>Ma</code> returns Márcia Oliveira, María García, and Mateo Jackson. If you use multiple characters, the API only returns data that matches all characters. For example, querying on <code>Ma J</code> only returns Mateo Jackson.</p> </li> </ul>
		/// Min length: 1
		/// Max length: 512
		// </param>
		/// <param name="include">The state of the users. Specify "ALL" to include inactive users.</param>
		/// <param name="order">The order for the results.</param>
		/// <param name="sort">The sorting criteria.</param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call.)
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="limit">The maximum number of items to return.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="fields">A comma-separated list of values. Specify "STORAGE_METADATA" to include the user storage quota and utilization information.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeUsersResponse> DescribeUsersAsync(string organizationId, string userIds, string query, UserFilterType include, OrderType order, UserSortType sort, string marker, int limit, string fields, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/users?organizationId=" + (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"&userIds=" + (userIds==null? "" : System.Uri.EscapeDataString(userIds))+"&query=" + (query==null? "" : System.Uri.EscapeDataString(query))+"&include=" + include+"&order=" + order+"&sort=" + sort+"&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&limit="+limit+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields))+"&Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeUsersResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified comment from the document version.
		/// DeleteComment api/v1/documents/{DocumentId}/versions/{VersionId}/comment/{CommentId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="VersionId">The ID of the document version.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="CommentId">The ID of the comment.
		/// Min length: 1
		/// Max length: 128
		// </param>
		public async Task DeleteCommentAsync(string DocumentId, string VersionId, string CommentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : System.Uri.EscapeDataString(VersionId))+"/comment/"+ (CommentId==null? "" : System.Uri.EscapeDataString(CommentId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Permanently deletes the specified document and its associated metadata.
		/// DeleteDocument api/v1/documents/{DocumentId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		public async Task DeleteDocumentAsync(string DocumentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves details of a document.
		/// GetDocument api/v1/documents/{DocumentId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="includeCustomMetadata">Set this to <code>TRUE</code> to include custom metadata in the response.</param>
		/// <returns>Success</returns>
		public async Task<GetDocumentResponse> GetDocumentAsync(string DocumentId, bool includeCustomMetadata, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId))+"&includeCustomMetadata="+includeCustomMetadata;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetDocumentResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified attributes of a document. The user must have access to both the document and its parent folder, if applicable.
		/// UpdateDocument api/v1/documents/{DocumentId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <returns>Success</returns>
		public async Task UpdateDocumentAsync(string DocumentId, UpdateDocumentPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a specific version of a document.
		/// DeleteDocumentVersion api/v1/documentVersions/{DocumentId}/versions/{VersionId}#deletePriorVersions
		/// </summary>
		/// <param name="DocumentId">The ID of the document associated with the version being deleted.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="VersionId">The ID of the version being deleted.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="deletePriorVersions">Deletes all versions of a document prior to the current version.</param>
		public async Task DeleteDocumentVersionAsync(string DocumentId, string VersionId, bool deletePriorVersions, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documentVersions/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : System.Uri.EscapeDataString(VersionId))+"#deletePriorVersions&deletePriorVersions="+deletePriorVersions;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Permanently deletes the specified folder and its contents.
		/// DeleteFolder api/v1/folders/{FolderId}
		/// </summary>
		/// <param name="FolderId">The ID of the folder.
		/// Min length: 1
		/// Max length: 128
		// </param>
		public async Task DeleteFolderAsync(string FolderId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/folders/"+ (FolderId==null? "" : System.Uri.EscapeDataString(FolderId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the metadata of the specified folder.
		/// GetFolder api/v1/folders/{FolderId}
		/// </summary>
		/// <param name="FolderId">The ID of the folder.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="includeCustomMetadata">Set to TRUE to include custom metadata in the response.</param>
		/// <returns>Success</returns>
		public async Task<GetFolderResponse> GetFolderAsync(string FolderId, bool includeCustomMetadata, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/folders/"+ (FolderId==null? "" : System.Uri.EscapeDataString(FolderId))+"&includeCustomMetadata="+includeCustomMetadata;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetFolderResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified attributes of the specified folder. The user must have access to both the folder and its parent folder, if applicable.
		/// UpdateFolder api/v1/folders/{FolderId}
		/// </summary>
		/// <param name="FolderId">The ID of the folder.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <returns>Success</returns>
		public async Task UpdateFolderAsync(string FolderId, UpdateFolderPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/folders/"+ (FolderId==null? "" : System.Uri.EscapeDataString(FolderId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the contents of the specified folder.
		/// DeleteFolderContents api/v1/folders/{FolderId}/contents
		/// </summary>
		/// <param name="FolderId">The ID of the folder.
		/// Min length: 1
		/// Max length: 128
		// </param>
		public async Task DeleteFolderContentsAsync(string FolderId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/folders/"+ (FolderId==null? "" : System.Uri.EscapeDataString(FolderId))+"/contents";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Describes the contents of the specified folder, including its documents and subfolders.</p> <p>By default, Amazon WorkDocs returns the first 100 active document and folder metadata items. If there are more results, the response includes a marker that you can use to request the next set of results. You can also request initialized documents.</p>
		/// DescribeFolderContents api/v1/folders/{FolderId}/contents
		/// </summary>
		/// <param name="FolderId">The ID of the folder.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="sort">The sorting criteria.</param>
		/// <param name="order">The order for the contents of the folder.</param>
		/// <param name="limit">The maximum number of items to return with this call.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="marker">The marker for the next set of results. This marker was received from a previous call.
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="type">The type of items.</param>
		/// <param name="include">The contents to include. Specify "INITIALIZED" to include initialized documents.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeFolderContentsResponse> DescribeFolderContentsAsync(string FolderId, ResourceSortType sort, OrderType order, int limit, string marker, FolderContentType type, string include, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/folders/"+ (FolderId==null? "" : System.Uri.EscapeDataString(FolderId))+"/contents&sort=" + sort+"&order=" + order+"&limit="+limit+"&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&type=" + type+"&include=" + (include==null? "" : System.Uri.EscapeDataString(include))+"&Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeFolderContentsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified subscription from the specified organization.
		/// DeleteNotificationSubscription api/v1/organizations/{OrganizationId}/subscriptions/{SubscriptionId}
		/// </summary>
		/// <param name="SubscriptionId">The ID of the subscription.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="OrganizationId">The ID of the organization.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <returns>Success</returns>
		public async Task DeleteNotificationSubscriptionAsync(string SubscriptionId, string OrganizationId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/organizations/"+ (OrganizationId==null? "" : System.Uri.EscapeDataString(OrganizationId))+"/subscriptions/"+ (SubscriptionId==null? "" : System.Uri.EscapeDataString(SubscriptionId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Deletes the specified user from a Simple AD or Microsoft AD directory.</p> <important> <p>Deleting a user immediately and permanently deletes all content in that user's folder structure. Site retention policies do NOT apply to this type of deletion.</p> </important>
		/// DeleteUser api/v1/users/{UserId}
		/// </summary>
		/// <param name="UserId">The ID of the user.
		/// Min length: 1
		/// Max length: 256
		// </param>
		public async Task DeleteUserAsync(string UserId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/users/"+ (UserId==null? "" : System.Uri.EscapeDataString(UserId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified attributes of the specified user, and grants or revokes administrative privileges to the Amazon WorkDocs site.
		/// UpdateUser api/v1/users/{UserId}
		/// </summary>
		/// <param name="UserId">The ID of the user.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <returns>Success</returns>
		public async Task<UpdateUserResponse> UpdateUserAsync(string UserId, UpdateUserPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/users/"+ (UserId==null? "" : System.Uri.EscapeDataString(UserId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UpdateUserResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes the user activities in a specified time period.
		/// DescribeActivities api/v1/activities
		/// </summary>
		/// <param name="startTime">The timestamp that determines the starting time of the activities. The response includes the activities performed after the specified timestamp.</param>
		/// <param name="endTime">The timestamp that determines the end time of the activities. The response includes the activities performed before the specified timestamp.</param>
		/// <param name="organizationId">The ID of the organization. This is a mandatory parameter when using administrative API (SigV4) requests.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="activityTypes">Specifies which activity types to include in the response. If this field is left empty, all activity types are returned.
		/// Min length: 1
		/// Max length: 1024
		// </param>
		/// <param name="resourceId">The document or folder ID for which to describe activity types.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="userId">The ID of the user who performed the action. The response includes activities pertaining to this user. This is an optional parameter and is only applicable for administrative API (SigV4) requests.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="includeIndirectActivities">Includes indirect activities. An indirect activity results from a direct activity performed on a parent resource. For example, sharing a parent folder (the direct activity) shares all of the subfolders and documents within the parent folder (the indirect activity).</param>
		/// <param name="limit">The maximum number of items to return.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="marker">The marker for the next set of results.
		/// Min length: 1
		/// Max length: 12288
		// </param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeActivitiesResponse> DescribeActivitiesAsync(System.DateTimeOffset startTime, System.DateTimeOffset endTime, string organizationId, string activityTypes, string resourceId, string userId, bool includeIndirectActivities, int limit, string marker, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/activities?startTime=" + startTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&endTime=" + endTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&organizationId=" + (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"&activityTypes=" + (activityTypes==null? "" : System.Uri.EscapeDataString(activityTypes))+"&resourceId=" + (resourceId==null? "" : System.Uri.EscapeDataString(resourceId))+"&userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&includeIndirectActivities="+includeIndirectActivities+"&limit="+limit+"&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeActivitiesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all the comments for the specified document version.
		/// DescribeComments api/v1/documents/{DocumentId}/versions/{VersionId}/comments
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="VersionId">The ID of the document version.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="limit">The maximum number of items to return.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="marker">The marker for the next set of results. This marker was received from a previous call.
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeCommentsResponse> DescribeCommentsAsync(string DocumentId, string VersionId, int limit, string marker, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId))+"/versions/"+ (VersionId==null? "" : System.Uri.EscapeDataString(VersionId))+"/comments&limit="+limit+"&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeCommentsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves the document versions for the specified document.</p> <p>By default, only active versions are returned.</p>
		/// DescribeDocumentVersions api/v1/documents/{DocumentId}/versions
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call.)
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="limit">The maximum number of versions to return with this call.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="include">A comma-separated list of values. Specify "INITIALIZED" to include incomplete versions.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="fields">Specify "SOURCE" to include initialized versions and a URL for the source document.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeDocumentVersionsResponse> DescribeDocumentVersionsAsync(string DocumentId, string marker, int limit, string include, string fields, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId))+"/versions&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&limit="+limit+"&include=" + (include==null? "" : System.Uri.EscapeDataString(include))+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields))+"&Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeDocumentVersionsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Describes the groups specified by the query. Groups are defined by the underlying Active Directory.
		/// DescribeGroups api/v1/groups#searchQuery
		/// </summary>
		/// <param name="searchQuery">A query to describe groups by group name.
		/// Min length: 1
		/// Max length: 512
		// </param>
		/// <param name="organizationId">The ID of the organization.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call.)
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="limit">The maximum number of items to return with this call.
		/// Minimum: 1
		// </param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeGroupsResponse> DescribeGroupsAsync(string searchQuery, string organizationId, string marker, int limit, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/groups#searchQuery?searchQuery=" + (searchQuery==null? "" : System.Uri.EscapeDataString(searchQuery))+"&organizationId=" + (organizationId==null? "" : System.Uri.EscapeDataString(organizationId))+"&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&limit="+limit+"&Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeGroupsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Describes the current user's special folders; the <code>RootFolder</code> and the <code>RecycleBin</code>. <code>RootFolder</code> is the root of user's files and folders and <code>RecycleBin</code> is the root of recycled items. This is not a valid action for SigV4 (administrative API) clients.</p> <p>This action requires an authentication token. To get an authentication token, register an application with Amazon WorkDocs. For more information, see <a href="https://docs.aws.amazon.com/workdocs/latest/developerguide/wd-auth-user.html">Authentication and Access Control for User Applications</a> in the <i>Amazon WorkDocs Developer Guide</i>.</p>
		/// DescribeRootFolders api/v1/me/root#Authentication
		/// </summary>
		/// <param name="limit">The maximum number of items to return.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="marker">The marker for the next set of results. (You received this marker from a previous call.)
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<DescribeRootFoldersResponse> DescribeRootFoldersAsync(int limit, string marker, string Limit, string Marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/me/root#Authentication?limit="+limit+"&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker))+"&Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DescribeRootFoldersResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves details of the current user for whom the authentication token was generated. This is not a valid action for SigV4 (administrative API) clients.</p> <p>This action requires an authentication token. To get an authentication token, register an application with Amazon WorkDocs. For more information, see <a href="https://docs.aws.amazon.com/workdocs/latest/developerguide/wd-auth-user.html">Authentication and Access Control for User Applications</a> in the <i>Amazon WorkDocs Developer Guide</i>.</p>
		/// GetCurrentUser api/v1/me#Authentication
		/// </summary>
		/// <returns>Success</returns>
		public async Task<GetCurrentUserResponse> GetCurrentUserAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/me#Authentication";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetCurrentUserResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves the path information (the hierarchy from the root folder) for the requested document.</p> <p>By default, Amazon WorkDocs returns a maximum of 100 levels upwards from the requested document and only includes the IDs of the parent folders in the path. You can limit the maximum number of levels. You can also request the names of the parent folders.</p>
		/// GetDocumentPath api/v1/documents/{DocumentId}/path
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="limit">The maximum number of levels in the hierarchy to return.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="fields">A comma-separated list of values. Specify <code>NAME</code> to include the names of the parent folders.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="marker">This value is not supported.
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <returns>Success</returns>
		public async Task<GetDocumentPathResponse> GetDocumentPathAsync(string DocumentId, int limit, string fields, string marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId))+"/path&limit="+limit+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields))+"&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetDocumentPathResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Retrieves the path information (the hierarchy from the root folder) for the specified folder.</p> <p>By default, Amazon WorkDocs returns a maximum of 100 levels upwards from the requested folder and only includes the IDs of the parent folders in the path. You can limit the maximum number of levels. You can also request the parent folder names.</p>
		/// GetFolderPath api/v1/folders/{FolderId}/path
		/// </summary>
		/// <param name="FolderId">The ID of the folder.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="limit">The maximum number of levels in the hierarchy to return.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="fields">A comma-separated list of values. Specify "NAME" to include the names of the parent folders.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="marker">This value is not supported.
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <returns>Success</returns>
		public async Task<GetFolderPathResponse> GetFolderPathAsync(string FolderId, int limit, string fields, string marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/folders/"+ (FolderId==null? "" : System.Uri.EscapeDataString(FolderId))+"/path&limit="+limit+"&fields=" + (fields==null? "" : System.Uri.EscapeDataString(fields))+"&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetFolderPathResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a collection of resources, including folders and documents. The only <code>CollectionType</code> supported is <code>SHARED_WITH_ME</code>.
		/// GetResources api/v1/resources
		/// </summary>
		/// <param name="userId">The user ID for the resource collection. This is a required field for accessing the API operation using IAM credentials.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="collectionType">The collection type.</param>
		/// <param name="limit">The maximum number of resources to return.
		/// Minimum: 1
		/// Maximum: 999
		// </param>
		/// <param name="marker">The marker for the next set of results. This marker was received from a previous call.
		/// Min length: 1
		/// Max length: 2048
		// </param>
		/// <returns>Success</returns>
		public async Task<GetResourcesResponse> GetResourcesAsync(string userId, ResourceCollectionType collectionType, int limit, string marker, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/resources?userId=" + (userId==null? "" : System.Uri.EscapeDataString(userId))+"&collectionType=" + collectionType+"&limit="+limit+"&marker=" + (marker==null? "" : System.Uri.EscapeDataString(marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<GetResourcesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// <p>Creates a new document object and version object.</p> <p>The client specifies the parent folder ID and name of the document to upload. The ID is optionally specified when creating a new version of an existing document. This is the first step to upload a document. Next, upload the document to the URL returned from the call, and then call <a>UpdateDocumentVersion</a>.</p> <p>To cancel the document upload, call <a>AbortDocumentVersionUpload</a>.</p>
		/// InitiateDocumentVersionUpload api/v1/documents
		/// </summary>
		public async Task InitiateDocumentVersionUploadAsync(InitiateDocumentVersionUploadPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documents";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes the permission for the specified principal from the specified resource.
		/// RemoveResourcePermission api/v1/resources/{ResourceId}/permissions/{PrincipalId}
		/// </summary>
		/// <param name="ResourceId">The ID of the resource.
		/// Min length: 1
		/// Max length: 128
		// </param>
		/// <param name="PrincipalId">The principal ID of the resource.
		/// Min length: 1
		/// Max length: 256
		// </param>
		/// <param name="type">The principal type of the resource.</param>
		public async Task RemoveResourcePermissionAsync(string ResourceId, string PrincipalId, PrincipalType type, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/resources/"+ (ResourceId==null? "" : System.Uri.EscapeDataString(ResourceId))+"/permissions/"+ (PrincipalId==null? "" : System.Uri.EscapeDataString(PrincipalId))+"&type=" + type;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Recovers a deleted version of an Amazon WorkDocs document.
		/// RestoreDocumentVersions api/v1/documentVersions/restore/{DocumentId}
		/// </summary>
		/// <param name="DocumentId">The ID of the document.
		/// Min length: 1
		/// Max length: 128
		// </param>
		public async Task RestoreDocumentVersionsAsync(string DocumentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/documentVersions/restore/"+ (DocumentId==null? "" : System.Uri.EscapeDataString(DocumentId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Searches metadata and the content of folders, documents, document versions, and comments.
		/// SearchResources api/v1/search
		/// </summary>
		/// <param name="Limit">Pagination limit</param>
		/// <param name="Marker">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<SearchResourcesResponse> SearchResourcesAsync(string Limit, string Marker, SearchResourcesPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v1/search?Limit=" + (Limit==null? "" : System.Uri.EscapeDataString(Limit))+"&Marker=" + (Marker==null? "" : System.Uri.EscapeDataString(Marker));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SearchResourcesResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class UpdateDocumentVersionPatchBody
	{
		
		/// <summary>
		/// The status of the version.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public DocumentVersionStatus VersionStatus { get; set; }
	}
	
	public class AddResourcePermissionsPostBody
	{
		
		/// <summary>
		/// The users, groups, or organization being granted permission.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SharePrincipal[] Principals { get; set; }
		
		/// <summary>
		/// Set of options which defines notification preferences of given action.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AddResourcePermissionsPostBodyNotificationOptions NotificationOptions { get; set; }
	}
	
	public class AddResourcePermissionsPostBodyNotificationOptions
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> SendEmail { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string EmailMessage { get; set; }
	}
	
	public class CreateCommentPostBody
	{
		
		/// <summary>
		/// The ID of the parent comment.
		/// Min length: 1
		/// Max length: 128
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\w+-.@]+")]
		public string ParentId { get; set; }
		
		/// <summary>
		/// The ID of the root comment in the thread.
		/// Min length: 1
		/// Max length: 128
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\w+-.@]+")]
		public string ThreadId { get; set; }
		
		/// <summary>
		/// The text of the comment.
		/// Required
		/// Min length: 1
		/// Max length: 2048
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(2048)]
		public string Text { get; set; }
		
		/// <summary>
		/// The visibility of the comment. Options are either PRIVATE, where the comment is visible only to the comment author and document owner and co-owners, or PUBLIC, where the comment is visible to document owners, co-owners, and contributors.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CommentVisibilityType Visibility { get; set; }
		
		/// <summary>
		/// Set this parameter to TRUE to send an email out to the document collaborators after the comment is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> NotifyCollaborators { get; set; }
	}
	
	public class CreateCustomMetadataPutBody
	{
		
		/// <summary>
		/// Custom metadata in the form of name-value pairs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.Collections.Generic.Dictionary<string, string> CustomMetadata { get; set; }
	}
	
	public class CreateFolderPostBody
	{
		
		/// <summary>
		/// The name of the new folder.
		/// Min length: 1
		/// Max length: 255
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\u0020-\u202D\u202F-\uFFFF]+")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the parent folder.
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\w+-.@]+")]
		public string ParentFolderId { get; set; }
	}
	
	public class CreateLabelsPutBody
	{
		
		/// <summary>
		/// List of labels to add to the resource.
		/// Required
		/// Maximum items: 20
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MaxLength(20)]
		public string[] Labels { get; set; }
	}
	
	public class CreateNotificationSubscriptionPostBody
	{
		
		/// <summary>
		/// The endpoint to receive the notifications. If the protocol is HTTPS, the endpoint is a URL that begins with <code>https</code>.
		/// Required
		/// Min length: 1
		/// Max length: 256
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string Endpoint { get; set; }
		
		/// <summary>
		/// The protocol to use. The supported value is https, which delivers JSON-encoded messages using HTTPS POST.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SubscriptionProtocolType Protocol { get; set; }
		
		/// <summary>
		/// The notification type.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public SubscriptionType SubscriptionType { get; set; }
	}
	
	public class CreateUserPostBody
	{
		
		/// <summary>
		/// The ID of the organization.
		/// Min length: 1
		/// Max length: 256
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[&\w+-.@]+")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// The login name of the user.
		/// Required
		/// Min length: 1
		/// Max length: 256
		/// Pattern: [\w\-+.]+(@[a-zA-Z0-9.\-]+\.[a-zA-Z]+)?
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\w\-+.]+(@[a-zA-Z0-9.\-]+\.[a-zA-Z]+)?")]
		public string Username { get; set; }
		
		/// <summary>
		/// The email address of the user.
		/// Min length: 1
		/// Max length: 256
		/// Pattern: [a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}")]
		public string EmailAddress { get; set; }
		
		/// <summary>
		/// The given name of the user.
		/// Required
		/// Min length: 1
		/// Max length: 64
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string GivenName { get; set; }
		
		/// <summary>
		/// The surname of the user.
		/// Required
		/// Min length: 1
		/// Max length: 64
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string Surname { get; set; }
		
		/// <summary>
		/// The password of the user.
		/// Required
		/// Min length: 4
		/// Max length: 32
		/// Pattern: [\u0020-\u00FF]+
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(4)]
		[System.ComponentModel.DataAnnotations.MaxLength(32)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\u0020-\u00FF]+")]
		public string Password { get; set; }
		
		/// <summary>
		/// The time zone ID of the user.
		/// Min length: 1
		/// Max length: 256
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string TimeZoneId { get; set; }
		
		/// <summary>
		/// Describes the storage for a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public CreateUserPostBodyStorageRule StorageRule { get; set; }
	}
	
	public class CreateUserPostBodyStorageRule
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StorageAllocatedInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageType StorageType { get; set; }
	}
	
	public class UpdateDocumentPatchBody
	{
		
		/// <summary>
		/// The name of the document.
		/// Min length: 1
		/// Max length: 255
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\u0020-\u202D\u202F-\uFFFF]+")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the parent folder.
		/// Min length: 1
		/// Max length: 128
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\w+-.@]+")]
		public string ParentFolderId { get; set; }
		
		/// <summary>
		/// The resource state of the document. Only ACTIVE and RECYCLED are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ResourceStateType ResourceState { get; set; }
	}
	
	public class UpdateFolderPatchBody
	{
		
		/// <summary>
		/// The name of the folder.
		/// Min length: 1
		/// Max length: 255
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\u0020-\u202D\u202F-\uFFFF]+")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ID of the parent folder.
		/// Min length: 1
		/// Max length: 128
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\w+-.@]+")]
		public string ParentFolderId { get; set; }
		
		/// <summary>
		/// The resource state of the folder. Only ACTIVE and RECYCLED are accepted values from the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public ResourceStateType ResourceState { get; set; }
	}
	
	public class UpdateUserPatchBody
	{
		
		/// <summary>
		/// The given name of the user.
		/// Min length: 1
		/// Max length: 64
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string GivenName { get; set; }
		
		/// <summary>
		/// The surname of the user.
		/// Min length: 1
		/// Max length: 64
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string Surname { get; set; }
		
		/// <summary>
		/// The type of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UserType Type { get; set; }
		
		/// <summary>
		/// Describes the storage for a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public UpdateUserPatchBodyStorageRule StorageRule { get; set; }
		
		/// <summary>
		/// The time zone ID of the user.
		/// Min length: 1
		/// Max length: 256
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		public string TimeZoneId { get; set; }
		
		/// <summary>
		/// The locale of the user.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<UpdateUserPatchBodyLocale> Locale { get; set; }
		
		/// <summary>
		/// Boolean value to determine whether the user is granted Power user privileges.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public BooleanEnumType GrantPoweruserPrivileges { get; set; }
	}
	
	public class UpdateUserPatchBodyStorageRule
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> StorageAllocatedInBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageType StorageType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum UpdateUserPatchBodyLocale
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		fr = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ko = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		de = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		es = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ja = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ru = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zh_CN = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		zh_TW = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pt_BR = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="default")]
		_default = 10,
	}
	
	public class InitiateDocumentVersionUploadPostBody
	{
		
		/// <summary>
		/// The ID of the document.
		/// Min length: 1
		/// Max length: 128
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\w+-.@]+")]
		public string Id { get; set; }
		
		/// <summary>
		/// The name of the document.
		/// Min length: 1
		/// Max length: 255
		/// Pattern: [\u0020-\u202D\u202F-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(255)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\u0020-\u202D\u202F-\uFFFF]+")]
		public string Name { get; set; }
		
		/// <summary>
		/// The timestamp when the content of the document was originally created.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ContentCreatedTimestamp { get; set; }
		
		/// <summary>
		/// The timestamp when the content of the document was modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.DateTimeOffset> ContentModifiedTimestamp { get; set; }
		
		/// <summary>
		/// The content type of the document.
		/// Min length: 1
		/// Max length: 128
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		public string ContentType { get; set; }
		
		/// <summary>
		/// The size of the document, in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> DocumentSizeInBytes { get; set; }
		
		/// <summary>
		/// The ID of the parent folder.
		/// Min length: 1
		/// Max length: 128
		/// Pattern: [\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\w+-.@]+")]
		public string ParentFolderId { get; set; }
	}
	
	public class SearchResourcesPostBody
	{
		
		/// <summary>
		/// The String to search for. Searches across different text fields based on request parameters. Use double quotes around the query string for exact phrase matches.
		/// Min length: 1
		/// Max length: 512
		/// Pattern: [\u0020-\uFFFF]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(512)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\u0020-\uFFFF]+")]
		public string QueryText { get; set; }
		
		/// <summary>
		/// Filter based on the text field type. A Folder has only a name and no content. A Comment has only content and no name. A Document or Document Version has a name and content
		/// Maximum items: 2
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MaxLength(2)]
		public SearchQueryScopeType[] QueryScopes { get; set; }
		
		/// <summary>
		/// Filters based on the resource owner OrgId. This is a mandatory parameter when using Admin SigV4 credentials.
		/// Min length: 1
		/// Max length: 256
		/// Pattern: [&\w+-.@]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(256)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[&\w+-.@]+")]
		public string OrganizationId { get; set; }
		
		/// <summary>
		/// A list of attributes to include in the response. Used to request fields that are not normally returned in a standard response.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public AdditionalResponseFieldType[] AdditionalResponseFields { get; set; }
		
		/// <summary>
		/// Filters results based on entity metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public SearchResourcesPostBodyFilters Filters { get; set; }
		
		/// <summary>
		/// Order by results in one or more categories.
		/// Maximum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MaxLength(1)]
		public SearchSortResult[] OrderBy { get; set; }
		
		/// <summary>
		/// Max results count per page.
		/// Minimum: 1
		/// Maximum: 100
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.Range(1, 100)]
		public System.Nullable<System.Int32> Limit { get; set; }
		
		/// <summary>
		/// The marker for the next set of results.
		/// Min length: 1
		/// Max length: 2048
		/// Pattern: [\d]+
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(2048)]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[\d]+")]
		public string Marker { get; set; }
	}
	
	public class SearchResourcesPostBodyFilters
	{
		
		[System.Runtime.Serialization.DataMember()]
		public LanguageCodeType[] TextLocales { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ContentCategoryType[] ContentCategories { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SearchResourceType[] ResourceTypes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SearchPrincipalType[] Principals { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] AncestorIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public SearchCollectionType[] SearchCollectionTypes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LongRangeType SizeRange { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DateRangeType CreatedRange { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public DateRangeType ModifiedRange { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
