//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ArtifactMetaData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public System.DateTimeOffset CreatedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="globalId")]
		public long GlobalId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="modifiedBy")]
		public string ModifiedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="modifiedOn")]
		public System.DateTimeOffset ModifiedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// User-defined name-value pairs. Name and value must be strings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Properties Properties { get; set; }
		
		/// <summary>
		/// Describes the state of an artifact or artifact version.  The following states
		///are possible:
		///
		///* ENABLED
		///* DISABLED
		///* DEPRECATED
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ArtifactMetaDataState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ArtifactMetaDataType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public long Version { get; set; }
	}
	
	/// <summary>
	/// User-defined name-value pairs. Name and value must be strings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Properties
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ArtifactMetaDataState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ArtifactMetaDataType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVRO = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROTOBUF = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROTOBUF_FD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPENAPI = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASYNCAPI = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRAPHQL = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KCONNECT = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WSDL = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XSD = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XML = 10,
	}
	
	/// <summary>
	/// Describes the response received when searching for artifacts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ArtifactSearchResults
	{
		
		/// <summary>
		/// The artifacts that matched the search criteria.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="artifacts")]
		public SearchedArtifact[] Artifacts { get; set; }
		
		/// <summary>
		/// The total number of artifacts that matched the search criteria.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="count")]
		public int Count { get; set; }
	}
	
	/// <summary>
	/// Models a single artifact from the result set returned when searching for artifacts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchedArtifact
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public System.DateTimeOffset CreatedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="modifiedBy")]
		public string ModifiedBy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="modifiedOn")]
		public System.Nullable<System.DateTimeOffset> ModifiedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes the state of an artifact or artifact version.  The following states
		///are possible:
		///
		///* ENABLED
		///* DISABLED
		///* DEPRECATED
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ArtifactMetaDataState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ArtifactMetaDataType Type { get; set; }
	}
	
	/// <summary>
	/// Describes the state of an artifact or artifact version.  The following states
	///are possible:
	///
	///* ENABLED
	///* DISABLED
	///* DEPRECATED
	///
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ArtifactState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ArtifactType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVRO = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROTOBUF = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROTOBUF_FD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPENAPI = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASYNCAPI = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRAPHQL = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KCONNECT = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WSDL = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XSD = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XML = 10,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EditableMetaData
	{
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// User-defined name-value pairs. Name and value must be strings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Properties Properties { get; set; }
	}
	
	/// <summary>
	/// All error responses, whether `4xx` or `5xx` will include one of these as the response
	///body.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Error
	{
		
		/// <summary>
		/// Full details about the error.  This might contain a server stack trace, for example.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detail")]
		public string Detail { get; set; }
		
		/// <summary>
		/// The server-side error code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error_code")]
		public System.Nullable<System.Int32> Error_code { get; set; }
		
		/// <summary>
		/// The short error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Rule
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="config")]
		public string Config { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<RuleType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum RuleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VALIDITY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPATIBILITY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SearchOver
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		everything = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		name = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		description = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		labels = 3,
	}
	
	/// <summary>
	/// Models a single artifact from the result set returned when searching for artifacts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SearchedVersion
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public System.DateTimeOffset CreatedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="globalId")]
		public long GlobalId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Describes the state of an artifact or artifact version.  The following states
		///are possible:
		///
		///* ENABLED
		///* DISABLED
		///* DEPRECATED
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ArtifactMetaDataState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ArtifactMetaDataType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public int Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SortOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		asc = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		desc = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UpdateState
	{
		
		/// <summary>
		/// Describes the state of an artifact or artifact version.  The following states
		///are possible:
		///
		///* ENABLED
		///* DISABLED
		///* DEPRECATED
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ArtifactMetaDataState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VersionMetaData
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdBy")]
		public string CreatedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public System.DateTimeOffset CreatedOn { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="globalId")]
		public long GlobalId { get; set; }
		
		/// <summary>
		/// The artifact id.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public string[] Labels { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// User-defined name-value pairs. Name and value must be strings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public Properties Properties { get; set; }
		
		/// <summary>
		/// Describes the state of an artifact or artifact version.  The following states
		///are possible:
		///
		///* ENABLED
		///* DISABLED
		///* DEPRECATED
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ArtifactMetaDataState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ArtifactMetaDataType Type { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public long Version { get; set; }
	}
	
	/// <summary>
	/// Describes the response received when searching for artifacts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class VersionSearchResults
	{
		
		/// <summary>
		/// The total number of artifacts that matched the search criteria.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="count")]
		public int Count { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="versions")]
		public SearchedVersion[] Versions { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// List all artifact IDs
		/// Returns a list of IDs of all artifacts in the registry as a flat list.  Typically the
		/// server is configured to limit the number of artifact IDs returned when a large number
		/// of artifacts exist. In this case, the result of this call may be non-deterministic. The
		/// default limit is typically 1000 artifacts.
		/// ListArtifacts artifacts
		/// </summary>
		/// <returns>On a successful response, returns an array of artifact IDs - one for each artifact
		///in the registry.</returns>
		public async Task<string[]> ListArtifactsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<string[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete artifact
		/// Deletes an artifact completely, resulting in all versions of the artifact also being
		/// deleted.  This may fail for one of the following reasons:
		/// 
		/// * No artifact with the `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// DeleteArtifact artifacts/{artifactId}
		/// </summary>
		public async Task DeleteArtifactAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get latest artifact
		/// Returns the latest version of the artifact in its raw form.  The `Content-Type` of the response depends on the artifact type.  In most cases, this is `application/json`, but for some types it may be different (for example, `PROTOBUF`). If the latest version of the artifact is marked as `DISABLED`, the next available non-disabled version will be used.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists or all versions are `DISABLED` (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetLatestArtifact artifacts/{artifactId}
		/// </summary>
		/// <returns>The most recent version of the artifact.</returns>
		public async Task GetLatestArtifactAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact metadata
		/// Gets the metadata for an artifact in the registry, based on the latest version. If the latest version of the artifact is marked as `DISABLED`, the next available non-disabled version will be used. The returned metadata includes both generated (read-only) and editable metadata (such as name and description).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists or all versions are `DISABLED` (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// GetArtifactMetaData artifacts/{artifactId}/meta
		/// </summary>
		/// <returns>The artifact's metadata.</returns>
		public async Task<ArtifactMetaData> GetArtifactMetaDataAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactMetaData>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact metadata by content
		/// Gets the metadata for an artifact that matches the raw content.  Searches the registry
		/// for a version of the given artifact matching the content provided in the body of the
		/// POST.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * Provided content (request body) was empty (HTTP error `400`)
		/// * No artifact with the `artifactId` exists (HTTP error `404`)
		/// * No artifact version matching the provided content exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetArtifactMetaDataByContent artifacts/{artifactId}/meta
		/// </summary>
		/// <returns>The metadata of the artifact version matching the provided content.</returns>
		public async Task<ArtifactMetaData> GetArtifactMetaDataByContentAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactMetaData>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete artifact rules
		/// Deletes all of the rules configured for the artifact.  After this is done, the global
		/// rules apply to the artifact again.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// DeleteArtifactRules artifacts/{artifactId}/rules
		/// </summary>
		public async Task DeleteArtifactRulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List artifact rules
		/// Returns a list of all rules configured for the artifact.  The set of rules determines
		/// how the content of an artifact can evolve over time.  If no rules are configured for
		/// an artifact, the set of globally configured rules are used.  If no global rules
		/// are defined, there are no restrictions on content evolution.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// ListArtifactRules artifacts/{artifactId}/rules
		/// </summary>
		/// <returns>Returns the names of the rules configured for the artifact.</returns>
		public async Task<RuleType[]> ListArtifactRulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RuleType[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create artifact rule
		/// Adds a rule to the list of rules that get applied to the artifact when adding new
		/// versions.  All configured rules must pass to successfully add a new artifact version.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * Rule (named in the request body) is unknown (HTTP error `400`)
		/// * A server error occurred (HTTP error `500`)
		/// CreateArtifactRule artifacts/{artifactId}/rules
		/// </summary>
		public async Task CreateArtifactRuleAsync(Rule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete artifact rule
		/// Deletes a rule from the artifact.  This results in the rule no longer applying for
		/// this artifact.  If this is the only rule configured for the artifact, this is the
		/// same as deleting **all** rules, and the globally configured rules now apply to
		/// this artifact.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No rule with this name/type is configured for this artifact (HTTP error `404`)
		/// * Invalid rule type (HTTP error `400`)
		/// * A server error occurred (HTTP error `500`)
		/// DeleteArtifactRule artifacts/{artifactId}/rules/{rule}
		/// </summary>
		public async Task DeleteArtifactRuleAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact rule configuration
		/// Returns information about a single rule configured for an artifact.  This is useful
		/// when you want to know what the current configuration settings are for a specific rule.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No rule with this name/type is configured for this artifact (HTTP error `404`)
		/// * Invalid rule type (HTTP error `400`)
		/// * A server error occurred (HTTP error `500`)
		/// GetArtifactRuleConfig artifacts/{artifactId}/rules/{rule}
		/// </summary>
		/// <returns>Information about a rule.</returns>
		public async Task<Rule> GetArtifactRuleConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Rule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update artifact rule configuration
		/// Updates the configuration of a single rule for the artifact.  The configuration data
		/// is specific to each rule type, so the configuration of the `COMPATIBILITY` rule
		/// is in a different format from the configuration of the `VALIDITY` rule.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No rule with this name/type is configured for this artifact (HTTP error `404`)
		/// * Invalid rule type (HTTP error `400`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateArtifactRuleConfig artifacts/{artifactId}/rules/{rule}
		/// </summary>
		/// <returns>Rule configuration was updated.</returns>
		public async Task<Rule> UpdateArtifactRuleConfigAsync(Rule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Rule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update artifact state
		/// Updates the state of the artifact. For example, you can use this to mark the latest version of an artifact as `DEPRECATED`. The operation changes the state of the latest version of the artifact, even if this version is `DISABLED`. If multiple versions exist, only the most recent is changed.
		/// 
		/// The following state changes are supported:
		/// 
		/// * Enabled -> Disabled
		/// * Enabled -> Deprecated
		/// * Enabled -> Deleted
		/// * Disabled -> Enabled
		/// * Disabled -> Deleted
		/// * Disabled -> Deprecated
		/// * Deprecated -> Deleted
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * Artifact cannot transition to the given state (HTTP error `400`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateArtifactState artifacts/{artifactId}/state
		/// </summary>
		public async Task UpdateArtifactStateAsync(UpdateState requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List artifact versions
		/// Returns a list of all version numbers for the artifact.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// ListArtifactVersions artifacts/{artifactId}/versions
		/// </summary>
		/// <returns>List of all artifact versions (just the version IDs).</returns>
		public async Task<int[]> ListArtifactVersionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/versions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<int[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact version
		/// Retrieves a single version of the artifact content.  Both the `artifactId` and the
		/// unique `version` number must be provided.  The `Content-Type` of the response depends
		/// on the artifact type.  In most cases, this is `application/json`, but for some types
		/// it may be different (for example, `PROTOBUF`).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetArtifactVersion artifacts/{artifactId}/versions/{version}
		/// </summary>
		/// <returns>The content of the artifact version.</returns>
		public async Task GetArtifactVersionAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/versions/{version}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete artifact version metadata
		/// Deletes the user-editable metadata properties of the artifact version.  Any properties
		/// that are not user-editable are preserved.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// DeleteArtifactVersionMetaData artifacts/{artifactId}/versions/{version}/meta
		/// </summary>
		public async Task DeleteArtifactVersionMetaDataAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/versions/{version}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact version metadata
		/// Retrieves the metadata for a single version of the artifact.  The version metadata is
		/// a subset of the artifact metadata and only includes the metadata that is specific to
		/// the version (for example, this doesn't include `modifiedOn`).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetArtifactVersionMetaData artifacts/{artifactId}/versions/{version}/meta
		/// </summary>
		/// <returns>The artifact version's metadata.</returns>
		public async Task<VersionMetaData> GetArtifactVersionMetaDataAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/versions/{version}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<VersionMetaData>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update artifact version metadata
		/// Updates the user-editable portion of the artifact version's metadata.  Only some of
		/// the metadata fields are editable by the user.  For example, `description` is editable,
		/// but `createdOn` is not.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateArtifactVersionMetaData artifacts/{artifactId}/versions/{version}/meta
		/// </summary>
		public async Task UpdateArtifactVersionMetaDataAsync(EditableMetaData requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/versions/{version}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update artifact version state
		/// Updates the state of a specific version of an artifact.  For example, you can use
		/// this operation to disable a specific version.
		/// 
		/// The following state changes are supported:
		/// 
		/// * Enabled -> Disabled
		/// * Enabled -> Deprecated
		/// * Enabled -> Deleted
		/// * Disabled -> Enabled
		/// * Disabled -> Deleted
		/// * Disabled -> Deprecated
		/// * Deprecated -> Deleted
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * No artifact with this `artifactId` exists (HTTP error `404`)
		/// * No version with this `version` exists (HTTP error `404`)
		/// * Artifact version cannot transition to the given state (HTTP error `400`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateArtifactVersionState artifacts/{artifactId}/versions/{version}/state
		/// </summary>
		public async Task UpdateArtifactVersionStateAsync(UpdateState requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "artifacts/{artifactId}/versions/{version}/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get artifact by global ID
		/// Gets the content for an artifact version in the registry using its globally unique
		/// identifier.
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * No artifact version with this `globalId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetArtifactByGlobalId ids/{globalId}
		/// </summary>
		/// <returns>The content of the artifact version.</returns>
		public async Task GetArtifactByGlobalIdAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ids/{globalId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get global artifact metadata
		/// Gets the metadata for an artifact version in the registry using its globally unique
		/// identifier.  The returned metadata includes both generated (read-only) and editable
		/// metadata (such as name and description).
		/// 
		/// This operation may fail for one of the following reasons:
		/// 
		/// * No artifact version with this `globalId` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetArtifactMetaDataByGlobalId ids/{globalId}/meta
		/// </summary>
		/// <returns>The artifact's metadata.</returns>
		public async Task<ArtifactMetaData> GetArtifactMetaDataByGlobalIdAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "ids/{globalId}/meta";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactMetaData>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete all global rules
		/// Deletes all globally configured rules.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// DeleteAllGlobalRules rules
		/// </summary>
		public async Task DeleteAllGlobalRulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List global rules
		/// Gets a list of all the currently configured global rules (if any).
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// ListGlobalRules rules
		/// </summary>
		/// <returns>The list of names of the globally configured rules.</returns>
		public async Task<RuleType[]> ListGlobalRulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RuleType[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create global rule
		/// Adds a rule to the list of globally configured rules.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * The rule type is unknown (HTTP error `400`)
		/// * The rule already exists (HTTP error `409`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// CreateGlobalRule rules
		/// </summary>
		public async Task CreateGlobalRuleAsync(Rule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "rules";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete global rule
		/// Deletes a single global rule.  If this is the only rule configured, this is the same
		/// as deleting **all** rules.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * Invalid rule name/type (HTTP error `400`)
		/// * No rule with name/type `rule` exists (HTTP error `404`)
		/// * Rule cannot be deleted (HTTP error `409`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// DeleteGlobalRule rules/{rule}
		/// </summary>
		public async Task DeleteGlobalRuleAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get global rule configuration
		/// Returns information about the named globally configured rule.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * Invalid rule name/type (HTTP error `400`)
		/// * No rule with name/type `rule` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// GetGlobalRuleConfig rules/{rule}
		/// </summary>
		/// <returns>The global rule's configuration.</returns>
		public async Task<Rule> GetGlobalRuleConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Rule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update global rule configuration
		/// Updates the configuration for a globally configured rule.
		/// 
		/// This operation can fail for the following reasons:
		/// 
		/// * Invalid rule name/type (HTTP error `400`)
		/// * No rule with name/type `rule` exists (HTTP error `404`)
		/// * A server error occurred (HTTP error `500`)
		/// 
		/// UpdateGlobalRuleConfig rules/{rule}
		/// </summary>
		/// <returns>The global rule's configuration was successfully updated.</returns>
		public async Task<Rule> UpdateGlobalRuleConfigAsync(Rule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "rules/{rule}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Rule>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search for artifacts
		/// Returns a paginated list of all artifacts that match the provided search criteria.
		/// 
		/// SearchArtifacts search/artifacts
		/// </summary>
		/// <param name="search">The text to search.</param>
		/// <param name="offset">The number of artifacts to skip before starting to collect the result set.</param>
		/// <param name="limit">The number of artifacts to return.</param>
		/// <param name="over">What fields to search.</param>
		/// <param name="order">Sort order, ascending or descending.</param>
		/// <returns>On a successful response, returns a result set of artifacts - one for each artifact
		///in the registry that matches the criteria.</returns>
		public async Task<ArtifactSearchResults> SearchArtifactsAsync(string search, int offset, int limit, SearchOver over, SortOrder order, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/artifacts?search=" + (search==null? "" : System.Uri.EscapeDataString(search))+"&offset="+offset+"&limit="+limit+"&over=" + over+"&order=" + order;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ArtifactSearchResults>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search artifact versions
		/// Searches for versions of a specific artifact.  This is typically used to get a listing
		/// of all versions of an artifact (for example, in a user interface).
		/// SearchVersions search/artifacts/{artifactId}/versions
		/// </summary>
		/// <param name="offset">The number of versions to skip before starting to collect the result set.</param>
		/// <param name="limit">The number of versions to return.</param>
		/// <returns>On a successful response, returns a result set of versions - one for each version
		///of the artifact.</returns>
		public async Task<VersionSearchResults> SearchVersionsAsync(int offset, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/artifacts/{artifactId}/versions?offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<VersionSearchResults>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum CreateArtifactIfExists
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAIL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RETURN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RETURN_OR_UPDATE = 3,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
