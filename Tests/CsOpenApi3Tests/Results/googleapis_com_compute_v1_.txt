//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Contains the configurations necessary to generate a signature for access to private storage buckets that support Signature Version 4 for authentication. The service name for generating the authentication header will always default to 's3'.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AWSV4Signature
	{
		
		/// <summary>
		/// The access key used for s3 bucket authentication. Required for updating or creating a backend that uses AWS v4 signature authentication, but will not be returned as part of the configuration when queried with a REST API GET request. @InputOnly
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessKey")]
		public string AccessKey { get; set; }
		
		/// <summary>
		/// The identifier of an access key used for s3 bucket authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessKeyId")]
		public string AccessKeyId { get; set; }
		
		/// <summary>
		/// The optional version identifier for the access key. You can use this to keep track of different iterations of your access key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessKeyVersion")]
		public string AccessKeyVersion { get; set; }
		
		/// <summary>
		/// The name of the cloud region of your origin. This is a free-form field with the name of the region your cloud uses to host your origin. For example, "us-east-1" for AWS or "us-ashburn-1" for OCI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="originRegion")]
		public string OriginRegion { get; set; }
	}
	
	/// <summary>
	/// A specification of the type and number of accelerator cards attached to the instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AcceleratorConfig
	{
		
		/// <summary>
		/// The number of the guest accelerator cards exposed to this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceleratorCount")]
		public System.Nullable<System.Int32> AcceleratorCount { get; set; }
		
		/// <summary>
		/// Full or partial URL of the accelerator type resource to attach to this instance. For example: projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100 If you are creating an instance template, specify only the accelerator name. See GPUs on Compute Engine for a full list of accelerator types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceleratorType")]
		public string AcceleratorType { get; set; }
	}
	
	/// <summary>
	/// Represents an Accelerator Type resource. Google Cloud Platform provides graphics processing units (accelerators) that you can add to VM instances to improve or accelerate performance when working with intensive workloads. For more information, read GPUs on Compute Engine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AcceleratorType
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// Deprecation status for a public resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public DeprecationStatus Deprecated { get; set; }
		
		/// <summary>
		/// [Output Only] An optional textual description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] The type of the resource. Always compute#acceleratorType for accelerator types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#acceleratorType")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#acceleratorType";
		
		/// <summary>
		/// [Output Only] Maximum number of accelerator cards allowed per instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumCardsPerInstance")]
		public System.Nullable<System.Int32> MaximumCardsPerInstance { get; set; }
		
		/// <summary>
		/// [Output Only] Name of the resource.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined, fully qualified URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the zone where the accelerator type resides, such as us-central1-a. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// Deprecation status for a public resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeprecationStatus
	{
		
		/// <summary>
		/// An optional RFC3339 timestamp on or after which the state of this resource is intended to change to DELETED. This is only informational and the status will not change unless the client explicitly changes it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public string Deleted { get; set; }
		
		/// <summary>
		/// An optional RFC3339 timestamp on or after which the state of this resource is intended to change to DEPRECATED. This is only informational and the status will not change unless the client explicitly changes it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public string Deprecated { get; set; }
		
		/// <summary>
		/// An optional RFC3339 timestamp on or after which the state of this resource is intended to change to OBSOLETE. This is only informational and the status will not change unless the client explicitly changes it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="obsolete")]
		public string Obsolete { get; set; }
		
		/// <summary>
		/// The URL of the suggested replacement for a deprecated resource. The suggested replacement resource must be the same kind of resource as the deprecated resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replacement")]
		public string Replacement { get; set; }
		
		/// <summary>
		/// The deprecation state of this resource. This can be ACTIVE, DEPRECATED, OBSOLETE, or DELETED. Operations which communicate the end of life date for an image, can use ACTIVE. Operations which create a new resource using a DEPRECATED resource will return successfully, but with a warning indicating the deprecated resource and recommending its replacement. Operations which use OBSOLETE or DELETED resources will be rejected and result in an error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<DeprecationStatusState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DeprecationStatusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OBSOLETE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AcceleratorTypeAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of AcceleratorTypesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, AcceleratorTypesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#acceleratorTypeAggregatedList for aggregated lists of accelerator types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#acceleratorTypeAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#acceleratorTypeAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public AcceleratorTypeAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AcceleratorTypesScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of accelerator types contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceleratorTypes")]
		public AcceleratorType[] AcceleratorTypes { get; set; }
		
		/// <summary>
		/// [Output Only] An informational warning that appears when the accelerator types list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public AcceleratorTypesScopedListWarning Warning { get; set; }
	}
	
	public class AcceleratorTypesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<AcceleratorTypesScopedListWarningCode> Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AcceleratorTypesScopedListWarningData[] AcceleratorTypesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AcceleratorTypesScopedListWarningCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLEANUP_FAILED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED_RESOURCE_USED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPRECATED_TYPE_USED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISK_SIZE_LARGER_THAN_IMAGE_SIZE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPERIMENTAL_TYPE_USED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL_API_WARNING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIELD_VALUE_OVERRIDEN = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INJECTED_KERNELS_DEPRECATED = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LARGE_DEPLOYMENT_WARNING = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LIST_OVERHEAD_QUOTA_EXCEED = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MISSING_TYPE_DEPENDENCY = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEXT_HOP_ADDRESS_NOT_ASSIGNED = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEXT_HOP_CANNOT_IP_FORWARD = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEXT_HOP_INSTANCE_NOT_FOUND = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEXT_HOP_INSTANCE_NOT_ON_NETWORK = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEXT_HOP_NOT_RUNNING = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_CRITICAL_ERROR = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_RESULTS_ON_PAGE = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTIAL_SUCCESS = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REQUIRED_TOS_AGREEMENT = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOURCE_NOT_DELETED = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCHEMA_VALIDATION_IGNORED = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SINGLE_INSTANCE_PROPERTY_TEMPLATE = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNDECLARED_PROPERTIES = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNREACHABLE = 27,
	}
	
	public class AcceleratorTypesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class AcceleratorTypeAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AcceleratorTypeAggregatedListWarningData[] AcceleratorTypeAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class AcceleratorTypeAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of accelerator types.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AcceleratorTypeList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of AcceleratorType resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public AcceleratorType[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#acceleratorTypeList for lists of accelerator types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#acceleratorTypeList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#acceleratorTypeList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public AcceleratorTypeListWarning Warning { get; set; }
	}
	
	public class AcceleratorTypeListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AcceleratorTypeListWarningData[] AcceleratorTypeListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class AcceleratorTypeListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// An access configuration attached to an instance's network interface. Only one access config per instance is supported.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AccessConfig
	{
		
		/// <summary>
		/// Applies to ipv6AccessConfigs only. The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalIpv6")]
		public string ExternalIpv6 { get; set; }
		
		/// <summary>
		/// Applies to ipv6AccessConfigs only. The prefix length of the external IPv6 range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalIpv6PrefixLength")]
		public System.Nullable<System.Int32> ExternalIpv6PrefixLength { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#accessConfig for access configs.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#accessConfig")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#accessConfig";
		
		/// <summary>
		/// The name of this access configuration. In accessConfigs (IPv4), the default and recommended name is External NAT, but you can use any arbitrary string, such as My external IP or Network Access. In ipv6AccessConfigs, the recommend name is External IPv6.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Applies to accessConfigs (IPv4) only. An external IP address associated with this instance. Specify an unused static external IP address available to the project or leave this field undefined to use an IP from a shared ephemeral IP address pool. If you specify a static external IP address, it must live in the same region as the zone of the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natIP")]
		public string NatIP { get; set; }
		
		/// <summary>
		/// This signifies the networking tier used for configuring this access configuration and can only take the following values: PREMIUM, STANDARD. If an AccessConfig is specified without a valid external IP address, an ephemeral IP will be created with this networkTier. If an AccessConfig with a valid external IP address is specified, it must match that of the networkTier associated with the Address resource owning that IP.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTier")]
		public System.Nullable<AccessConfigNetworkTier> NetworkTier { get; set; }
		
		/// <summary>
		/// The DNS domain name for the public PTR record. You can set this field only if the `setPublicPtr` field is enabled in accessConfig. If this field is unspecified in ipv6AccessConfig, a default PTR record will be createc for first IP in associated external IPv6 range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicPtrDomainName")]
		public string PublicPtrDomainName { get; set; }
		
		/// <summary>
		/// [Output Only] The resource URL for the security policy associated with this access config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securityPolicy")]
		public string SecurityPolicy { get; set; }
		
		/// <summary>
		/// Specifies whether a public DNS 'PTR' record should be created to map the external IP address of the instance to a DNS domain name. This field is not used in ipv6AccessConfig. A default PTR record will be created if the VM has external IPv6 range associated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="setPublicPtr")]
		public System.Nullable<System.Boolean> SetPublicPtr { get; set; }
		
		/// <summary>
		/// The type of configuration. In accessConfigs (IPv4), the default and only option is ONE_TO_ONE_NAT. In ipv6AccessConfigs, the default and only option is DIRECT_IPV6.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<AccessConfigType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AccessConfigNetworkTier
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIXED_STANDARD = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREMIUM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD_OVERRIDES_FIXED_STANDARD = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AccessConfigType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIRECT_IPV6 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONE_TO_ONE_NAT = 1,
	}
	
	/// <summary>
	/// Represents an IP Address resource. Google Compute Engine has two IP Address resources: * [Global (external and internal)](https://cloud.google.com/compute/docs/reference/rest/v1/globalAddresses) * [Regional (external and internal)](https://cloud.google.com/compute/docs/reference/rest/v1/addresses) For more information, see Reserving a static external IP address.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Address
	{
		
		/// <summary>
		/// The static IP address represented by this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address1 { get; set; }
		
		/// <summary>
		/// The type of address to reserve, either INTERNAL or EXTERNAL. If unspecified, defaults to EXTERNAL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addressType")]
		public System.Nullable<AddressAddressType> AddressType { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this field when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The IP version that will be used by this address. Valid options are IPV4 or IPV6.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipVersion")]
		public System.Nullable<AddressIpVersion> IpVersion { get; set; }
		
		/// <summary>
		/// The endpoint type of this address, which should be VM or NETLB. This is used for deciding which type of endpoint this address can be used after the external IPv6 address reservation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6EndpointType")]
		public System.Nullable<AddressIpv6EndpointType> Ipv6EndpointType { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#address for addresses.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#address")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#address";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this Address, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an Address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels for this resource. These can only be added or modified by the setLabels method. Each label key/value pair must comply with RFC1035. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all following characters (except for the last character) must be a dash, lowercase letter, or digit. The last character must be a lowercase letter or digit.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The URL of the network in which to reserve the address. This field can only be used with INTERNAL type with the VPC_PEERING purpose.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// This signifies the networking tier used for configuring this address and can only take the following values: PREMIUM or STANDARD. Internal IP addresses are always Premium Tier; global external IP addresses are always Premium Tier; regional external IP addresses can be either Standard or Premium Tier. If this field is not specified, it is assumed to be PREMIUM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTier")]
		public AccessConfigNetworkTier NetworkTier { get; set; }
		
		/// <summary>
		/// The prefix length if the resource represents an IP range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixLength")]
		public System.Nullable<System.Int32> PrefixLength { get; set; }
		
		/// <summary>
		/// The purpose of this resource, which can be one of the following values: - GCE_ENDPOINT for addresses that are used by VM instances, alias IP ranges, load balancers, and similar resources. - DNS_RESOLVER for a DNS resolver address in a subnetwork for a Cloud DNS inbound forwarder IP addresses (regional internal IP address in a subnet of a VPC network) - VPC_PEERING for global internal IP addresses used for private services access allocated ranges. - NAT_AUTO for the regional external IP addresses used by Cloud NAT when allocating addresses using automatic NAT IP address allocation. - IPSEC_INTERCONNECT for addresses created from a private IP range that are reserved for a VLAN attachment in an *HA VPN over Cloud Interconnect* configuration. These addresses are regional resources. - `SHARED_LOADBALANCER_VIP` for an internal IP address that is assigned to multiple internal forwarding rules. - `PRIVATE_SERVICE_CONNECT` for a private network address that is used to configure Private Service Connect. Only global internal addresses can use this purpose. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="purpose")]
		public System.Nullable<AddressPurpose> Purpose { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the region where a regional address resides. For regional addresses, you must specify the region as a path parameter in the HTTP request URL. *This field is not applicable to global addresses.*
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the address, which can be one of RESERVING, RESERVED, or IN_USE. An address that is RESERVING is currently in the process of being reserved. A RESERVED address is currently reserved and available to use. An IN_USE address is currently being used by another resource and is not available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<AddressStatus> Status { get; set; }
		
		/// <summary>
		/// The URL of the subnetwork in which to reserve the address. If an IP address is specified, it must be within the subnetwork's IP range. This field can only be used with INTERNAL type with a GCE_ENDPOINT or DNS_RESOLVER purpose.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetwork")]
		public string Subnetwork { get; set; }
		
		/// <summary>
		/// [Output Only] The URLs of the resources that are using this address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="users")]
		public string[] Users { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AddressAddressType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED_TYPE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AddressIpVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPV4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPV6 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED_VERSION = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AddressIpv6EndpointType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETLB = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VM = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AddressPurpose
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DNS_RESOLVER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GCE_ENDPOINT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPSEC_INTERCONNECT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NAT_AUTO = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE_SERVICE_CONNECT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVERLESS = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHARED_LOADBALANCER_VIP = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPC_PEERING = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AddressStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_USE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESERVED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESERVING = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AddressAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of AddressesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, AddressesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#addressAggregatedList for aggregated lists of addresses.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#addressAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#addressAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public AddressAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AddressesScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of addresses contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="addresses")]
		public Address[] Addresses { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning which replaces the list of addresses when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public AddressesScopedListWarning Warning { get; set; }
	}
	
	public class AddressesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AddressesScopedListWarningData[] AddressesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class AddressesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class AddressAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AddressAggregatedListWarningData[] AddressAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class AddressAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of addresses.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AddressList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Address resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Address[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#addressList for lists of addresses.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#addressList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#addressList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public AddressListWarning Warning { get; set; }
	}
	
	public class AddressListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AddressListWarningData[] AddressListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class AddressListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Specifies options for controlling advanced machine features. Options that would traditionally be configured in a BIOS belong here. Features that require operating system support may have corresponding entries in the GuestOsFeatures of an Image (e.g., whether or not the OS in the Image supports nested virtualization being enabled or disabled).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AdvancedMachineFeatures
	{
		
		/// <summary>
		/// Whether to enable nested virtualization or not (default is false).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableNestedVirtualization")]
		public System.Nullable<System.Boolean> EnableNestedVirtualization { get; set; }
		
		/// <summary>
		/// Whether to enable UEFI networking for instance creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableUefiNetworking")]
		public System.Nullable<System.Boolean> EnableUefiNetworking { get; set; }
		
		/// <summary>
		/// The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="threadsPerCore")]
		public System.Nullable<System.Int32> ThreadsPerCore { get; set; }
		
		/// <summary>
		/// The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance's nominal CPU count and the underlying platform's SMT width.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="visibleCoreCount")]
		public System.Nullable<System.Int32> VisibleCoreCount { get; set; }
	}
	
	/// <summary>
	/// An alias IP range attached to an instance's network interface.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AliasIpRange
	{
		
		/// <summary>
		/// The IP alias ranges to allocate for this interface. This IP CIDR range must belong to the specified subnetwork and cannot contain IP addresses reserved by system or used by other network interfaces. This range may be a single IP address (such as 10.2.3.4), a netmask (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipCidrRange")]
		public string IpCidrRange { get; set; }
		
		/// <summary>
		/// The name of a subnetwork secondary IP range from which to allocate an IP alias range. If not specified, the primary range of the subnetwork is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetworkRangeName")]
		public string SubnetworkRangeName { get; set; }
	}
	
	/// <summary>
	/// This reservation type is specified by total resource amounts (e.g. total count of CPUs) and can account for multiple instance SKUs. In other words, one can create instances of varying shapes against this reservation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AllocationAggregateReservation
	{
		
		/// <summary>
		/// [Output only] List of resources currently in use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inUseResources")]
		public AllocationAggregateReservationReservedResourceInfo[] InUseResources { get; set; }
		
		/// <summary>
		/// List of reserved resources (CPUs, memory, accelerators).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedResources")]
		public AllocationAggregateReservationReservedResourceInfo[] ReservedResources { get; set; }
		
		/// <summary>
		/// The VM family that all instances scheduled against this reservation must belong to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmFamily")]
		public System.Nullable<AllocationAggregateReservationVmFamily> VmFamily { get; set; }
		
		/// <summary>
		/// The workload type of the instances that will target this reservation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workloadType")]
		public System.Nullable<AllocationAggregateReservationWorkloadType> WorkloadType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AllocationAggregateReservationReservedResourceInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="accelerator")]
		public AllocationAggregateReservationReservedResourceInfoAccelerator Accelerator { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AllocationAggregateReservationReservedResourceInfoAccelerator
	{
		
		/// <summary>
		/// Number of accelerators of specified type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceleratorCount")]
		public System.Nullable<System.Int32> AcceleratorCount { get; set; }
		
		/// <summary>
		/// Full or partial URL to accelerator type. e.g. "projects/{PROJECT}/zones/{ZONE}/acceleratorTypes/ct4l"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceleratorType")]
		public string AcceleratorType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AllocationAggregateReservationVmFamily
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VM_FAMILY_CLOUD_TPU_LITE_DEVICE_CT5L = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VM_FAMILY_CLOUD_TPU_LITE_POD_SLICE_CT5LP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VM_FAMILY_CLOUD_TPU_POD_SLICE_CT4P = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AllocationAggregateReservationWorkloadType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BATCH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED = 2,
	}
	
	/// <summary>
	/// [Output Only] Contains output only fields.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AllocationResourceStatus
	{
		
		/// <summary>
		/// Contains Properties set for the reservation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="specificSkuAllocation")]
		public AllocationResourceStatusSpecificSKUAllocation SpecificSkuAllocation { get; set; }
	}
	
	/// <summary>
	/// Contains Properties set for the reservation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AllocationResourceStatusSpecificSKUAllocation
	{
		
		/// <summary>
		/// ID of the instance template used to populate reservation properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceInstanceTemplateId")]
		public string SourceInstanceTemplateId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk
	{
		
		/// <summary>
		/// Specifies the size of the disk in base-2 GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGb")]
		public string DiskSizeGb { get; set; }
		
		/// <summary>
		/// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. The default is SCSI. For performance characteristics of SCSI over NVMe, see Local SSD performance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interface")]
		public System.Nullable<AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface> Interface { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVME = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCSI = 1,
	}
	
	/// <summary>
	/// Properties of the SKU instances being reserved. Next ID: 9
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AllocationSpecificSKUAllocationReservedInstanceProperties
	{
		
		/// <summary>
		/// Specifies accelerator type and count.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestAccelerators")]
		public AcceleratorConfig[] GuestAccelerators { get; set; }
		
		/// <summary>
		/// Specifies amount of local ssd to reserve with each instance. The type of disk is local-ssd.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localSsds")]
		public AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk[] LocalSsds { get; set; }
		
		/// <summary>
		/// An opaque location hint used to place the allocation close to other resources. This field is for use by internal tools that use the public API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationHint")]
		public string LocationHint { get; set; }
		
		/// <summary>
		/// Specifies type of machine (name only) which has fixed number of vCPUs and fixed amount of memory. This also includes specifying custom machine type following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
		
		/// <summary>
		/// Minimum cpu platform the reservation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minCpuPlatform")]
		public string MinCpuPlatform { get; set; }
	}
	
	/// <summary>
	/// This reservation type allows to pre allocate specific instance configuration. Next ID: 6
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AllocationSpecificSKUReservation
	{
		
		/// <summary>
		/// [Output Only] Indicates how many instances are actually usable currently.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assuredCount")]
		public string AssuredCount { get; set; }
		
		/// <summary>
		/// Specifies the number of resources that are allocated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public string Count { get; set; }
		
		/// <summary>
		/// [Output Only] Indicates how many instances are in use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inUseCount")]
		public string InUseCount { get; set; }
		
		/// <summary>
		/// Properties of the SKU instances being reserved. Next ID: 9
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceProperties")]
		public AllocationSpecificSKUAllocationReservedInstanceProperties InstanceProperties { get; set; }
		
		/// <summary>
		/// Specifies the instance template to create the reservation. If you use this field, you must exclude the instanceProperties field. This field is optional, and it can be a full or partial URL. For example, the following are all valid URLs to an instance template: - https://www.googleapis.com/compute/v1/projects/project /global/instanceTemplates/instanceTemplate - projects/project/global/instanceTemplates/instanceTemplate - global/instanceTemplates/instanceTemplate 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceInstanceTemplate")]
		public string SourceInstanceTemplate { get; set; }
	}
	
	/// <summary>
	/// An instance-attached disk resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttachedDisk
	{
		
		/// <summary>
		/// [Output Only] The architecture of the attached disk. Valid values are ARM64 or X86_64.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public System.Nullable<AttachedDiskArchitecture> Architecture { get; set; }
		
		/// <summary>
		/// Specifies whether the disk will be auto-deleted when the instance is deleted (but not when the disk is detached from the instance).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoDelete")]
		public System.Nullable<System.Boolean> AutoDelete { get; set; }
		
		/// <summary>
		/// Indicates that this is a boot disk. The virtual machine will use the first partition of the disk for its root filesystem.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="boot")]
		public System.Nullable<System.Boolean> Boot { get; set; }
		
		/// <summary>
		/// Specifies a unique device name of your choice that is reflected into the /dev/disk/by-id/google-* tree of a Linux operating system running within the instance. This name can be used to reference the device for mounting, resizing, and so on, from within the instance. If not specified, the server chooses a default device name to apply to this disk, in the form persistent-disk-x, where x is a number assigned by Google Compute Engine. This field is only applicable for persistent disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceName")]
		public string DeviceName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="diskEncryptionKey")]
		public CustomerEncryptionKey DiskEncryptionKey { get; set; }
		
		/// <summary>
		/// The size of the disk in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGb")]
		public string DiskSizeGb { get; set; }
		
		/// <summary>
		/// [Input Only] Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceAttach")]
		public System.Nullable<System.Boolean> ForceAttach { get; set; }
		
		/// <summary>
		/// A list of features to enable on the guest operating system. Applicable only for bootable images. Read Enabling guest operating system features to see a list of available options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestOsFeatures")]
		public GuestOsFeature[] GuestOsFeatures { get; set; }
		
		/// <summary>
		/// [Output Only] A zero-based index to this disk, where 0 is reserved for the boot disk. If you have many disks attached to an instance, each disk would have a unique index number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="index")]
		public System.Nullable<System.Int32> Index { get; set; }
		
		/// <summary>
		/// [Input Only] Specifies the parameters for a new disk that will be created alongside the new instance. Use initialization parameters to create boot disks or local SSDs attached to the new instance. This field is persisted and returned for instanceTemplate and not returned in the context of instance. This property is mutually exclusive with the source property; you can only define one or the other, but not both.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="initializeParams")]
		public AttachedDiskInitializeParams InitializeParams { get; set; }
		
		/// <summary>
		/// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. For most machine types, the default is SCSI. Local SSDs can use either NVME or SCSI. In certain configurations, persistent disks can use NVMe. For more information, see About persistent disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interface")]
		public AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface Interface { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#attachedDisk for attached disks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#attachedDisk")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#attachedDisk";
		
		/// <summary>
		/// [Output Only] Any valid publicly visible licenses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public string[] Licenses { get; set; }
		
		/// <summary>
		/// The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<AttachedDiskMode> Mode { get; set; }
		
		/// <summary>
		/// For LocalSSD disks on VM Instances in STOPPED or SUSPENDED state, this field is set to PRESERVED if the LocalSSD data has been saved to a persistent location by customer request. (see the discard_local_ssd option on Stop/Suspend). Read-only in the api.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="savedState")]
		public System.Nullable<AttachedDiskSavedState> SavedState { get; set; }
		
		/// <summary>
		/// Initial State for shielded instance, these are public keys which are safe to store in public
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shieldedInstanceInitialState")]
		public InitialStateConfig ShieldedInstanceInitialState { get; set; }
		
		/// <summary>
		/// Specifies a valid partial or full URL to an existing Persistent Disk resource. When creating a new instance, one of initializeParams.sourceImage or initializeParams.sourceSnapshot or disks.source is required except for local SSD. If desired, you can also attach existing non-root persistent disks using this property. This field is only applicable for persistent disks. Note that for InstanceTemplate, specify the disk name for zonal disk, and the URL for regional disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified, the default is PERSISTENT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<AttachedDiskType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AttachedDiskArchitecture
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHITECTURE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARM64 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		X86_64 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CustomerEncryptionKey
	{
		
		/// <summary>
		/// The name of the encryption key that is stored in Google Cloud KMS. For example: "kmsKeyName": "projects/kms_project_id/locations/region/keyRings/ key_region/cryptoKeys/key The fully-qualifed key name may be returned for resource GET requests. For example: "kmsKeyName": "projects/kms_project_id/locations/region/keyRings/ key_region/cryptoKeys/key /cryptoKeyVersions/1 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kmsKeyName")]
		public string KmsKeyName { get; set; }
		
		/// <summary>
		/// The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used. For example: "kmsKeyServiceAccount": "name@project_id.iam.gserviceaccount.com/ 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kmsKeyServiceAccount")]
		public string KmsKeyServiceAccount { get; set; }
		
		/// <summary>
		/// Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. You can provide either the rawKey or the rsaEncryptedKey. For example: "rawKey": "SGVsbG8gZnJvbSBHb29nbGUgQ2xvdWQgUGxhdGZvcm0=" 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rawKey")]
		public string RawKey { get; set; }
		
		/// <summary>
		/// Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. You can provide either the rawKey or the rsaEncryptedKey. For example: "rsaEncryptedKey": "ieCx/NcW06PcT7Ep1X6LUTc/hLvUDYyzSZPPVCVPTVEohpeHASqC8uw5TzyO9U+Fka9JFH z0mBibXUInrC/jEk014kCK/NPjYgEMOyssZ4ZINPKxlUh2zn1bV+MCaTICrdmuSBTWlUUiFoD D6PYznLwh8ZNdaheCeZ8ewEXgFQ8V+sDroLaN3Xs3MDTXQEMMoNUXMCZEIpg9Vtp9x2oe==" The key must meet the following requirements before you can provide it to Compute Engine: 1. The key is wrapped using a RSA public key certificate provided by Google. 2. After being wrapped, the key must be encoded in RFC 4648 base64 encoding. Gets the RSA public key certificate provided by Google at: https://cloud-certs.storage.googleapis.com/google-cloud-csek-ingress.pem 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rsaEncryptedKey")]
		public string RsaEncryptedKey { get; set; }
		
		/// <summary>
		/// [Output only] The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sha256")]
		public string Sha256 { get; set; }
	}
	
	/// <summary>
	/// Guest OS features.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GuestOsFeature
	{
		
		/// <summary>
		/// The ID of a supported feature. To add multiple values, use commas to separate values. Set to one or more of the following values: - VIRTIO_SCSI_MULTIQUEUE - WINDOWS - MULTI_IP_SUBNET - UEFI_COMPATIBLE - GVNIC - SEV_CAPABLE - SUSPEND_RESUME_COMPATIBLE - SEV_LIVE_MIGRATABLE - SEV_SNP_CAPABLE - IDPF For more information, see Enabling guest operating system features.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<GuestOsFeatureType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GuestOsFeatureType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FEATURE_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GVNIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IDPF = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MULTI_IP_SUBNET = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECURE_BOOT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEV_CAPABLE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEV_LIVE_MIGRATABLE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEV_LIVE_MIGRATABLE_V2 = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEV_SNP_CAPABLE = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UEFI_COMPATIBLE = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIRTIO_SCSI_MULTIQUEUE = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WINDOWS = 11,
	}
	
	/// <summary>
	/// [Input Only] Specifies the parameters for a new disk that will be created alongside the new instance. Use initialization parameters to create boot disks or local SSDs attached to the new instance. This field is persisted and returned for instanceTemplate and not returned in the context of instance. This property is mutually exclusive with the source property; you can only define one or the other, but not both.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AttachedDiskInitializeParams
	{
		
		/// <summary>
		/// The architecture of the attached disk. Valid values are arm64 or x86_64.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public AttachedDiskArchitecture Architecture { get; set; }
		
		/// <summary>
		/// An optional description. Provide this property when creating the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Specifies the disk name. If not specified, the default is to use the name of the instance. If a disk with the same name already exists in the given region, the existing disk is attached to the new instance and the new disk is not created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskName")]
		public string DiskName { get; set; }
		
		/// <summary>
		/// Specifies the size of the disk in base-2 GB. The size must be at least 10 GB. If you specify a sourceImage, which is required for boot disks, the default size is the size of the sourceImage. If you do not specify a sourceImage, the default disk size is 500 GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGb")]
		public string DiskSizeGb { get; set; }
		
		/// <summary>
		/// Specifies the disk type to use to create the instance. If not specified, the default is pd-standard, specified using the full URL. For example: https://www.googleapis.com/compute/v1/projects/project/zones/zone /diskTypes/pd-standard For a full list of acceptable values, see Persistent disk types. If you specify this field when creating a VM, you can provide either the full or partial URL. For example, the following values are valid: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /diskTypes/diskType - projects/project/zones/zone/diskTypes/diskType - zones/zone/diskTypes/diskType If you specify this field when creating or updating an instance template or all-instances configuration, specify the type of the disk, not the URL. For example: pd-standard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskType")]
		public string DiskType { get; set; }
		
		/// <summary>
		/// Whether this disk is using confidential compute mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableConfidentialCompute")]
		public System.Nullable<System.Boolean> EnableConfidentialCompute { get; set; }
		
		/// <summary>
		/// Labels to apply to this disk. These can be later modified by the disks.setLabels method. This field is only applicable for persistent disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// A list of publicly visible licenses. Reserved for Google's use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public string[] Licenses { get; set; }
		
		/// <summary>
		/// Specifies which action to take on instance update with this disk. Default is to use the existing disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="onUpdateAction")]
		public System.Nullable<AttachedDiskInitializeParamsOnUpdateAction> OnUpdateAction { get; set; }
		
		/// <summary>
		/// Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. Values must be between 10,000 and 120,000. For more details, see the Extreme persistent disk documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisionedIops")]
		public string ProvisionedIops { get; set; }
		
		/// <summary>
		/// Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle. Values must be between 1 and 7,124.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisionedThroughput")]
		public string ProvisionedThroughput { get; set; }
		
		/// <summary>
		/// Required for each regional disk associated with the instance. Specify the URLs of the zones where the disk should be replicated to. You must provide exactly two replica zones, and one zone must be the same as the instance zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicaZones")]
		public string[] ReplicaZones { get; set; }
		
		/// <summary>
		/// Resource manager tags to be bound to the disk. Tag keys and values have the same definition as resource manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and values are in the format `tagValues/456`. The field is ignored (both PUT & PATCH) when empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceManagerTags")]
		public System.Collections.Generic.Dictionary<string, string> ResourceManagerTags { get; set; }
		
		/// <summary>
		/// Resource policies applied to this disk for automatic snapshot creations. Specified using the full or partial URL. For instance template, specify only the resource policy name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public string[] ResourcePolicies { get; set; }
		
		/// <summary>
		/// The source image to create this disk. When creating a new instance, one of initializeParams.sourceImage or initializeParams.sourceSnapshot or disks.source is required except for local SSD. To create a disk with one of the public operating system images, specify the image by its family name. For example, specify family/debian-9 to use the latest Debian 9 image: projects/debian-cloud/global/images/family/debian-9 Alternatively, use a specific version of a public operating system image: projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD To create a disk with a custom image that you created, specify the image name in the following format: global/images/my-custom-image You can also specify a custom image by its image family, which returns the latest version of the image in that family. Replace the image name with family/family-name: global/images/family/my-image-family If the source image is deleted later, this field will not be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceImage")]
		public string SourceImage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceImageEncryptionKey")]
		public CustomerEncryptionKey SourceImageEncryptionKey { get; set; }
		
		/// <summary>
		/// The source snapshot to create this disk. When creating a new instance, one of initializeParams.sourceSnapshot or initializeParams.sourceImage or disks.source is required except for local SSD. To create a disk with a snapshot that you created, specify the snapshot name in the following format: global/snapshots/my-backup If the source snapshot is deleted later, this field will not be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceSnapshot")]
		public string SourceSnapshot { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceSnapshotEncryptionKey")]
		public CustomerEncryptionKey SourceSnapshotEncryptionKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AttachedDiskInitializeParamsOnUpdateAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECREATE_DISK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECREATE_DISK_IF_SOURCE_CHANGED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USE_EXISTING_DISK = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AttachedDiskMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READ_ONLY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READ_WRITE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AttachedDiskSavedState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISK_SAVED_STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRESERVED = 1,
	}
	
	/// <summary>
	/// Initial State for shielded instance, these are public keys which are safe to store in public
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InitialStateConfig
	{
		
		/// <summary>
		/// The Key Database (db).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dbs")]
		public FileContentBuffer[] Dbs { get; set; }
		
		/// <summary>
		/// The forbidden key database (dbx).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dbxs")]
		public FileContentBuffer[] Dbxs { get; set; }
		
		/// <summary>
		/// The Key Exchange Key (KEK).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keks")]
		public FileContentBuffer[] Keks { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pk")]
		public FileContentBuffer Pk { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FileContentBuffer
	{
		
		/// <summary>
		/// The raw content in the secure keys file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// The file type of source file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fileType")]
		public System.Nullable<FileContentBufferFileType> FileType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FileContentBufferFileType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BIN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNDEFINED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		X509 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AttachedDiskType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PERSISTENT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCRATCH = 1,
	}
	
	/// <summary>
	/// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts jose@example.com from DATA_READ logging, and aliya@example.com from DATA_WRITE logging.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuditConfig
	{
		
		/// <summary>
		/// The configuration for logging of each type of permission.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auditLogConfigs")]
		public AuditLogConfig[] AuditLogConfigs { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exemptedMembers")]
		public string[] ExemptedMembers { get; set; }
		
		/// <summary>
		/// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
	}
	
	/// <summary>
	/// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuditLogConfig
	{
		
		/// <summary>
		/// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exemptedMembers")]
		public string[] ExemptedMembers { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ignoreChildExemptions")]
		public System.Nullable<System.Boolean> IgnoreChildExemptions { get; set; }
		
		/// <summary>
		/// The log type that this config enables.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logType")]
		public System.Nullable<AuditLogConfigLogType> LogType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AuditLogConfigLogType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN_READ = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_READ = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_WRITE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOG_TYPE_UNSPECIFIED = 3,
	}
	
	/// <summary>
	/// This is deprecated and has no effect. Do not use.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AuthorizationLoggingOptions
	{
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissionType")]
		public System.Nullable<AuthorizationLoggingOptionsPermissionType> PermissionType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AuthorizationLoggingOptionsPermissionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN_READ = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN_WRITE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_READ = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_WRITE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PERMISSION_TYPE_UNSPECIFIED = 4,
	}
	
	/// <summary>
	/// Represents an Autoscaler resource. Google Compute Engine has two Autoscaler resources: * [Zonal](/compute/docs/reference/rest/v1/autoscalers) * [Regional](/compute/docs/reference/rest/v1/regionAutoscalers) Use autoscalers to automatically add or delete instances from a managed instance group according to your defined autoscaling policy. For more information, read Autoscaling Groups of Instances. For zonal managed instance groups resource, use the autoscaler resource. For regional managed instance groups, use the regionAutoscalers resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Autoscaler
	{
		
		/// <summary>
		/// Cloud Autoscaler policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoscalingPolicy")]
		public AutoscalingPolicy AutoscalingPolicy { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#autoscaler for autoscalers.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#autoscaler")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#autoscaler";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] Target recommended MIG size (number of instances) computed by autoscaler. Autoscaler calculates the recommended MIG size even when the autoscaling policy mode is different from ON. This field is empty when autoscaler is not connected to an existing managed instance group or autoscaler did not generate its prediction.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recommendedSize")]
		public System.Nullable<System.Int32> RecommendedSize { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the instance group resides (for autoscalers living in regional scope).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Status information of existing scaling schedules.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scalingScheduleStatus")]
		public System.Collections.Generic.Dictionary<string, ScalingScheduleStatus> ScalingScheduleStatus { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the autoscaler configuration. Current set of possible values: - PENDING: Autoscaler backend hasn't read new/updated configuration. - DELETING: Configuration is being deleted. - ACTIVE: Configuration is acknowledged to be effective. Some warnings might be present in the statusDetails field. - ERROR: Configuration has errors. Actionable for users. Details are present in the statusDetails field. New values might be added in the future.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<AutoscalerStatus> Status { get; set; }
		
		/// <summary>
		/// [Output Only] Human-readable details about the current state of the autoscaler. Read the documentation for Commonly returned status messages for examples of status messages you might encounter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusDetails")]
		public AutoscalerStatusDetails[] StatusDetails { get; set; }
		
		/// <summary>
		/// URL of the managed instance group that this autoscaler will scale. This field is required when creating an autoscaler.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the zone where the instance group resides (for autoscalers living in zonal scope).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// Cloud Autoscaler policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoscalingPolicy
	{
		
		/// <summary>
		/// The number of seconds that your application takes to initialize on a VM instance. This is referred to as the [initialization period](/compute/docs/autoscaler#cool_down_period). Specifying an accurate initialization period improves autoscaler decisions. For example, when scaling out, the autoscaler ignores data from VMs that are still initializing because those VMs might not yet represent normal usage of your application. The default initialization period is 60 seconds. Initialization periods might vary because of numerous factors. We recommend that you test how long your application takes to initialize. To do this, create a VM and time your application's startup process.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coolDownPeriodSec")]
		public System.Nullable<System.Int32> CoolDownPeriodSec { get; set; }
		
		/// <summary>
		/// CPU utilization policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuUtilization")]
		public AutoscalingPolicyCpuUtilization CpuUtilization { get; set; }
		
		/// <summary>
		/// Configuration parameters of autoscaling based on a custom metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customMetricUtilizations")]
		public AutoscalingPolicyCustomMetricUtilization[] CustomMetricUtilizations { get; set; }
		
		/// <summary>
		/// Configuration parameters of autoscaling based on load balancing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancingUtilization")]
		public AutoscalingPolicyLoadBalancingUtilization LoadBalancingUtilization { get; set; }
		
		/// <summary>
		/// The maximum number of instances that the autoscaler can scale out to. This is required when creating or updating an autoscaler. The maximum number of replicas must not be lower than minimal number of replicas.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxNumReplicas")]
		public System.Nullable<System.Int32> MaxNumReplicas { get; set; }
		
		/// <summary>
		/// The minimum number of replicas that the autoscaler can scale in to. This cannot be less than 0. If not provided, autoscaler chooses a default value depending on maximum number of instances allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minNumReplicas")]
		public System.Nullable<System.Int32> MinNumReplicas { get; set; }
		
		/// <summary>
		/// Defines the operating mode for this policy. The following modes are available: - OFF: Disables the autoscaler but maintains its configuration. - ONLY_SCALE_OUT: Restricts the autoscaler to add VM instances only. - ON: Enables all autoscaler activities according to its policy. For more information, see "Turning off or restricting an autoscaler"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<AutoscalingPolicyMode> Mode { get; set; }
		
		/// <summary>
		/// Configuration that allows for slower scale in so that even if Autoscaler recommends an abrupt scale in of a MIG, it will be throttled as specified by the parameters below.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scaleInControl")]
		public AutoscalingPolicyScaleInControl ScaleInControl { get; set; }
		
		/// <summary>
		/// Scaling schedules defined for an autoscaler. Multiple schedules can be set on an autoscaler, and they can overlap. During overlapping periods the greatest min_required_replicas of all scaling schedules is applied. Up to 128 scaling schedules are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scalingSchedules")]
		public System.Collections.Generic.Dictionary<string, AutoscalingPolicyScalingSchedule> ScalingSchedules { get; set; }
	}
	
	/// <summary>
	/// CPU utilization policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoscalingPolicyCpuUtilization
	{
		
		/// <summary>
		/// Indicates whether predictive autoscaling based on CPU metric is enabled. Valid values are: * NONE (default). No predictive method is used. The autoscaler scales the group to meet current demand based on real-time metrics. * OPTIMIZE_AVAILABILITY. Predictive autoscaling improves availability by monitoring daily and weekly load patterns and scaling out ahead of anticipated demand.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="predictiveMethod")]
		public System.Nullable<AutoscalingPolicyCpuUtilizationPredictiveMethod> PredictiveMethod { get; set; }
		
		/// <summary>
		/// The target CPU utilization that the autoscaler maintains. Must be a float value in the range (0, 1]. If not specified, the default is 0.6. If the CPU level is below the target utilization, the autoscaler scales in the number of instances until it reaches the minimum number of instances you specified or until the average CPU of your instances reaches the target utilization. If the average CPU is above the target utilization, the autoscaler scales out until it reaches the maximum number of instances you specified or until the average utilization reaches the target utilization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizationTarget")]
		public System.Nullable<System.Double> UtilizationTarget { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AutoscalingPolicyCpuUtilizationPredictiveMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPTIMIZE_AVAILABILITY = 1,
	}
	
	/// <summary>
	/// Custom utilization metric policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoscalingPolicyCustomMetricUtilization
	{
		
		/// <summary>
		/// A filter string, compatible with a Stackdriver Monitoring filter string for TimeSeries.list API call. This filter is used to select a specific TimeSeries for the purpose of autoscaling and to determine whether the metric is exporting per-instance or per-group data. For the filter to be valid for autoscaling purposes, the following rules apply: - You can only use the AND operator for joining selectors. - You can only use direct equality comparison operator (=) without any functions for each selector. - You can specify the metric in both the filter string and in the metric field. However, if specified in both places, the metric must be identical. - The monitored resource type determines what kind of values are expected for the metric. If it is a gce_instance, the autoscaler expects the metric to include a separate TimeSeries for each instance in a group. In such a case, you cannot filter on resource labels. If the resource type is any other value, the autoscaler expects this metric to contain values that apply to the entire autoscaled instance group and resource label filtering can be performed to point autoscaler at the correct TimeSeries to scale upon. This is called a *per-group metric* for the purpose of autoscaling. If not specified, the type defaults to gce_instance. Try to provide a filter that is selective enough to pick just one TimeSeries for the autoscaled group or for each of the instances (if you are using gce_instance resource type). If multiple TimeSeries are returned upon the query execution, the autoscaler will sum their respective values to obtain its scaling value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public string Filter { get; set; }
		
		/// <summary>
		/// The identifier (type) of the Stackdriver Monitoring metric. The metric cannot have negative values. The metric must have a value type of INT64 or DOUBLE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public string Metric { get; set; }
		
		/// <summary>
		/// If scaling is based on a per-group metric value that represents the total amount of work to be done or resource usage, set this value to an amount assigned for a single instance of the scaled group. Autoscaler keeps the number of instances proportional to the value of this metric. The metric itself does not change value due to group resizing. A good metric to use with the target is for example pubsub.googleapis.com/subscription/num_undelivered_messages or a custom metric exporting the total number of requests coming to your instances. A bad example would be a metric exporting an average or median latency, since this value can't include a chunk assignable to a single instance, it could be better used with utilization_target instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="singleInstanceAssignment")]
		public System.Nullable<System.Double> SingleInstanceAssignment { get; set; }
		
		/// <summary>
		/// The target value of the metric that autoscaler maintains. This must be a positive value. A utilization metric scales number of virtual machines handling requests to increase or decrease proportionally to the metric. For example, a good metric to use as a utilization_target is https://www.googleapis.com/compute/v1/instance/network/received_bytes_count. The autoscaler works to keep this value constant for each of the instances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizationTarget")]
		public System.Nullable<System.Double> UtilizationTarget { get; set; }
		
		/// <summary>
		/// Defines how target utilization value is expressed for a Stackdriver Monitoring metric. Either GAUGE, DELTA_PER_SECOND, or DELTA_PER_MINUTE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizationTargetType")]
		public System.Nullable<AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType> UtilizationTargetType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AutoscalingPolicyCustomMetricUtilizationUtilizationTargetType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELTA_PER_MINUTE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELTA_PER_SECOND = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GAUGE = 2,
	}
	
	/// <summary>
	/// Configuration parameters of autoscaling based on load balancing.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoscalingPolicyLoadBalancingUtilization
	{
		
		/// <summary>
		/// Fraction of backend capacity utilization (set in HTTP(S) load balancing configuration) that the autoscaler maintains. Must be a positive float value. If not defined, the default is 0.8.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="utilizationTarget")]
		public System.Nullable<System.Double> UtilizationTarget { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AutoscalingPolicyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFF = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ON = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONLY_SCALE_OUT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONLY_UP = 3,
	}
	
	/// <summary>
	/// Configuration that allows for slower scale in so that even if Autoscaler recommends an abrupt scale in of a MIG, it will be throttled as specified by the parameters below.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoscalingPolicyScaleInControl
	{
		
		/// <summary>
		/// Encapsulates numeric value that can be either absolute or relative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxScaledInReplicas")]
		public FixedOrPercent MaxScaledInReplicas { get; set; }
		
		/// <summary>
		/// How far back autoscaling looks when computing recommendations to include directives regarding slower scale in, as described above.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeWindowSec")]
		public System.Nullable<System.Int32> TimeWindowSec { get; set; }
	}
	
	/// <summary>
	/// Encapsulates numeric value that can be either absolute or relative.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FixedOrPercent
	{
		
		/// <summary>
		/// [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="calculated")]
		public System.Nullable<System.Int32> Calculated { get; set; }
		
		/// <summary>
		/// Specifies a fixed number of VM instances. This must be a positive integer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixed")]
		public System.Nullable<System.Int32> Fixed { get; set; }
		
		/// <summary>
		/// Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percent")]
		public System.Nullable<System.Int32> Percent { get; set; }
	}
	
	/// <summary>
	/// Scaling based on user-defined schedule. The message describes a single scaling schedule. A scaling schedule changes the minimum number of VM instances an autoscaler can recommend, which can trigger scaling out.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoscalingPolicyScalingSchedule
	{
		
		/// <summary>
		/// A description of a scaling schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// A boolean value that specifies whether a scaling schedule can influence autoscaler recommendations. If set to true, then a scaling schedule has no effect. This field is optional, and its value is false by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// The duration of time intervals, in seconds, for which this scaling schedule is to run. The minimum allowed value is 300. This field is required.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="durationSec")]
		public System.Nullable<System.Int32> DurationSec { get; set; }
		
		/// <summary>
		/// The minimum number of VM instances that the autoscaler will recommend in time intervals starting according to schedule. This field is required.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minRequiredReplicas")]
		public System.Nullable<System.Int32> MinRequiredReplicas { get; set; }
		
		/// <summary>
		/// The start timestamps of time intervals when this scaling schedule is to provide a scaling signal. This field uses the extended cron format (with an optional year field). The expression can describe a single timestamp if the optional year is set, in which case the scaling schedule runs once. The schedule is interpreted with respect to time_zone. This field is required. Note: These timestamps only describe when autoscaler starts providing the scaling signal. The VMs need additional time to become serving.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public string Schedule { get; set; }
		
		/// <summary>
		/// The time zone to use when interpreting the schedule. The value of this field must be a time zone name from the tz database: https://en.wikipedia.org/wiki/Tz_database. This field is assigned a default value of "UTC" if left empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ScalingScheduleStatus
	{
		
		/// <summary>
		/// [Output Only] The last time the scaling schedule became active. Note: this is a timestamp when a schedule actually became active, not when it was planned to do so. The timestamp is in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastStartTime")]
		public string LastStartTime { get; set; }
		
		/// <summary>
		/// [Output Only] The next time the scaling schedule is to become active. Note: this is a timestamp when a schedule is planned to run, but the actual time might be slightly different. The timestamp is in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextStartTime")]
		public string NextStartTime { get; set; }
		
		/// <summary>
		/// [Output Only] The current state of a scaling schedule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<ScalingScheduleStatusState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ScalingScheduleStatusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OBSOLETE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AutoscalerStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERROR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoscalerStatusDetails
	{
		
		/// <summary>
		/// The status message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// The type of error, warning, or notice returned. Current set of possible values: - ALL_INSTANCES_UNHEALTHY (WARNING): All instances in the instance group are unhealthy (not in RUNNING state). - BACKEND_SERVICE_DOES_NOT_EXIST (ERROR): There is no backend service attached to the instance group. - CAPPED_AT_MAX_NUM_REPLICAS (WARNING): Autoscaler recommends a size greater than maxNumReplicas. - CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE (WARNING): The custom metric samples are not exported often enough to be a credible base for autoscaling. - CUSTOM_METRIC_INVALID (ERROR): The custom metric that was specified does not exist or does not have the necessary labels. - MIN_EQUALS_MAX (WARNING): The minNumReplicas is equal to maxNumReplicas. This means the autoscaler cannot add or remove instances from the instance group. - MISSING_CUSTOM_METRIC_DATA_POINTS (WARNING): The autoscaler did not receive any data from the custom metric configured for autoscaling. - MISSING_LOAD_BALANCING_DATA_POINTS (WARNING): The autoscaler is configured to scale based on a load balancing signal but the instance group has not received any requests from the load balancer. - MODE_OFF (WARNING): Autoscaling is turned off. The number of instances in the group won't change automatically. The autoscaling configuration is preserved. - MODE_ONLY_UP (WARNING): Autoscaling is in the "Autoscale only out" mode. The autoscaler can add instances but not remove any. - MORE_THAN_ONE_BACKEND_SERVICE (ERROR): The instance group cannot be autoscaled because it has more than one backend service attached to it. - NOT_ENOUGH_QUOTA_AVAILABLE (ERROR): There is insufficient quota for the necessary resources, such as CPU or number of instances. - REGION_RESOURCE_STOCKOUT (ERROR): Shown only for regional autoscalers: there is a resource stockout in the chosen region. - SCALING_TARGET_DOES_NOT_EXIST (ERROR): The target to be scaled does not exist. - UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION (ERROR): Autoscaling does not work with an HTTP/S load balancer that has been configured for maxRate. - ZONE_RESOURCE_STOCKOUT (ERROR): For zonal autoscalers: there is a resource stockout in the chosen zone. For regional autoscalers: in at least one of the zones you're using there is a resource stockout. New values might be added in the future. Some of the values might not be available in all API versions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<AutoscalerStatusDetailsType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum AutoscalerStatusDetailsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_INSTANCES_UNHEALTHY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKEND_SERVICE_DOES_NOT_EXIST = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CAPPED_AT_MAX_NUM_REPLICAS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_METRIC_INVALID = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIN_EQUALS_MAX = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MISSING_CUSTOM_METRIC_DATA_POINTS = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MISSING_LOAD_BALANCING_DATA_POINTS = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODE_OFF = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODE_ONLY_SCALE_OUT = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODE_ONLY_UP = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MORE_THAN_ONE_BACKEND_SERVICE = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_ENOUGH_QUOTA_AVAILABLE = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGION_RESOURCE_STOCKOUT = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCALING_TARGET_DOES_NOT_EXIST = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZONE_RESOURCE_STOCKOUT = 19,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoscalerAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of AutoscalersScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, AutoscalersScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#autoscalerAggregatedList for aggregated lists of autoscalers.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#autoscalerAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#autoscalerAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources. end_interface: MixerListResponseWithEtagBuilder
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public AutoscalerAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoscalersScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of autoscalers contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoscalers")]
		public Autoscaler[] Autoscalers { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning which replaces the list of autoscalers when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public AutoscalersScopedListWarning Warning { get; set; }
	}
	
	public class AutoscalersScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AutoscalersScopedListWarningData[] AutoscalersScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class AutoscalersScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class AutoscalerAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AutoscalerAggregatedListWarningData[] AutoscalerAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class AutoscalerAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of Autoscaler resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class AutoscalerList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Autoscaler resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Autoscaler[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#autoscalerList for lists of autoscalers.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#autoscalerList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#autoscalerList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public AutoscalerListWarning Warning { get; set; }
	}
	
	public class AutoscalerListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public AutoscalerListWarningData[] AutoscalerListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class AutoscalerListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Message containing information of one individual backend.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Backend
	{
		
		/// <summary>
		/// Specifies how to determine whether the backend of a load balancer can handle additional traffic or is fully loaded. For usage guidelines, see Connection balancing mode. Backends must use compatible balancing modes. For more information, see Supported balancing modes and target capacity settings and Restrictions and guidance for instance groups. Note: Currently, if you use the API to configure incompatible balancing modes, the configuration might be accepted even though it has no impact and is ignored. Specifically, Backend.maxUtilization is ignored when Backend.balancingMode is RATE. In the future, this incompatible combination will be rejected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="balancingMode")]
		public System.Nullable<BackendBalancingMode> BalancingMode { get; set; }
		
		/// <summary>
		/// A multiplier applied to the backend's target capacity of its balancing mode. The default value is 1, which means the group serves up to 100% of its configured capacity (depending on balancingMode). A setting of 0 means the group is completely drained, offering 0% of its available capacity. The valid ranges are 0.0 and [0.1,1.0]. You cannot configure a setting larger than 0 and smaller than 0.1. You cannot configure a setting of 0 when there is only one backend attached to the backend service. Not available with backends that don't support using a balancingMode. This includes backends such as global internet NEGs, regional serverless NEGs, and PSC NEGs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="capacityScaler")]
		public System.Nullable<System.Single> CapacityScaler { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// This field designates whether this is a failover backend. More than one failover backend can be configured for a given BackendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failover")]
		public System.Nullable<System.Boolean> Failover { get; set; }
		
		/// <summary>
		/// The fully-qualified URL of an instance group or network endpoint group (NEG) resource. To determine what types of backends a load balancer supports, see the [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service#backends). You must use the *fully-qualified* URL (starting with https://www.googleapis.com/) to specify the instance group or NEG. Partial URLs are not supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
		
		/// <summary>
		/// Defines a target maximum number of simultaneous connections. For usage guidelines, see Connection balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is RATE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConnections")]
		public System.Nullable<System.Int32> MaxConnections { get; set; }
		
		/// <summary>
		/// Defines a target maximum number of simultaneous connections. For usage guidelines, see Connection balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is RATE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConnectionsPerEndpoint")]
		public System.Nullable<System.Int32> MaxConnectionsPerEndpoint { get; set; }
		
		/// <summary>
		/// Defines a target maximum number of simultaneous connections. For usage guidelines, see Connection balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is RATE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConnectionsPerInstance")]
		public System.Nullable<System.Int32> MaxConnectionsPerInstance { get; set; }
		
		/// <summary>
		/// Defines a maximum number of HTTP requests per second (RPS). For usage guidelines, see Rate balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is CONNECTION.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRate")]
		public System.Nullable<System.Int32> MaxRate { get; set; }
		
		/// <summary>
		/// Defines a maximum target for requests per second (RPS). For usage guidelines, see Rate balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is CONNECTION.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRatePerEndpoint")]
		public System.Nullable<System.Single> MaxRatePerEndpoint { get; set; }
		
		/// <summary>
		/// Defines a maximum target for requests per second (RPS). For usage guidelines, see Rate balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is CONNECTION.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRatePerInstance")]
		public System.Nullable<System.Single> MaxRatePerInstance { get; set; }
		
		/// <summary>
		/// Optional parameter to define a target capacity for the UTILIZATION balancing mode. The valid range is [0.0, 1.0]. For usage guidelines, see Utilization balancing mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxUtilization")]
		public System.Nullable<System.Single> MaxUtilization { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackendBalancingMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECTION = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UTILIZATION = 2,
	}
	
	/// <summary>
	/// Represents a Cloud Storage Bucket resource. This Cloud Storage bucket resource is referenced by a URL map of a load balancer. For more information, read Backend Buckets.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendBucket
	{
		
		/// <summary>
		/// Cloud Storage bucket name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucketName")]
		public string BucketName { get; set; }
		
		/// <summary>
		/// Message containing Cloud CDN configuration for a backend bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cdnPolicy")]
		public BackendBucketCdnPolicy CdnPolicy { get; set; }
		
		/// <summary>
		/// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compressionMode")]
		public System.Nullable<BackendBucketCompressionMode> CompressionMode { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// Headers that the Application Load Balancer should add to proxied responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customResponseHeaders")]
		public string[] CustomResponseHeaders { get; set; }
		
		/// <summary>
		/// An optional textual description of the resource; provided by the client when the resource is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The resource URL for the edge security policy associated with this backend bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="edgeSecurityPolicy")]
		public string EdgeSecurityPolicy { get; set; }
		
		/// <summary>
		/// If true, enable Cloud CDN for this BackendBucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableCdn")]
		public System.Nullable<System.Boolean> EnableCdn { get; set; }
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Type of the resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#backendBucket")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#backendBucket";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
	}
	
	/// <summary>
	/// Message containing Cloud CDN configuration for a backend bucket.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendBucketCdnPolicy
	{
		
		/// <summary>
		/// Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified. The cache is bypassed for all cdnPolicy.cacheMode settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bypassCacheOnRequestHeaders")]
		public BackendBucketCdnPolicyBypassCacheOnRequestHeader[] BypassCacheOnRequestHeaders { get; set; }
		
		/// <summary>
		/// Message containing what to include in the cache key for a request for Cloud CDN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheKeyPolicy")]
		public BackendBucketCdnPolicyCacheKeyPolicy CacheKeyPolicy { get; set; }
		
		/// <summary>
		/// Specifies the cache setting for all responses from this backend. The possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server. FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content. CACHE_ALL_STATIC Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheMode")]
		public System.Nullable<BackendBucketCdnPolicyCacheMode> CacheMode { get; set; }
		
		/// <summary>
		/// Specifies a separate client (e.g. browser client) maximum TTL. This is used to clamp the max-age (or Expires) value sent to the client. With FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for the response max-age directive, along with a "public" directive. For cacheable content in CACHE_ALL_STATIC mode, client_ttl clamps the max-age from the origin (if specified), or else sets the response max-age directive to the lesser of the client_ttl and default_ttl, and also ensures a "public" cache-control directive is present. If a client TTL is not specified, a default value (1 hour) will be used. The maximum allowed value is 31,622,400s (1 year).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientTtl")]
		public System.Nullable<System.Int32> ClientTtl { get; set; }
		
		/// <summary>
		/// Specifies the default TTL for cached content served by this origin for responses that do not have an existing valid TTL (max-age or s-max-age). Setting a TTL of "0" means "always revalidate". The value of defaultTTL cannot be set to a value greater than that of maxTTL, but can be equal. When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will overwrite the TTL set in all responses. The maximum allowed value is 31,622,400s (1 year), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultTtl")]
		public System.Nullable<System.Int32> DefaultTtl { get; set; }
		
		/// <summary>
		/// Specifies the maximum allowed TTL for cached content served by this origin. Cache directives that attempt to set a max-age or s-maxage higher than this, or an Expires header more than maxTTL seconds in the future will be capped at the value of maxTTL, as if it were the value of an s-maxage Cache-Control directive. Headers sent to the client will not be modified. Setting a TTL of "0" means "always revalidate". The maximum allowed value is 31,622,400s (1 year), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxTtl")]
		public System.Nullable<System.Int32> MaxTtl { get; set; }
		
		/// <summary>
		/// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects. This can reduce the load on your origin and improve end-user experience by reducing response latency. When the cache mode is set to CACHE_ALL_STATIC or USE_ORIGIN_HEADERS, negative caching applies to responses with the specified response code that lack any Cache-Control, Expires, or Pragma: no-cache directives. When the cache mode is set to FORCE_CACHE_ALL, negative caching applies to all responses with the specified response code, and override any caching headers. By default, Cloud CDN will apply the following default TTLs to these status codes: HTTP 300 (Multiple Choice), 301, 308 (Permanent Redirects): 10m HTTP 404 (Not Found), 410 (Gone), 451 (Unavailable For Legal Reasons): 120s HTTP 405 (Method Not Found), 421 (Misdirected Request), 501 (Not Implemented): 60s. These defaults can be overridden in negative_caching_policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="negativeCaching")]
		public System.Nullable<System.Boolean> NegativeCaching { get; set; }
		
		/// <summary>
		/// Sets a cache TTL for the specified HTTP status code. negative_caching must be enabled to configure negative_caching_policy. Omitting the policy and leaving negative_caching enabled will use Cloud CDN's default cache TTLs. Note that when specifying an explicit negative_caching_policy, you should take care to specify a cache TTL for all response codes that you wish to cache. Cloud CDN will not apply any default negative caching when a policy exists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="negativeCachingPolicy")]
		public BackendBucketCdnPolicyNegativeCachingPolicy[] NegativeCachingPolicy { get; set; }
		
		/// <summary>
		/// If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests to the origin.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestCoalescing")]
		public System.Nullable<System.Boolean> RequestCoalescing { get; set; }
		
		/// <summary>
		/// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache. This setting defines the default "max-stale" duration for any cached responses that do not specify a max-stale directive. Stale responses that exceed the TTL configured here will not be served. The default limit (max-stale) is 86400s (1 day), which will allow stale content to be served up to this limit beyond the max-age (or s-max-age) of a cached response. The maximum allowed value is 604800 (1 week). Set this to zero (0) to disable serve-while-stale.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serveWhileStale")]
		public System.Nullable<System.Int32> ServeWhileStale { get; set; }
		
		/// <summary>
		/// Maximum number of seconds the response to a signed URL request will be considered fresh. After this time period, the response will be revalidated before being served. Defaults to 1hr (3600s). When serving responses to signed URL requests, Cloud CDN will internally behave as though all responses from this backend had a "Cache-Control: public, max-age=[TTL]" header, regardless of any existing Cache-Control header. The actual headers served in responses will not be altered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signedUrlCacheMaxAgeSec")]
		public string SignedUrlCacheMaxAgeSec { get; set; }
		
		/// <summary>
		/// [Output Only] Names of the keys for signing request URLs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signedUrlKeyNames")]
		public string[] SignedUrlKeyNames { get; set; }
	}
	
	/// <summary>
	/// Bypass the cache when the specified request headers are present, e.g. Pragma or Authorization headers. Values are case insensitive. The presence of such a header overrides the cache_mode setting.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendBucketCdnPolicyBypassCacheOnRequestHeader
	{
		
		/// <summary>
		/// The header field name to match on when bypassing cache. Values are case-insensitive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerName")]
		public string HeaderName { get; set; }
	}
	
	/// <summary>
	/// Message containing what to include in the cache key for a request for Cloud CDN.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendBucketCdnPolicyCacheKeyPolicy
	{
		
		/// <summary>
		/// Allows HTTP request headers (by name) to be used in the cache key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeHttpHeaders")]
		public string[] IncludeHttpHeaders { get; set; }
		
		/// <summary>
		/// Names of query string parameters to include in cache keys. Default parameters are always included. '&' and '=' will be percent encoded and not treated as delimiters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryStringWhitelist")]
		public string[] QueryStringWhitelist { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackendBucketCdnPolicyCacheMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CACHE_ALL_STATIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FORCE_CACHE_ALL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_CACHE_MODE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USE_ORIGIN_HEADERS = 3,
	}
	
	/// <summary>
	/// Specify CDN TTLs for response error codes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendBucketCdnPolicyNegativeCachingPolicy
	{
		
		/// <summary>
		/// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 302, 307, 308, 404, 405, 410, 421, 451 and 501 are can be specified as values, and you cannot specify a status code more than once.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackendBucketCompressionMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOMATIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
	}
	
	/// <summary>
	/// Contains a list of BackendBucket resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendBucketList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of BackendBucket resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public BackendBucket[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#backendBucketList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#backendBucketList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public BackendBucketListWarning Warning { get; set; }
	}
	
	public class BackendBucketListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public BackendBucketListWarningData[] BackendBucketListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class BackendBucketListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Backend Service resource. A backend service defines how Google Cloud load balancers distribute traffic. The backend service configuration contains a set of values, such as the protocol used to connect to backends, various distribution and session settings, health checks, and timeouts. These settings provide fine-grained control over how your load balancer behaves. Most of the settings have default values that allow for easy configuration if you need to get started quickly. Backend services in Google Compute Engine can be either regionally or globally scoped. * [Global](https://cloud.google.com/compute/docs/reference/rest/v1/backendServices) * [Regional](https://cloud.google.com/compute/docs/reference/rest/v1/regionBackendServices) For more information, see Backend Services.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendService
	{
		
		/// <summary>
		/// Lifetime of cookies in seconds. This setting is applicable to Application Load Balancers and Traffic Director and requires GENERATED_COOKIE or HTTP_COOKIE session affinity. If set to 0, the cookie is non-persistent and lasts only until the end of the browser session (or equivalent). The maximum allowed value is two weeks (1,209,600). Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="affinityCookieTtlSec")]
		public System.Nullable<System.Int32> AffinityCookieTtlSec { get; set; }
		
		/// <summary>
		/// The list of backends that serve this BackendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backends")]
		public Backend[] Backends { get; set; }
		
		/// <summary>
		/// Message containing Cloud CDN configuration for a backend service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cdnPolicy")]
		public BackendServiceCdnPolicy CdnPolicy { get; set; }
		
		/// <summary>
		/// Settings controlling the volume of requests, connections and retries to this backend service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="circuitBreakers")]
		public CircuitBreakers CircuitBreakers { get; set; }
		
		/// <summary>
		/// Compress text responses using Brotli or gzip compression, based on the client's Accept-Encoding header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="compressionMode")]
		public BackendBucketCompressionMode CompressionMode { get; set; }
		
		/// <summary>
		/// Message containing connection draining configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionDraining")]
		public ConnectionDraining ConnectionDraining { get; set; }
		
		/// <summary>
		/// Connection Tracking configuration for this BackendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionTrackingPolicy")]
		public BackendServiceConnectionTrackingPolicy ConnectionTrackingPolicy { get; set; }
		
		/// <summary>
		/// This message defines settings for a consistent hash style load balancer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consistentHash")]
		public ConsistentHashLoadBalancerSettings ConsistentHash { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// Headers that the load balancer adds to proxied requests. See [Creating custom headers](https://cloud.google.com/load-balancing/docs/custom-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customRequestHeaders")]
		public string[] CustomRequestHeaders { get; set; }
		
		/// <summary>
		/// Headers that the load balancer adds to proxied responses. See [Creating custom headers](https://cloud.google.com/load-balancing/docs/custom-headers).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customResponseHeaders")]
		public string[] CustomResponseHeaders { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The resource URL for the edge security policy associated with this backend service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="edgeSecurityPolicy")]
		public string EdgeSecurityPolicy { get; set; }
		
		/// <summary>
		/// If true, enables Cloud CDN for the backend service of a global external Application Load Balancer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableCDN")]
		public System.Nullable<System.Boolean> EnableCDN { get; set; }
		
		/// <summary>
		/// For load balancers that have configurable failover: [Internal passthrough Network Load Balancers](https://cloud.google.com/load-balancing/docs/internal/failover-overview) and [external passthrough Network Load Balancers](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview). On failover or failback, this field indicates whether connection draining will be honored. Google Cloud has a fixed connection draining timeout of 10 minutes. A setting of true terminates existing TCP connections to the active pool during failover and failback, immediately draining traffic. A setting of false allows existing TCP connections to persist, even on VMs no longer in the active pool, for up to the duration of the connection draining timeout (10 minutes).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failoverPolicy")]
		public BackendServiceFailoverPolicy FailoverPolicy { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a BackendService. An up-to-date fingerprint must be provided in order to update the BackendService, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a BackendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// The list of URLs to the healthChecks, httpHealthChecks (legacy), or httpsHealthChecks (legacy) resource for health checking this backend service. Not all backend services support legacy health checks. See Load balancer guide. Currently, at most one health check can be specified for each backend service. Backend services with instance group or zonal NEG backends must have a health check. Backend services with internet or serverless NEG backends must not have a health check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthChecks")]
		public string[] HealthChecks { get; set; }
		
		/// <summary>
		/// Identity-Aware Proxy
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iap")]
		public BackendServiceIAP Iap { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#backendService for backend services.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#backendService")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#backendService";
		
		/// <summary>
		/// Specifies the load balancer type. A backend service created for one type of load balancer cannot be used with another. For more information, refer to Choosing a load balancer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancingScheme")]
		public System.Nullable<BackendServiceLoadBalancingScheme> LoadBalancingScheme { get; set; }
		
		/// <summary>
		/// A list of locality load-balancing policies to be used in order of preference. When you use localityLbPolicies, you must set at least one value for either the localityLbPolicies[].policy or the localityLbPolicies[].customPolicy field. localityLbPolicies overrides any value set in the localityLbPolicy field. For an example of how to use this field, see Define a list of preferred policies. Caution: This field and its children are intended for use in a service mesh that includes gRPC clients only. Envoy proxies can't use backend services that have this configuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localityLbPolicies")]
		public BackendServiceLocalityLoadBalancingPolicyConfig[] LocalityLbPolicies { get; set; }
		
		/// <summary>
		/// The load balancing algorithm used within the scope of the locality. The possible values are: - ROUND_ROBIN: This is a simple policy in which each healthy backend is selected in round robin order. This is the default. - LEAST_REQUEST: An O(1) algorithm which selects two random healthy hosts and picks the host which has fewer active requests. - RING_HASH: The ring/modulo hash load balancer implements consistent hashing to backends. The algorithm has the property that the addition/removal of a host from a set of N hosts only affects 1/N of the requests. - RANDOM: The load balancer selects a random healthy host. - ORIGINAL_DESTINATION: Backend host is selected based on the client connection metadata, i.e., connections are opened to the same address as the destination address of the incoming connection before the connection was redirected to the load balancer. - MAGLEV: used as a drop in replacement for the ring hash load balancer. Maglev is not as stable as ring hash but has faster table lookup build times and host selection times. For more information about Maglev, see https://ai.google/research/pubs/pub44824 This field is applicable to either: - A regional backend service with the service_protocol set to HTTP, HTTPS, or HTTP2, and load_balancing_scheme set to INTERNAL_MANAGED. - A global backend service with the load_balancing_scheme set to INTERNAL_SELF_MANAGED, INTERNAL_MANAGED, or EXTERNAL_MANAGED. If sessionAffinity is not NONE, and this field is not set to MAGLEV or RING_HASH, session affinity settings will not take effect. Only ROUND_ROBIN and RING_HASH are supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localityLbPolicy")]
		public BackendServiceLocalityLoadBalancingPolicyConfigPolicyName LocalityLbPolicy { get; set; }
		
		/// <summary>
		/// The available logging options for the load balancer traffic served by this backend service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public BackendServiceLogConfig LogConfig { get; set; }
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxStreamDuration")]
		public Duration MaxStreamDuration { get; set; }
		
		/// <summary>
		/// Deployment metadata associated with the resource to be set by a GKE hub controller and read by the backend RCTH
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadatas")]
		public System.Collections.Generic.Dictionary<string, string> Metadatas { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The URL of the network to which this backend service belongs. This field can only be specified when the load balancing scheme is set to INTERNAL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outlierDetection")]
		public OutlierDetection OutlierDetection { get; set; }
		
		/// <summary>
		/// Deprecated in favor of portName. The TCP port to connect on the backend. The default value is 80. For internal passthrough Network Load Balancers and external passthrough Network Load Balancers, omit port.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// A named port on a backend instance group representing the port for communication to the backend VMs in that group. The named port must be [defined on each backend instance group](https://cloud.google.com/load-balancing/docs/backend-service#named_ports). This parameter has no meaning if the backends are NEGs. For internal passthrough Network Load Balancers and external passthrough Network Load Balancers, omit port_name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portName")]
		public string PortName { get; set; }
		
		/// <summary>
		/// The protocol this BackendService uses to communicate with backends. Possible values are HTTP, HTTPS, HTTP2, TCP, SSL, UDP or GRPC. depending on the chosen load balancer or Traffic Director configuration. Refer to the documentation for the load balancers or for Traffic Director for more information. Must be set to GRPC when the backend service is referenced by a URL map that is bound to target gRPC proxy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocol")]
		public System.Nullable<BackendServiceProtocol> Protocol { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional backend service resides. This field is not applicable to global backend services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] The resource URL for the security policy associated with this backend service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securityPolicy")]
		public string SecurityPolicy { get; set; }
		
		/// <summary>
		/// The authentication and authorization settings for a BackendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securitySettings")]
		public SecuritySettings SecuritySettings { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// URLs of networkservices.ServiceBinding resources. Can only be set if load balancing scheme is INTERNAL_SELF_MANAGED. If set, lists of backends and health checks must be both empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceBindings")]
		public string[] ServiceBindings { get; set; }
		
		/// <summary>
		/// Type of session affinity to use. The default is NONE. Only NONE and HEADER_FIELD are supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true. For more details, see: [Session Affinity](https://cloud.google.com/load-balancing/docs/backend-service#session_affinity).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sessionAffinity")]
		public System.Nullable<BackendServiceSessionAffinity> SessionAffinity { get; set; }
		
		/// <summary>
		/// Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing, Internal HTTP(S) load balancing and Traffic Director.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsetting")]
		public Subsetting Subsetting { get; set; }
		
		/// <summary>
		/// The backend service timeout has a different meaning depending on the type of load balancer. For more information see, Backend service settings. The default is 30 seconds. The full range of timeout values allowed goes from 1 through 2,147,483,647 seconds. This value can be overridden in the PathMatcher configuration of the UrlMap that references this backend service. Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true. Instead, use maxStreamDuration.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeoutSec")]
		public System.Nullable<System.Int32> TimeoutSec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="usedBy")]
		public BackendServiceUsedBy[] UsedBy { get; set; }
	}
	
	/// <summary>
	/// Message containing Cloud CDN configuration for a backend service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceCdnPolicy
	{
		
		/// <summary>
		/// Bypass the cache when the specified request headers are matched - e.g. Pragma or Authorization headers. Up to 5 headers can be specified. The cache is bypassed for all cdnPolicy.cacheMode settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bypassCacheOnRequestHeaders")]
		public BackendServiceCdnPolicyBypassCacheOnRequestHeader[] BypassCacheOnRequestHeaders { get; set; }
		
		/// <summary>
		/// Message containing what to include in the cache key for a request for Cloud CDN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheKeyPolicy")]
		public CacheKeyPolicy CacheKeyPolicy { get; set; }
		
		/// <summary>
		/// Specifies the cache setting for all responses from this backend. The possible values are: USE_ORIGIN_HEADERS Requires the origin to set valid caching headers to cache content. Responses without these headers will not be cached at Google's edge, and will require a full trip to the origin on every request, potentially impacting performance and increasing load on the origin server. FORCE_CACHE_ALL Cache all content, ignoring any "private", "no-store" or "no-cache" directives in Cache-Control response headers. Warning: this may result in Cloud CDN caching private, per-user (user identifiable) content. CACHE_ALL_STATIC Automatically cache static content, including common image formats, media (video and audio), and web assets (JavaScript and CSS). Requests and responses that are marked as uncacheable, as well as dynamic content (including HTML), will not be cached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cacheMode")]
		public BackendBucketCdnPolicyCacheMode CacheMode { get; set; }
		
		/// <summary>
		/// Specifies a separate client (e.g. browser client) maximum TTL. This is used to clamp the max-age (or Expires) value sent to the client. With FORCE_CACHE_ALL, the lesser of client_ttl and default_ttl is used for the response max-age directive, along with a "public" directive. For cacheable content in CACHE_ALL_STATIC mode, client_ttl clamps the max-age from the origin (if specified), or else sets the response max-age directive to the lesser of the client_ttl and default_ttl, and also ensures a "public" cache-control directive is present. If a client TTL is not specified, a default value (1 hour) will be used. The maximum allowed value is 31,622,400s (1 year).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientTtl")]
		public System.Nullable<System.Int32> ClientTtl { get; set; }
		
		/// <summary>
		/// Specifies the default TTL for cached content served by this origin for responses that do not have an existing valid TTL (max-age or s-max-age). Setting a TTL of "0" means "always revalidate". The value of defaultTTL cannot be set to a value greater than that of maxTTL, but can be equal. When the cacheMode is set to FORCE_CACHE_ALL, the defaultTTL will overwrite the TTL set in all responses. The maximum allowed value is 31,622,400s (1 year), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultTtl")]
		public System.Nullable<System.Int32> DefaultTtl { get; set; }
		
		/// <summary>
		/// Specifies the maximum allowed TTL for cached content served by this origin. Cache directives that attempt to set a max-age or s-maxage higher than this, or an Expires header more than maxTTL seconds in the future will be capped at the value of maxTTL, as if it were the value of an s-maxage Cache-Control directive. Headers sent to the client will not be modified. Setting a TTL of "0" means "always revalidate". The maximum allowed value is 31,622,400s (1 year), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxTtl")]
		public System.Nullable<System.Int32> MaxTtl { get; set; }
		
		/// <summary>
		/// Negative caching allows per-status code TTLs to be set, in order to apply fine-grained caching for common errors or redirects. This can reduce the load on your origin and improve end-user experience by reducing response latency. When the cache mode is set to CACHE_ALL_STATIC or USE_ORIGIN_HEADERS, negative caching applies to responses with the specified response code that lack any Cache-Control, Expires, or Pragma: no-cache directives. When the cache mode is set to FORCE_CACHE_ALL, negative caching applies to all responses with the specified response code, and override any caching headers. By default, Cloud CDN will apply the following default TTLs to these status codes: HTTP 300 (Multiple Choice), 301, 308 (Permanent Redirects): 10m HTTP 404 (Not Found), 410 (Gone), 451 (Unavailable For Legal Reasons): 120s HTTP 405 (Method Not Found), 421 (Misdirected Request), 501 (Not Implemented): 60s. These defaults can be overridden in negative_caching_policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="negativeCaching")]
		public System.Nullable<System.Boolean> NegativeCaching { get; set; }
		
		/// <summary>
		/// Sets a cache TTL for the specified HTTP status code. negative_caching must be enabled to configure negative_caching_policy. Omitting the policy and leaving negative_caching enabled will use Cloud CDN's default cache TTLs. Note that when specifying an explicit negative_caching_policy, you should take care to specify a cache TTL for all response codes that you wish to cache. Cloud CDN will not apply any default negative caching when a policy exists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="negativeCachingPolicy")]
		public BackendServiceCdnPolicyNegativeCachingPolicy[] NegativeCachingPolicy { get; set; }
		
		/// <summary>
		/// If true then Cloud CDN will combine multiple concurrent cache fill requests into a small number of requests to the origin.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestCoalescing")]
		public System.Nullable<System.Boolean> RequestCoalescing { get; set; }
		
		/// <summary>
		/// Serve existing content from the cache (if available) when revalidating content with the origin, or when an error is encountered when refreshing the cache. This setting defines the default "max-stale" duration for any cached responses that do not specify a max-stale directive. Stale responses that exceed the TTL configured here will not be served. The default limit (max-stale) is 86400s (1 day), which will allow stale content to be served up to this limit beyond the max-age (or s-max-age) of a cached response. The maximum allowed value is 604800 (1 week). Set this to zero (0) to disable serve-while-stale.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serveWhileStale")]
		public System.Nullable<System.Int32> ServeWhileStale { get; set; }
		
		/// <summary>
		/// Maximum number of seconds the response to a signed URL request will be considered fresh. After this time period, the response will be revalidated before being served. Defaults to 1hr (3600s). When serving responses to signed URL requests, Cloud CDN will internally behave as though all responses from this backend had a "Cache-Control: public, max-age=[TTL]" header, regardless of any existing Cache-Control header. The actual headers served in responses will not be altered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signedUrlCacheMaxAgeSec")]
		public string SignedUrlCacheMaxAgeSec { get; set; }
		
		/// <summary>
		/// [Output Only] Names of the keys for signing request URLs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signedUrlKeyNames")]
		public string[] SignedUrlKeyNames { get; set; }
	}
	
	/// <summary>
	/// Bypass the cache when the specified request headers are present, e.g. Pragma or Authorization headers. Values are case insensitive. The presence of such a header overrides the cache_mode setting.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceCdnPolicyBypassCacheOnRequestHeader
	{
		
		/// <summary>
		/// The header field name to match on when bypassing cache. Values are case-insensitive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerName")]
		public string HeaderName { get; set; }
	}
	
	/// <summary>
	/// Message containing what to include in the cache key for a request for Cloud CDN.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CacheKeyPolicy
	{
		
		/// <summary>
		/// If true, requests to different hosts will be cached separately.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeHost")]
		public System.Nullable<System.Boolean> IncludeHost { get; set; }
		
		/// <summary>
		/// Allows HTTP request headers (by name) to be used in the cache key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeHttpHeaders")]
		public string[] IncludeHttpHeaders { get; set; }
		
		/// <summary>
		/// Allows HTTP cookies (by name) to be used in the cache key. The name=value pair will be used in the cache key Cloud CDN generates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeNamedCookies")]
		public string[] IncludeNamedCookies { get; set; }
		
		/// <summary>
		/// If true, http and https requests will be cached separately.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeProtocol")]
		public System.Nullable<System.Boolean> IncludeProtocol { get; set; }
		
		/// <summary>
		/// If true, include query string parameters in the cache key according to query_string_whitelist and query_string_blacklist. If neither is set, the entire query string will be included. If false, the query string will be excluded from the cache key entirely.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="includeQueryString")]
		public System.Nullable<System.Boolean> IncludeQueryString { get; set; }
		
		/// <summary>
		/// Names of query string parameters to exclude in cache keys. All other parameters will be included. Either specify query_string_whitelist or query_string_blacklist, not both. '&' and '=' will be percent encoded and not treated as delimiters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryStringBlacklist")]
		public string[] QueryStringBlacklist { get; set; }
		
		/// <summary>
		/// Names of query string parameters to include in cache keys. All other parameters will be excluded. Either specify query_string_whitelist or query_string_blacklist, not both. '&' and '=' will be percent encoded and not treated as delimiters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryStringWhitelist")]
		public string[] QueryStringWhitelist { get; set; }
	}
	
	/// <summary>
	/// Specify CDN TTLs for response error codes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceCdnPolicyNegativeCachingPolicy
	{
		
		/// <summary>
		/// The HTTP status code to define a TTL against. Only HTTP status codes 300, 301, 302, 307, 308, 404, 405, 410, 421, 451 and 501 are can be specified as values, and you cannot specify a status code more than once.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// The TTL (in seconds) for which to cache responses with the corresponding status code. The maximum allowed value is 1800s (30 minutes), noting that infrequently accessed objects may be evicted from the cache before the defined TTL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public System.Nullable<System.Int32> Ttl { get; set; }
	}
	
	/// <summary>
	/// Settings controlling the volume of requests, connections and retries to this backend service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CircuitBreakers
	{
		
		/// <summary>
		/// The maximum number of connections to the backend service. If not specified, there is no limit. Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConnections")]
		public System.Nullable<System.Int32> MaxConnections { get; set; }
		
		/// <summary>
		/// The maximum number of pending requests allowed to the backend service. If not specified, there is no limit. Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPendingRequests")]
		public System.Nullable<System.Int32> MaxPendingRequests { get; set; }
		
		/// <summary>
		/// The maximum number of parallel requests that allowed to the backend service. If not specified, there is no limit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRequests")]
		public System.Nullable<System.Int32> MaxRequests { get; set; }
		
		/// <summary>
		/// Maximum requests for a single connection to the backend service. This parameter is respected by both the HTTP/1.1 and HTTP/2 implementations. If not specified, there is no limit. Setting this parameter to 1 will effectively disable keep alive. Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRequestsPerConnection")]
		public System.Nullable<System.Int32> MaxRequestsPerConnection { get; set; }
		
		/// <summary>
		/// The maximum number of parallel retries allowed to the backend cluster. If not specified, the default is 1. Not supported when the backend service is referenced by a URL map that is bound to target gRPC proxy that has validateForProxyless field set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRetries")]
		public System.Nullable<System.Int32> MaxRetries { get; set; }
	}
	
	/// <summary>
	/// Message containing connection draining configuration.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectionDraining
	{
		
		/// <summary>
		/// Configures a duration timeout for existing requests on a removed backend instance. For supported load balancers and protocols, as described in Enabling connection draining.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="drainingTimeoutSec")]
		public System.Nullable<System.Int32> DrainingTimeoutSec { get; set; }
	}
	
	/// <summary>
	/// Connection Tracking configuration for this BackendService.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceConnectionTrackingPolicy
	{
		
		/// <summary>
		/// Specifies connection persistence when backends are unhealthy. The default value is DEFAULT_FOR_PROTOCOL. If set to DEFAULT_FOR_PROTOCOL, the existing connections persist on unhealthy backends only for connection-oriented protocols (TCP and SCTP) and only if the Tracking Mode is PER_CONNECTION (default tracking mode) or the Session Affinity is configured for 5-tuple. They do not persist for UDP. If set to NEVER_PERSIST, after a backend becomes unhealthy, the existing connections on the unhealthy backend are never persisted on the unhealthy backend. They are always diverted to newly selected healthy backends (unless all backends are unhealthy). If set to ALWAYS_PERSIST, existing connections always persist on unhealthy backends regardless of protocol and session affinity. It is generally not recommended to use this mode overriding the default. For more details, see [Connection Persistence for Network Load Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-backend-service#connection-persistence) and [Connection Persistence for Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal#connection-persistence).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionPersistenceOnUnhealthyBackends")]
		public System.Nullable<BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends> ConnectionPersistenceOnUnhealthyBackends { get; set; }
		
		/// <summary>
		/// Enable Strong Session Affinity for external passthrough Network Load Balancers. This option is not available publicly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableStrongAffinity")]
		public System.Nullable<System.Boolean> EnableStrongAffinity { get; set; }
		
		/// <summary>
		/// Specifies how long to keep a Connection Tracking entry while there is no matching traffic (in seconds). For internal passthrough Network Load Balancers: - The minimum (default) is 10 minutes and the maximum is 16 hours. - It can be set only if Connection Tracking is less than 5-tuple (i.e. Session Affinity is CLIENT_IP_NO_DESTINATION, CLIENT_IP or CLIENT_IP_PROTO, and Tracking Mode is PER_SESSION). For external passthrough Network Load Balancers the default is 60 seconds. This option is not available publicly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idleTimeoutSec")]
		public System.Nullable<System.Int32> IdleTimeoutSec { get; set; }
		
		/// <summary>
		/// Specifies the key used for connection tracking. There are two options: - PER_CONNECTION: This is the default mode. The Connection Tracking is performed as per the Connection Key (default Hash Method) for the specific protocol. - PER_SESSION: The Connection Tracking is performed as per the configured Session Affinity. It matches the configured Session Affinity. For more details, see [Tracking Mode for Network Load Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-backend-service#tracking-mode) and [Tracking Mode for Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal#tracking-mode).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trackingMode")]
		public System.Nullable<BackendServiceConnectionTrackingPolicyTrackingMode> TrackingMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackendServiceConnectionTrackingPolicyConnectionPersistenceOnUnhealthyBackends
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALWAYS_PERSIST = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT_FOR_PROTOCOL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEVER_PERSIST = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackendServiceConnectionTrackingPolicyTrackingMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_TRACKING_MODE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_CONNECTION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PER_SESSION = 2,
	}
	
	/// <summary>
	/// This message defines settings for a consistent hash style load balancer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConsistentHashLoadBalancerSettings
	{
		
		/// <summary>
		/// The information about the HTTP Cookie on which the hash function is based for load balancing policies that use a consistent hash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpCookie")]
		public ConsistentHashLoadBalancerSettingsHttpCookie HttpCookie { get; set; }
		
		/// <summary>
		/// The hash based on the value of the specified header field. This field is applicable if the sessionAffinity is set to HEADER_FIELD.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpHeaderName")]
		public string HttpHeaderName { get; set; }
		
		/// <summary>
		/// The minimum number of virtual nodes to use for the hash ring. Defaults to 1024. Larger ring sizes result in more granular load distributions. If the number of hosts in the load balancing pool is larger than the ring size, each host will be assigned a single virtual node.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumRingSize")]
		public string MinimumRingSize { get; set; }
	}
	
	/// <summary>
	/// The information about the HTTP Cookie on which the hash function is based for load balancing policies that use a consistent hash.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConsistentHashLoadBalancerSettingsHttpCookie
	{
		
		/// <summary>
		/// Name of the cookie.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Path to set for the cookie.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public Duration Ttl { get; set; }
	}
	
	/// <summary>
	/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Duration
	{
		
		/// <summary>
		/// Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 `seconds` field and a positive `nanos` field. Must be from 0 to 999,999,999 inclusive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nanos")]
		public System.Nullable<System.Int32> Nanos { get; set; }
		
		/// <summary>
		/// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="seconds")]
		public string Seconds { get; set; }
	}
	
	/// <summary>
	/// For load balancers that have configurable failover: [Internal passthrough Network Load Balancers](https://cloud.google.com/load-balancing/docs/internal/failover-overview) and [external passthrough Network Load Balancers](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview). On failover or failback, this field indicates whether connection draining will be honored. Google Cloud has a fixed connection draining timeout of 10 minutes. A setting of true terminates existing TCP connections to the active pool during failover and failback, immediately draining traffic. A setting of false allows existing TCP connections to persist, even on VMs no longer in the active pool, for up to the duration of the connection draining timeout (10 minutes).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceFailoverPolicy
	{
		
		/// <summary>
		/// This can be set to true only if the protocol is TCP. The default is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disableConnectionDrainOnFailover")]
		public System.Nullable<System.Boolean> DisableConnectionDrainOnFailover { get; set; }
		
		/// <summary>
		/// If set to true, connections to the load balancer are dropped when all primary and all backup backend VMs are unhealthy.If set to false, connections are distributed among all primary VMs when all primary and all backup backend VMs are unhealthy. For load balancers that have configurable failover: [Internal passthrough Network Load Balancers](https://cloud.google.com/load-balancing/docs/internal/failover-overview) and [external passthrough Network Load Balancers](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview). The default is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dropTrafficIfUnhealthy")]
		public System.Nullable<System.Boolean> DropTrafficIfUnhealthy { get; set; }
		
		/// <summary>
		/// The value of the field must be in the range [0, 1]. If the value is 0, the load balancer performs a failover when the number of healthy primary VMs equals zero. For all other values, the load balancer performs a failover when the total number of healthy primary VMs is less than this ratio. For load balancers that have configurable failover: [Internal TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/internal/failover-overview) and [external TCP/UDP Load Balancing](https://cloud.google.com/load-balancing/docs/network/networklb-failover-overview).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failoverRatio")]
		public System.Nullable<System.Single> FailoverRatio { get; set; }
	}
	
	/// <summary>
	/// Identity-Aware Proxy
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceIAP
	{
		
		/// <summary>
		/// Whether the serving infrastructure will authenticate and authorize all incoming requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		/// <summary>
		/// OAuth2 client ID to use for the authentication flow.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauth2ClientId")]
		public string Oauth2ClientId { get; set; }
		
		/// <summary>
		/// OAuth2 client secret to use for the authentication flow. For security reasons, this value cannot be retrieved via the API. Instead, the SHA-256 hash of the value is returned in the oauth2ClientSecretSha256 field. @InputOnly
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauth2ClientSecret")]
		public string Oauth2ClientSecret { get; set; }
		
		/// <summary>
		/// [Output Only] SHA256 hash value for the field oauth2_client_secret above.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauth2ClientSecretSha256")]
		public string Oauth2ClientSecretSha256 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackendServiceLoadBalancingScheme
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL_MANAGED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL_MANAGED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL_SELF_MANAGED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_LOAD_BALANCING_SCHEME = 5,
	}
	
	/// <summary>
	/// Container for either a built-in LB policy supported by gRPC or Envoy or a custom one implemented by the end user.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceLocalityLoadBalancingPolicyConfig
	{
		
		/// <summary>
		/// The configuration for a custom policy implemented by the user and deployed with the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customPolicy")]
		public BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy CustomPolicy { get; set; }
		
		/// <summary>
		/// The configuration for a built-in load balancing policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public BackendServiceLocalityLoadBalancingPolicyConfigPolicy Policy { get; set; }
	}
	
	/// <summary>
	/// The configuration for a custom policy implemented by the user and deployed with the client.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy
	{
		
		/// <summary>
		/// An optional, arbitrary JSON object with configuration data, understood by a locally installed custom policy implementation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
		
		/// <summary>
		/// Identifies the custom policy. The value should match the name of a custom implementation registered on the gRPC clients. It should follow protocol buffer message naming conventions and include the full path (for example, myorg.CustomLbPolicy). The maximum length is 256 characters. Do not specify the same custom policy more than once for a backend. If you do, the configuration is rejected. For an example of how to use this field, see Use a custom policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The configuration for a built-in load balancing policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceLocalityLoadBalancingPolicyConfigPolicy
	{
		
		/// <summary>
		/// The name of a locality load-balancing policy. Valid values include ROUND_ROBIN and, for Java clients, LEAST_REQUEST. For information about these values, see the description of localityLbPolicy. Do not specify the same policy more than once for a backend. If you do, the configuration is rejected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public System.Nullable<BackendServiceLocalityLoadBalancingPolicyConfigPolicyName> Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackendServiceLocalityLoadBalancingPolicyConfigPolicyName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_LB_POLICY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LEAST_REQUEST = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAGLEV = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORIGINAL_DESTINATION = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RANDOM = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RING_HASH = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ROUND_ROBIN = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEIGHTED_MAGLEV = 7,
	}
	
	/// <summary>
	/// The available logging options for the load balancer traffic served by this backend service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceLogConfig
	{
		
		/// <summary>
		/// Denotes whether to enable logging for the load balancer traffic served by this backend service. The default value is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable")]
		public System.Nullable<System.Boolean> Enable { get; set; }
		
		/// <summary>
		/// This field can only be specified if logging is enabled for this backend service and "logConfig.optionalMode" was set to CUSTOM. Contains a list of optional fields you want to include in the logs. For example: serverInstance, serverGkeDetails.cluster, serverGkeDetails.pod.podNamespace
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="optionalFields")]
		public string[] OptionalFields { get; set; }
		
		/// <summary>
		/// This field can only be specified if logging is enabled for this backend service. Configures whether all, none or a subset of optional fields should be added to the reported logs. One of [INCLUDE_ALL_OPTIONAL, EXCLUDE_ALL_OPTIONAL, CUSTOM]. Default is EXCLUDE_ALL_OPTIONAL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="optionalMode")]
		public System.Nullable<BackendServiceLogConfigOptionalMode> OptionalMode { get; set; }
		
		/// <summary>
		/// This field can only be specified if logging is enabled for this backend service. The value of the field must be in [0, 1]. This configures the sampling rate of requests to the load balancer where 1.0 means all logged requests are reported and 0.0 means no logged requests are reported. The default value is 1.0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sampleRate")]
		public System.Nullable<System.Single> SampleRate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackendServiceLogConfigOptionalMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXCLUDE_ALL_OPTIONAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCLUDE_ALL_OPTIONAL = 2,
	}
	
	/// <summary>
	/// Settings controlling the eviction of unhealthy hosts from the load balancing pool for the backend service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OutlierDetection
	{
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseEjectionTime")]
		public Duration BaseEjectionTime { get; set; }
		
		/// <summary>
		/// Number of consecutive errors before a backend endpoint is ejected from the load balancing pool. When the backend endpoint is accessed over HTTP, a 5xx return code qualifies as an error. Defaults to 5.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consecutiveErrors")]
		public System.Nullable<System.Int32> ConsecutiveErrors { get; set; }
		
		/// <summary>
		/// The number of consecutive gateway failures (502, 503, 504 status or connection errors that are mapped to one of those status codes) before a consecutive gateway failure ejection occurs. Defaults to 3.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consecutiveGatewayFailure")]
		public System.Nullable<System.Int32> ConsecutiveGatewayFailure { get; set; }
		
		/// <summary>
		/// The percentage chance that a backend endpoint will be ejected when an outlier status is detected through consecutive 5xx. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcingConsecutiveErrors")]
		public System.Nullable<System.Int32> EnforcingConsecutiveErrors { get; set; }
		
		/// <summary>
		/// The percentage chance that a backend endpoint will be ejected when an outlier status is detected through consecutive gateway failures. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcingConsecutiveGatewayFailure")]
		public System.Nullable<System.Int32> EnforcingConsecutiveGatewayFailure { get; set; }
		
		/// <summary>
		/// The percentage chance that a backend endpoint will be ejected when an outlier status is detected through success rate statistics. This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100. Not supported when the backend service uses Serverless NEG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforcingSuccessRate")]
		public System.Nullable<System.Int32> EnforcingSuccessRate { get; set; }
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interval")]
		public Duration Interval { get; set; }
		
		/// <summary>
		/// Maximum percentage of backend endpoints in the load balancing pool for the backend service that can be ejected if the ejection conditions are met. Defaults to 50%.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxEjectionPercent")]
		public System.Nullable<System.Int32> MaxEjectionPercent { get; set; }
		
		/// <summary>
		/// The number of backend endpoints in the load balancing pool that must have enough request volume to detect success rate outliers. If the number of backend endpoints is fewer than this setting, outlier detection via success rate statistics is not performed for any backend endpoint in the load balancing pool. Defaults to 5. Not supported when the backend service uses Serverless NEG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="successRateMinimumHosts")]
		public System.Nullable<System.Int32> SuccessRateMinimumHosts { get; set; }
		
		/// <summary>
		/// The minimum number of total requests that must be collected in one interval (as defined by the interval duration above) to include this backend endpoint in success rate based outlier detection. If the volume is lower than this setting, outlier detection via success rate statistics is not performed for that backend endpoint. Defaults to 100. Not supported when the backend service uses Serverless NEG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="successRateRequestVolume")]
		public System.Nullable<System.Int32> SuccessRateRequestVolume { get; set; }
		
		/// <summary>
		/// This factor is used to determine the ejection threshold for success rate outlier ejection. The ejection threshold is the difference between the mean success rate, and the product of this factor and the standard deviation of the mean success rate: mean - (stdev * successRateStdevFactor). This factor is divided by a thousand to get a double. That is, if the desired factor is 1.9, the runtime value should be 1900. Defaults to 1900. Not supported when the backend service uses Serverless NEG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="successRateStdevFactor")]
		public System.Nullable<System.Int32> SuccessRateStdevFactor { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackendServiceProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRPC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTPS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SSL = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TCP = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UDP = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED = 7,
	}
	
	/// <summary>
	/// The authentication and authorization settings for a BackendService.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecuritySettings
	{
		
		/// <summary>
		/// Contains the configurations necessary to generate a signature for access to private storage buckets that support Signature Version 4 for authentication. The service name for generating the authentication header will always default to 's3'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="awsV4Authentication")]
		public AWSV4Signature AwsV4Authentication { get; set; }
		
		/// <summary>
		/// Optional. A URL referring to a networksecurity.ClientTlsPolicy resource that describes how clients should authenticate with this service's backends. clientTlsPolicy only applies to a global BackendService with the loadBalancingScheme set to INTERNAL_SELF_MANAGED. If left blank, communications are not encrypted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientTlsPolicy")]
		public string ClientTlsPolicy { get; set; }
		
		/// <summary>
		/// Optional. A list of Subject Alternative Names (SANs) that the client verifies during a mutual TLS handshake with an server/endpoint for this BackendService. When the server presents its X.509 certificate to the client, the client inspects the certificate's subjectAltName field. If the field contains one of the specified values, the communication continues. Otherwise, it fails. This additional check enables the client to verify that the server is authorized to run the requested service. Note that the contents of the server certificate's subjectAltName field are configured by the Public Key Infrastructure which provisions server identities. Only applies to a global BackendService with loadBalancingScheme set to INTERNAL_SELF_MANAGED. Only applies when BackendService has an attached clientTlsPolicy with clientCertificate (mTLS mode).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subjectAltNames")]
		public string[] SubjectAltNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BackendServiceSessionAffinity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT_IP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT_IP_NO_DESTINATION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT_IP_PORT_PROTO = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLIENT_IP_PROTO = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GENERATED_COOKIE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HEADER_FIELD = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP_COOKIE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 7,
	}
	
	/// <summary>
	/// Subsetting configuration for this BackendService. Currently this is applicable only for Internal TCP/UDP load balancing, Internal HTTP(S) load balancing and Traffic Director.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Subsetting
	{
		
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public System.Nullable<SubsettingPolicy> Policy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SubsettingPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONSISTENT_HASH_SUBSETTING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceUsedBy
	{
		
		[System.Runtime.Serialization.DataMember(Name="reference")]
		public string Reference { get; set; }
	}
	
	/// <summary>
	/// Contains a list of BackendServicesScopedList.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of BackendServicesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, BackendServicesScopedList> Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#backendServiceAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#backendServiceAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public BackendServiceAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServicesScopedList
	{
		
		/// <summary>
		/// A list of BackendServices contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backendServices")]
		public BackendService[] BackendServices { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of backend services when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public BackendServicesScopedListWarning Warning { get; set; }
	}
	
	public class BackendServicesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public BackendServicesScopedListWarningData[] BackendServicesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class BackendServicesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class BackendServiceAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public BackendServiceAggregatedListWarningData[] BackendServiceAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class BackendServiceAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceGroupHealth
	{
		
		/// <summary>
		/// Metadata defined as annotations on the network endpoint group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public System.Collections.Generic.Dictionary<string, string> Annotations { get; set; }
		
		/// <summary>
		/// Health state of the backend instances or endpoints in requested instance or network endpoint group, determined based on configured health checks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthStatus")]
		public HealthStatus[] HealthStatus { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#backendServiceGroupHealth for the health of backend services.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#backendServiceGroupHealth")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#backendServiceGroupHealth";
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthStatus
	{
		
		/// <summary>
		/// Metadata defined as annotations for network endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public System.Collections.Generic.Dictionary<string, string> Annotations { get; set; }
		
		/// <summary>
		/// URL of the forwarding rule associated with the health status of the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forwardingRule")]
		public string ForwardingRule { get; set; }
		
		/// <summary>
		/// A forwarding rule IP address assigned to this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forwardingRuleIp")]
		public string ForwardingRuleIp { get; set; }
		
		/// <summary>
		/// Health state of the IPv4 address of the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthState")]
		public System.Nullable<HealthStatusHealthState> HealthState { get; set; }
		
		/// <summary>
		/// URL of the instance resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
		
		/// <summary>
		/// For target pool based Network Load Balancing, it indicates the forwarding rule's IP address assigned to this instance. For other types of load balancing, the field indicates VM internal ip.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// The named port of the instance group, not necessarily the port that is health-checked.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public string Weight { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="weightError")]
		public System.Nullable<HealthStatusWeightError> WeightError { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HealthStatusHealthState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HEALTHY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNHEALTHY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HealthStatusWeightError
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_WEIGHT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MISSING_WEIGHT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNAVAILABLE_WEIGHT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEIGHT_NONE = 3,
	}
	
	/// <summary>
	/// Contains a list of BackendService resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of BackendService resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public BackendService[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#backendServiceList for lists of backend services.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#backendServiceList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#backendServiceList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public BackendServiceListWarning Warning { get; set; }
	}
	
	public class BackendServiceListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public BackendServiceListWarningData[] BackendServiceListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class BackendServiceListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of usable BackendService resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceListUsable
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of BackendService resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public BackendService[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#usableBackendServiceList for lists of usable backend services.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#usableBackendServiceList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#usableBackendServiceList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public BackendServiceListUsableWarning Warning { get; set; }
	}
	
	public class BackendServiceListUsableWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public BackendServiceListUsableWarningData[] BackendServiceListUsableWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class BackendServiceListUsableWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BackendServiceReference
	{
		
		[System.Runtime.Serialization.DataMember(Name="backendService")]
		public string BackendService { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BfdPacket
	{
		
		/// <summary>
		/// The Authentication Present bit of the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authenticationPresent")]
		public System.Nullable<System.Boolean> AuthenticationPresent { get; set; }
		
		/// <summary>
		/// The Control Plane Independent bit of the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controlPlaneIndependent")]
		public System.Nullable<System.Boolean> ControlPlaneIndependent { get; set; }
		
		/// <summary>
		/// The demand bit of the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="demand")]
		public System.Nullable<System.Boolean> Demand { get; set; }
		
		/// <summary>
		/// The diagnostic code specifies the local system's reason for the last change in session state. This allows remote systems to determine the reason that the previous session failed, for example. These diagnostic codes are specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diagnostic")]
		public System.Nullable<BfdPacketDiagnostic> Diagnostic { get; set; }
		
		/// <summary>
		/// The Final bit of the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="final")]
		public System.Nullable<System.Boolean> Final { get; set; }
		
		/// <summary>
		/// The length of the BFD Control packet in bytes. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="length")]
		public System.Nullable<System.UInt32> Length { get; set; }
		
		/// <summary>
		/// The Required Min Echo RX Interval value in the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minEchoRxIntervalMs")]
		public System.Nullable<System.UInt32> MinEchoRxIntervalMs { get; set; }
		
		/// <summary>
		/// The Required Min RX Interval value in the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minRxIntervalMs")]
		public System.Nullable<System.UInt32> MinRxIntervalMs { get; set; }
		
		/// <summary>
		/// The Desired Min TX Interval value in the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minTxIntervalMs")]
		public System.Nullable<System.UInt32> MinTxIntervalMs { get; set; }
		
		/// <summary>
		/// The detection time multiplier of the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multiplier")]
		public System.Nullable<System.UInt32> Multiplier { get; set; }
		
		/// <summary>
		/// The multipoint bit of the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multipoint")]
		public System.Nullable<System.Boolean> Multipoint { get; set; }
		
		/// <summary>
		/// The My Discriminator value in the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="myDiscriminator")]
		public System.Nullable<System.UInt32> MyDiscriminator { get; set; }
		
		/// <summary>
		/// The Poll bit of the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poll")]
		public System.Nullable<System.Boolean> Poll { get; set; }
		
		/// <summary>
		/// The current BFD session state as seen by the transmitting system. These states are specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<BfdPacketState> State { get; set; }
		
		/// <summary>
		/// The version number of the BFD protocol, as specified in section 4.1 of RFC5880.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<System.UInt32> Version { get; set; }
		
		/// <summary>
		/// The Your Discriminator value in the BFD packet. This is specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="yourDiscriminator")]
		public System.Nullable<System.UInt32> YourDiscriminator { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BfdPacketDiagnostic
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMINISTRATIVELY_DOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONCATENATED_PATH_DOWN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTROL_DETECTION_TIME_EXPIRED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DIAGNOSTIC_UNSPECIFIED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ECHO_FUNCTION_FAILED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FORWARDING_PLANE_RESET = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEIGHBOR_SIGNALED_SESSION_DOWN = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_DIAGNOSTIC = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PATH_DOWN = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVERSE_CONCATENATED_PATH_DOWN = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BfdPacketState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN_DOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOWN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INIT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UP = 4,
	}
	
	/// <summary>
	/// Next free: 15
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BfdStatus
	{
		
		/// <summary>
		/// The BFD session initialization mode for this BGP peer. If set to ACTIVE, the Cloud Router will initiate the BFD session for this BGP peer. If set to PASSIVE, the Cloud Router will wait for the peer router to initiate the BFD session for this BGP peer. If set to DISABLED, BFD is disabled for this BGP peer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bfdSessionInitializationMode")]
		public System.Nullable<BfdStatusBfdSessionInitializationMode> BfdSessionInitializationMode { get; set; }
		
		/// <summary>
		/// Unix timestamp of the most recent config update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configUpdateTimestampMicros")]
		public string ConfigUpdateTimestampMicros { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="controlPacketCounts")]
		public BfdStatusPacketCounts ControlPacketCounts { get; set; }
		
		/// <summary>
		/// Inter-packet time interval statistics for control packets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="controlPacketIntervals")]
		public PacketIntervals[] ControlPacketIntervals { get; set; }
		
		/// <summary>
		/// The diagnostic code specifies the local system's reason for the last change in session state. This allows remote systems to determine the reason that the previous session failed, for example. These diagnostic codes are specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localDiagnostic")]
		public BfdPacketDiagnostic LocalDiagnostic { get; set; }
		
		/// <summary>
		/// The current BFD session state as seen by the transmitting system. These states are specified in section 4.1 of RFC5880
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localState")]
		public BfdPacketState LocalState { get; set; }
		
		/// <summary>
		/// Negotiated transmit interval for control packets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="negotiatedLocalControlTxIntervalMs")]
		public System.Nullable<System.UInt32> NegotiatedLocalControlTxIntervalMs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rxPacket")]
		public BfdPacket RxPacket { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="txPacket")]
		public BfdPacket TxPacket { get; set; }
		
		/// <summary>
		/// Session uptime in milliseconds. Value will be 0 if session is not up.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uptimeMs")]
		public string UptimeMs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BfdStatusBfdSessionInitializationMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PASSIVE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BfdStatusPacketCounts
	{
		
		/// <summary>
		/// Number of packets received since the beginning of the current BFD session.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numRx")]
		public System.Nullable<System.UInt32> NumRx { get; set; }
		
		/// <summary>
		/// Number of packets received that were rejected because of errors since the beginning of the current BFD session.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numRxRejected")]
		public System.Nullable<System.UInt32> NumRxRejected { get; set; }
		
		/// <summary>
		/// Number of packets received that were successfully processed since the beginning of the current BFD session.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numRxSuccessful")]
		public System.Nullable<System.UInt32> NumRxSuccessful { get; set; }
		
		/// <summary>
		/// Number of packets transmitted since the beginning of the current BFD session.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numTx")]
		public System.Nullable<System.UInt32> NumTx { get; set; }
	}
	
	/// <summary>
	/// Next free: 7
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketIntervals
	{
		
		/// <summary>
		/// Average observed inter-packet interval in milliseconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="avgMs")]
		public string AvgMs { get; set; }
		
		/// <summary>
		/// From how long ago in the past these intervals were observed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public System.Nullable<PacketIntervalsDuration> Duration { get; set; }
		
		/// <summary>
		/// Maximum observed inter-packet interval in milliseconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxMs")]
		public string MaxMs { get; set; }
		
		/// <summary>
		/// Minimum observed inter-packet interval in milliseconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minMs")]
		public string MinMs { get; set; }
		
		/// <summary>
		/// Number of inter-packet intervals from which these statistics were derived.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numIntervals")]
		public string NumIntervals { get; set; }
		
		/// <summary>
		/// The type of packets for which inter-packet intervals were computed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<PacketIntervalsType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PacketIntervalsDuration
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DURATION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HOUR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAX = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MINUTE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PacketIntervalsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOOPBACK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECEIVE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRANSMIT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNSPECIFIED = 3,
	}
	
	/// <summary>
	/// Associates `members`, or principals, with a `role`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Binding
	{
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindingId")]
		public string BindingId { get; set; }
		
		/// <summary>
		/// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="condition")]
		public Expr Condition { get; set; }
		
		/// <summary>
		/// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="members")]
		public string[] Members { get; set; }
		
		/// <summary>
		/// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public string Role { get; set; }
	}
	
	/// <summary>
	/// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Expr
	{
		
		/// <summary>
		/// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Textual representation of an expression in Common Expression Language syntax.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expression")]
		public string Expression { get; set; }
		
		/// <summary>
		/// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="title")]
		public string Title { get; set; }
	}
	
	/// <summary>
	/// A transient resource used in compute.disks.bulkInsert and compute.regionDisks.bulkInsert. It is only used to process requests and is not persisted.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkInsertDiskResource
	{
		
		/// <summary>
		/// The URL of the DiskConsistencyGroupPolicy for the group of disks to clone. This may be a full or partial URL, such as: - https://www.googleapis.com/compute/v1/projects/project/regions/region /resourcePolicies/resourcePolicy - projects/project/regions/region/resourcePolicies/resourcePolicy - regions/region/resourcePolicies/resourcePolicy 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceConsistencyGroupPolicy")]
		public string SourceConsistencyGroupPolicy { get; set; }
	}
	
	/// <summary>
	/// A transient resource used in compute.instances.bulkInsert and compute.regionInstances.bulkInsert . This resource is not persisted anywhere, it is used only for processing the requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkInsertInstanceResource
	{
		
		/// <summary>
		/// The maximum number of instances to create.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public string Count { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="instanceProperties")]
		public InstanceProperties InstanceProperties { get; set; }
		
		/// <summary>
		/// Configuration for location policy among multiple possible locations (e.g. preferences for zone selection among zones in a single region).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationPolicy")]
		public LocationPolicy LocationPolicy { get; set; }
		
		/// <summary>
		/// The minimum number of instances to create. If no min_count is specified then count is used as the default value. If min_count instances cannot be created, then no instances will be created and instances already created will be deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minCount")]
		public string MinCount { get; set; }
		
		/// <summary>
		/// The string pattern used for the names of the VMs. Either name_pattern or per_instance_properties must be set. The pattern must contain one continuous sequence of placeholder hash characters (#) with each character corresponding to one digit of the generated instance name. Example: a name_pattern of inst-#### generates instance names such as inst-0001 and inst-0002. If existing instances in the same project and zone have names that match the name pattern then the generated instance numbers start after the biggest existing number. For example, if there exists an instance with name inst-0050, then instance names generated using the pattern inst-#### begin with inst-0051. The name pattern placeholder #...# can contain up to 18 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namePattern")]
		public string NamePattern { get; set; }
		
		/// <summary>
		/// Per-instance properties to be set on individual instances. Keys of this map specify requested instance names. Can be empty if name_pattern is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perInstanceProperties")]
		public System.Collections.Generic.Dictionary<string, BulkInsertInstanceResourcePerInstanceProperties> PerInstanceProperties { get; set; }
		
		/// <summary>
		/// Specifies the instance template from which to create instances. You may combine sourceInstanceTemplate with instanceProperties to override specific values from an existing instance template. Bulk API follows the semantics of JSON Merge Patch described by RFC 7396. It can be a full or partial URL. For example, the following are all valid URLs to an instance template: - https://www.googleapis.com/compute/v1/projects/project /global/instanceTemplates/instanceTemplate - projects/project/global/instanceTemplates/instanceTemplate - global/instanceTemplates/instanceTemplate This field is optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceInstanceTemplate")]
		public string SourceInstanceTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceProperties
	{
		
		/// <summary>
		/// Specifies options for controlling advanced machine features. Options that would traditionally be configured in a BIOS belong here. Features that require operating system support may have corresponding entries in the GuestOsFeatures of an Image (e.g., whether or not the OS in the Image supports nested virtualization being enabled or disabled).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advancedMachineFeatures")]
		public AdvancedMachineFeatures AdvancedMachineFeatures { get; set; }
		
		/// <summary>
		/// Enables instances created based on these properties to send packets with source IP addresses other than their own and receive packets with destination IP addresses other than their own. If these instances will be used as an IP gateway or it will be set as the next-hop in a Route resource, specify true. If unsure, leave this set to false. See the Enable IP forwarding documentation for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canIpForward")]
		public System.Nullable<System.Boolean> CanIpForward { get; set; }
		
		/// <summary>
		/// A set of Confidential Instance options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidentialInstanceConfig")]
		public ConfidentialInstanceConfig ConfidentialInstanceConfig { get; set; }
		
		/// <summary>
		/// An optional text description for the instances that are created from these properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// An array of disks that are associated with the instances that are created from these properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public AttachedDisk[] Disks { get; set; }
		
		/// <summary>
		/// A list of guest accelerator cards' type and count to use for instances created from these properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestAccelerators")]
		public AcceleratorConfig[] GuestAccelerators { get; set; }
		
		/// <summary>
		/// KeyRevocationActionType of the instance. Supported options are "STOP" and "NONE". The default value is "NONE" if it is not specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyRevocationActionType")]
		public System.Nullable<InstancePropertiesKeyRevocationActionType> KeyRevocationActionType { get; set; }
		
		/// <summary>
		/// Labels to apply to instances that are created from these properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// The machine type to use for instances that are created from these properties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
		
		/// <summary>
		/// A metadata key/value entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public Metadata Metadata { get; set; }
		
		/// <summary>
		/// Minimum cpu/platform to be used by instances. The instance may be scheduled on the specified or newer cpu/platform. Applicable values are the friendly names of CPU platforms, such as minCpuPlatform: "Intel Haswell" or minCpuPlatform: "Intel Sandy Bridge". For more information, read Specifying a Minimum CPU Platform.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minCpuPlatform")]
		public string MinCpuPlatform { get; set; }
		
		/// <summary>
		/// An array of network access configurations for this interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaces")]
		public NetworkInterface[] NetworkInterfaces { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="networkPerformanceConfig")]
		public NetworkPerformanceConfig NetworkPerformanceConfig { get; set; }
		
		/// <summary>
		/// The private IPv6 google access type for VMs. If not specified, use INHERIT_FROM_SUBNETWORK as default. Note that for MachineImage, this is not supported yet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateIpv6GoogleAccess")]
		public System.Nullable<InstancePropertiesPrivateIpv6GoogleAccess> PrivateIpv6GoogleAccess { get; set; }
		
		/// <summary>
		/// Specifies the reservations that this instance can consume from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservationAffinity")]
		public ReservationAffinity ReservationAffinity { get; set; }
		
		/// <summary>
		/// Resource manager tags to be bound to the instance. Tag keys and values have the same definition as resource manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and values are in the format `tagValues/456`. The field is ignored (both PUT & PATCH) when empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceManagerTags")]
		public System.Collections.Generic.Dictionary<string, string> ResourceManagerTags { get; set; }
		
		/// <summary>
		/// Resource policies (names, not URLs) applied to instances created from these properties. Note that for MachineImage, this is not supported yet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public string[] ResourcePolicies { get; set; }
		
		/// <summary>
		/// Sets the scheduling options for an Instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduling")]
		public Scheduling Scheduling { get; set; }
		
		/// <summary>
		/// A list of service accounts with specified scopes. Access tokens for these service accounts are available to the instances that are created from these properties. Use metadata queries to obtain the access tokens for these instances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccounts")]
		public ServiceAccount[] ServiceAccounts { get; set; }
		
		/// <summary>
		/// A set of Shielded Instance options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shieldedInstanceConfig")]
		public ShieldedInstanceConfig ShieldedInstanceConfig { get; set; }
		
		/// <summary>
		/// A set of instance tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
	}
	
	/// <summary>
	/// A set of Confidential Instance options.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfidentialInstanceConfig
	{
		
		/// <summary>
		/// Defines whether the instance should have confidential compute enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableConfidentialCompute")]
		public System.Nullable<System.Boolean> EnableConfidentialCompute { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstancePropertiesKeyRevocationActionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOP = 2,
	}
	
	/// <summary>
	/// A metadata key/value entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Metadata
	{
		
		/// <summary>
		/// Specifies a fingerprint for this request, which is essentially a hash of the metadata's contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update metadata. You must always provide an up-to-date fingerprint hash in order to update or change metadata, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// Array of key/value pairs. The total size of all keys and values must be less than 512 KB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public MetadataItems[] MetadataItems { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#metadata for metadata.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#metadata")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#metadata";
	}
	
	public class MetadataItems
	{
		
		/// <summary>
		/// Key for the metadata entry. Keys must conform to the following regexp: [a-zA-Z0-9-_]+, and be less than 128 bytes in length. This is reflected as part of a URL in the metadata server. Additionally, to avoid ambiguity, keys must not conflict with any other metadata keys for the project.
		/// Pattern: [a-zA-Z0-9-_]{1,128}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-zA-Z0-9-_]{1,128}")]
		public string Key { get; set; }
		
		/// <summary>
		/// Value for the metadata entry. These are free-form strings, and only have meaning as interpreted by the image running in the instance. The only restriction placed on values is that their size must be less than or equal to 262144 bytes (256 KiB).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A network interface resource attached to an instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkInterface
	{
		
		/// <summary>
		/// An array of configurations for this interface. Currently, only one access config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs specified, then this instance will have no external internet access.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accessConfigs")]
		public AccessConfig[] AccessConfigs { get; set; }
		
		/// <summary>
		/// An array of alias IP ranges for this network interface. You can only specify this field for network interfaces in VPC networks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aliasIpRanges")]
		public AliasIpRange[] AliasIpRanges { get; set; }
		
		/// <summary>
		/// Fingerprint hash of contents stored in this network interface. This field will be ignored when inserting an Instance or adding a NetworkInterface. An up-to-date fingerprint must be provided in order to update the NetworkInterface. The request will fail with error 400 Bad Request if the fingerprint is not provided, or 412 Precondition Failed if the fingerprint is out of date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// The prefix length of the primary internal IPv6 range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalIpv6PrefixLength")]
		public System.Nullable<System.Int32> InternalIpv6PrefixLength { get; set; }
		
		/// <summary>
		/// An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6AccessConfigs")]
		public AccessConfig[] Ipv6AccessConfigs { get; set; }
		
		/// <summary>
		/// [Output Only] One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork. Valid only if stackType is IPV4_IPV6.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6AccessType")]
		public System.Nullable<NetworkInterfaceIpv6AccessType> Ipv6AccessType { get; set; }
		
		/// <summary>
		/// An IPv6 internal network address for this network interface. To use a static internal IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6Address")]
		public string Ipv6Address { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#networkInterface for network interfaces.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#networkInterface")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkInterface";
		
		/// <summary>
		/// [Output Only] The name of the network interface, which is generated by the server. For a VM, the network interface uses the nicN naming format. Where N is a value between 0 and 7. The default interface value is nic0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// URL of the VPC network resource for this instance. When creating an instance, if neither the network nor the subnetwork is specified, the default network global/networks/default is used. If the selected project doesn't have the default network, you must specify a network or subnet. If the network is not specified but the subnetwork is specified, the network is inferred. If you specify this property, you can specify the network as a full or partial URL. For example, the following are all valid URLs: - https://www.googleapis.com/compute/v1/projects/project/global/networks/ network - projects/project/global/networks/network - global/networks/default 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// The URL of the network attachment that this interface should connect to in the following format: projects/{project_number}/regions/{region_name}/networkAttachments/{network_attachment_name}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkAttachment")]
		public string NetworkAttachment { get; set; }
		
		/// <summary>
		/// An IPv4 internal IP address to assign to the instance for this network interface. If not specified by the user, an unused internal IP is assigned by the system.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkIP")]
		public string NetworkIP { get; set; }
		
		/// <summary>
		/// The type of vNIC to be used on this interface. This may be gVNIC or VirtioNet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nicType")]
		public System.Nullable<NetworkInterfaceNicType> NicType { get; set; }
		
		/// <summary>
		/// The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It'll be empty if not specified by the users.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queueCount")]
		public System.Nullable<System.Int32> QueueCount { get; set; }
		
		/// <summary>
		/// The stack type for this network interface. To assign only IPv4 addresses, use IPV4_ONLY. To assign both IPv4 and IPv6 addresses, use IPV4_IPV6. If not specified, IPV4_ONLY is used. This field can be both set at instance creation and update network interface operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackType")]
		public System.Nullable<NetworkInterfaceStackType> StackType { get; set; }
		
		/// <summary>
		/// The URL of the Subnetwork resource for this instance. If the network resource is in legacy mode, do not specify this field. If the network is in auto subnet mode, specifying the subnetwork is optional. If the network is in custom subnet mode, specifying the subnetwork is required. If you specify this field, you can specify the subnetwork as a full or partial URL. For example, the following are all valid URLs: - https://www.googleapis.com/compute/v1/projects/project/regions/region /subnetworks/subnetwork - regions/region/subnetworks/subnetwork 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetwork")]
		public string Subnetwork { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkInterfaceIpv6AccessType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkInterfaceNicType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GVNIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED_NIC_TYPE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VIRTIO_NET = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkInterfaceStackType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPV4_IPV6 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPV4_ONLY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkPerformanceConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="totalEgressBandwidthTier")]
		public System.Nullable<NetworkPerformanceConfigTotalEgressBandwidthTier> TotalEgressBandwidthTier { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkPerformanceConfigTotalEgressBandwidthTier
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIER_1 = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstancePropertiesPrivateIpv6GoogleAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INHERIT_FROM_SUBNETWORK = 2,
	}
	
	/// <summary>
	/// Specifies the reservations that this instance can consume from.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReservationAffinity
	{
		
		/// <summary>
		/// Specifies the type of reservation from which this instance can consume resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or NO_RESERVATION. See Consuming reserved instances for examples.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consumeReservationType")]
		public System.Nullable<ReservationAffinityConsumeReservationType> ConsumeReservationType { get; set; }
		
		/// <summary>
		/// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify googleapis.com/reservation-name as the key and specify the name of your reservation as its value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Corresponds to the label values of a reservation resource. This can be either a name to a reservation in the same project or "projects/different-project/reservations/some-reservation-name" to target a shared reservation in the same zone but in a different project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReservationAffinityConsumeReservationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY_RESERVATION = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_RESERVATION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SPECIFIC_RESERVATION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED = 3,
	}
	
	/// <summary>
	/// Sets the scheduling options for an Instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Scheduling
	{
		
		/// <summary>
		/// Specifies whether the instance should be automatically restarted if it is terminated by Compute Engine (not terminated by a user). You can only set the automatic restart option for standard instances. Preemptible instances cannot be automatically restarted. By default, this is set to true so an instance is automatically restarted if it is terminated by Compute Engine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="automaticRestart")]
		public System.Nullable<System.Boolean> AutomaticRestart { get; set; }
		
		/// <summary>
		/// Specifies the termination action for the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceTerminationAction")]
		public System.Nullable<SchedulingInstanceTerminationAction> InstanceTerminationAction { get; set; }
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localSsdRecoveryTimeout")]
		public Duration LocalSsdRecoveryTimeout { get; set; }
		
		/// <summary>
		/// An opaque location hint used to place the instance close to other resources. This field is for use by internal tools that use the public API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationHint")]
		public string LocationHint { get; set; }
		
		/// <summary>
		/// The minimum number of virtual CPUs this instance will consume when running on a sole-tenant node.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minNodeCpus")]
		public System.Nullable<System.Int32> MinNodeCpus { get; set; }
		
		/// <summary>
		/// A set of node affinity and anti-affinity configurations. Refer to Configuring node affinity for more information. Overrides reservationAffinity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeAffinities")]
		public SchedulingNodeAffinity[] NodeAffinities { get; set; }
		
		/// <summary>
		/// Defines the maintenance behavior for this instance. For standard instances, the default behavior is MIGRATE. For preemptible instances, the default and only possible behavior is TERMINATE. For more information, see Set VM host maintenance policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="onHostMaintenance")]
		public System.Nullable<SchedulingOnHostMaintenance> OnHostMaintenance { get; set; }
		
		/// <summary>
		/// Defines whether the instance is preemptible. This can only be set during instance creation or while the instance is stopped and therefore, in a `TERMINATED` state. See Instance Life Cycle for more information on the possible instance states.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preemptible")]
		public System.Nullable<System.Boolean> Preemptible { get; set; }
		
		/// <summary>
		/// Specifies the provisioning model of the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioningModel")]
		public System.Nullable<SchedulingProvisioningModel> ProvisioningModel { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SchedulingInstanceTerminationAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INSTANCE_TERMINATION_ACTION_UNSPECIFIED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOP = 2,
	}
	
	/// <summary>
	/// Node Affinity: the configuration of desired nodes onto which this Instance could be scheduled.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SchedulingNodeAffinity
	{
		
		/// <summary>
		/// Corresponds to the label key of Node resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Defines the operation of node selection. Valid operators are IN for affinity and NOT_IN for anti-affinity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operator")]
		public System.Nullable<SchedulingNodeAffinityOperator> Operator { get; set; }
		
		/// <summary>
		/// Corresponds to the label values of Node resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SchedulingNodeAffinityOperator
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_IN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPERATOR_UNSPECIFIED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SchedulingOnHostMaintenance
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIGRATE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TERMINATE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SchedulingProvisioningModel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SPOT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD = 1,
	}
	
	/// <summary>
	/// A service account.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceAccount
	{
		
		/// <summary>
		/// Email address of the service account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The list of scopes to be made available for this service account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
	}
	
	/// <summary>
	/// A set of Shielded Instance options.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ShieldedInstanceConfig
	{
		
		/// <summary>
		/// Defines whether the instance has integrity monitoring enabled. Enabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableIntegrityMonitoring")]
		public System.Nullable<System.Boolean> EnableIntegrityMonitoring { get; set; }
		
		/// <summary>
		/// Defines whether the instance has Secure Boot enabled. Disabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableSecureBoot")]
		public System.Nullable<System.Boolean> EnableSecureBoot { get; set; }
		
		/// <summary>
		/// Defines whether the instance has the vTPM enabled. Enabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableVtpm")]
		public System.Nullable<System.Boolean> EnableVtpm { get; set; }
	}
	
	/// <summary>
	/// A set of instance tags.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tags
	{
		
		/// <summary>
		/// Specifies a fingerprint for this request, which is essentially a hash of the tags' contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update tags. You must always provide an up-to-date fingerprint hash in order to update or change tags. To see the latest fingerprint, make get() request to the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string[] Items { get; set; }
	}
	
	/// <summary>
	/// Configuration for location policy among multiple possible locations (e.g. preferences for zone selection among zones in a single region).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocationPolicy
	{
		
		/// <summary>
		/// Location configurations mapped by location name. Currently only zone names are supported and must be represented as valid internal URLs, such as zones/us-central1-a.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public System.Collections.Generic.Dictionary<string, LocationPolicyLocation> Locations { get; set; }
		
		/// <summary>
		/// Strategy for distributing VMs across zones in a region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetShape")]
		public System.Nullable<LocationPolicyTargetShape> TargetShape { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocationPolicyLocation
	{
		
		/// <summary>
		/// Per-zone constraints on location policy for this zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public LocationPolicyLocationConstraints Constraints { get; set; }
		
		/// <summary>
		/// Preference for a given location. Set to either ALLOW or DENY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preference")]
		public System.Nullable<LocationPolicyLocationPreference> Preference { get; set; }
	}
	
	/// <summary>
	/// Per-zone constraints on location policy for this zone.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocationPolicyLocationConstraints
	{
		
		/// <summary>
		/// Maximum number of items that are allowed to be placed in this zone. The value must be non-negative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxCount")]
		public System.Nullable<System.Int32> MaxCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LocationPolicyLocationPreference
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALLOW = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DENY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREFERENCE_UNSPECIFIED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LocationPolicyTargetShape
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY_SINGLE_ZONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BALANCED = 2,
	}
	
	/// <summary>
	/// Per-instance properties to be set on individual instances. To be extended in the future.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkInsertInstanceResourcePerInstanceProperties
	{
		
		/// <summary>
		/// Specifies the hostname of the instance. More details in: https://cloud.google.com/compute/docs/instances/custom-hostname-vm#naming_convention
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// This field is only temporary. It will be removed. Do not use it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BulkInsertOperationStatus
	{
		
		/// <summary>
		/// [Output Only] Count of VMs successfully created so far.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdVmCount")]
		public System.Nullable<System.Int32> CreatedVmCount { get; set; }
		
		/// <summary>
		/// [Output Only] Count of VMs that got deleted during rollback.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deletedVmCount")]
		public System.Nullable<System.Int32> DeletedVmCount { get; set; }
		
		/// <summary>
		/// [Output Only] Count of VMs that started creating but encountered an error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failedToCreateVmCount")]
		public System.Nullable<System.Int32> FailedToCreateVmCount { get; set; }
		
		/// <summary>
		/// [Output Only] Creation status of BulkInsert operation - information if the flow is rolling forward or rolling back.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<BulkInsertOperationStatusStatus> Status { get; set; }
		
		/// <summary>
		/// [Output Only] Count of VMs originally planned to be created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetVmCount")]
		public System.Nullable<System.Int32> TargetVmCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum BulkInsertOperationStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ROLLING_BACK = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATUS_UNSPECIFIED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CacheInvalidationRule
	{
		
		/// <summary>
		/// If set, this invalidation rule will only apply to requests with a Host header matching host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// Represents a regional Commitment resource. Creating a commitment resource means that you are purchasing a committed use contract with an explicit start and end time. You can create commitments based on vCPUs and memory usage and receive discounted rates. For full details, read Signing Up for Committed Use Discounts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Commitment
	{
		
		/// <summary>
		/// Specifies whether to enable automatic renewal for the commitment. The default value is false if not specified. The field can be updated until the day of the commitment expiration at 12:00am PST. If the field is set to true, the commitment will be automatically renewed for either one or three years according to the terms of the existing commitment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoRenew")]
		public System.Nullable<System.Boolean> AutoRenew { get; set; }
		
		/// <summary>
		/// The category of the commitment. Category MACHINE specifies commitments composed of machine resources such as VCPU or MEMORY, listed in resources. Category LICENSE specifies commitments composed of software licenses, listed in licenseResources. Note that only MACHINE commitments should have a Type specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="category")]
		public System.Nullable<CommitmentCategory> Category { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] Commitment end time in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTimestamp")]
		public string EndTimestamp { get; set; }
		
		/// <summary>
		/// Specifies the already existing reservations to attach to the Commitment. This field is optional, and it can be a full or partial URL. For example, the following are valid URLs to an reservation: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /reservations/reservation - projects/project/zones/zone/reservations/reservation 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="existingReservations")]
		public string[] ExistingReservations { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#commitment for commitments.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#commitment")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#commitment";
		
		/// <summary>
		/// Commitment for a particular license resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseResource")]
		public LicenseResourceCommitment LicenseResource { get; set; }
		
		/// <summary>
		/// List of source commitments to be merged into a new commitment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mergeSourceCommitments")]
		public string[] MergeSourceCommitments { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The plan for this commitment, which determines duration and discount rate. The currently supported plans are TWELVE_MONTH (1 year), and THIRTY_SIX_MONTH (3 years).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="plan")]
		public System.Nullable<CommitmentPlan> Plan { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where this commitment may be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// List of create-on-create reservations for this commitment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservations")]
		public Reservation[] Reservations { get; set; }
		
		/// <summary>
		/// A list of commitment amounts for particular resources. Note that VCPU and MEMORY resource commitments must occur together.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public ResourceCommitment[] Resources { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Source commitment to be split into a new commitment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="splitSourceCommitment")]
		public string SplitSourceCommitment { get; set; }
		
		/// <summary>
		/// [Output Only] Commitment start time in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTimestamp")]
		public string StartTimestamp { get; set; }
		
		/// <summary>
		/// [Output Only] Status of the commitment with regards to eventual expiration (each commitment has an end date defined). One of the following values: NOT_YET_ACTIVE, ACTIVE, EXPIRED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<CommitmentStatus> Status { get; set; }
		
		/// <summary>
		/// [Output Only] An optional, human-readable explanation of the status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// The type of commitment, which affects the discount rate and the eligible resources. Type MEMORY_OPTIMIZED specifies a commitment that will only apply to memory optimized machines. Type ACCELERATOR_OPTIMIZED specifies a commitment that will only apply to accelerator optimized machines.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<CommitmentType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CommitmentCategory
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CATEGORY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LICENSE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MACHINE = 2,
	}
	
	/// <summary>
	/// Commitment for a particular license resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LicenseResourceCommitment
	{
		
		/// <summary>
		/// The number of licenses purchased.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public string Amount { get; set; }
		
		/// <summary>
		/// Specifies the core range of the instance for which this license applies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="coresPerLicense")]
		public string CoresPerLicense { get; set; }
		
		/// <summary>
		/// Any applicable license URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="license")]
		public string License { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CommitmentPlan
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THIRTY_SIX_MONTH = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TWELVE_MONTH = 2,
	}
	
	/// <summary>
	/// Represents a reservation resource. A reservation ensures that capacity is held in a specific zone even if the reserved VMs are not running. For more information, read Reserving zonal resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Reservation
	{
		
		/// <summary>
		/// This reservation type is specified by total resource amounts (e.g. total count of CPUs) and can account for multiple instance SKUs. In other words, one can create instances of varying shapes against this reservation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregateReservation")]
		public AllocationAggregateReservation AggregateReservation { get; set; }
		
		/// <summary>
		/// [Output Only] Full or partial URL to a parent commitment. This field displays for reservations that are tied to a commitment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitment")]
		public string Commitment { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#reservations for reservations.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#reservation")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#reservation";
		
		/// <summary>
		/// The name of the resource, provided by the client when initially creating the resource. The resource name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Resource policies to be added to this reservation. The key is defined by user, and the value is resource policy url. This is to define placement policy with reservation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public System.Collections.Generic.Dictionary<string, string> ResourcePolicies { get; set; }
		
		/// <summary>
		/// [Output Only] Contains output only fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceStatus")]
		public AllocationResourceStatus ResourceStatus { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzs")]
		public System.Nullable<System.Boolean> SatisfiesPzs { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined fully-qualified URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The share setting for reservations and sole tenancy node groups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shareSettings")]
		public ShareSettings ShareSettings { get; set; }
		
		/// <summary>
		/// This reservation type allows to pre allocate specific instance configuration. Next ID: 6
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="specificReservation")]
		public AllocationSpecificSKUReservation SpecificReservation { get; set; }
		
		/// <summary>
		/// Indicates whether the reservation can be consumed by VMs with affinity for "any" reservation. If the field is set, then only VMs that target the reservation by name can consume from this reservation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="specificReservationRequired")]
		public System.Nullable<System.Boolean> SpecificReservationRequired { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the reservation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ReservationStatus> Status { get; set; }
		
		/// <summary>
		/// Zone in which the reservation resides. A zone must be provided if the reservation is created within a commitment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// The share setting for reservations and sole tenancy node groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ShareSettings
	{
		
		/// <summary>
		/// A map of project id and project config. This is only valid when share_type's value is SPECIFIC_PROJECTS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="projectMap")]
		public System.Collections.Generic.Dictionary<string, ShareSettingsProjectConfig> ProjectMap { get; set; }
		
		/// <summary>
		/// Type of sharing for this shared-reservation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shareType")]
		public System.Nullable<ShareSettingsShareType> ShareType { get; set; }
	}
	
	/// <summary>
	/// Config for each project in the share settings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ShareSettingsProjectConfig
	{
		
		/// <summary>
		/// The project ID, should be same as the key of this project config in the parent map.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="projectId")]
		public string ProjectId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ShareSettingsShareType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORGANIZATION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHARE_TYPE_UNSPECIFIED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SPECIFIC_PROJECTS = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ReservationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 4,
	}
	
	/// <summary>
	/// Commitment for a particular resource (a Commitment is composed of one or more of these).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceCommitment
	{
		
		/// <summary>
		/// Name of the accelerator type resource. Applicable only when the type is ACCELERATOR.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceleratorType")]
		public string AcceleratorType { get; set; }
		
		/// <summary>
		/// The amount of the resource purchased (in a type-dependent unit, such as bytes). For vCPUs, this can just be an integer. For memory, this must be provided in MB. Memory must be a multiple of 256 MB, with up to 6.5GB of memory per every vCPU.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="amount")]
		public string Amount { get; set; }
		
		/// <summary>
		/// Type of resource for which this commitment applies. Possible values are VCPU, MEMORY, LOCAL_SSD, and ACCELERATOR.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ResourceCommitmentType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ResourceCommitmentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCELERATOR = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL_SSD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MEMORY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VCPU = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CommitmentStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_YET_ACTIVE = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum CommitmentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCELERATOR_OPTIMIZED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCELERATOR_OPTIMIZED_A3 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_OPTIMIZED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_OPTIMIZED_C2D = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_OPTIMIZED_C3 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_OPTIMIZED_C3D = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPUTE_OPTIMIZED_H3 = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GENERAL_PURPOSE = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GENERAL_PURPOSE_E2 = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GENERAL_PURPOSE_N2 = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GENERAL_PURPOSE_N2D = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GENERAL_PURPOSE_T2D = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRAPHICS_OPTIMIZED = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MEMORY_OPTIMIZED = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MEMORY_OPTIMIZED_M3 = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNSPECIFIED = 15,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CommitmentAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of CommitmentsScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, CommitmentsScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#commitmentAggregatedList for aggregated lists of commitments.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#commitmentAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#commitmentAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public CommitmentAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CommitmentsScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of commitments contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commitments")]
		public Commitment[] Commitments { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning which replaces the list of commitments when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public CommitmentsScopedListWarning Warning { get; set; }
	}
	
	public class CommitmentsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public CommitmentsScopedListWarningData[] CommitmentsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class CommitmentsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class CommitmentAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public CommitmentAggregatedListWarningData[] CommitmentAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class CommitmentAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of Commitment resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CommitmentList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Commitment resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Commitment[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#commitmentList for lists of commitments.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#commitmentList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#commitmentList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public CommitmentListWarning Warning { get; set; }
	}
	
	public class CommitmentListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public CommitmentListWarningData[] CommitmentListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class CommitmentListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// This is deprecated and has no effect. Do not use.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Condition
	{
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="iam")]
		public System.Nullable<ConditionIam> Iam { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="op")]
		public System.Nullable<ConditionOp> Op { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="svc")]
		public string Svc { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sys")]
		public System.Nullable<ConditionSys> Sys { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConditionIam
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPROVER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ATTRIBUTION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTHORITY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREDENTIALS_TYPE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREDS_ASSERTION = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JUSTIFICATION_TYPE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_ATTR = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECURITY_REALM = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConditionOp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISCHARGED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EQUALS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_EQUALS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_IN = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_OP = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ConditionSys
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NAME = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_ATTR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGION = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVICE = 4,
	}
	
	/// <summary>
	/// The specification for allowing client-side cross-origin requests. For more information about the W3C recommendation for cross-origin resource sharing (CORS), see Fetch API Living Standard.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CorsPolicy
	{
		
		/// <summary>
		/// In response to a preflight request, setting this to true indicates that the actual request can include user credentials. This field translates to the Access-Control-Allow-Credentials header. Default is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowCredentials")]
		public System.Nullable<System.Boolean> AllowCredentials { get; set; }
		
		/// <summary>
		/// Specifies the content for the Access-Control-Allow-Headers header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowHeaders")]
		public string[] AllowHeaders { get; set; }
		
		/// <summary>
		/// Specifies the content for the Access-Control-Allow-Methods header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowMethods")]
		public string[] AllowMethods { get; set; }
		
		/// <summary>
		/// Specifies a regular expression that matches allowed origins. For more information about the regular expression syntax, see Syntax. An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes. Regular expressions can only be used when the loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowOriginRegexes")]
		public string[] AllowOriginRegexes { get; set; }
		
		/// <summary>
		/// Specifies the list of origins that is allowed to do CORS requests. An origin is allowed if it matches either an item in allowOrigins or an item in allowOriginRegexes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowOrigins")]
		public string[] AllowOrigins { get; set; }
		
		/// <summary>
		/// If true, the setting specifies the CORS policy is disabled. The default value of false, which indicates that the CORS policy is in effect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// Specifies the content for the Access-Control-Expose-Headers header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exposeHeaders")]
		public string[] ExposeHeaders { get; set; }
		
		/// <summary>
		/// Specifies how long results of a preflight request can be cached in seconds. This field translates to the Access-Control-Max-Age header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxAge")]
		public System.Nullable<System.Int32> MaxAge { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CustomerEncryptionKeyProtectedDisk
	{
		
		[System.Runtime.Serialization.DataMember(Name="diskEncryptionKey")]
		public CustomerEncryptionKey DiskEncryptionKey { get; set; }
		
		/// <summary>
		/// Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks. For example: "source": "/compute/v1/projects/project_id/zones/zone/disks/ disk_name 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	/// <summary>
	/// Represents a Persistent Disk resource. Google Compute Engine has two Disk resources: * [Zonal](/compute/docs/reference/rest/v1/disks) * [Regional](/compute/docs/reference/rest/v1/regionDisks) Persistent disks are required for running your VM instances. Create both boot and non-boot (data) persistent disks. For more information, read Persistent Disks. For more storage options, read Storage options. The disks resource represents a zonal persistent disk. For more information, read Zonal persistent disks. The regionDisks resource represents a regional persistent disk. For more information, read Regional resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Disk
	{
		
		/// <summary>
		/// The architecture of the disk. Valid values are ARM64 or X86_64.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public AttachedDiskArchitecture Architecture { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="asyncPrimaryDisk")]
		public DiskAsyncReplication AsyncPrimaryDisk { get; set; }
		
		/// <summary>
		/// [Output Only] A list of disks this disk is asynchronously replicated to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asyncSecondaryDisks")]
		public System.Collections.Generic.Dictionary<string, DiskAsyncReplicationList> AsyncSecondaryDisks { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="diskEncryptionKey")]
		public CustomerEncryptionKey DiskEncryptionKey { get; set; }
		
		/// <summary>
		/// Whether this disk is using confidential compute mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableConfidentialCompute")]
		public System.Nullable<System.Boolean> EnableConfidentialCompute { get; set; }
		
		/// <summary>
		/// A list of features to enable on the guest operating system. Applicable only for bootable images. Read Enabling guest operating system features to see a list of available options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestOsFeatures")]
		public GuestOsFeature[] GuestOsFeatures { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#disk for disks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#disk")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#disk";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this disk, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels to apply to this disk. These can be later modified by the setLabels method.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// [Output Only] Last attach timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastAttachTimestamp")]
		public string LastAttachTimestamp { get; set; }
		
		/// <summary>
		/// [Output Only] Last detach timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastDetachTimestamp")]
		public string LastDetachTimestamp { get; set; }
		
		/// <summary>
		/// Integer license codes indicating which licenses are attached to this disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseCodes")]
		public string[] LicenseCodes { get; set; }
		
		/// <summary>
		/// A list of publicly visible licenses. Reserved for Google's use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public string[] Licenses { get; set; }
		
		/// <summary>
		/// An opaque location hint used to place the disk close to other resources. This field is for use by internal tools that use the public API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationHint")]
		public string LocationHint { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Internal use only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="options")]
		public string Options { get; set; }
		
		/// <summary>
		/// Additional disk params.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="params")]
		public DiskParams Params { get; set; }
		
		/// <summary>
		/// Physical block size of the persistent disk, in bytes. If not present in a request, a default value is used. The currently supported size is 4096, other sizes may be added in the future. If an unsupported value is requested, the error message will list the supported values for the caller's project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="physicalBlockSizeBytes")]
		public string PhysicalBlockSizeBytes { get; set; }
		
		/// <summary>
		/// Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. Values must be between 10,000 and 120,000. For more details, see the Extreme persistent disk documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisionedIops")]
		public string ProvisionedIops { get; set; }
		
		/// <summary>
		/// Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle. Values must be between 1 and 7,124.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisionedThroughput")]
		public string ProvisionedThroughput { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the disk resides. Only applicable for regional resources. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// URLs of the zones where the disk should be replicated to. Only applicable for regional resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replicaZones")]
		public string[] ReplicaZones { get; set; }
		
		/// <summary>
		/// Resource policies applied to this disk for automatic snapshot creations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public string[] ResourcePolicies { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resourceStatus")]
		public DiskResourceStatus ResourceStatus { get; set; }
		
		/// <summary>
		/// Output only. Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzi")]
		public System.Nullable<System.Boolean> SatisfiesPzi { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzs")]
		public System.Nullable<System.Boolean> SatisfiesPzs { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined fully-qualified URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Size, in GB, of the persistent disk. You can specify this field when creating a persistent disk using the sourceImage, sourceSnapshot, or sourceDisk parameter, or specify it alone to create an empty persistent disk. If you specify this field along with a source, the value of sizeGb must not be less than the size of the source. Acceptable values are greater than 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public string SizeGb { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the DiskConsistencyGroupPolicy for a secondary disk that was created using a consistency group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceConsistencyGroupPolicy")]
		public string SourceConsistencyGroupPolicy { get; set; }
		
		/// <summary>
		/// [Output Only] ID of the DiskConsistencyGroupPolicy for a secondary disk that was created using a consistency group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceConsistencyGroupPolicyId")]
		public string SourceConsistencyGroupPolicyId { get; set; }
		
		/// <summary>
		/// The source disk used to create this disk. You can provide this as a partial or full URL to the resource. For example, the following are valid values: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /disks/disk - https://www.googleapis.com/compute/v1/projects/project/regions/region /disks/disk - projects/project/zones/zone/disks/disk - projects/project/regions/region/disks/disk - zones/zone/disks/disk - regions/region/disks/disk 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDisk")]
		public string SourceDisk { get; set; }
		
		/// <summary>
		/// [Output Only] The unique ID of the disk used to create this disk. This value identifies the exact disk that was used to create this persistent disk. For example, if you created the persistent disk from a disk that was later deleted and recreated under the same name, the source disk ID would identify the exact version of the disk that was used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDiskId")]
		public string SourceDiskId { get; set; }
		
		/// <summary>
		/// The source image used to create this disk. If the source image is deleted, this field will not be set. To create a disk with one of the public operating system images, specify the image by its family name. For example, specify family/debian-9 to use the latest Debian 9 image: projects/debian-cloud/global/images/family/debian-9 Alternatively, use a specific version of a public operating system image: projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD To create a disk with a custom image that you created, specify the image name in the following format: global/images/my-custom-image You can also specify a custom image by its image family, which returns the latest version of the image in that family. Replace the image name with family/family-name: global/images/family/my-image-family 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceImage")]
		public string SourceImage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceImageEncryptionKey")]
		public CustomerEncryptionKey SourceImageEncryptionKey { get; set; }
		
		/// <summary>
		/// [Output Only] The ID value of the image used to create this disk. This value identifies the exact image that was used to create this persistent disk. For example, if you created the persistent disk from an image that was later deleted and recreated under the same name, the source image ID would identify the exact version of the image that was used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceImageId")]
		public string SourceImageId { get; set; }
		
		/// <summary>
		/// The source snapshot used to create this disk. You can provide this as a partial or full URL to the resource. For example, the following are valid values: - https://www.googleapis.com/compute/v1/projects/project /global/snapshots/snapshot - projects/project/global/snapshots/snapshot - global/snapshots/snapshot 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceSnapshot")]
		public string SourceSnapshot { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceSnapshotEncryptionKey")]
		public CustomerEncryptionKey SourceSnapshotEncryptionKey { get; set; }
		
		/// <summary>
		/// [Output Only] The unique ID of the snapshot used to create this disk. This value identifies the exact snapshot that was used to create this persistent disk. For example, if you created the persistent disk from a snapshot that was later deleted and recreated under the same name, the source snapshot ID would identify the exact version of the snapshot that was used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceSnapshotId")]
		public string SourceSnapshotId { get; set; }
		
		/// <summary>
		/// The full Google Cloud Storage URI where the disk image is stored. This file must be a gzip-compressed tarball whose name ends in .tar.gz or virtual machine disk whose name ends in vmdk. Valid URIs may start with gs:// or https://storage.googleapis.com/. This flag is not optimized for creating multiple disks from a source storage object. To create many disks from a source storage object, use gcloud compute images import instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceStorageObject")]
		public string SourceStorageObject { get; set; }
		
		/// <summary>
		/// [Output Only] The status of disk creation. - CREATING: Disk is provisioning. - RESTORING: Source data is being copied into the disk. - FAILED: Disk creation failed. - READY: Disk is ready for use. - DELETING: Disk is deleting. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<DiskStatus> Status { get; set; }
		
		/// <summary>
		/// URL of the disk type resource describing which disk type to use to create the disk. Provide this when creating the disk. For example: projects/project /zones/zone/diskTypes/pd-ssd . See Persistent disk types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// [Output Only] Links to the users of the disk (attached instances) in form: projects/project/zones/zone/instances/instance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="users")]
		public string[] Users { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the zone where the disk resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskAsyncReplication
	{
		
		/// <summary>
		/// [Output Only] URL of the DiskConsistencyGroupPolicy if replication was started on the disk as a member of a group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consistencyGroupPolicy")]
		public string ConsistencyGroupPolicy { get; set; }
		
		/// <summary>
		/// [Output Only] ID of the DiskConsistencyGroupPolicy if replication was started on the disk as a member of a group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consistencyGroupPolicyId")]
		public string ConsistencyGroupPolicyId { get; set; }
		
		/// <summary>
		/// The other disk asynchronously replicated to or from the current disk. You can provide this as a partial or full URL to the resource. For example, the following are valid values: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /disks/disk - projects/project/zones/zone/disks/disk - zones/zone/disks/disk 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disk")]
		public string Disk { get; set; }
		
		/// <summary>
		/// [Output Only] The unique ID of the other disk asynchronously replicated to or from the current disk. This value identifies the exact disk that was used to create this replication. For example, if you started replicating the persistent disk from a disk that was later deleted and recreated under the same name, the disk ID would identify the exact version of the disk that was used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskId")]
		public string DiskId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskAsyncReplicationList
	{
		
		[System.Runtime.Serialization.DataMember(Name="asyncReplicationDisk")]
		public DiskAsyncReplication AsyncReplicationDisk { get; set; }
	}
	
	/// <summary>
	/// Additional disk params.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskParams
	{
		
		/// <summary>
		/// Resource manager tags to be bound to the disk. Tag keys and values have the same definition as resource manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and values are in the format `tagValues/456`. The field is ignored (both PUT & PATCH) when empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceManagerTags")]
		public System.Collections.Generic.Dictionary<string, string> ResourceManagerTags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskResourceStatus
	{
		
		[System.Runtime.Serialization.DataMember(Name="asyncPrimaryDisk")]
		public DiskResourceStatusAsyncReplicationStatus AsyncPrimaryDisk { get; set; }
		
		/// <summary>
		/// Key: disk, value: AsyncReplicationStatus message
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asyncSecondaryDisks")]
		public System.Collections.Generic.Dictionary<string, DiskResourceStatusAsyncReplicationStatus> AsyncSecondaryDisks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskResourceStatusAsyncReplicationStatus
	{
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<DiskResourceStatusAsyncReplicationStatusState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DiskResourceStatusAsyncReplicationStatusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DiskStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTORING = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of DisksScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, DisksScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#diskAggregatedList for aggregated lists of persistent disks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#diskAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#diskAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public DiskAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisksScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of disks contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public Disk[] Disks { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning which replaces the list of disks when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public DisksScopedListWarning Warning { get; set; }
	}
	
	public class DisksScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public DisksScopedListWarningData[] DisksScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class DisksScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class DiskAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public DiskAggregatedListWarningData[] DiskAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class DiskAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A specification of the desired way to instantiate a disk in the instance template when its created from a source instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskInstantiationConfig
	{
		
		/// <summary>
		/// Specifies whether the disk will be auto-deleted when the instance is deleted (but not when the disk is detached from the instance).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoDelete")]
		public System.Nullable<System.Boolean> AutoDelete { get; set; }
		
		/// <summary>
		/// The custom source image to be used to restore this disk when instantiating this instance template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customImage")]
		public string CustomImage { get; set; }
		
		/// <summary>
		/// Specifies the device name of the disk to which the configurations apply to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceName")]
		public string DeviceName { get; set; }
		
		/// <summary>
		/// Specifies whether to include the disk and what image to use. Possible values are: - source-image: to use the same image that was used to create the source instance's corresponding disk. Applicable to the boot disk and additional read-write disks. - source-image-family: to use the same image family that was used to create the source instance's corresponding disk. Applicable to the boot disk and additional read-write disks. - custom-image: to use a user-provided image url for disk creation. Applicable to the boot disk and additional read-write disks. - attach-read-only: to attach a read-only disk. Applicable to read-only disks. - do-not-include: to exclude a disk from the template. Applicable to additional read-write disks, local SSDs, and read-only disks. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instantiateFrom")]
		public System.Nullable<DiskInstantiationConfigInstantiateFrom> InstantiateFrom { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DiskInstantiationConfigInstantiateFrom
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ATTACH_READ_ONLY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BLANK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_IMAGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DO_NOT_INCLUDE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOURCE_IMAGE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOURCE_IMAGE_FAMILY = 6,
	}
	
	/// <summary>
	/// A list of Disk resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Disk resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Disk[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#diskList for lists of disks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#diskList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#diskList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public DiskListWarning Warning { get; set; }
	}
	
	public class DiskListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public DiskListWarningData[] DiskListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class DiskListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskMoveRequest
	{
		
		/// <summary>
		/// The URL of the destination zone to move the disk. This can be a full or partial URL. For example, the following are all valid URLs to a zone: - https://www.googleapis.com/compute/v1/projects/project/zones/zone - projects/project/zones/zone - zones/zone 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationZone")]
		public string DestinationZone { get; set; }
		
		/// <summary>
		/// The URL of the target disk to move. This can be a full or partial URL. For example, the following are all valid URLs to a disk: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /disks/disk - projects/project/zones/zone/disks/disk - zones/zone/disks/disk 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetDisk")]
		public string TargetDisk { get; set; }
	}
	
	/// <summary>
	/// Represents a Disk Type resource. Google Compute Engine has two Disk Type resources: * [Regional](/compute/docs/reference/rest/v1/regionDiskTypes) * [Zonal](/compute/docs/reference/rest/v1/diskTypes) You can choose from a variety of disk types based on your needs. For more information, read Storage options. The diskTypes resource represents disk types for a zonal persistent disk. For more information, read Zonal persistent disks. The regionDiskTypes resource represents disk types for a regional persistent disk. For more information, read Regional persistent disks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskType
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined default disk size in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultDiskSizeGb")]
		public string DefaultDiskSizeGb { get; set; }
		
		/// <summary>
		/// Deprecation status for a public resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public DeprecationStatus Deprecated { get; set; }
		
		/// <summary>
		/// [Output Only] An optional description of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#diskType for disk types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#diskType")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#diskType";
		
		/// <summary>
		/// [Output Only] Name of the resource.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the disk type resides. Only applicable for regional resources. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] An optional textual description of the valid disk size, such as "10GB-10TB".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validDiskSize")]
		public string ValidDiskSize { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the zone where the disk type resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskTypeAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of DiskTypesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, DiskTypesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#diskTypeAggregatedList.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#diskTypeAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#diskTypeAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public DiskTypeAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskTypesScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of disk types contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskTypes")]
		public DiskType[] DiskTypes { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning which replaces the list of disk types when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public DiskTypesScopedListWarning Warning { get; set; }
	}
	
	public class DiskTypesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public DiskTypesScopedListWarningData[] DiskTypesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class DiskTypesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class DiskTypeAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public DiskTypeAggregatedListWarningData[] DiskTypeAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class DiskTypeAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of disk types.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DiskTypeList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of DiskType resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public DiskType[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#diskTypeList for disk types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#diskTypeList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#diskTypeList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public DiskTypeListWarning Warning { get; set; }
	}
	
	public class DiskTypeListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public DiskTypeListWarningData[] DiskTypeListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class DiskTypeListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisksAddResourcePoliciesRequest
	{
		
		/// <summary>
		/// Full or relative path to the resource policy to be added to this disk. You can only specify one resource policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public string[] ResourcePolicies { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisksRemoveResourcePoliciesRequest
	{
		
		/// <summary>
		/// Resource policies to be removed from this disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public string[] ResourcePolicies { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisksResizeRequest
	{
		
		/// <summary>
		/// The new size of the persistent disk, which is specified in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public string SizeGb { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisksStartAsyncReplicationRequest
	{
		
		/// <summary>
		/// The secondary disk to start asynchronous replication to. You can provide this as a partial or full URL to the resource. For example, the following are valid values: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /disks/disk - https://www.googleapis.com/compute/v1/projects/project/regions/region /disks/disk - projects/project/zones/zone/disks/disk - projects/project/regions/region/disks/disk - zones/zone/disks/disk - regions/region/disks/disk 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asyncSecondaryDisk")]
		public string AsyncSecondaryDisk { get; set; }
	}
	
	/// <summary>
	/// A transient resource used in compute.disks.stopGroupAsyncReplication and compute.regionDisks.stopGroupAsyncReplication. It is only used to process requests and is not persisted.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisksStopGroupAsyncReplicationResource
	{
		
		/// <summary>
		/// The URL of the DiskConsistencyGroupPolicy for the group of disks to stop. This may be a full or partial URL, such as: - https://www.googleapis.com/compute/v1/projects/project/regions/region /resourcePolicies/resourcePolicy - projects/project/regions/region/resourcePolicies/resourcePolicy - regions/region/resourcePolicies/resourcePolicy 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicy")]
		public string ResourcePolicy { get; set; }
	}
	
	/// <summary>
	/// A set of Display Device options
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DisplayDevice
	{
		
		/// <summary>
		/// Defines whether the instance has Display enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableDisplay")]
		public System.Nullable<System.Boolean> EnableDisplay { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DistributionPolicy
	{
		
		/// <summary>
		/// The distribution shape to which the group converges either proactively or on resize events (depending on the value set in updatePolicy.instanceRedistributionType).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetShape")]
		public System.Nullable<DistributionPolicyTargetShape> TargetShape { get; set; }
		
		/// <summary>
		/// Zones where the regional managed instance group will create and manage its instances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public DistributionPolicyZoneConfiguration[] Zones { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum DistributionPolicyTargetShape
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANY_SINGLE_ZONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BALANCED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EVEN = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DistributionPolicyZoneConfiguration
	{
		
		/// <summary>
		/// The URL of the zone. The zone must exist in the region where the managed instance group is located.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// Describes the cause of the error with structured details. Example of an error when contacting the "pubsub.googleapis.com" API when it is not enabled: { "reason": "API_DISABLED" "domain": "googleapis.com" "metadata": { "resource": "projects/123", "service": "pubsub.googleapis.com" } } This response indicates that the pubsub.googleapis.com API is not enabled. Example of an error that is returned when attempting to create a Spanner instance in a region that is out of stock: { "reason": "STOCKOUT" "domain": "spanner.googleapis.com", "metadata": { "availableRegions": "us-central1,us-east2" } }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ErrorInfo
	{
		
		/// <summary>
		/// The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com". If the error is generated by some common infrastructure, the error domain must be a globally unique value that identifies the infrastructure. For Google API infrastructure, the error domain is "googleapis.com".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// Additional structured details about this error. Keys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {"instanceLimit": "100/request"}, should be returned as, {"instanceLimitPerRequest": "100"}, if the client exceeds the number of instances that can be created in a single (batch) request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadatas")]
		public System.Collections.Generic.Dictionary<string, string> Metadatas { get; set; }
		
		/// <summary>
		/// The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors. This should be at most 63 characters and match a regular expression of `A-Z+[A-Z0-9]`, which represents UPPER_SNAKE_CASE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExchangedPeeringRoute
	{
		
		/// <summary>
		/// The destination range of the route.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destRange")]
		public string DestRange { get; set; }
		
		/// <summary>
		/// True if the peering route has been imported from a peer. The actual import happens if the field networkPeering.importCustomRoutes is true for this network, and networkPeering.exportCustomRoutes is true for the peer network, and the import does not result in a route conflict.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imported")]
		public System.Nullable<System.Boolean> Imported { get; set; }
		
		/// <summary>
		/// The region of peering route next hop, only applies to dynamic routes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextHopRegion")]
		public string NextHopRegion { get; set; }
		
		/// <summary>
		/// The priority of the peering route.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.UInt32> Priority { get; set; }
		
		/// <summary>
		/// The type of the peering route.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ExchangedPeeringRouteType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ExchangedPeeringRouteType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DYNAMIC_PEERING_ROUTE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATIC_PEERING_ROUTE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUBNET_PEERING_ROUTE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExchangedPeeringRoutesList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of ExchangedPeeringRoute resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ExchangedPeeringRoute[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#exchangedPeeringRoutesList for exchanged peering routes lists.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#exchangedPeeringRoutesList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#exchangedPeeringRoutesList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ExchangedPeeringRoutesListWarning Warning { get; set; }
	}
	
	public class ExchangedPeeringRoutesListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ExchangedPeeringRoutesListWarningData[] ExchangedPeeringRoutesListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ExchangedPeeringRoutesListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents an external VPN gateway. External VPN gateway is the on-premises VPN gateway(s) or another cloud provider's VPN gateway that connects to your Google Cloud VPN gateway. To create a highly available VPN from Google Cloud Platform to your VPN gateway or another cloud provider's VPN gateway, you must create a external VPN gateway resource with information about the other gateway. For more information about using external VPN gateways, see Creating an HA VPN gateway and tunnel pair to a peer VPN.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExternalVpnGateway
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of interfaces for this external VPN gateway. If your peer-side gateway is an on-premises gateway and non-AWS cloud providers' gateway, at most two interfaces can be provided for an external VPN gateway. If your peer side is an AWS virtual private gateway, four interfaces should be provided for an external VPN gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public ExternalVpnGatewayInterface[] Interfaces { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#externalVpnGateway for externalVpnGateways.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#externalVpnGateway")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#externalVpnGateway";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this ExternalVpnGateway, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an ExternalVpnGateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels for this resource. These can only be added or modified by the setLabels method. Each label key/value pair must comply with RFC1035. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Indicates the user-supplied redundancy type of this external VPN gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redundancyType")]
		public System.Nullable<ExternalVpnGatewayRedundancyType> RedundancyType { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
	}
	
	/// <summary>
	/// The interface for the external VPN gateway.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExternalVpnGatewayInterface
	{
		
		/// <summary>
		/// The numeric ID of this interface. The allowed input values for this id for different redundancy types of external VPN gateway: - SINGLE_IP_INTERNALLY_REDUNDANT - 0 - TWO_IPS_REDUNDANCY - 0, 1 - FOUR_IPS_REDUNDANCY - 0, 1, 2, 3 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.UInt32> Id { get; set; }
		
		/// <summary>
		/// IP address of the interface in the external VPN gateway. Only IPv4 is supported. This IP address can be either from your on-premise gateway or another Cloud provider's VPN gateway, it cannot be an IP address from Google Compute Engine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ExternalVpnGatewayRedundancyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOUR_IPS_REDUNDANCY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SINGLE_IP_INTERNALLY_REDUNDANT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TWO_IPS_REDUNDANCY = 2,
	}
	
	/// <summary>
	/// Response to the list request, and contains a list of externalVpnGateways.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExternalVpnGatewayList
	{
		
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of ExternalVpnGateway resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ExternalVpnGateway[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#externalVpnGatewayList for lists of externalVpnGateways.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#externalVpnGatewayList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#externalVpnGatewayList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ExternalVpnGatewayListWarning Warning { get; set; }
	}
	
	public class ExternalVpnGatewayListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ExternalVpnGatewayListWarningData[] ExternalVpnGatewayListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ExternalVpnGatewayListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Firewall Rule resource. Firewall rules allow or deny ingress traffic to, and egress traffic from your instances. For more information, read Firewall rules.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Firewall
	{
		
		/// <summary>
		/// The list of ALLOW rules specified by this firewall. Each rule specifies a protocol and port-range tuple that describes a permitted connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowed")]
		public FirewallAllowed[] FirewallAllowed { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// The list of DENY rules specified by this firewall. Each rule specifies a protocol and port-range tuple that describes a denied connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="denied")]
		public FirewallDenied[] FirewallDenied { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this field when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// If destination ranges are specified, the firewall rule applies only to traffic that has destination IP address in these ranges. These ranges must be expressed in CIDR format. Both IPv4 and IPv6 are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationRanges")]
		public string[] DestinationRanges { get; set; }
		
		/// <summary>
		/// Direction of traffic to which this firewall applies, either `INGRESS` or `EGRESS`. The default is `INGRESS`. For `EGRESS` traffic, you cannot specify the sourceTags fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public System.Nullable<FirewallDirection> Direction { get; set; }
		
		/// <summary>
		/// Denotes whether the firewall rule is disabled. When set to true, the firewall rule is not enforced and the network behaves as if it did not exist. If this is unspecified, the firewall rule will be enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#firewall for firewall rules.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#firewall")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#firewall";
		
		/// <summary>
		/// The available logging options for a firewall rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public FirewallLogConfig LogConfig { get; set; }
		
		/// <summary>
		/// Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all following characters (except for the last character) must be a dash, lowercase letter, or digit. The last character must be a lowercase letter or digit.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// URL of the network resource for this firewall rule. If not specified when creating a firewall rule, the default network is used: global/networks/default If you choose to specify this field, you can specify the network as a full or partial URL. For example, the following are all valid URLs: - https://www.googleapis.com/compute/v1/projects/myproject/global/networks/my-network - projects/myproject/global/networks/my-network - global/networks/default 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// Priority for this rule. This is an integer between `0` and `65535`, both inclusive. The default value is `1000`. Relative priorities determine which rule takes effect if multiple rules apply. Lower values indicate higher priority. For example, a rule with priority `0` has higher precedence than a rule with priority `1`. DENY rules take precedence over ALLOW rules if they have equal priority. Note that VPC networks have implied rules with a priority of `65535`. To avoid conflicts with the implied rules, use a priority number less than `65535`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// If source ranges are specified, the firewall rule applies only to traffic that has a source IP address in these ranges. These ranges must be expressed in CIDR format. One or both of sourceRanges and sourceTags may be set. If both fields are set, the rule applies to traffic that has a source IP address within sourceRanges OR a source IP from a resource with a matching tag listed in the sourceTags field. The connection does not need to match both fields for the rule to apply. Both IPv4 and IPv6 are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceRanges")]
		public string[] SourceRanges { get; set; }
		
		/// <summary>
		/// If source service accounts are specified, the firewall rules apply only to traffic originating from an instance with a service account in this list. Source service accounts cannot be used to control traffic to an instance's external IP address because service accounts are associated with an instance, not an IP address. sourceRanges can be set at the same time as sourceServiceAccounts. If both are set, the firewall applies to traffic that has a source IP address within the sourceRanges OR a source IP that belongs to an instance with service account listed in sourceServiceAccount. The connection does not need to match both fields for the firewall to apply. sourceServiceAccounts cannot be used at the same time as sourceTags or targetTags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceServiceAccounts")]
		public string[] SourceServiceAccounts { get; set; }
		
		/// <summary>
		/// If source tags are specified, the firewall rule applies only to traffic with source IPs that match the primary network interfaces of VM instances that have the tag and are in the same VPC network. Source tags cannot be used to control traffic to an instance's external IP address, it only applies to traffic between instances in the same virtual network. Because tags are associated with instances, not IP addresses. One or both of sourceRanges and sourceTags may be set. If both fields are set, the firewall applies to traffic that has a source IP address within sourceRanges OR a source IP from a resource with a matching tag listed in the sourceTags field. The connection does not need to match both fields for the firewall to apply.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceTags")]
		public string[] SourceTags { get; set; }
		
		/// <summary>
		/// A list of service accounts indicating sets of instances located in the network that may make network connections as specified in allowed[]. targetServiceAccounts cannot be used at the same time as targetTags or sourceTags. If neither targetServiceAccounts nor targetTags are specified, the firewall rule applies to all instances on the specified network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetServiceAccounts")]
		public string[] TargetServiceAccounts { get; set; }
		
		/// <summary>
		/// A list of tags that controls which instances the firewall rule applies to. If targetTags are specified, then the firewall rule applies only to instances in the VPC network that have one of those tags. If no targetTags are specified, the firewall rule applies to all instances on the specified network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetTags")]
		public string[] TargetTags { get; set; }
	}
	
	public class FirewallAllowed
	{
		
		/// <summary>
		/// The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp) or the IP protocol number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IPProtocol { get; set; }
		
		/// <summary>
		/// An optional list of ports to which this rule applies. This field is only applicable for the UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port. Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public string[] Ports { get; set; }
	}
	
	public class FirewallDenied
	{
		
		/// <summary>
		/// The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp) or the IP protocol number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IPProtocol { get; set; }
		
		/// <summary>
		/// An optional list of ports to which this rule applies. This field is only applicable for the UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port. Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public string[] Ports { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FirewallDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EGRESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INGRESS = 1,
	}
	
	/// <summary>
	/// The available logging options for a firewall rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FirewallLogConfig
	{
		
		/// <summary>
		/// This field denotes whether to enable logging for a particular firewall rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable")]
		public System.Nullable<System.Boolean> Enable { get; set; }
		
		/// <summary>
		/// This field can only be specified for a particular firewall rule if logging is enabled for that rule. This field denotes whether to include or exclude metadata for firewall logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Nullable<FirewallLogConfigMetadata> Metadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FirewallLogConfigMetadata
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXCLUDE_ALL_METADATA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCLUDE_ALL_METADATA = 1,
	}
	
	/// <summary>
	/// Contains a list of firewalls.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FirewallList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Firewall resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Firewall[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#firewallList for lists of firewalls.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#firewallList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#firewallList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public FirewallListWarning Warning { get; set; }
	}
	
	public class FirewallListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public FirewallListWarningData[] FirewallListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class FirewallListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FirewallPoliciesListAssociationsResponse
	{
		
		/// <summary>
		/// A list of associations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="associations")]
		public FirewallPolicyAssociation[] Associations { get; set; }
		
		/// <summary>
		/// [Output Only] Type of firewallPolicy associations. Always compute#FirewallPoliciesListAssociations for lists of firewallPolicy associations.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#firewallPoliciesListAssociationsResponse")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#firewallPoliciesListAssociationsResponse";
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FirewallPolicyAssociation
	{
		
		/// <summary>
		/// The target that the firewall policy is attached to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attachmentTarget")]
		public string AttachmentTarget { get; set; }
		
		/// <summary>
		/// [Output Only] Deprecated, please use short name instead. The display name of the firewall policy of the association.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// [Output Only] The firewall policy ID of the association.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallPolicyId")]
		public string FirewallPolicyId { get; set; }
		
		/// <summary>
		/// The name for an association.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] The short name of the firewall policy of the association.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
	}
	
	/// <summary>
	/// Represents a Firewall Policy resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FirewallPolicy
	{
		
		/// <summary>
		/// A list of associations that belong to this firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="associations")]
		public FirewallPolicyAssociation[] Associations { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Deprecated, please use short name instead. User-provided name of the Organization firewall policy. The name should be unique in the organization in which the firewall policy is created. This field is not applicable to network firewall policies. This name must be set on creation and cannot be changed. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// Specifies a fingerprint for this resource, which is essentially a hash of the metadata's contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update metadata. You must always provide an up-to-date fingerprint hash in order to update or change metadata, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make get() request to the firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output only] Type of the resource. Always compute#firewallPolicyfor firewall policies
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#firewallPolicy")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#firewallPolicy";
		
		/// <summary>
		/// Name of the resource. For Organization Firewall Policies it's a [Output Only] numeric ID allocated by Google Cloud which uniquely identifies the Organization Firewall Policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] The parent of the firewall policy. This field is not applicable to network firewall policies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public string Parent { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional firewall policy resides. This field is not applicable to global firewall policies. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Total count of all firewall policy rule tuples. A firewall policy can not exceed a set number of tuples.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleTupleCount")]
		public System.Nullable<System.Int32> RuleTupleCount { get; set; }
		
		/// <summary>
		/// A list of rules that belong to this policy. There must always be a default rule (rule with priority 2147483647 and match "*"). If no rules are provided when creating a firewall policy, a default rule with action "allow" will be added.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public FirewallPolicyRule[] Rules { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource with the resource id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLinkWithId")]
		public string SelfLinkWithId { get; set; }
		
		/// <summary>
		/// User-provided name of the Organization firewall policy. The name should be unique in the organization in which the firewall policy is created. This field is not applicable to network firewall policies. This name must be set on creation and cannot be changed. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string ShortName { get; set; }
	}
	
	/// <summary>
	/// Represents a rule that describes one or more match conditions along with the action to be taken when traffic matches this condition (allow or deny).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FirewallPolicyRule
	{
		
		/// <summary>
		/// The Action to perform when the client connection triggers the rule. Valid actions are "allow", "deny" and "goto_next".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string Action { get; set; }
		
		/// <summary>
		/// An optional description for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The direction in which this rule applies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public FirewallDirection Direction { get; set; }
		
		/// <summary>
		/// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disabled")]
		public System.Nullable<System.Boolean> Disabled { get; set; }
		
		/// <summary>
		/// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on "goto_next" rules.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableLogging")]
		public System.Nullable<System.Boolean> EnableLogging { get; set; }
		
		/// <summary>
		/// [Output only] Type of the resource. Always compute#firewallPolicyRule for firewall policy rules
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#firewallPolicyRule")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#firewallPolicyRule";
		
		/// <summary>
		/// Represents a match condition that incoming traffic is evaluated against. Exactly one field must be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="match")]
		public FirewallPolicyRuleMatcher Match { get; set; }
		
		/// <summary>
		/// An integer indicating the priority of a rule in the list. The priority must be a positive value between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest prority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		/// <summary>
		/// An optional name for the rule. This field is not a unique identifier and can be updated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleName")]
		public string RuleName { get; set; }
		
		/// <summary>
		/// [Output Only] Calculation of the complexity of a single firewall policy rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleTupleCount")]
		public System.Nullable<System.Int32> RuleTupleCount { get; set; }
		
		/// <summary>
		/// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get this rule. If this field is left blank, all VMs within the organization will receive the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetResources")]
		public string[] TargetResources { get; set; }
		
		/// <summary>
		/// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the target_secure_tag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule applies to all instances on the specified network. Maximum number of target label tags allowed is 256.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetSecureTags")]
		public FirewallPolicyRuleSecureTag[] TargetSecureTags { get; set; }
		
		/// <summary>
		/// A list of service accounts indicating the sets of instances that are applied with this rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetServiceAccounts")]
		public string[] TargetServiceAccounts { get; set; }
	}
	
	/// <summary>
	/// Represents a match condition that incoming traffic is evaluated against. Exactly one field must be specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FirewallPolicyRuleMatcher
	{
		
		/// <summary>
		/// Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destAddressGroups")]
		public string[] DestAddressGroups { get; set; }
		
		/// <summary>
		/// Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destFqdns")]
		public string[] DestFqdns { get; set; }
		
		/// <summary>
		/// CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destIpRanges")]
		public string[] DestIpRanges { get; set; }
		
		/// <summary>
		/// Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destRegionCodes")]
		public string[] DestRegionCodes { get; set; }
		
		/// <summary>
		/// Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destThreatIntelligences")]
		public string[] DestThreatIntelligences { get; set; }
		
		/// <summary>
		/// Pairs of IP protocols and ports that the rule should match.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="layer4Configs")]
		public FirewallPolicyRuleMatcherLayer4Config[] Layer4Configs { get; set; }
		
		/// <summary>
		/// Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcAddressGroups")]
		public string[] SrcAddressGroups { get; set; }
		
		/// <summary>
		/// Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcFqdns")]
		public string[] SrcFqdns { get; set; }
		
		/// <summary>
		/// CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcIpRanges")]
		public string[] SrcIpRanges { get; set; }
		
		/// <summary>
		/// Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcRegionCodes")]
		public string[] SrcRegionCodes { get; set; }
		
		/// <summary>
		/// List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcSecureTags")]
		public FirewallPolicyRuleSecureTag[] SrcSecureTags { get; set; }
		
		/// <summary>
		/// Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcThreatIntelligences")]
		public string[] SrcThreatIntelligences { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FirewallPolicyRuleMatcherLayer4Config
	{
		
		/// <summary>
		/// The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipProtocol")]
		public string IpProtocol { get; set; }
		
		/// <summary>
		/// An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port. Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public string[] Ports { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FirewallPolicyRuleSecureTag
	{
		
		/// <summary>
		/// Name of the secure tag, created with TagManager's TagValue API.
		/// Pattern: tagValues/[0-9]+
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"tagValues/[0-9]+")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] State of the secure tag, either `EFFECTIVE` or `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted or its network is deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<FirewallPolicyRuleSecureTagState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FirewallPolicyRuleSecureTagState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EFFECTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INEFFECTIVE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FirewallPolicyList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of FirewallPolicy resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public FirewallPolicy[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#firewallPolicyList for listsof FirewallPolicies
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#firewallPolicyList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#firewallPolicyList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public FirewallPolicyListWarning Warning { get; set; }
	}
	
	public class FirewallPolicyListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public FirewallPolicyListWarningData[] FirewallPolicyListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class FirewallPolicyListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Forwarding Rule resource. Forwarding rule resources in Google Cloud can be either regional or global in scope: * [Global](https://cloud.google.com/compute/docs/reference/rest/v1/globalForwardingRules) * [Regional](https://cloud.google.com/compute/docs/reference/rest/v1/forwardingRules) A forwarding rule and its corresponding IP address represent the frontend configuration of a Google Cloud load balancer. Forwarding rules can also reference target instances and Cloud VPN Classic gateways (targetVpnGateway). For more information, read Forwarding rule concepts and Using protocol forwarding.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForwardingRule
	{
		
		/// <summary>
		/// IP address for which this forwarding rule accepts traffic. When a client sends traffic to this IP address, the forwarding rule directs the traffic to the referenced target or backendService. While creating a forwarding rule, specifying an IPAddress is required under the following circumstances: - When the target is set to targetGrpcProxy and validateForProxyless is set to true, the IPAddress should be set to 0.0.0.0. - When the target is a Private Service Connect Google APIs bundle, you must specify an IPAddress. Otherwise, you can optionally specify an IP address that references an existing static (reserved) IP address resource. When omitted, Google Cloud assigns an ephemeral IP address. Use one of the following formats to specify an IP address while creating a forwarding rule: * IP address number, as in `100.1.2.3` * IPv6 address range, as in `2600:1234::/96` * Full resource URL, as in https://www.googleapis.com/compute/v1/projects/ project_id/regions/region/addresses/address-name * Partial URL or by name, as in: - projects/project_id/regions/region/addresses/address-name - regions/region/addresses/address-name - global/addresses/address-name - address-name The forwarding rule's target or backendService, and in most cases, also the loadBalancingScheme, determine the type of IP address that you can use. For detailed information, see [IP address specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications). When reading an IPAddress, the API always returns the IP address number.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string IPAddress { get; set; }
		
		/// <summary>
		/// The IP protocol to which this rule applies. For protocol forwarding, valid options are TCP, UDP, ESP, AH, SCTP, ICMP and L3_DEFAULT. The valid IP protocols are different for different load balancing products as described in [Load balancing features](https://cloud.google.com/load-balancing/docs/features#protocols_from_the_load_balancer_to_the_backends).
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<ForwardingRuleIPProtocol> IPProtocol { get; set; }
		
		/// <summary>
		/// The ports, portRange, and allPorts fields are mutually exclusive. Only packets addressed to ports in the specified range will be forwarded to the backends configured with this forwarding rule. The allPorts field has the following limitations: - It requires that the forwarding rule IPProtocol be TCP, UDP, SCTP, or L3_DEFAULT. - It's applicable only to the following products: internal passthrough Network Load Balancers, backend service-based external passthrough Network Load Balancers, and internal and external protocol forwarding. - Set this field to true to allow packets addressed to any port or packets lacking destination port information (for example, UDP fragments after the first fragment) to be forwarded to the backends configured with this forwarding rule. The L3_DEFAULT protocol requires allPorts be set to true. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allPorts")]
		public System.Nullable<System.Boolean> AllPorts { get; set; }
		
		/// <summary>
		/// This field is used along with the backend_service field for internal load balancing or with the target field for internal TargetInstance. If set to true, clients can access the internal passthrough Network Load Balancers, the regional internal Application Load Balancer, and the regional internal proxy Network Load Balancer from all regions. If false, only allows access from the local region the load balancer is located at. Note that for INTERNAL_MANAGED forwarding rules, this field cannot be changed after the forwarding rule is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowGlobalAccess")]
		public System.Nullable<System.Boolean> AllowGlobalAccess { get; set; }
		
		/// <summary>
		/// This is used in PSC consumer ForwardingRule to control whether the PSC endpoint can be accessed from another region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowPscGlobalAccess")]
		public System.Nullable<System.Boolean> AllowPscGlobalAccess { get; set; }
		
		/// <summary>
		/// Identifies the backend service to which the forwarding rule sends traffic. Required for internal and external passthrough Network Load Balancers; must be omitted for all other load balancer types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backendService")]
		public string BackendService { get; set; }
		
		/// <summary>
		/// [Output Only] The URL for the corresponding base forwarding rule. By base forwarding rule, we mean the forwarding rule that has the same IP address, protocol, and port settings with the current forwarding rule, but without sourceIPRanges specified. Always empty if the current forwarding rule does not have sourceIPRanges specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseForwardingRule")]
		public string BaseForwardingRule { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ForwardingRule. Include the fingerprint in patch request to ensure that you do not overwrite changes that were applied from another concurrent request. To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The IP Version that will be used by this forwarding rule. Valid options are IPV4 or IPV6.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipVersion")]
		public AddressIpVersion IpVersion { get; set; }
		
		/// <summary>
		/// Indicates whether or not this load balancer can be used as a collector for packet mirroring. To prevent mirroring loops, instances behind this load balancer will not have their traffic mirrored even if a PacketMirroring rule applies to them. This can only be set to true for load balancers that have their loadBalancingScheme set to INTERNAL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isMirroringCollector")]
		public System.Nullable<System.Boolean> IsMirroringCollector { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#forwardingRule for forwarding rule resources.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#forwardingRule")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#forwardingRule";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this resource, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a ForwardingRule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels for this resource. These can only be added or modified by the setLabels method. Each label key/value pair must comply with RFC1035. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Specifies the forwarding rule type. For more information about forwarding rules, refer to Forwarding rule concepts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancingScheme")]
		public System.Nullable<ForwardingRuleLoadBalancingScheme> LoadBalancingScheme { get; set; }
		
		/// <summary>
		/// Opaque filter criteria used by load balancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to load balancer, xDS clients present node metadata. When there is a match, the relevant configuration is made available to those proxies. Otherwise, all the resources (e.g. TargetHttpProxy, UrlMap) referenced by the ForwardingRule are not visible to those proxies. For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadataFilters are specified, all of them need to be satisfied in order to be considered a match. metadataFilters specified here will be applifed before those specified in the UrlMap that this ForwardingRule references. metadataFilters only applies to Loadbalancers that have their loadBalancingScheme set to INTERNAL_SELF_MANAGED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadataFilters")]
		public MetadataFilter[] MetadataFilters { get; set; }
		
		/// <summary>
		/// Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash. For Private Service Connect forwarding rules that forward traffic to Google APIs, the forwarding rule name must be a 1-20 characters string with lowercase letters and numbers and must start with a letter.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// This field is not used for global external load balancing. For internal passthrough Network Load Balancers, this field identifies the network that the load balanced IP should belong to for this forwarding rule. If the subnetwork is specified, the network of the subnetwork will be used. If neither subnetwork nor this field is specified, the default network will be used. For Private Service Connect forwarding rules that forward traffic to Google APIs, a network must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// This signifies the networking tier used for configuring this load balancer and can only take the following values: PREMIUM, STANDARD. For regional ForwardingRule, the valid values are PREMIUM and STANDARD. For GlobalForwardingRule, the valid value is PREMIUM. If this field is not specified, it is assumed to be PREMIUM. If IPAddress is specified, this value must be equal to the networkTier of the Address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTier")]
		public AccessConfigNetworkTier NetworkTier { get; set; }
		
		/// <summary>
		/// This is used in PSC consumer ForwardingRule to control whether it should try to auto-generate a DNS zone or not. Non-PSC forwarding rules do not use this field. Once set, this field is not mutable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="noAutomateDnsZone")]
		public System.Nullable<System.Boolean> NoAutomateDnsZone { get; set; }
		
		/// <summary>
		/// The ports, portRange, and allPorts fields are mutually exclusive. Only packets addressed to ports in the specified range will be forwarded to the backends configured with this forwarding rule. The portRange field has the following limitations: - It requires that the forwarding rule IPProtocol be TCP, UDP, or SCTP, and - It's applicable only to the following products: external passthrough Network Load Balancers, internal and external proxy Network Load Balancers, internal and external Application Load Balancers, external protocol forwarding, and Classic VPN. - Some products have restrictions on what ports can be used. See port specifications for details. For external forwarding rules, two or more forwarding rules cannot use the same [IPAddress, IPProtocol] pair, and cannot have overlapping portRanges. For internal forwarding rules within the same VPC network, two or more forwarding rules cannot use the same [IPAddress, IPProtocol] pair, and cannot have overlapping portRanges. @pattern: \\d+(?:-\\d+)?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portRange")]
		public string PortRange { get; set; }
		
		/// <summary>
		/// The ports, portRange, and allPorts fields are mutually exclusive. Only packets addressed to ports in the specified range will be forwarded to the backends configured with this forwarding rule. The ports field has the following limitations: - It requires that the forwarding rule IPProtocol be TCP, UDP, or SCTP, and - It's applicable only to the following products: internal passthrough Network Load Balancers, backend service-based external passthrough Network Load Balancers, and internal protocol forwarding. - You can specify a list of up to five ports by number, separated by commas. The ports can be contiguous or discontiguous. For external forwarding rules, two or more forwarding rules cannot use the same [IPAddress, IPProtocol] pair if they share at least one port number. For internal forwarding rules within the same VPC network, two or more forwarding rules cannot use the same [IPAddress, IPProtocol] pair if they share at least one port number. @pattern: \\d+(?:-\\d+)?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ports")]
		public string[] Ports { get; set; }
		
		/// <summary>
		/// [Output Only] The PSC connection id of the PSC forwarding rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pscConnectionId")]
		public string PscConnectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pscConnectionStatus")]
		public System.Nullable<ForwardingRulePscConnectionStatus> PscConnectionStatus { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional forwarding rule resides. This field is not applicable to global forwarding rules. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Service Directory resources to register this forwarding rule with. Currently, only supports a single Service Directory resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceDirectoryRegistrations")]
		public ForwardingRuleServiceDirectoryRegistration[] ServiceDirectoryRegistrations { get; set; }
		
		/// <summary>
		/// An optional prefix to the service name for this forwarding rule. If specified, the prefix is the first label of the fully qualified service name. The label must be 1-63 characters long, and comply with RFC1035. Specifically, the label must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash. This field is only used for internal load balancing.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceLabel")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string ServiceLabel { get; set; }
		
		/// <summary>
		/// [Output Only] The internal fully qualified service name for this forwarding rule. This field is only used for internal load balancing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceName")]
		public string ServiceName { get; set; }
		
		/// <summary>
		/// If not empty, this forwarding rule will only forward the traffic when the source IP address matches one of the IP addresses or CIDR ranges set here. Note that a forwarding rule can only have up to 64 source IP ranges, and this field can only be used with a regional forwarding rule whose scheme is EXTERNAL. Each source_ip_range entry should be either an IP address (for example, 1.2.3.4) or a CIDR range (for example, 1.2.3.0/24).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceIpRanges")]
		public string[] SourceIpRanges { get; set; }
		
		/// <summary>
		/// This field identifies the subnetwork that the load balanced IP should belong to for this forwarding rule, used with internal load balancers and external passthrough Network Load Balancers with IPv6. If the network specified is in auto subnet mode, this field is optional. However, a subnetwork must be specified if the network is in custom subnet mode or when creating external forwarding rule with IPv6.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetwork")]
		public string Subnetwork { get; set; }
		
		/// <summary>
		/// The URL of the target resource to receive the matched traffic. For regional forwarding rules, this target must be in the same region as the forwarding rule. For global forwarding rules, this target must be a global load balancing resource. The forwarded traffic must be of a type appropriate to the target object. - For load balancers, see the "Target" column in [Port specifications](https://cloud.google.com/load-balancing/docs/forwarding-rule-concepts#ip_address_specifications). - For Private Service Connect forwarding rules that forward traffic to Google APIs, provide the name of a supported Google API bundle: - vpc-sc - APIs that support VPC Service Controls. - all-apis - All supported Google APIs. - For Private Service Connect forwarding rules that forward traffic to managed services, the target must be a service attachment. The target is not mutable once set as a service attachment. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ForwardingRuleIPProtocol
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ESP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ICMP = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		L3_DEFAULT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCTP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TCP = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UDP = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ForwardingRuleLoadBalancingScheme
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL_MANAGED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL_MANAGED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL_SELF_MANAGED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 5,
	}
	
	/// <summary>
	/// Opaque filter criteria used by load balancers to restrict routing configuration to a limited set of load balancing proxies. Proxies and sidecars involved in load balancing would typically present metadata to the load balancers that need to match criteria specified here. If a match takes place, the relevant configuration is made available to those proxies. For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. An example for using metadataFilters would be: if load balancing involves Envoys, they receive routing configuration when values in metadataFilters match values supplied in of their XDS requests to loadbalancers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MetadataFilter
	{
		
		/// <summary>
		/// The list of label value pairs that must match labels in the provided metadata based on filterMatchCriteria This list must not be empty and can have at the most 64 entries.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filterLabels")]
		public MetadataFilterLabelMatch[] FilterLabels { get; set; }
		
		/// <summary>
		/// Specifies how individual filter label matches within the list of filterLabels and contributes toward the overall metadataFilter match. Supported values are: - MATCH_ANY: at least one of the filterLabels must have a matching label in the provided metadata. - MATCH_ALL: all filterLabels must have matching labels in the provided metadata. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filterMatchCriteria")]
		public System.Nullable<MetadataFilterFilterMatchCriteria> FilterMatchCriteria { get; set; }
	}
	
	/// <summary>
	/// MetadataFilter label name value pairs that are expected to match corresponding labels presented as metadata to the load balancer.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MetadataFilterLabelMatch
	{
		
		/// <summary>
		/// Name of metadata label. The name can have a maximum length of 1024 characters and must be at least 1 character long.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of the label must match the specified value. value can have a maximum length of 1024 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MetadataFilterFilterMatchCriteria
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MATCH_ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MATCH_ANY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_SET = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ForwardingRulePscConnectionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPTED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOSED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEEDS_ATTENTION = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REJECTED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATUS_UNSPECIFIED = 5,
	}
	
	/// <summary>
	/// Describes the auto-registration of the forwarding rule to Service Directory. The region and project of the Service Directory resource generated from this registration will be the same as this forwarding rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForwardingRuleServiceDirectoryRegistration
	{
		
		/// <summary>
		/// Service Directory namespace to register the forwarding rule under.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespace")]
		public string Namespace { get; set; }
		
		/// <summary>
		/// Service Directory service to register the forwarding rule under.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
		
		/// <summary>
		/// [Optional] Service Directory region to register this global forwarding rule under. Default to "us-central1". Only used for PSC for Google APIs. All PSC for Google APIs forwarding rules on the same network should use the same Service Directory region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceDirectoryRegion")]
		public string ServiceDirectoryRegion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForwardingRuleAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of ForwardingRulesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, ForwardingRulesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#forwardingRuleAggregatedList for lists of forwarding rules.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#forwardingRuleAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#forwardingRuleAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ForwardingRuleAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForwardingRulesScopedList
	{
		
		/// <summary>
		/// A list of forwarding rules contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forwardingRules")]
		public ForwardingRule[] ForwardingRules { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of forwarding rules when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ForwardingRulesScopedListWarning Warning { get; set; }
	}
	
	public class ForwardingRulesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ForwardingRulesScopedListWarningData[] ForwardingRulesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ForwardingRulesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class ForwardingRuleAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ForwardingRuleAggregatedListWarningData[] ForwardingRuleAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ForwardingRuleAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of ForwardingRule resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForwardingRuleList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of ForwardingRule resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ForwardingRule[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#forwardingRuleList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#forwardingRuleList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ForwardingRuleListWarning Warning { get; set; }
	}
	
	public class ForwardingRuleListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ForwardingRuleListWarningData[] ForwardingRuleListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ForwardingRuleListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForwardingRuleReference
	{
		
		[System.Runtime.Serialization.DataMember(Name="forwardingRule")]
		public string ForwardingRule { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GRPCHealthCheck
	{
		
		/// <summary>
		/// The gRPC service name for the health check. This field is optional. The value of grpc_service_name has the following meanings by convention: - Empty service_name means the overall status of all services at the backend. - Non-empty service_name means the health of that gRPC service, as defined by the owner of the service. The grpc_service_name can only be ASCII.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grpcServiceName")]
		public string GrpcServiceName { get; set; }
		
		/// <summary>
		/// The TCP port number to which the health check prober sends packets. Valid values are 1 through 65535.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Not supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portName")]
		public string PortName { get; set; }
		
		/// <summary>
		/// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for passthrough load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for passthrough load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portSpecification")]
		public System.Nullable<GRPCHealthCheckPortSpecification> PortSpecification { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum GRPCHealthCheckPortSpecification
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USE_FIXED_PORT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USE_NAMED_PORT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USE_SERVING_PORT = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalAddressesMoveRequest
	{
		
		/// <summary>
		/// An optional destination address description if intended to be different from the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The URL of the destination address to move to. This can be a full or partial URL. For example, the following are all valid URLs to a address: - https://www.googleapis.com/compute/v1/projects/project /global/addresses/address - projects/project/global/addresses/address Note that destination project must be different from the source project. So /global/addresses/address is not valid partial url.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationAddress")]
		public string DestinationAddress { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalNetworkEndpointGroupsAttachEndpointsRequest
	{
		
		/// <summary>
		/// The list of network endpoints to be attached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEndpoints")]
		public NetworkEndpoint[] NetworkEndpoints { get; set; }
	}
	
	/// <summary>
	/// The network endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpoint
	{
		
		/// <summary>
		/// Metadata defined as annotations on the network endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public System.Collections.Generic.Dictionary<string, string> Annotations { get; set; }
		
		/// <summary>
		/// Optional fully qualified domain name of network endpoint. This can only be specified when NetworkEndpointGroup.network_endpoint_type is NON_GCP_FQDN_PORT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fqdn")]
		public string Fqdn { get; set; }
		
		/// <summary>
		/// The name for a specific VM instance that the IP address belongs to. This is required for network endpoints of type GCE_VM_IP_PORT. The instance must be in the same zone of network endpoint group. The name must be 1-63 characters long, and comply with RFC1035.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
		
		/// <summary>
		/// Optional IPv4 address of network endpoint. The IP address must belong to a VM in Compute Engine (either the primary IP or as part of an aliased IP range). If the IP address is not specified, then the primary IP address for the VM instance in the network that the network endpoint group belongs to will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// Optional port number of network endpoint. If not specified, the defaultPort for the network endpoint group will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalNetworkEndpointGroupsDetachEndpointsRequest
	{
		
		/// <summary>
		/// The list of network endpoints to be detached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEndpoints")]
		public NetworkEndpoint[] NetworkEndpoints { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalOrganizationSetPolicyRequest
	{
		
		/// <summary>
		/// Flatten Policy to create a backward compatible wire-format. Deprecated. Use 'policy' to specify bindings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindings")]
		public Binding[] Bindings { get; set; }
		
		/// <summary>
		/// Flatten Policy to create a backward compatible wire-format. Deprecated. Use 'policy' to specify the etag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public Policy Policy { get; set; }
	}
	
	/// <summary>
	/// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Policy
	{
		
		/// <summary>
		/// Specifies cloud audit logging configuration for this policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auditConfigs")]
		public AuditConfig[] AuditConfigs { get; set; }
		
		/// <summary>
		/// Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindings")]
		public Binding[] Bindings { get; set; }
		
		/// <summary>
		/// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public Rule[] Rules { get; set; }
		
		/// <summary>
		/// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public System.Nullable<System.Int32> Version { get; set; }
	}
	
	/// <summary>
	/// This is deprecated and has no effect. Do not use.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Rule
	{
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public System.Nullable<RuleAction> Action { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conditions")]
		public Condition[] Conditions { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ins")]
		public string[] Ins { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logConfigs")]
		public LogConfig[] LogConfigs { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notIns")]
		public string[] NotIns { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public string[] Permissions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RuleAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALLOW = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALLOW_WITH_LOG = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DENY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DENY_WITH_LOG = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOG = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_ACTION = 5,
	}
	
	/// <summary>
	/// This is deprecated and has no effect. Do not use.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogConfig
	{
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudAudit")]
		public LogConfigCloudAuditOptions CloudAudit { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counter")]
		public LogConfigCounterOptions Counter { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataAccess")]
		public LogConfigDataAccessOptions DataAccess { get; set; }
	}
	
	/// <summary>
	/// This is deprecated and has no effect. Do not use.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogConfigCloudAuditOptions
	{
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizationLoggingOptions")]
		public AuthorizationLoggingOptions AuthorizationLoggingOptions { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logName")]
		public System.Nullable<LogConfigCloudAuditOptionsLogName> LogName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LogConfigCloudAuditOptionsLogName
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADMIN_ACTIVITY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DATA_ACCESS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED_LOG_NAME = 2,
	}
	
	/// <summary>
	/// This is deprecated and has no effect. Do not use.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogConfigCounterOptions
	{
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customFields")]
		public LogConfigCounterOptionsCustomField[] CustomFields { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="field")]
		public string Field { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public string Metric { get; set; }
	}
	
	/// <summary>
	/// This is deprecated and has no effect. Do not use.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogConfigCounterOptionsCustomField
	{
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// This is deprecated and has no effect. Do not use.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LogConfigDataAccessOptions
	{
		
		/// <summary>
		/// This is deprecated and has no effect. Do not use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logMode")]
		public System.Nullable<LogConfigDataAccessOptionsLogMode> LogMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LogConfigDataAccessOptionsLogMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOG_FAIL_CLOSED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOG_MODE_UNSPECIFIED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalSetLabelsRequest
	{
		
		/// <summary>
		/// The fingerprint of the previous set of labels for this resource, used to detect conflicts. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash when updating or changing labels, otherwise the request will fail with error 412 conditionNotMet. Make a get() request to the resource to get the latest fingerprint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// A list of labels to apply for this resource. Each label must comply with the requirements for labels. For example, "webserver-frontend": "images". A label value can also be empty (e.g. "my-label": "").
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GlobalSetPolicyRequest
	{
		
		/// <summary>
		/// Flatten Policy to create a backward compatible wire-format. Deprecated. Use 'policy' to specify bindings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindings")]
		public Binding[] Bindings { get; set; }
		
		/// <summary>
		/// Flatten Policy to create a backward compatible wire-format. Deprecated. Use 'policy' to specify the etag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public Policy Policy { get; set; }
	}
	
	/// <summary>
	/// A guest attributes entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GuestAttributes
	{
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#guestAttributes for guest attributes entry.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#guestAttributes")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#guestAttributes";
		
		/// <summary>
		/// The path to be queried. This can be the default namespace ('') or a nested namespace ('\/') or a specified key ('\/\').
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryPath")]
		public string QueryPath { get; set; }
		
		/// <summary>
		/// Array of guest attribute namespace/key/value tuples.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryValue")]
		public GuestAttributesValue QueryValue { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The key to search for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="variableKey")]
		public string VariableKey { get; set; }
		
		/// <summary>
		/// [Output Only] The value found for the requested key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="variableValue")]
		public string VariableValue { get; set; }
	}
	
	/// <summary>
	/// Array of guest attribute namespace/key/value tuples.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GuestAttributesValue
	{
		
		[System.Runtime.Serialization.DataMember(Name="items")]
		public GuestAttributesEntry[] Items { get; set; }
	}
	
	/// <summary>
	/// A guest attributes namespace/key/value entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GuestAttributesEntry
	{
		
		/// <summary>
		/// Key for the guest attribute entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Namespace for the guest attribute entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespace")]
		public string Namespace { get; set; }
		
		/// <summary>
		/// Value for the guest attribute entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HTTP2HealthCheck
	{
		
		/// <summary>
		/// The value of the host header in the HTTP/2 health check request. If left empty (default value), the host header is set to the destination IP address to which health check packets are sent. The destination IP address depends on the type of load balancer. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The TCP port number to which the health check prober sends packets. The default value is 443. Valid values are 1 through 65535.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Not supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portName")]
		public string PortName { get; set; }
		
		/// <summary>
		/// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for passthrough load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for passthrough load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portSpecification")]
		public GRPCHealthCheckPortSpecification PortSpecification { get; set; }
		
		/// <summary>
		/// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyHeader")]
		public System.Nullable<HTTP2HealthCheckProxyHeader> ProxyHeader { get; set; }
		
		/// <summary>
		/// The request path of the HTTP/2 health check request. The default value is /.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestPath")]
		public string RequestPath { get; set; }
		
		/// <summary>
		/// Creates a content-based HTTP/2 health check. In addition to the required HTTP 200 (OK) status code, you can configure the health check to pass only when the backend sends this specific ASCII response string within the first 1024 bytes of the HTTP response body. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HTTP2HealthCheckProxyHeader
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROXY_V1 = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HTTPHealthCheck
	{
		
		/// <summary>
		/// The value of the host header in the HTTP health check request. If left empty (default value), the host header is set to the destination IP address to which health check packets are sent. The destination IP address depends on the type of load balancer. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The TCP port number to which the health check prober sends packets. The default value is 80. Valid values are 1 through 65535.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Not supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portName")]
		public string PortName { get; set; }
		
		/// <summary>
		/// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for passthrough load balancers and backend services for proxy load balancers. Also supported in legacy HTTP health checks for target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for pass-through load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portSpecification")]
		public GRPCHealthCheckPortSpecification PortSpecification { get; set; }
		
		/// <summary>
		/// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyHeader")]
		public HTTP2HealthCheckProxyHeader ProxyHeader { get; set; }
		
		/// <summary>
		/// The request path of the HTTP health check request. The default value is /.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestPath")]
		public string RequestPath { get; set; }
		
		/// <summary>
		/// Creates a content-based HTTP health check. In addition to the required HTTP 200 (OK) status code, you can configure the health check to pass only when the backend sends this specific ASCII response string within the first 1024 bytes of the HTTP response body. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HTTPSHealthCheck
	{
		
		/// <summary>
		/// The value of the host header in the HTTPS health check request. If left empty (default value), the host header is set to the destination IP address to which health check packets are sent. The destination IP address depends on the type of load balancer. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#hc-packet-dest
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// The TCP port number to which the health check prober sends packets. The default value is 443. Valid values are 1 through 65535.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Not supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portName")]
		public string PortName { get; set; }
		
		/// <summary>
		/// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for passthrough load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for passthrough load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portSpecification")]
		public GRPCHealthCheckPortSpecification PortSpecification { get; set; }
		
		/// <summary>
		/// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyHeader")]
		public HTTP2HealthCheckProxyHeader ProxyHeader { get; set; }
		
		/// <summary>
		/// The request path of the HTTPS health check request. The default value is /.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestPath")]
		public string RequestPath { get; set; }
		
		/// <summary>
		/// Creates a content-based HTTPS health check. In addition to the required HTTP 200 (OK) status code, you can configure the health check to pass only when the backend sends this specific ASCII response string within the first 1024 bytes of the HTTP response body. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-http
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
	}
	
	/// <summary>
	/// Represents a health check resource. Google Compute Engine has two health check resources: * [Regional](/compute/docs/reference/rest/v1/regionHealthChecks) * [Global](/compute/docs/reference/rest/v1/healthChecks) These health check resources can be used for load balancing and for autohealing VMs in a managed instance group (MIG). **Load balancing** Health check requirements vary depending on the type of load balancer. For details about the type of health check supported for each load balancer and corresponding backend type, see Health checks overview: Load balancer guide. **Autohealing in MIGs** The health checks that you use for autohealing VMs in a MIG can be either regional or global. For more information, see Set up an application health check and autohealing. For more information, see Health checks overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheck
	{
		
		/// <summary>
		/// How often (in seconds) to send a health check. The default value is 5 seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checkIntervalSec")]
		public System.Nullable<System.Int32> CheckIntervalSec { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in 3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="grpcHealthCheck")]
		public GRPCHealthCheck GrpcHealthCheck { get; set; }
		
		/// <summary>
		/// A so-far unhealthy instance will be marked healthy after this many consecutive successes. The default value is 2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthyThreshold")]
		public System.Nullable<System.Int32> HealthyThreshold { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="http2HealthCheck")]
		public HTTP2HealthCheck Http2HealthCheck { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpHealthCheck")]
		public HTTPHealthCheck HttpHealthCheck { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="httpsHealthCheck")]
		public HTTPSHealthCheck HttpsHealthCheck { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Type of the resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#healthCheck")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#healthCheck";
		
		/// <summary>
		/// Configuration of logging on a health check. If logging is enabled, logs will be exported to Stackdriver.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public HealthCheckLogConfig LogConfig { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. For example, a name that is 1-63 characters long, matches the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`, and otherwise complies with RFC1035. This regular expression describes a name where the first character is a lowercase letter, and all following characters are a dash, lowercase letter, or digit, except the last character, which isn't a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] Region where the health check resides. Not applicable to global health checks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sslHealthCheck")]
		public SSLHealthCheck SslHealthCheck { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tcpHealthCheck")]
		public TCPHealthCheck TcpHealthCheck { get; set; }
		
		/// <summary>
		/// How long (in seconds) to wait before claiming failure. The default value is 5 seconds. It is invalid for timeoutSec to have greater value than checkIntervalSec.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeoutSec")]
		public System.Nullable<System.Int32> TimeoutSec { get; set; }
		
		/// <summary>
		/// Specifies the type of the healthCheck, either TCP, SSL, HTTP, HTTPS, HTTP2 or GRPC. Exactly one of the protocol-specific health check fields must be specified, which must match type field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<HealthCheckType> Type { get; set; }
		
		/// <summary>
		/// A so-far healthy instance will be marked unhealthy after this many consecutive failures. The default value is 2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unhealthyThreshold")]
		public System.Nullable<System.Int32> UnhealthyThreshold { get; set; }
	}
	
	/// <summary>
	/// Configuration of logging on a health check. If logging is enabled, logs will be exported to Stackdriver.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckLogConfig
	{
		
		/// <summary>
		/// Indicates whether or not to export logs. This is false by default, which means no health check logging will be done.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable")]
		public System.Nullable<System.Boolean> Enable { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SSLHealthCheck
	{
		
		/// <summary>
		/// The TCP port number to which the health check prober sends packets. The default value is 443. Valid values are 1 through 65535.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Not supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portName")]
		public string PortName { get; set; }
		
		/// <summary>
		/// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for passthrough load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for passthrough load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portSpecification")]
		public GRPCHealthCheckPortSpecification PortSpecification { get; set; }
		
		/// <summary>
		/// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyHeader")]
		public HTTP2HealthCheckProxyHeader ProxyHeader { get; set; }
		
		/// <summary>
		/// Instructs the health check prober to send this exact ASCII string, up to 1024 bytes in length, after establishing the TCP connection and SSL handshake.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="request")]
		public string Request { get; set; }
		
		/// <summary>
		/// Creates a content-based SSL health check. In addition to establishing a TCP connection and the TLS handshake, you can configure the health check to pass only when the backend sends this exact response ASCII string, up to 1024 bytes in length. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TCPHealthCheck
	{
		
		/// <summary>
		/// The TCP port number to which the health check prober sends packets. The default value is 80. Valid values are 1 through 65535.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// Not supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portName")]
		public string PortName { get; set; }
		
		/// <summary>
		/// Specifies how a port is selected for health checking. Can be one of the following values: USE_FIXED_PORT: Specifies a port number explicitly using the port field in the health check. Supported by backend services for passthrough load balancers and backend services for proxy load balancers. Not supported by target pools. The health check supports all backends supported by the backend service provided the backend can be health checked. For example, GCE_VM_IP network endpoint groups, GCE_VM_IP_PORT network endpoint groups, and instance group backends. USE_NAMED_PORT: Not supported. USE_SERVING_PORT: Provides an indirect method of specifying the health check port by referring to the backend service. Only supported by backend services for proxy load balancers. Not supported by target pools. Not supported by backend services for passthrough load balancers. Supports all backends that can be health checked; for example, GCE_VM_IP_PORT network endpoint groups and instance group backends. For GCE_VM_IP_PORT network endpoint group backends, the health check uses the port number specified for each endpoint in the network endpoint group. For instance group backends, the health check uses the port number determined by looking up the backend service's named port in the instance group's list of named ports.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portSpecification")]
		public GRPCHealthCheckPortSpecification PortSpecification { get; set; }
		
		/// <summary>
		/// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyHeader")]
		public HTTP2HealthCheckProxyHeader ProxyHeader { get; set; }
		
		/// <summary>
		/// Instructs the health check prober to send this exact ASCII string, up to 1024 bytes in length, after establishing the TCP connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="request")]
		public string Request { get; set; }
		
		/// <summary>
		/// Creates a content-based TCP health check. In addition to establishing a TCP connection, you can configure the health check to pass only when the backend sends this exact response ASCII string, up to 1024 bytes in length. For details, see: https://cloud.google.com/load-balancing/docs/health-check-concepts#criteria-protocol-ssl-tcp
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public string Response { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HealthCheckType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRPC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP2 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTPS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SSL = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TCP = 6,
	}
	
	/// <summary>
	/// Contains a list of HealthCheck resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of HealthCheck resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public HealthCheck[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#healthCheckList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#healthCheckList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public HealthCheckListWarning Warning { get; set; }
	}
	
	public class HealthCheckListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HealthCheckListWarningData[] HealthCheckListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class HealthCheckListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A full or valid partial URL to a health check. For example, the following are valid URLs: - https://www.googleapis.com/compute/beta/projects/project-id/global/httpHealthChecks/health-check - projects/project-id/global/httpHealthChecks/health-check - global/httpHealthChecks/health-check 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckReference
	{
		
		[System.Runtime.Serialization.DataMember(Name="healthCheck")]
		public string HealthCheck { get; set; }
	}
	
	/// <summary>
	/// Represents a Health-Check as a Service resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckService
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a HealthCheckService. An up-to-date fingerprint must be provided in order to patch/update the HealthCheckService; Otherwise, the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve the HealthCheckService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// A list of URLs to the HealthCheck resources. Must have at least one HealthCheck, and not more than 10 for regional HealthCheckService, and not more than 1 for global HealthCheckService. HealthCheck resources must have portSpecification=USE_SERVING_PORT or portSpecification=USE_FIXED_PORT. For regional HealthCheckService, the HealthCheck must be regional and in the same region. For global HealthCheckService, HealthCheck must be global. Mix of regional and global HealthChecks is not supported. Multiple regional HealthChecks must belong to the same region. Regional HealthChecks must belong to the same region as zones of NetworkEndpointGroups. For global HealthCheckService using global INTERNET_IP_PORT NetworkEndpointGroups, the global HealthChecks must specify sourceRegions, and HealthChecks that specify sourceRegions can only be used with global INTERNET_IP_PORT NetworkEndpointGroups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthChecks")]
		public string[] HealthChecks { get; set; }
		
		/// <summary>
		/// Optional. Policy for how the results from multiple health checks for the same endpoint are aggregated. Defaults to NO_AGGREGATION if unspecified. - NO_AGGREGATION. An EndpointHealth message is returned for each pair in the health check service. - AND. If any health check of an endpoint reports UNHEALTHY, then UNHEALTHY is the HealthState of the endpoint. If all health checks report HEALTHY, the HealthState of the endpoint is HEALTHY. . This is only allowed with regional HealthCheckService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthStatusAggregationPolicy")]
		public System.Nullable<HealthCheckServiceHealthStatusAggregationPolicy> HealthStatusAggregationPolicy { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output only] Type of the resource. Always compute#healthCheckServicefor health check services.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#healthCheckService")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#healthCheckService";
		
		/// <summary>
		/// Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of URLs to the NetworkEndpointGroup resources. Must not have more than 100. For regional HealthCheckService, NEGs must be in zones in the region of the HealthCheckService. For global HealthCheckServices, the NetworkEndpointGroups must be global INTERNET_IP_PORT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEndpointGroups")]
		public string[] NetworkEndpointGroups { get; set; }
		
		/// <summary>
		/// A list of URLs to the NotificationEndpoint resources. Must not have more than 10. A list of endpoints for receiving notifications of change in health status. For regional HealthCheckService, NotificationEndpoint must be regional and in the same region. For global HealthCheckService, NotificationEndpoint must be global.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notificationEndpoints")]
		public string[] NotificationEndpoints { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the health check service resides. This field is not applicable to global health check services. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HealthCheckServiceHealthStatusAggregationPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AND = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_AGGREGATION = 1,
	}
	
	/// <summary>
	/// A full or valid partial URL to a health check service. For example, the following are valid URLs: - https://www.googleapis.com/compute/beta/projects/project-id/regions/us-west1/healthCheckServices/health-check-service - projects/project-id/regions/us-west1/healthCheckServices/health-check-service - regions/us-west1/healthCheckServices/health-check-service 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckServiceReference
	{
		
		[System.Runtime.Serialization.DataMember(Name="healthCheckService")]
		public string HealthCheckService { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthCheckServicesList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of HealthCheckService resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public HealthCheckService[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#healthCheckServicesList for lists of HealthCheckServices.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#healthCheckServicesList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#healthCheckServicesList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public HealthCheckServicesListWarning Warning { get; set; }
	}
	
	public class HealthCheckServicesListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HealthCheckServicesListWarningData[] HealthCheckServicesListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class HealthCheckServicesListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthChecksAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of HealthChecksScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, HealthChecksScopedList> Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#healthChecksAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#healthChecksAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public HealthChecksAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthChecksScopedList
	{
		
		/// <summary>
		/// A list of HealthChecks contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthChecks")]
		public HealthCheck[] HealthChecks { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of backend services when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public HealthChecksScopedListWarning Warning { get; set; }
	}
	
	public class HealthChecksScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HealthChecksScopedListWarningData[] HealthChecksScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class HealthChecksScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class HealthChecksAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HealthChecksAggregatedListWarningData[] HealthChecksAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class HealthChecksAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HealthStatusForNetworkEndpoint
	{
		
		[System.Runtime.Serialization.DataMember(Name="backendService")]
		public BackendServiceReference BackendService { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="forwardingRule")]
		public ForwardingRuleReference ForwardingRule { get; set; }
		
		/// <summary>
		/// A full or valid partial URL to a health check. For example, the following are valid URLs: - https://www.googleapis.com/compute/beta/projects/project-id/global/httpHealthChecks/health-check - projects/project-id/global/httpHealthChecks/health-check - global/httpHealthChecks/health-check 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthCheck")]
		public HealthCheckReference HealthCheck { get; set; }
		
		/// <summary>
		/// A full or valid partial URL to a health check service. For example, the following are valid URLs: - https://www.googleapis.com/compute/beta/projects/project-id/regions/us-west1/healthCheckServices/health-check-service - projects/project-id/regions/us-west1/healthCheckServices/health-check-service - regions/us-west1/healthCheckServices/health-check-service 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthCheckService")]
		public HealthCheckServiceReference HealthCheckService { get; set; }
		
		/// <summary>
		/// Health state of the network endpoint determined based on the health checks configured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthState")]
		public System.Nullable<HealthStatusForNetworkEndpointHealthState> HealthState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HealthStatusForNetworkEndpointHealthState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DRAINING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HEALTHY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNHEALTHY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 3,
	}
	
	/// <summary>
	/// Provides links to documentation or for performing an out of band action. For example, if a quota check failed with an error indicating the calling project hasn't enabled the accessed service, this can contain a URL pointing directly to the right place in the developer console to flip the bit.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Help
	{
		
		/// <summary>
		/// URL(s) pointing to additional information on handling the current error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public HelpLink[] Links { get; set; }
	}
	
	/// <summary>
	/// Describes a URL link.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HelpLink
	{
		
		/// <summary>
		/// Describes what the link offers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The URL of the link.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// UrlMaps A host-matching rule for a URL. If matched, will use the named PathMatcher to select the BackendService.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HostRule
	{
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The list of host patterns to match. They must be valid hostnames with optional port numbers in the format host:port. * matches any string of ([a-z0-9-.]*). In that case, * must be the first character, and if followed by anything, the immediate following character must be either - or .. * based matching is not supported when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hosts")]
		public string[] Hosts { get; set; }
		
		/// <summary>
		/// The name of the PathMatcher to use to match the path portion of the URL if the hostRule matches the URL's host portion.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathMatcher")]
		public string PathMatcher { get; set; }
	}
	
	/// <summary>
	/// Specification for how requests are aborted as part of fault injection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpFaultAbort
	{
		
		/// <summary>
		/// The HTTP status code used to abort the request. The value must be from 200 to 599 inclusive. For gRPC protocol, the gRPC status code is mapped to HTTP status code according to this mapping table. HTTP status 200 is mapped to gRPC status UNKNOWN. Injecting an OK status is currently not supported by Traffic Director.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpStatus")]
		public System.Nullable<System.UInt32> HttpStatus { get; set; }
		
		/// <summary>
		/// The percentage of traffic for connections, operations, or requests that is aborted as part of fault injection. The value must be from 0.0 to 100.0 inclusive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public System.Nullable<System.Double> Percentage { get; set; }
	}
	
	/// <summary>
	/// Specifies the delay introduced by the load balancer before forwarding the request to the backend service as part of fault injection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpFaultDelay
	{
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fixedDelay")]
		public Duration FixedDelay { get; set; }
		
		/// <summary>
		/// The percentage of traffic for connections, operations, or requests for which a delay is introduced as part of fault injection. The value must be from 0.0 to 100.0 inclusive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentage")]
		public System.Nullable<System.Double> Percentage { get; set; }
	}
	
	/// <summary>
	/// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure. As part of fault injection, when clients send requests to a backend service, delays can be introduced by the load balancer on a percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpFaultInjection
	{
		
		/// <summary>
		/// Specification for how requests are aborted as part of fault injection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="abort")]
		public HttpFaultAbort Abort { get; set; }
		
		/// <summary>
		/// Specifies the delay introduced by the load balancer before forwarding the request to the backend service as part of fault injection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delay")]
		public HttpFaultDelay Delay { get; set; }
	}
	
	/// <summary>
	/// The request and response header transformations that take effect before the request is passed along to the selected backendService.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpHeaderAction
	{
		
		/// <summary>
		/// Headers to add to a matching request before forwarding the request to the backendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestHeadersToAdd")]
		public HttpHeaderOption[] RequestHeadersToAdd { get; set; }
		
		/// <summary>
		/// A list of header names for headers that need to be removed from the request before forwarding the request to the backendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestHeadersToRemove")]
		public string[] RequestHeadersToRemove { get; set; }
		
		/// <summary>
		/// Headers to add the response before sending the response back to the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseHeadersToAdd")]
		public HttpHeaderOption[] ResponseHeadersToAdd { get; set; }
		
		/// <summary>
		/// A list of header names for headers that need to be removed from the response before sending the response back to the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="responseHeadersToRemove")]
		public string[] ResponseHeadersToRemove { get; set; }
	}
	
	/// <summary>
	/// Specification determining how headers are added to requests or responses.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpHeaderOption
	{
		
		/// <summary>
		/// The name of the header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerName")]
		public string HeaderName { get; set; }
		
		/// <summary>
		/// The value of the header to add.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerValue")]
		public string HeaderValue { get; set; }
		
		/// <summary>
		/// If false, headerValue is appended to any values that already exist for the header. If true, headerValue is set for the header, discarding any values that were set for that header. The default value is false. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replace")]
		public System.Nullable<System.Boolean> Replace { get; set; }
	}
	
	/// <summary>
	/// matchRule criteria for request header matches.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpHeaderMatch
	{
		
		/// <summary>
		/// The value should exactly match contents of exactMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exactMatch")]
		public string ExactMatch { get; set; }
		
		/// <summary>
		/// The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method". When the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true, only non-binary user-specified custom metadata and the `content-type` header are supported. The following transport-level headers cannot be used in header matching rules: `:authority`, `:method`, `:path`, `:scheme`, `user-agent`, `accept-encoding`, `content-encoding`, `grpc-accept-encoding`, `grpc-encoding`, `grpc-previous-rpc-attempts`, `grpc-tags-bin`, `grpc-timeout` and `grpc-trace-bin`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerName")]
		public string HeaderName { get; set; }
		
		/// <summary>
		/// If set to false, the headerMatch is considered a match if the preceding match criteria are met. If set to true, the headerMatch is considered a match if the preceding match criteria are NOT met. The default setting is false. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="invertMatch")]
		public System.Nullable<System.Boolean> InvertMatch { get; set; }
		
		/// <summary>
		/// The value of the header must start with the contents of prefixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixMatch")]
		public string PrefixMatch { get; set; }
		
		/// <summary>
		/// A header with the contents of headerName must exist. The match takes place whether or not the request's header has a value. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="presentMatch")]
		public System.Nullable<System.Boolean> PresentMatch { get; set; }
		
		/// <summary>
		/// HttpRouteRuleMatch criteria for field values that must stay within the specified integer range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rangeMatch")]
		public Int64RangeMatch RangeMatch { get; set; }
		
		/// <summary>
		/// The value of the header must match the regular expression specified in regexMatch. For more information about regular expression syntax, see Syntax. For matching against a port specified in the HTTP request, use a headerMatch with headerName set to PORT and a regular expression that satisfies the RFC2616 Host header's port specifier. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set. Regular expressions can only be used when the loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regexMatch")]
		public string RegexMatch { get; set; }
		
		/// <summary>
		/// The value of the header must end with the contents of suffixMatch. Only one of exactMatch, prefixMatch, suffixMatch, regexMatch, presentMatch or rangeMatch must be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suffixMatch")]
		public string SuffixMatch { get; set; }
	}
	
	/// <summary>
	/// HttpRouteRuleMatch criteria for field values that must stay within the specified integer range.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Int64RangeMatch
	{
		
		/// <summary>
		/// The end of the range (exclusive) in signed long integer format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rangeEnd")]
		public string RangeEnd { get; set; }
		
		/// <summary>
		/// The start of the range (inclusive) in signed long integer format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rangeStart")]
		public string RangeStart { get; set; }
	}
	
	/// <summary>
	/// Represents a legacy HTTP Health Check resource. Legacy HTTP health checks are now only required by target pool-based network load balancers. For all other load balancers, including backend service-based network load balancers, and for managed instance group auto-healing, you must use modern (non-legacy) health checks. For more information, see Health checks overview .
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpHealthCheck
	{
		
		/// <summary>
		/// How often (in seconds) to send a health check. The default value is 5 seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checkIntervalSec")]
		public System.Nullable<System.Int32> CheckIntervalSec { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// A so-far unhealthy instance will be marked healthy after this many consecutive successes. The default value is 2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthyThreshold")]
		public System.Nullable<System.Int32> HealthyThreshold { get; set; }
		
		/// <summary>
		/// The value of the host header in the HTTP health check request. If left empty (default value), the public IP on behalf of which this health check is performed will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#httpHealthCheck for HTTP health checks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#httpHealthCheck")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#httpHealthCheck";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The TCP port number for the HTTP health check request. The default value is 80.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// The request path of the HTTP health check request. The default value is /. This field does not support query parameters. Must comply with RFC3986.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestPath")]
		public string RequestPath { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// How long (in seconds) to wait before claiming failure. The default value is 5 seconds. It is invalid for timeoutSec to have greater value than checkIntervalSec.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeoutSec")]
		public System.Nullable<System.Int32> TimeoutSec { get; set; }
		
		/// <summary>
		/// A so-far healthy instance will be marked unhealthy after this many consecutive failures. The default value is 2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unhealthyThreshold")]
		public System.Nullable<System.Int32> UnhealthyThreshold { get; set; }
	}
	
	/// <summary>
	/// Contains a list of HttpHealthCheck resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpHealthCheckList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of HttpHealthCheck resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public HttpHealthCheck[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#httpHealthCheckList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#httpHealthCheckList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public HttpHealthCheckListWarning Warning { get; set; }
	}
	
	public class HttpHealthCheckListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HttpHealthCheckListWarningData[] HttpHealthCheckListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class HttpHealthCheckListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// HttpRouteRuleMatch criteria for a request's query parameter.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpQueryParameterMatch
	{
		
		/// <summary>
		/// The queryParameterMatch matches if the value of the parameter exactly matches the contents of exactMatch. Only one of presentMatch, exactMatch, or regexMatch must be set. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exactMatch")]
		public string ExactMatch { get; set; }
		
		/// <summary>
		/// The name of the query parameter to match. The query parameter must exist in the request, in the absence of which the request match fails.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies that the queryParameterMatch matches if the request contains the query parameter, irrespective of whether the parameter has a value or not. Only one of presentMatch, exactMatch, or regexMatch must be set. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="presentMatch")]
		public System.Nullable<System.Boolean> PresentMatch { get; set; }
		
		/// <summary>
		/// The queryParameterMatch matches if the value of the parameter matches the regular expression specified by regexMatch. For more information about regular expression syntax, see Syntax. Only one of presentMatch, exactMatch, or regexMatch must be set. Regular expressions can only be used when the loadBalancingScheme is set to INTERNAL_SELF_MANAGED. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regexMatch")]
		public string RegexMatch { get; set; }
	}
	
	/// <summary>
	/// Specifies settings for an HTTP redirect.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpRedirectAction
	{
		
		/// <summary>
		/// The host that is used in the redirect response instead of the one that was supplied in the request. The value must be from 1 to 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostRedirect")]
		public string HostRedirect { get; set; }
		
		/// <summary>
		/// If set to true, the URL scheme in the redirected request is set to HTTPS. If set to false, the URL scheme of the redirected request remains the same as that of the request. This must only be set for URL maps used in TargetHttpProxys. Setting this true for TargetHttpsProxy is not permitted. The default is set to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpsRedirect")]
		public System.Nullable<System.Boolean> HttpsRedirect { get; set; }
		
		/// <summary>
		/// The path that is used in the redirect response instead of the one that was supplied in the request. pathRedirect cannot be supplied together with prefixRedirect. Supply one alone or neither. If neither is supplied, the path of the original request is used for the redirect. The value must be from 1 to 1024 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathRedirect")]
		public string PathRedirect { get; set; }
		
		/// <summary>
		/// The prefix that replaces the prefixMatch specified in the HttpRouteRuleMatch, retaining the remaining portion of the URL before redirecting the request. prefixRedirect cannot be supplied together with pathRedirect. Supply one alone or neither. If neither is supplied, the path of the original request is used for the redirect. The value must be from 1 to 1024 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixRedirect")]
		public string PrefixRedirect { get; set; }
		
		/// <summary>
		/// The HTTP Status code to use for this RedirectAction. Supported values are: - MOVED_PERMANENTLY_DEFAULT, which is the default value and corresponds to 301. - FOUND, which corresponds to 302. - SEE_OTHER which corresponds to 303. - TEMPORARY_REDIRECT, which corresponds to 307. In this case, the request method is retained. - PERMANENT_REDIRECT, which corresponds to 308. In this case, the request method is retained. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectResponseCode")]
		public System.Nullable<HttpRedirectActionRedirectResponseCode> RedirectResponseCode { get; set; }
		
		/// <summary>
		/// If set to true, any accompanying query portion of the original URL is removed before redirecting the request. If set to false, the query portion of the original URL is retained. The default is set to false. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stripQuery")]
		public System.Nullable<System.Boolean> StripQuery { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum HttpRedirectActionRedirectResponseCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOUND = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MOVED_PERMANENTLY_DEFAULT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PERMANENT_REDIRECT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SEE_OTHER = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TEMPORARY_REDIRECT = 4,
	}
	
	/// <summary>
	/// The retry policy associates with HttpRouteRule
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpRetryPolicy
	{
		
		/// <summary>
		/// Specifies the allowed number retries. This number must be > 0. If not specified, defaults to 1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numRetries")]
		public System.Nullable<System.UInt32> NumRetries { get; set; }
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perTryTimeout")]
		public Duration PerTryTimeout { get; set; }
		
		/// <summary>
		/// Specifies one or more conditions when this retry policy applies. Valid values are: - 5xx: retry is attempted if the instance or endpoint responds with any 5xx response code, or if the instance or endpoint does not respond at all. For example, disconnects, reset, read timeout, connection failure, and refused streams. - gateway-error: Similar to 5xx, but only applies to response codes 502, 503 or 504. - connect-failure: a retry is attempted on failures connecting to the instance or endpoint. For example, connection timeouts. - retriable-4xx: a retry is attempted if the instance or endpoint responds with a 4xx response code. The only error that you can retry is error code 409. - refused-stream: a retry is attempted if the instance or endpoint resets the stream with a REFUSED_STREAM error code. This reset type indicates that it is safe to retry. - cancelled: a retry is attempted if the gRPC status code in the response header is set to cancelled. - deadline-exceeded: a retry is attempted if the gRPC status code in the response header is set to deadline-exceeded. - internal: a retry is attempted if the gRPC status code in the response header is set to internal. - resource-exhausted: a retry is attempted if the gRPC status code in the response header is set to resource-exhausted. - unavailable: a retry is attempted if the gRPC status code in the response header is set to unavailable. Only the following codes are supported when the URL map is bound to target gRPC proxy that has validateForProxyless field set to true. - cancelled - deadline-exceeded - internal - resource-exhausted - unavailable 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retryConditions")]
		public string[] RetryConditions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpRouteAction
	{
		
		/// <summary>
		/// The specification for allowing client-side cross-origin requests. For more information about the W3C recommendation for cross-origin resource sharing (CORS), see Fetch API Living Standard.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="corsPolicy")]
		public CorsPolicy CorsPolicy { get; set; }
		
		/// <summary>
		/// The specification for fault injection introduced into traffic to test the resiliency of clients to backend service failure. As part of fault injection, when clients send requests to a backend service, delays can be introduced by the load balancer on a percentage of requests before sending those request to the backend service. Similarly requests from clients can be aborted by the load balancer for a percentage of requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="faultInjectionPolicy")]
		public HttpFaultInjection FaultInjectionPolicy { get; set; }
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxStreamDuration")]
		public Duration MaxStreamDuration { get; set; }
		
		/// <summary>
		/// A policy that specifies how requests intended for the route's backends are shadowed to a separate mirrored backend service. The load balancer doesn't wait for responses from the shadow service. Before sending traffic to the shadow service, the host or authority header is suffixed with -shadow.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestMirrorPolicy")]
		public RequestMirrorPolicy RequestMirrorPolicy { get; set; }
		
		/// <summary>
		/// The retry policy associates with HttpRouteRule
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retryPolicy")]
		public HttpRetryPolicy RetryPolicy { get; set; }
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public Duration Timeout { get; set; }
		
		/// <summary>
		/// The spec for modifying the path before sending the request to the matched backend service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRewrite")]
		public UrlRewrite UrlRewrite { get; set; }
		
		/// <summary>
		/// A list of weighted backend services to send traffic to when a route match occurs. The weights determine the fraction of traffic that flows to their corresponding backend service. If all traffic needs to go to a single backend service, there must be one weightedBackendService with weight set to a non-zero number. After a backend service is identified and before forwarding the request to the backend service, advanced routing actions such as URL rewrites and header transformations are applied depending on additional settings specified in this HttpRouteAction.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weightedBackendServices")]
		public WeightedBackendService[] WeightedBackendServices { get; set; }
	}
	
	/// <summary>
	/// A policy that specifies how requests intended for the route's backends are shadowed to a separate mirrored backend service. The load balancer doesn't wait for responses from the shadow service. Before sending traffic to the shadow service, the host or authority header is suffixed with -shadow.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RequestMirrorPolicy
	{
		
		/// <summary>
		/// The full or partial URL to the BackendService resource being mirrored to. The backend service configured for a mirroring policy must reference backends that are of the same type as the original backend service matched in the URL map. Serverless NEG backends are not currently supported as a mirrored backend service. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backendService")]
		public string BackendService { get; set; }
	}
	
	/// <summary>
	/// The spec for modifying the path before sending the request to the matched backend service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlRewrite
	{
		
		/// <summary>
		/// Before forwarding the request to the selected service, the request's host header is replaced with contents of hostRewrite. The value must be from 1 to 255 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostRewrite")]
		public string HostRewrite { get; set; }
		
		/// <summary>
		/// Before forwarding the request to the selected backend service, the matching portion of the request's path is replaced by pathPrefixRewrite. The value must be from 1 to 1024 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathPrefixRewrite")]
		public string PathPrefixRewrite { get; set; }
		
		/// <summary>
		///  If specified, the pattern rewrites the URL path (based on the :path header) using the HTTP template syntax. A corresponding path_template_match must be specified. Any template variables must exist in the path_template_match field. - -At least one variable must be specified in the path_template_match field - You can omit variables from the rewritten URL - The * and ** operators cannot be matched unless they have a corresponding variable name - e.g. {format=*} or {var=**}. For example, a path_template_match of /static/{format=**} could be rewritten as /static/content/{format} to prefix /content to the URL. Variables can also be re-ordered in a rewrite, so that /{country}/{format}/{suffix=**} can be rewritten as /content/{format}/{country}/{suffix}. At least one non-empty routeRules[].matchRules[].path_template_match is required. Only one of path_prefix_rewrite or path_template_rewrite may be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathTemplateRewrite")]
		public string PathTemplateRewrite { get; set; }
	}
	
	/// <summary>
	/// In contrast to a single BackendService in HttpRouteAction to which all matching traffic is directed to, WeightedBackendService allows traffic to be split across multiple backend services. The volume of traffic for each backend service is proportional to the weight specified in each WeightedBackendService
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WeightedBackendService
	{
		
		/// <summary>
		/// The full or partial URL to the default BackendService resource. Before forwarding the request to backendService, the load balancer applies any relevant headerActions specified as part of this backendServiceWeight.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backendService")]
		public string BackendService { get; set; }
		
		/// <summary>
		/// The request and response header transformations that take effect before the request is passed along to the selected backendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerAction")]
		public HttpHeaderAction HeaderAction { get; set; }
		
		/// <summary>
		/// Specifies the fraction of traffic sent to a backend service, computed as weight / (sum of all weightedBackendService weights in routeAction) . The selection of a backend service is determined only for new traffic. Once a user's request has been directed to a backend service, subsequent requests are sent to the same backend service as determined by the backend service's session affinity policy. The value must be from 0 to 1000.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public System.Nullable<System.UInt32> Weight { get; set; }
	}
	
	/// <summary>
	/// The HttpRouteRule setting specifies how to match an HTTP request and the corresponding routing action that load balancing proxies perform.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpRouteRule
	{
		
		/// <summary>
		/// The short description conveying the intent of this routeRule. The description can have a maximum length of 1024 characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The request and response header transformations that take effect before the request is passed along to the selected backendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerAction")]
		public HttpHeaderAction HeaderAction { get; set; }
		
		/// <summary>
		/// The list of criteria for matching attributes of a request to this routeRule. This list has OR semantics: the request matches this routeRule when any of the matchRules are satisfied. However predicates within a given matchRule have AND semantics. All predicates within a matchRule must match for the request to match the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="matchRules")]
		public HttpRouteRuleMatch[] MatchRules { get; set; }
		
		/// <summary>
		/// For routeRules within a given pathMatcher, priority determines the order in which a load balancer interprets routeRules. RouteRules are evaluated in order of priority, from the lowest to highest number. The priority of a rule decreases as its number increases (1, 2, 3, N+1). The first rule that matches the request is applied. You cannot configure two or more routeRules with the same priority. Priority for each rule must be set to a number from 0 to 2147483647 inclusive. Priority numbers can have gaps, which enable you to add or remove rules in the future without affecting the rest of the rules. For example, 1, 2, 3, 4, 5, 9, 12, 16 is a valid series of priority numbers to which you could add rules numbered from 6 to 8, 10 to 11, and 13 to 15 in the future without any impact on existing rules.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="routeAction")]
		public HttpRouteAction RouteAction { get; set; }
		
		/// <summary>
		/// The full or partial URL of the backend service resource to which traffic is directed if this rule is matched. If routeAction is also specified, advanced routing actions, such as URL rewrites, take effect before sending the request to the backend. However, if service is specified, routeAction cannot contain any weightedBackendServices. Conversely, if routeAction specifies any weightedBackendServices, service must not be specified. Only one of urlRedirect, service or routeAction.weightedBackendService must be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
		
		/// <summary>
		/// Specifies settings for an HTTP redirect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirect")]
		public HttpRedirectAction UrlRedirect { get; set; }
	}
	
	/// <summary>
	/// HttpRouteRuleMatch specifies a set of criteria for matching requests to an HttpRouteRule. All specified criteria must be satisfied for a match to occur.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpRouteRuleMatch
	{
		
		/// <summary>
		/// For satisfying the matchRule condition, the path of the request must exactly match the value specified in fullPathMatch after removing any query parameters and anchor that may be part of the original URL. fullPathMatch must be from 1 to 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fullPathMatch")]
		public string FullPathMatch { get; set; }
		
		/// <summary>
		/// Specifies a list of header match criteria, all of which must match corresponding headers in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerMatches")]
		public HttpHeaderMatch[] HeaderMatches { get; set; }
		
		/// <summary>
		/// Specifies that prefixMatch and fullPathMatch matches are case sensitive. The default value is false. ignoreCase must not be used with regexMatch. Not supported when the URL map is bound to a target gRPC proxy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ignoreCase")]
		public System.Nullable<System.Boolean> IgnoreCase { get; set; }
		
		/// <summary>
		/// Opaque filter criteria used by the load balancer to restrict routing configuration to a limited set of xDS compliant clients. In their xDS requests to the load balancer, xDS clients present node metadata. When there is a match, the relevant routing configuration is made available to those proxies. For each metadataFilter in this list, if its filterMatchCriteria is set to MATCH_ANY, at least one of the filterLabels must match the corresponding label provided in the metadata. If its filterMatchCriteria is set to MATCH_ALL, then all of its filterLabels must match with corresponding labels provided in the metadata. If multiple metadata filters are specified, all of them need to be satisfied in order to be considered a match. metadataFilters specified here is applied after those specified in ForwardingRule that refers to the UrlMap this HttpRouteRuleMatch belongs to. metadataFilters only applies to load balancers that have loadBalancingScheme set to INTERNAL_SELF_MANAGED. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadataFilters")]
		public MetadataFilter[] MetadataFilters { get; set; }
		
		/// <summary>
		/// If specified, the route is a pattern match expression that must match the :path header once the query string is removed. A pattern match allows you to match - The value must be between 1 and 1024 characters - The pattern must start with a leading slash ("/") - There may be no more than 5 operators in pattern Precisely one of prefix_match, full_path_match, regex_match or path_template_match must be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathTemplateMatch")]
		public string PathTemplateMatch { get; set; }
		
		/// <summary>
		/// For satisfying the matchRule condition, the request's path must begin with the specified prefixMatch. prefixMatch must begin with a /. The value must be from 1 to 1024 characters. Only one of prefixMatch, fullPathMatch or regexMatch must be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefixMatch")]
		public string PrefixMatch { get; set; }
		
		/// <summary>
		/// Specifies a list of query parameter match criteria, all of which must match corresponding query parameters in the request. Not supported when the URL map is bound to a target gRPC proxy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryParameterMatches")]
		public HttpQueryParameterMatch[] QueryParameterMatches { get; set; }
		
		/// <summary>
		/// For satisfying the matchRule condition, the path of the request must satisfy the regular expression specified in regexMatch after removing any query parameters and anchor supplied with the original URL. For more information about regular expression syntax, see Syntax. Only one of prefixMatch, fullPathMatch or regexMatch must be specified. Regular expressions can only be used when the loadBalancingScheme is set to INTERNAL_SELF_MANAGED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regexMatch")]
		public string RegexMatch { get; set; }
	}
	
	/// <summary>
	/// Represents a legacy HTTPS Health Check resource. Legacy HTTPS health checks have been deprecated. If you are using a target pool-based network load balancer, you must use a legacy HTTP (not HTTPS) health check. For all other load balancers, including backend service-based network load balancers, and for managed instance group auto-healing, you must use modern (non-legacy) health checks. For more information, see Health checks overview .
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpsHealthCheck
	{
		
		/// <summary>
		/// How often (in seconds) to send a health check. The default value is 5 seconds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="checkIntervalSec")]
		public System.Nullable<System.Int32> CheckIntervalSec { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// A so-far unhealthy instance will be marked healthy after this many consecutive successes. The default value is 2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthyThreshold")]
		public System.Nullable<System.Int32> HealthyThreshold { get; set; }
		
		/// <summary>
		/// The value of the host header in the HTTPS health check request. If left empty (default value), the public IP on behalf of which this health check is performed will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Type of the resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#httpsHealthCheck")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#httpsHealthCheck";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The TCP port number for the HTTPS health check request. The default value is 443.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
		
		/// <summary>
		/// The request path of the HTTPS health check request. The default value is "/". Must comply with RFC3986.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestPath")]
		public string RequestPath { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// How long (in seconds) to wait before claiming failure. The default value is 5 seconds. It is invalid for timeoutSec to have a greater value than checkIntervalSec.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeoutSec")]
		public System.Nullable<System.Int32> TimeoutSec { get; set; }
		
		/// <summary>
		/// A so-far healthy instance will be marked unhealthy after this many consecutive failures. The default value is 2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unhealthyThreshold")]
		public System.Nullable<System.Int32> UnhealthyThreshold { get; set; }
	}
	
	/// <summary>
	/// Contains a list of HttpsHealthCheck resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HttpsHealthCheckList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of HttpsHealthCheck resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public HttpsHealthCheck[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#httpsHealthCheckList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#httpsHealthCheckList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public HttpsHealthCheckListWarning Warning { get; set; }
	}
	
	public class HttpsHealthCheckListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public HttpsHealthCheckListWarningData[] HttpsHealthCheckListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class HttpsHealthCheckListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents an Image resource. You can use images to create boot disks for your VM instances. For more information, read Images.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Image
	{
		
		/// <summary>
		/// The architecture of the image. Valid values are ARM64 or X86_64.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public AttachedDiskArchitecture Architecture { get; set; }
		
		/// <summary>
		/// Size of the image tar.gz archive stored in Google Cloud Storage (in bytes).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archiveSizeBytes")]
		public string ArchiveSizeBytes { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// Deprecation status for a public resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public DeprecationStatus Deprecated { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Size of the image when restored onto a persistent disk (in GB).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGb")]
		public string DiskSizeGb { get; set; }
		
		/// <summary>
		/// Whether this image is created from a confidential compute mode disk. [Output Only]: This field is not set by user, but from source disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableConfidentialCompute")]
		public System.Nullable<System.Boolean> EnableConfidentialCompute { get; set; }
		
		/// <summary>
		/// The name of the image family to which this image belongs. The image family name can be from a publicly managed image family provided by Compute Engine, or from a custom image family you create. For example, centos-stream-9 is a publicly available image family. For more information, see Image family best practices. When creating disks, you can specify an image family instead of a specific image name. The image family always returns its latest image that is not deprecated. The name of the image family must comply with RFC1035.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="family")]
		public string Family { get; set; }
		
		/// <summary>
		/// A list of features to enable on the guest operating system. Applicable only for bootable images. To see a list of available options, see the guestOSfeatures[].type parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestOsFeatures")]
		public GuestOsFeature[] GuestOsFeatures { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="imageEncryptionKey")]
		public CustomerEncryptionKey ImageEncryptionKey { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#image for images.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#image")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#image";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this image, which is essentially a hash of the labels used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels to apply to this image. These can be later modified by the setLabels method.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Integer license codes indicating which licenses are attached to this image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseCodes")]
		public string[] LicenseCodes { get; set; }
		
		/// <summary>
		/// Any applicable license URI.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public string[] Licenses { get; set; }
		
		/// <summary>
		/// Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The parameters of the raw disk image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rawDisk")]
		public ImageRawDisk RawDisk { get; set; }
		
		/// <summary>
		/// Output only. Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzi")]
		public System.Nullable<System.Boolean> SatisfiesPzi { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzs")]
		public System.Nullable<System.Boolean> SatisfiesPzs { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Initial State for shielded instance, these are public keys which are safe to store in public
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shieldedInstanceInitialState")]
		public InitialStateConfig ShieldedInstanceInitialState { get; set; }
		
		/// <summary>
		/// URL of the source disk used to create this image. For example, the following are valid values: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /disks/disk - projects/project/zones/zone/disks/disk - zones/zone/disks/disk In order to create an image, you must provide the full or partial URL of one of the following: - The rawDisk.source URL - The sourceDisk URL - The sourceImage URL - The sourceSnapshot URL 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDisk")]
		public string SourceDisk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceDiskEncryptionKey")]
		public CustomerEncryptionKey SourceDiskEncryptionKey { get; set; }
		
		/// <summary>
		/// [Output Only] The ID value of the disk used to create this image. This value may be used to determine whether the image was taken from the current or a previous instance of a given disk name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDiskId")]
		public string SourceDiskId { get; set; }
		
		/// <summary>
		/// URL of the source image used to create this image. The following are valid formats for the URL: - https://www.googleapis.com/compute/v1/projects/project_id/global/ images/image_name - projects/project_id/global/images/image_name In order to create an image, you must provide the full or partial URL of one of the following: - The rawDisk.source URL - The sourceDisk URL - The sourceImage URL - The sourceSnapshot URL 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceImage")]
		public string SourceImage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceImageEncryptionKey")]
		public CustomerEncryptionKey SourceImageEncryptionKey { get; set; }
		
		/// <summary>
		/// [Output Only] The ID value of the image used to create this image. This value may be used to determine whether the image was taken from the current or a previous instance of a given image name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceImageId")]
		public string SourceImageId { get; set; }
		
		/// <summary>
		/// URL of the source snapshot used to create this image. The following are valid formats for the URL: - https://www.googleapis.com/compute/v1/projects/project_id/global/ snapshots/snapshot_name - projects/project_id/global/snapshots/snapshot_name In order to create an image, you must provide the full or partial URL of one of the following: - The rawDisk.source URL - The sourceDisk URL - The sourceImage URL - The sourceSnapshot URL 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceSnapshot")]
		public string SourceSnapshot { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceSnapshotEncryptionKey")]
		public CustomerEncryptionKey SourceSnapshotEncryptionKey { get; set; }
		
		/// <summary>
		/// [Output Only] The ID value of the snapshot used to create this image. This value may be used to determine whether the snapshot was taken from the current or a previous instance of a given snapshot name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceSnapshotId")]
		public string SourceSnapshotId { get; set; }
		
		/// <summary>
		/// The type of the image used to create this disk. The default and only valid value is RAW.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceType")]
		public System.Nullable<ImageSourceType> SourceType { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the image. An image can be used to create other resources, such as instances, only after the image has been successfully created and the status is set to READY. Possible values are FAILED, PENDING, or READY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ImageStatus> Status { get; set; }
		
		/// <summary>
		/// Cloud Storage bucket storage location of the image (regional or multi-regional).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageLocations")]
		public string[] StorageLocations { get; set; }
	}
	
	public class ImageRawDisk
	{
		
		/// <summary>
		/// The format used to encode and transmit the block device, which should be TAR. This is just a container and transmission format and not a runtime format. Provided by the client when the disk image is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="containerType")]
		public System.Nullable<ImageRawDiskContainerType> ContainerType { get; set; }
		
		/// <summary>
		/// [Deprecated] This field is deprecated. An optional SHA1 checksum of the disk image before unpackaging provided by the client when the disk image is created.
		/// Pattern: [a-f0-9]{40}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sha1Checksum")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-f0-9]{40}")]
		public string Sha1Checksum { get; set; }
		
		/// <summary>
		/// The full Google Cloud Storage URL where the raw disk image archive is stored. The following are valid formats for the URL: - https://storage.googleapis.com/bucket_name/image_archive_name - https://storage.googleapis.com/bucket_name/folder_name/ image_archive_name In order to create an image, you must provide the full or partial URL of one of the following: - The rawDisk.source URL - The sourceDisk URL - The sourceImage URL - The sourceSnapshot URL 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ImageRawDiskContainerType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TAR = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ImageSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RAW = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ImageStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageFamilyView
	{
		
		/// <summary>
		/// Represents an Image resource. You can use images to create boot disks for your VM instances. For more information, read Images.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="image")]
		public Image Image { get; set; }
	}
	
	/// <summary>
	/// Contains a list of images.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImageList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Image resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Image[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#imageList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#imageList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ImageListWarning Warning { get; set; }
	}
	
	public class ImageListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ImageListWarningData[] ImageListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ImageListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents an Instance resource. An instance is a virtual machine that is hosted on Google Cloud Platform. For more information, read Virtual Machine Instances.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Instance
	{
		
		/// <summary>
		/// Specifies options for controlling advanced machine features. Options that would traditionally be configured in a BIOS belong here. Features that require operating system support may have corresponding entries in the GuestOsFeatures of an Image (e.g., whether or not the OS in the Image supports nested virtualization being enabled or disabled).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advancedMachineFeatures")]
		public AdvancedMachineFeatures AdvancedMachineFeatures { get; set; }
		
		/// <summary>
		/// Allows this instance to send and receive packets with non-matching destination or source IPs. This is required if you plan to use this instance to forward routes. For more information, see Enabling IP Forwarding .
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canIpForward")]
		public System.Nullable<System.Boolean> CanIpForward { get; set; }
		
		/// <summary>
		/// A set of Confidential Instance options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="confidentialInstanceConfig")]
		public ConfidentialInstanceConfig ConfidentialInstanceConfig { get; set; }
		
		/// <summary>
		/// [Output Only] The CPU platform used by this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuPlatform")]
		public string CpuPlatform { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// Whether the resource should be protected against deletion.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deletionProtection")]
		public System.Nullable<System.Boolean> DeletionProtection { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Array of disks associated with this instance. Persistent disks must be created before you can assign them.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public AttachedDisk[] Disks { get; set; }
		
		/// <summary>
		/// A set of Display Device options
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayDevice")]
		public DisplayDevice DisplayDevice { get; set; }
		
		/// <summary>
		/// Specifies a fingerprint for this resource, which is essentially a hash of the instance's contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update the instance. You must always provide an up-to-date fingerprint hash in order to update the instance. To see the latest fingerprint, make get() request to the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// A list of the type and count of accelerator cards attached to the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestAccelerators")]
		public AcceleratorConfig[] GuestAccelerators { get; set; }
		
		/// <summary>
		/// Specifies the hostname of the instance. The specified hostname must be RFC1035 compliant. If hostname is not specified, the default hostname is [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global DNS, and [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal DNS.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostname")]
		public string Hostname { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="instanceEncryptionKey")]
		public CustomerEncryptionKey InstanceEncryptionKey { get; set; }
		
		/// <summary>
		/// KeyRevocationActionType of the instance. Supported options are "STOP" and "NONE". The default value is "NONE" if it is not specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyRevocationActionType")]
		public InstancePropertiesKeyRevocationActionType KeyRevocationActionType { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#instance for instances.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instance")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instance";
		
		/// <summary>
		/// A fingerprint for this request, which is essentially a hash of the label's contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels. To see the latest fingerprint, make get() request to the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels to apply to this instance. These can be later modified by the setLabels method.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// [Output Only] Last start timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastStartTimestamp")]
		public string LastStartTimestamp { get; set; }
		
		/// <summary>
		/// [Output Only] Last stop timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastStopTimestamp")]
		public string LastStopTimestamp { get; set; }
		
		/// <summary>
		/// [Output Only] Last suspended timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastSuspendedTimestamp")]
		public string LastSuspendedTimestamp { get; set; }
		
		/// <summary>
		/// Full or partial URL of the machine type resource to use for this instance, in the format: zones/zone/machineTypes/machine-type. This is provided by the client when the instance is created. For example, the following is a valid partial url to a predefined machine type: zones/us-central1-f/machineTypes/n1-standard-1 To create a custom machine type, provide a URL to a machine type in the following format, where CPUS is 1 or an even number up to 32 (2, 4, 6, ... 24, etc), and MEMORY is the total memory for this instance. Memory must be a multiple of 256 MB and must be supplied in MB (e.g. 5 GB of memory is 5120 MB): zones/zone/machineTypes/custom-CPUS-MEMORY For example: zones/us-central1-f/machineTypes/custom-4-5120 For a full list of restrictions, read the Specifications for custom machine types.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
		
		/// <summary>
		/// A metadata key/value entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public Metadata Metadata { get; set; }
		
		/// <summary>
		/// Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms, such as minCpuPlatform: "Intel Haswell" or minCpuPlatform: "Intel Sandy Bridge".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minCpuPlatform")]
		public string MinCpuPlatform { get; set; }
		
		/// <summary>
		/// The name of the resource, provided by the client when initially creating the resource. The resource name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// An array of network configurations for this instance. These specify how interfaces are configured to interact with other network services, such as connecting to the internet. Multiple interfaces are supported per instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaces")]
		public NetworkInterface[] NetworkInterfaces { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="networkPerformanceConfig")]
		public NetworkPerformanceConfig NetworkPerformanceConfig { get; set; }
		
		/// <summary>
		/// Additional instance params.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="params")]
		public InstanceParams Params { get; set; }
		
		/// <summary>
		/// The private IPv6 google access type for the VM. If not specified, use INHERIT_FROM_SUBNETWORK as default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateIpv6GoogleAccess")]
		public InstancePropertiesPrivateIpv6GoogleAccess PrivateIpv6GoogleAccess { get; set; }
		
		/// <summary>
		/// Specifies the reservations that this instance can consume from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservationAffinity")]
		public ReservationAffinity ReservationAffinity { get; set; }
		
		/// <summary>
		/// Resource policies applied to this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public string[] ResourcePolicies { get; set; }
		
		/// <summary>
		/// Contains output only fields. Use this sub-message for actual values set on Instance attributes as compared to the value requested by the user (intent) in their instance CRUD calls.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceStatus")]
		public ResourceStatus ResourceStatus { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzi")]
		public System.Nullable<System.Boolean> SatisfiesPzi { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzs")]
		public System.Nullable<System.Boolean> SatisfiesPzs { get; set; }
		
		/// <summary>
		/// Sets the scheduling options for an Instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduling")]
		public Scheduling Scheduling { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// A list of service accounts, with their specified scopes, authorized for this instance. Only one service account per VM instance is supported. Service accounts generate access tokens that can be accessed through the metadata server and used to authenticate applications on the instance. See Service Accounts for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccounts")]
		public ServiceAccount[] ServiceAccounts { get; set; }
		
		/// <summary>
		/// A set of Shielded Instance options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shieldedInstanceConfig")]
		public ShieldedInstanceConfig ShieldedInstanceConfig { get; set; }
		
		/// <summary>
		/// The policy describes the baseline against which Instance boot integrity is measured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shieldedInstanceIntegrityPolicy")]
		public ShieldedInstanceIntegrityPolicy ShieldedInstanceIntegrityPolicy { get; set; }
		
		/// <summary>
		/// Source machine image
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceMachineImage")]
		public string SourceMachineImage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceMachineImageEncryptionKey")]
		public CustomerEncryptionKey SourceMachineImageEncryptionKey { get; set; }
		
		/// <summary>
		/// [Output Only] Whether a VM has been restricted for start because Compute Engine has detected suspicious activity.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startRestricted")]
		public System.Nullable<System.Boolean> StartRestricted { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the instance. One of the following values: PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING, SUSPENDED, REPAIRING, and TERMINATED. For more information about the status of the instance, see Instance life cycle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<InstanceStatus> Status { get; set; }
		
		/// <summary>
		/// [Output Only] An optional, human-readable explanation of the status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// A set of instance tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the zone where the instance resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// Additional instance params.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceParams
	{
		
		/// <summary>
		/// Resource manager tags to be bound to the instance. Tag keys and values have the same definition as resource manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and values are in the format `tagValues/456`. The field is ignored (both PUT & PATCH) when empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceManagerTags")]
		public System.Collections.Generic.Dictionary<string, string> ResourceManagerTags { get; set; }
	}
	
	/// <summary>
	/// Contains output only fields. Use this sub-message for actual values set on Instance attributes as compared to the value requested by the user (intent) in their instance CRUD calls.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceStatus
	{
		
		/// <summary>
		/// [Output Only] An opaque ID of the host on which the VM is running.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="physicalHost")]
		public string PhysicalHost { get; set; }
		
		/// <summary>
		/// Upcoming Maintenance notification information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upcomingMaintenance")]
		public UpcomingMaintenance UpcomingMaintenance { get; set; }
	}
	
	/// <summary>
	/// Upcoming Maintenance notification information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpcomingMaintenance
	{
		
		/// <summary>
		/// Indicates if the maintenance can be customer triggered.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canReschedule")]
		public System.Nullable<System.Boolean> CanReschedule { get; set; }
		
		/// <summary>
		/// The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latestWindowStartTime")]
		public string LatestWindowStartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="maintenanceStatus")]
		public System.Nullable<UpcomingMaintenanceMaintenanceStatus> MaintenanceStatus { get; set; }
		
		/// <summary>
		/// Defines the type of maintenance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<UpcomingMaintenanceType> Type { get; set; }
		
		/// <summary>
		/// The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="windowEndTime")]
		public string WindowEndTime { get; set; }
		
		/// <summary>
		/// The current start time of the maintenance window. This timestamp value is in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="windowStartTime")]
		public string WindowStartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UpcomingMaintenanceMaintenanceStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONGOING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum UpcomingMaintenanceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SCHEDULED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN_TYPE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSCHEDULED = 2,
	}
	
	/// <summary>
	/// The policy describes the baseline against which Instance boot integrity is measured.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ShieldedInstanceIntegrityPolicy
	{
		
		/// <summary>
		/// Updates the integrity policy baseline using the measurements from the VM instance's most recent boot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateAutoLearnPolicy")]
		public System.Nullable<System.Boolean> UpdateAutoLearnPolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstanceStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPROVISIONING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROVISIONING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REPAIRING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STAGING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUSPENDED = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUSPENDING = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TERMINATED = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// An object that contains a list of instances scoped by zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, InstancesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#instanceAggregatedList for aggregated lists of Instance resources.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of instances contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public Instance[] Instances { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning which replaces the list of instances when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstancesScopedListWarning Warning { get; set; }
	}
	
	public class InstancesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstancesScopedListWarningData[] InstancesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstancesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class InstanceAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceAggregatedListWarningData[] InstanceAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceConsumptionData
	{
		
		[System.Runtime.Serialization.DataMember(Name="consumptionInfo")]
		public InstanceConsumptionInfo ConsumptionInfo { get; set; }
		
		/// <summary>
		/// Server-defined URL for the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceConsumptionInfo
	{
		
		/// <summary>
		/// The number of virtual CPUs that are available to the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestCpus")]
		public System.Nullable<System.Int32> GuestCpus { get; set; }
		
		/// <summary>
		/// The amount of local SSD storage available to the instance, defined in GiB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localSsdGb")]
		public System.Nullable<System.Int32> LocalSsdGb { get; set; }
		
		/// <summary>
		/// The amount of physical memory available to the instance, defined in MiB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryMb")]
		public System.Nullable<System.Int32> MemoryMb { get; set; }
		
		/// <summary>
		/// The minimal guaranteed number of virtual CPUs that are reserved.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minNodeCpus")]
		public System.Nullable<System.Int32> MinNodeCpus { get; set; }
	}
	
	/// <summary>
	/// Represents an Instance Group resource. Instance Groups can be used to configure a target for load balancing. Instance groups can either be managed or unmanaged. To create managed instance groups, use the instanceGroupManager or regionInstanceGroupManager resource instead. Use zonal unmanaged instance groups if you need to apply load balancing to groups of heterogeneous instances or if you need to manage the instances yourself. You cannot create regional unmanaged instance groups. For more information, read Instance groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroup
	{
		
		/// <summary>
		/// [Output Only] The creation timestamp for this instance group in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The fingerprint of the named ports. The system uses this fingerprint to detect conflicts when multiple users change the named ports concurrently.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] A unique identifier for this instance group, generated by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#instanceGroup for instance groups.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceGroup")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceGroup";
		
		/// <summary>
		/// The name of the instance group. The name must be 1-63 characters long, and comply with RFC1035.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		///  Assigns a name to a port number. For example: {name: "http", port: 80} This allows the system to reference ports by the assigned name instead of a port number. Named ports can also contain multiple ports. For example: [{name: "app1", port: 8080}, {name: "app1", port: 8081}, {name: "app2", port: 8082}] Named ports apply to all instances in this instance group. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namedPorts")]
		public NamedPort[] NamedPorts { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the network to which all instances in the instance group belong. If your instance has multiple network interfaces, then the network and subnetwork fields only refer to the network and subnet used by your primary interface (nic0).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the region where the instance group is located (for regional resources).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] The URL for this instance group. The server generates this URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The total number of instances in the instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the subnetwork to which all instances in the instance group belong. If your instance has multiple network interfaces, then the network and subnetwork fields only refer to the network and subnet used by your primary interface (nic0).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetwork")]
		public string Subnetwork { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the zone where the instance group is located (for zonal resources).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// The named port. For example: <"http", 80>.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NamedPort
	{
		
		/// <summary>
		/// The name for this named port. The name must be 1-63 characters long, and comply with RFC1035.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The port number, which can be a value between 1 and 65535.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="port")]
		public System.Nullable<System.Int32> Port { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InstanceGroupsScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, InstanceGroupsScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#instanceGroupAggregatedList for aggregated lists of instance groups.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceGroupAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceGroupAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceGroupAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupsScopedList
	{
		
		/// <summary>
		/// [Output Only] The list of instance groups that are contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceGroups")]
		public InstanceGroup[] InstanceGroups { get; set; }
		
		/// <summary>
		/// [Output Only] An informational warning that replaces the list of instance groups when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceGroupsScopedListWarning Warning { get; set; }
	}
	
	public class InstanceGroupsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceGroupsScopedListWarningData[] InstanceGroupsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceGroupsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class InstanceGroupAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceGroupAggregatedListWarningData[] InstanceGroupAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceGroupAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A list of InstanceGroup resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InstanceGroup resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InstanceGroup[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#instanceGroupList for instance group lists.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceGroupList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceGroupList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceGroupListWarning Warning { get; set; }
	}
	
	public class InstanceGroupListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceGroupListWarningData[] InstanceGroupListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceGroupListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Managed Instance Group resource. An instance group is a collection of VM instances that you can manage as a single entity. For more information, read Instance groups. For zonal Managed Instance Group, use the instanceGroupManagers resource. For regional Managed Instance Group, use the regionInstanceGroupManagers resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManager
	{
		
		/// <summary>
		/// The autohealing policy for this managed instance group. You can specify only one value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoHealingPolicies")]
		public InstanceGroupManagerAutoHealingPolicy[] AutoHealingPolicies { get; set; }
		
		/// <summary>
		/// The base instance name to use for instances in this group. The value must be 1-58 characters long. Instances are named by appending a hyphen and a random four-character string to the base instance name. The base instance name must comply with RFC1035.
		/// Pattern: [a-z][-a-z0-9]{0,57}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="baseInstanceName")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z][-a-z0-9]{0,57}")]
		public string BaseInstanceName { get; set; }
		
		/// <summary>
		/// [Output Only] The creation timestamp for this managed instance group in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="currentActions")]
		public InstanceGroupManagerActionsSummary CurrentActions { get; set; }
		
		/// <summary>
		/// An optional description of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="distributionPolicy")]
		public DistributionPolicy DistributionPolicy { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. This field may be used in optimistic locking. It will be ignored when inserting an InstanceGroupManager. An up-to-date fingerprint must be provided in order to update the InstanceGroupManager, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an InstanceGroupManager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] A unique identifier for this resource type. The server generates this identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the Instance Group resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceGroup")]
		public string InstanceGroup { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="instanceLifecyclePolicy")]
		public InstanceGroupManagerInstanceLifecyclePolicy InstanceLifecyclePolicy { get; set; }
		
		/// <summary>
		/// The URL of the instance template that is specified for this managed instance group. The group uses this template to create all new instances in the managed instance group. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group's updatePolicy.type to PROACTIVE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceTemplate")]
		public string InstanceTemplate { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#instanceGroupManager for managed instance groups.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceGroupManager")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceGroupManager";
		
		/// <summary>
		/// Pagination behavior of the listManagedInstances API method for this managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listManagedInstancesResults")]
		public System.Nullable<InstanceGroupManagerListManagedInstancesResults> ListManagedInstancesResults { get; set; }
		
		/// <summary>
		/// The name of the managed instance group. The name must be 1-63 characters long, and comply with RFC1035.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Named ports configured for the Instance Groups complementary to this Instance Group Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namedPorts")]
		public NamedPort[] NamedPorts { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the region where the managed instance group resides (for regional resources).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] The URL for this managed instance group. The server defines this URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="statefulPolicy")]
		public StatefulPolicy StatefulPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public InstanceGroupManagerStatus Status { get; set; }
		
		/// <summary>
		/// The URLs for all TargetPool resources to which instances in the instanceGroup field are added. The target pools automatically apply to all of the instances in the managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPools")]
		public string[] TargetPools { get; set; }
		
		/// <summary>
		/// The target number of running instances for this managed instance group. You can reduce this number by using the instanceGroupManager deleteInstances or abandonInstances methods. Resizing the group also changes this number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetSize")]
		public System.Nullable<System.Int32> TargetSize { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatePolicy")]
		public InstanceGroupManagerUpdatePolicy UpdatePolicy { get; set; }
		
		/// <summary>
		/// Specifies the instance templates used by this managed instance group to create instances. Each version is defined by an instanceTemplate and a name. Every version can appear at most once per instance group. This field overrides the top-level instanceTemplate field. Read more about the relationships between these fields. Exactly one version must leave the targetSize field unset. That version will be applied to all remaining instances. For more information, read about canary updates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="versions")]
		public InstanceGroupManagerVersion[] Versions { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of a zone where the managed instance group is located (for zonal resources).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerAutoHealingPolicy
	{
		
		/// <summary>
		/// The URL for the health check that signals autohealing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthCheck")]
		public string HealthCheck { get; set; }
		
		/// <summary>
		/// The initial delay is the number of seconds that a new VM takes to initialize and run its startup script. During a VM's initial delay period, the MIG ignores unsuccessful health checks because the VM might be in the startup process. This prevents the MIG from prematurely recreating a VM. If the health check receives a healthy response during the initial delay, it indicates that the startup process is complete and the VM is ready. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="initialDelaySec")]
		public System.Nullable<System.Int32> InitialDelaySec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerActionsSummary
	{
		
		/// <summary>
		/// [Output Only] The total number of instances in the managed instance group that are scheduled to be abandoned. Abandoning an instance removes it from the managed instance group without deleting it.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="abandoning")]
		public System.Nullable<System.Int32> Abandoning { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are scheduled to be created or are currently being created. If the group fails to create any of these instances, it tries again until it creates the instance successfully. If you have disabled creation retries, this field will not be populated; instead, the creatingWithoutRetries field will be populated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creating")]
		public System.Nullable<System.Int32> Creating { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances that the managed instance group will attempt to create. The group attempts to create each instance only once. If the group fails to create any of these instances, it decreases the group's targetSize value accordingly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creatingWithoutRetries")]
		public System.Nullable<System.Int32> CreatingWithoutRetries { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are scheduled to be deleted or are currently being deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleting")]
		public System.Nullable<System.Int32> Deleting { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are running and have no scheduled actions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="none")]
		public System.Nullable<System.Int32> None { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are scheduled to be recreated or are currently being being recreated. Recreating an instance deletes the existing root persistent disk and creates a new disk from the image that is defined in the instance template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recreating")]
		public System.Nullable<System.Int32> Recreating { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are being reconfigured with properties that do not require a restart or a recreate action. For example, setting or removing target pools for the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="refreshing")]
		public System.Nullable<System.Int32> Refreshing { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are scheduled to be restarted or are currently being restarted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="restarting")]
		public System.Nullable<System.Int32> Restarting { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are scheduled to be resumed or are currently being resumed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resuming")]
		public System.Nullable<System.Int32> Resuming { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are scheduled to be started or are currently being started.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="starting")]
		public System.Nullable<System.Int32> Starting { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are scheduled to be stopped or are currently being stopped.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stopping")]
		public System.Nullable<System.Int32> Stopping { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are scheduled to be suspended or are currently being suspended.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suspending")]
		public System.Nullable<System.Int32> Suspending { get; set; }
		
		/// <summary>
		/// [Output Only] The number of instances in the managed instance group that are being verified. See the managedInstances[].currentAction property in the listManagedInstances method documentation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="verifying")]
		public System.Nullable<System.Int32> Verifying { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerInstanceLifecyclePolicy
	{
		
		/// <summary>
		/// A bit indicating whether to forcefully apply the group's latest configuration when repairing a VM. Valid options are: - NO (default): If configuration updates are available, they are not forcefully applied during repair. Instead, configuration updates are applied according to the group's update policy. - YES: If configuration updates are available, they are applied during repair. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceUpdateOnRepair")]
		public System.Nullable<InstanceGroupManagerInstanceLifecyclePolicyForceUpdateOnRepair> ForceUpdateOnRepair { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstanceGroupManagerInstanceLifecyclePolicyForceUpdateOnRepair
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		YES = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstanceGroupManagerListManagedInstancesResults
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAGELESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PAGINATED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatefulPolicy
	{
		
		/// <summary>
		/// Configuration of preserved resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preservedState")]
		public StatefulPolicyPreservedState PreservedState { get; set; }
	}
	
	/// <summary>
	/// Configuration of preserved resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatefulPolicyPreservedState
	{
		
		/// <summary>
		/// Disks created on the instances that will be preserved on instance delete, update, etc. This map is keyed with the device names of the disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public System.Collections.Generic.Dictionary<string, StatefulPolicyPreservedStateDiskDevice> Disks { get; set; }
		
		/// <summary>
		/// External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalIPs")]
		public System.Collections.Generic.Dictionary<string, StatefulPolicyPreservedStateNetworkIp> ExternalIPs { get; set; }
		
		/// <summary>
		/// Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalIPs")]
		public System.Collections.Generic.Dictionary<string, StatefulPolicyPreservedStateNetworkIp> InternalIPs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatefulPolicyPreservedStateDiskDevice
	{
		
		/// <summary>
		/// These stateful disks will never be deleted during autohealing, update or VM instance recreate operations. This flag is used to configure if the disk should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted. Note: disks attached in READ_ONLY mode cannot be auto-deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoDelete")]
		public System.Nullable<StatefulPolicyPreservedStateDiskDeviceAutoDelete> AutoDelete { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum StatefulPolicyPreservedStateDiskDeviceAutoDelete
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEVER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ON_PERMANENT_INSTANCE_DELETION = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatefulPolicyPreservedStateNetworkIp
	{
		
		/// <summary>
		/// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoDelete")]
		public StatefulPolicyPreservedStateDiskDeviceAutoDelete AutoDelete { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerStatus
	{
		
		/// <summary>
		/// [Output Only] The URL of the Autoscaler that targets this instance group manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoscaler")]
		public string Autoscaler { get; set; }
		
		/// <summary>
		/// [Output Only] A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isStable")]
		public System.Nullable<System.Boolean> IsStable { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateful")]
		public InstanceGroupManagerStatusStateful Stateful { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="versionTarget")]
		public InstanceGroupManagerStatusVersionTarget VersionTarget { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerStatusStateful
	{
		
		/// <summary>
		/// [Output Only] A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful configuration even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasStatefulConfig")]
		public System.Nullable<System.Boolean> HasStatefulConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="perInstanceConfigs")]
		public InstanceGroupManagerStatusStatefulPerInstanceConfigs PerInstanceConfigs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerStatusStatefulPerInstanceConfigs
	{
		
		/// <summary>
		/// A bit indicating if all of the group's per-instance configurations (listed in the output of a listPerInstanceConfigs API call) have status EFFECTIVE or there are no per-instance-configs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allEffective")]
		public System.Nullable<System.Boolean> AllEffective { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerStatusVersionTarget
	{
		
		/// <summary>
		/// [Output Only] A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances' target version are specified by version field on Instance Group Manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isReached")]
		public System.Nullable<System.Boolean> IsReached { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerUpdatePolicy
	{
		
		/// <summary>
		/// The instance redistribution policy for regional managed instance groups. Valid values are: - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region. - NONE: For non-autoscaled groups, proactive redistribution is disabled. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceRedistributionType")]
		public System.Nullable<InstanceGroupManagerUpdatePolicyInstanceRedistributionType> InstanceRedistributionType { get; set; }
		
		/// <summary>
		/// Encapsulates numeric value that can be either absolute or relative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxSurge")]
		public FixedOrPercent MaxSurge { get; set; }
		
		/// <summary>
		/// Encapsulates numeric value that can be either absolute or relative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxUnavailable")]
		public FixedOrPercent MaxUnavailable { get; set; }
		
		/// <summary>
		/// Minimal action to be taken on an instance. Use this option to minimize disruption as much as possible or to apply a more disruptive action than is necessary. - To limit disruption as much as possible, set the minimal action to REFRESH. If your update requires a more disruptive action, Compute Engine performs the necessary action to execute the update. - To apply a more disruptive action than is strictly necessary, set the minimal action to RESTART or REPLACE. For example, Compute Engine does not need to restart a VM to change its metadata. But if your application reads instance metadata only when a VM is restarted, you can set the minimal action to RESTART in order to pick up metadata changes. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimalAction")]
		public System.Nullable<InstanceGroupManagerUpdatePolicyMinimalAction> MinimalAction { get; set; }
		
		/// <summary>
		/// Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to avoid restarting the VM and to limit disruption as much as possible. RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mostDisruptiveAllowedAction")]
		public InstanceGroupManagerUpdatePolicyMinimalAction MostDisruptiveAllowedAction { get; set; }
		
		/// <summary>
		/// What action should be used to replace instances. See minimal_action.REPLACE
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="replacementMethod")]
		public System.Nullable<InstanceGroupManagerUpdatePolicyReplacementMethod> ReplacementMethod { get; set; }
		
		/// <summary>
		/// The type of update process. You can specify either PROACTIVE so that the MIG automatically updates VMs to the latest configurations or OPPORTUNISTIC so that you can select the VMs that you want to update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<InstanceGroupManagerUpdatePolicyType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstanceGroupManagerUpdatePolicyInstanceRedistributionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROACTIVE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstanceGroupManagerUpdatePolicyMinimalAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REFRESH = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REPLACE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTART = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstanceGroupManagerUpdatePolicyReplacementMethod
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECREATE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUBSTITUTE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstanceGroupManagerUpdatePolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPPORTUNISTIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROACTIVE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerVersion
	{
		
		/// <summary>
		/// The URL of the instance template that is specified for this managed instance group. The group uses this template to create new instances in the managed instance group until the `targetSize` for this version is reached. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group's updatePolicy.type to PROACTIVE; in those cases, existing instances are updated until the `targetSize` for this version is reached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceTemplate")]
		public string InstanceTemplate { get; set; }
		
		/// <summary>
		/// Name of the version. Unique among all versions in the scope of this managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Encapsulates numeric value that can be either absolute or relative.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetSize")]
		public FixedOrPercent TargetSize { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InstanceGroupManagersScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, InstanceGroupManagersScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#instanceGroupManagerAggregatedList for an aggregated list of managed instance groups.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceGroupManagerAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceGroupManagerAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceGroupManagerAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersScopedList
	{
		
		/// <summary>
		/// [Output Only] The list of managed instance groups that are contained in the specified project and zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceGroupManagers")]
		public InstanceGroupManager[] InstanceGroupManagers { get; set; }
		
		/// <summary>
		/// [Output Only] The warning that replaces the list of managed instance groups when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceGroupManagersScopedListWarning Warning { get; set; }
	}
	
	public class InstanceGroupManagersScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceGroupManagersScopedListWarningData[] InstanceGroupManagersScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceGroupManagersScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class InstanceGroupManagerAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceGroupManagerAggregatedListWarningData[] InstanceGroupManagerAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceGroupManagerAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// [Output Only] A list of managed instance groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagerList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InstanceGroupManager resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InstanceGroupManager[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#instanceGroupManagerList for a list of managed instance groups.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceGroupManagerList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceGroupManagerList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceGroupManagerListWarning Warning { get; set; }
	}
	
	public class InstanceGroupManagerListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceGroupManagerListWarningData[] InstanceGroupManagerListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceGroupManagerListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersAbandonInstancesRequest
	{
		
		/// <summary>
		/// The URLs of one or more instances to abandon. This can be a full URL or a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
	}
	
	/// <summary>
	/// InstanceGroupManagers.applyUpdatesToInstances
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersApplyUpdatesRequest
	{
		
		/// <summary>
		/// Flag to update all instances instead of specified list of “instances”. If the flag is set to true then the instances may not be specified in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allInstances")]
		public System.Nullable<System.Boolean> AllInstances { get; set; }
		
		/// <summary>
		/// The list of URLs of one or more instances for which you want to apply updates. Each URL can be a full URL or a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
		
		/// <summary>
		/// The minimal action that you want to perform on each instance during the update: - REPLACE: At minimum, delete the instance and create it again. - RESTART: Stop the instance and start it again. - REFRESH: Do not stop the instance and limit disruption as much as possible. - NONE: Do not disrupt the instance at all. By default, the minimum action is NONE. If your update requires a more disruptive action than you set with this flag, the necessary action is performed to execute the update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimalAction")]
		public InstanceGroupManagerUpdatePolicyMinimalAction MinimalAction { get; set; }
		
		/// <summary>
		/// The most disruptive action that you want to perform on each instance during the update: - REPLACE: Delete the instance and create it again. - RESTART: Stop the instance and start it again. - REFRESH: Do not stop the instance and limit disruption as much as possible. - NONE: Do not disrupt the instance at all. By default, the most disruptive allowed action is REPLACE. If your update requires a more disruptive action than you set with this flag, the update request will fail.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mostDisruptiveAllowedAction")]
		public InstanceGroupManagerUpdatePolicyMinimalAction MostDisruptiveAllowedAction { get; set; }
	}
	
	/// <summary>
	/// InstanceGroupManagers.createInstances
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersCreateInstancesRequest
	{
		
		/// <summary>
		/// [Required] List of specifications of per-instance configs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public PerInstanceConfig[] Instances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PerInstanceConfig
	{
		
		/// <summary>
		/// Fingerprint of this per-instance config. This field can be used in optimistic locking. It is ignored when inserting a per-instance config. An up-to-date fingerprint must be provided in order to update an existing per-instance configuration or the field needs to be unset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// The name of a per-instance configuration and its corresponding instance. Serves as a merge key during UpdatePerInstanceConfigs operations, that is, if a per-instance configuration with the same name exists then it will be updated, otherwise a new one will be created for the VM instance with the same name. An attempt to create a per-instance configconfiguration for a VM instance that either doesn't exist or is not part of the group will result in an error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Preserved state for a given instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preservedState")]
		public PreservedState PreservedState { get; set; }
		
		/// <summary>
		/// The status of applying this per-instance configuration on the corresponding managed instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<PerInstanceConfigStatus> Status { get; set; }
	}
	
	/// <summary>
	/// Preserved state for a given instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PreservedState
	{
		
		/// <summary>
		/// Preserved disks defined for this instance. This map is keyed with the device names of the disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public System.Collections.Generic.Dictionary<string, PreservedStatePreservedDisk> Disks { get; set; }
		
		/// <summary>
		/// Preserved external IPs defined for this instance. This map is keyed with the name of the network interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalIPs")]
		public System.Collections.Generic.Dictionary<string, PreservedStatePreservedNetworkIp> ExternalIPs { get; set; }
		
		/// <summary>
		/// Preserved internal IPs defined for this instance. This map is keyed with the name of the network interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalIPs")]
		public System.Collections.Generic.Dictionary<string, PreservedStatePreservedNetworkIp> InternalIPs { get; set; }
		
		/// <summary>
		/// Preserved metadata defined for this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, string> Metadata { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PreservedStatePreservedDisk
	{
		
		/// <summary>
		/// These stateful disks will never be deleted during autohealing, update, instance recreate operations. This flag is used to configure if the disk should be deleted after it is no longer used by the group, e.g. when the given instance or the whole MIG is deleted. Note: disks attached in READ_ONLY mode cannot be auto-deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoDelete")]
		public StatefulPolicyPreservedStateDiskDeviceAutoDelete AutoDelete { get; set; }
		
		/// <summary>
		/// The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public AttachedDiskMode Mode { get; set; }
		
		/// <summary>
		/// The URL of the disk resource that is stateful and should be attached to the VM instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PreservedStatePreservedNetworkIp
	{
		
		/// <summary>
		/// These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoDelete")]
		public StatefulPolicyPreservedStateDiskDeviceAutoDelete AutoDelete { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public PreservedStatePreservedNetworkIpIpAddress IpAddress { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PreservedStatePreservedNetworkIpIpAddress
	{
		
		/// <summary>
		/// The URL of the reservation for this IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// An IPv4 internal network address to assign to the instance for this network interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="literal")]
		public string Literal { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PerInstanceConfigStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPLYING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EFFECTIVE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNAPPLIED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNAPPLIED_DELETION = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersDeleteInstancesRequest
	{
		
		/// <summary>
		/// The URLs of one or more instances to delete. This can be a full URL or a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME]. Queued instances do not have URL and can be deleted only by name. One cannot specify both URLs and names in a single request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
		
		/// <summary>
		/// Specifies whether the request should proceed despite the inclusion of instances that are not members of the group or that are already in the process of being deleted or abandoned. If this field is set to `false` and such an instance is specified in the request, the operation fails. The operation always fails if the request contains a malformed instance URL or a reference to an instance that exists in a zone or region other than the group's zone or region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="skipInstancesOnValidationError")]
		public System.Nullable<System.Boolean> SkipInstancesOnValidationError { get; set; }
	}
	
	/// <summary>
	/// InstanceGroupManagers.deletePerInstanceConfigs
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersDeletePerInstanceConfigsReq
	{
		
		/// <summary>
		/// The list of instance names for which we want to delete per-instance configs on this managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="names")]
		public string[] Names { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersListErrorsResponse
	{
		
		/// <summary>
		/// [Output Only] The list of errors of the managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InstanceManagedByIgmError[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceManagedByIgmError
	{
		
		[System.Runtime.Serialization.DataMember(Name="error")]
		public InstanceManagedByIgmErrorManagedInstanceError Error { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="instanceActionDetails")]
		public InstanceManagedByIgmErrorInstanceActionDetails InstanceActionDetails { get; set; }
		
		/// <summary>
		/// [Output Only] The time that this error occurred. This value is in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public string Timestamp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceManagedByIgmErrorManagedInstanceError
	{
		
		/// <summary>
		/// [Output Only] Error code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// [Output Only] Error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceManagedByIgmErrorInstanceActionDetails
	{
		
		/// <summary>
		/// [Output Only] Action that managed instance group was executing on the instance when the error occurred. Possible values:
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public System.Nullable<InstanceManagedByIgmErrorInstanceActionDetailsAction> Action { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the instance. The URL can be set even if the instance has not yet been created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public ManagedInstanceVersion Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstanceManagedByIgmErrorInstanceActionDetailsAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABANDONING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING_WITHOUT_RETRIES = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RECREATING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REFRESHING = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTARTING = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESUMING = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTING = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPING = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUSPENDING = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VERIFYING = 12,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManagedInstanceVersion
	{
		
		/// <summary>
		/// [Output Only] The intended template of the instance. This field is empty when current_action is one of { DELETING, ABANDONING }.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceTemplate")]
		public string InstanceTemplate { get; set; }
		
		/// <summary>
		/// [Output Only] Name of the version.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersListManagedInstancesResponse
	{
		
		/// <summary>
		/// [Output Only] The list of instances in the managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedInstances")]
		public ManagedInstance[] ManagedInstances { get; set; }
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// A Managed Instance resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManagedInstance
	{
		
		/// <summary>
		/// [Output Only] The current action that the managed instance group has scheduled for the instance. Possible values: - NONE The instance is running, and the managed instance group does not have any scheduled actions for this instance. - CREATING The managed instance group is creating this instance. If the group fails to create this instance, it will try again until it is successful. - CREATING_WITHOUT_RETRIES The managed instance group is attempting to create this instance only once. If the group fails to create this instance, it does not try again and the group's targetSize value is decreased instead. - RECREATING The managed instance group is recreating this instance. - DELETING The managed instance group is permanently deleting this instance. - ABANDONING The managed instance group is abandoning this instance. The instance will be removed from the instance group and from any target pools that are associated with this group. - RESTARTING The managed instance group is restarting the instance. - REFRESHING The managed instance group is applying configuration changes to the instance without stopping it. For example, the group can update the target pool list for an instance without stopping that instance. - VERIFYING The managed instance group has created the instance and it is in the process of being verified. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentAction")]
		public InstanceManagedByIgmErrorInstanceActionDetailsAction CurrentAction { get; set; }
		
		/// <summary>
		/// [Output only] The unique identifier for this resource. This field is empty when instance does not exist.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the instance. The URL can exist even if the instance has not yet been created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
		
		/// <summary>
		/// [Output Only] Health state of the instance per health-check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceHealth")]
		public ManagedInstanceInstanceHealth[] InstanceHealth { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the instance. This field is empty when the instance does not exist.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceStatus")]
		public InstanceStatus InstanceStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lastAttempt")]
		public ManagedInstanceLastAttempt LastAttempt { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the instance. The name always exists even if the instance has not yet been created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Preserved state for a given instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preservedStateFromConfig")]
		public PreservedState PreservedStateFromConfig { get; set; }
		
		/// <summary>
		/// Preserved state for a given instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preservedStateFromPolicy")]
		public PreservedState PreservedStateFromPolicy { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="version")]
		public ManagedInstanceVersion Version { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManagedInstanceInstanceHealth
	{
		
		/// <summary>
		/// [Output Only] The current detailed instance health state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detailedHealthState")]
		public System.Nullable<ManagedInstanceInstanceHealthDetailedHealthState> DetailedHealthState { get; set; }
		
		/// <summary>
		/// [Output Only] The URL for the health check that verifies whether the instance is healthy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthCheck")]
		public string HealthCheck { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ManagedInstanceInstanceHealthDetailedHealthState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DRAINING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HEALTHY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TIMEOUT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNHEALTHY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ManagedInstanceLastAttempt
	{
		
		/// <summary>
		/// [Output Only] Encountered errors during the last attempt to create or delete the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public ManagedInstanceLastAttemptErrors Errors { get; set; }
	}
	
	public class ManagedInstanceLastAttemptErrors
	{
		
		/// <summary>
		/// [Output Only] The array of errors encountered while processing this operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public ManagedInstanceLastAttemptErrorsErrors[] ManagedInstanceLastAttemptErrorsErrors { get; set; }
	}
	
	public class ManagedInstanceLastAttemptErrorsErrors
	{
		
		/// <summary>
		/// [Output Only] The error type identifier for this error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// [Output Only] An optional list of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorDetails")]
		public ManagedInstanceLastAttemptErrorsErrorsErrorDetails[] ManagedInstanceLastAttemptErrorsErrorsErrorDetails { get; set; }
		
		/// <summary>
		/// [Output Only] Indicates the field in the request that caused the error. This property is optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// [Output Only] An optional, human-readable error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ManagedInstanceLastAttemptErrorsErrorsErrorDetails
	{
		
		/// <summary>
		/// Describes the cause of the error with structured details. Example of an error when contacting the "pubsub.googleapis.com" API when it is not enabled: { "reason": "API_DISABLED" "domain": "googleapis.com" "metadata": { "resource": "projects/123", "service": "pubsub.googleapis.com" } } This response indicates that the pubsub.googleapis.com API is not enabled. Example of an error that is returned when attempting to create a Spanner instance in a region that is out of stock: { "reason": "STOCKOUT" "domain": "spanner.googleapis.com", "metadata": { "availableRegions": "us-central1,us-east2" } }
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorInfo")]
		public ErrorInfo ErrorInfo { get; set; }
		
		/// <summary>
		/// Provides links to documentation or for performing an out of band action. For example, if a quota check failed with an error indicating the calling project hasn't enabled the accessed service, this can contain a URL pointing directly to the right place in the developer console to flip the bit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="help")]
		public Help Help { get; set; }
		
		/// <summary>
		/// Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localizedMessage")]
		public LocalizedMessage LocalizedMessage { get; set; }
		
		/// <summary>
		/// Additional details for quota exceeded error for resource quota.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quotaInfo")]
		public QuotaExceededInfo QuotaInfo { get; set; }
	}
	
	/// <summary>
	/// Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocalizedMessage
	{
		
		/// <summary>
		/// The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: "en-US", "fr-CH", "es-MX"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locale")]
		public string Locale { get; set; }
		
		/// <summary>
		/// The localized error message in the above locale.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// Additional details for quota exceeded error for resource quota.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class QuotaExceededInfo
	{
		
		/// <summary>
		/// The map holding related quota dimensions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dimensions")]
		public System.Collections.Generic.Dictionary<string, string> Dimensions { get; set; }
		
		/// <summary>
		/// Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="futureLimit")]
		public System.Nullable<System.Double> FutureLimit { get; set; }
		
		/// <summary>
		/// Current effective quota limit. The limit's unit depends on the quota type or metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limit")]
		public System.Nullable<System.Double> Limit { get; set; }
		
		/// <summary>
		/// The name of the quota limit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limitName")]
		public string LimitName { get; set; }
		
		/// <summary>
		/// The Compute Engine quota metric name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metricName")]
		public string MetricName { get; set; }
		
		/// <summary>
		/// Rollout status of the future quota limit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rolloutStatus")]
		public System.Nullable<QuotaExceededInfoRolloutStatus> RolloutStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum QuotaExceededInfoRolloutStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_PROGRESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ROLLOUT_STATUS_UNSPECIFIED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersListPerInstanceConfigsResp
	{
		
		/// <summary>
		/// [Output Only] The list of PerInstanceConfig.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public PerInstanceConfig[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceGroupManagersListPerInstanceConfigsRespWarning Warning { get; set; }
	}
	
	public class InstanceGroupManagersListPerInstanceConfigsRespWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceGroupManagersListPerInstanceConfigsRespWarningData[] InstanceGroupManagersListPerInstanceConfigsRespWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceGroupManagersListPerInstanceConfigsRespWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// InstanceGroupManagers.patchPerInstanceConfigs
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersPatchPerInstanceConfigsReq
	{
		
		/// <summary>
		/// The list of per-instance configurations to insert or patch on this managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perInstanceConfigs")]
		public PerInstanceConfig[] PerInstanceConfigs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersRecreateInstancesRequest
	{
		
		/// <summary>
		/// The URLs of one or more instances to recreate. This can be a full URL or a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersSetInstanceTemplateRequest
	{
		
		/// <summary>
		/// The URL of the instance template that is specified for this managed instance group. The group uses this template to create all new instances in the managed instance group. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group's updatePolicy.type to PROACTIVE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceTemplate")]
		public string InstanceTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersSetTargetPoolsRequest
	{
		
		/// <summary>
		/// The fingerprint of the target pools information. Use this optional property to prevent conflicts when multiple users change the target pools settings concurrently. Obtain the fingerprint with the instanceGroupManagers.get method. Then, include the fingerprint in your request to ensure that you do not overwrite changes that were applied from another concurrent request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// The list of target pool URLs that instances in this managed instance group belong to. The managed instance group applies these target pools to all of the instances in the group. Existing instances and new instances in the group all receive these target pool settings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPools")]
		public string[] TargetPools { get; set; }
	}
	
	/// <summary>
	/// InstanceGroupManagers.updatePerInstanceConfigs
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupManagersUpdatePerInstanceConfigsReq
	{
		
		/// <summary>
		/// The list of per-instance configurations to insert or patch on this managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perInstanceConfigs")]
		public PerInstanceConfig[] PerInstanceConfigs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupsAddInstancesRequest
	{
		
		/// <summary>
		/// The list of instances to add to the instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public InstanceReference[] Instances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceReference
	{
		
		/// <summary>
		/// The URL for a specific instance. @required compute.instancegroups.addInstances/removeInstances
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupsListInstances
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InstanceWithNamedPorts resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InstanceWithNamedPorts[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#instanceGroupsListInstances for the list of instances in the specified instance group.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceGroupsListInstances")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceGroupsListInstances";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceGroupsListInstancesWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceWithNamedPorts
	{
		
		/// <summary>
		/// [Output Only] The URL of the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
		
		/// <summary>
		/// [Output Only] The named ports that belong to this instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namedPorts")]
		public NamedPort[] NamedPorts { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public InstanceStatus Status { get; set; }
	}
	
	public class InstanceGroupsListInstancesWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceGroupsListInstancesWarningData[] InstanceGroupsListInstancesWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceGroupsListInstancesWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupsListInstancesRequest
	{
		
		/// <summary>
		/// A filter for the state of the instances in the instance group. Valid options are ALL or RUNNING. If you do not specify this parameter the list includes all instances regardless of their state.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceState")]
		public System.Nullable<InstanceGroupsListInstancesRequestInstanceState> InstanceState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstanceGroupsListInstancesRequestInstanceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupsRemoveInstancesRequest
	{
		
		/// <summary>
		/// The list of instances to remove from the instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public InstanceReference[] Instances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceGroupsSetNamedPortsRequest
	{
		
		/// <summary>
		/// The fingerprint of the named ports information for this instance group. Use this optional property to prevent conflicts when multiple users change the named ports settings concurrently. Obtain the fingerprint with the instanceGroups.get method. Then, include the fingerprint in your request to ensure that you do not overwrite changes that were applied from another concurrent request. A request with an incorrect fingerprint will fail with error 412 conditionNotMet.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// The list of named ports to set for this instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namedPorts")]
		public NamedPort[] NamedPorts { get; set; }
	}
	
	/// <summary>
	/// Contains a list of instances.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Instance resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Instance[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#instanceList for lists of Instance resources.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceListWarning Warning { get; set; }
	}
	
	public class InstanceListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceListWarningData[] InstanceListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of instance referrers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceListReferrers
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Reference resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Reference[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#instanceListReferrers for lists of Instance referrers.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceListReferrers")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceListReferrers";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceListReferrersWarning Warning { get; set; }
	}
	
	/// <summary>
	/// Represents a reference to a resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Reference
	{
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#reference for references.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#reference")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#reference";
		
		/// <summary>
		/// A description of the reference type with no implied semantics. Possible values include: 1. MEMBER_OF 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="referenceType")]
		public string ReferenceType { get; set; }
		
		/// <summary>
		/// URL of the resource which refers to the target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="referrer")]
		public string Referrer { get; set; }
		
		/// <summary>
		/// URL of the resource to which this reference points.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	public class InstanceListReferrersWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceListReferrersWarningData[] InstanceListReferrersWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceListReferrersWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceMoveRequest
	{
		
		/// <summary>
		/// The URL of the destination zone to move the instance. This can be a full or partial URL. For example, the following are all valid URLs to a zone: - https://www.googleapis.com/compute/v1/projects/project/zones/zone - projects/project/zones/zone - zones/zone 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationZone")]
		public string DestinationZone { get; set; }
		
		/// <summary>
		/// The URL of the target instance to move. This can be a full or partial URL. For example, the following are all valid URLs to an instance: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /instances/instance - projects/project/zones/zone/instances/instance - zones/zone/instances/instance 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetInstance")]
		public string TargetInstance { get; set; }
	}
	
	/// <summary>
	/// Represents an Instance Template resource. Google Compute Engine has two Instance Template resources: * [Global](/compute/docs/reference/rest/v1/instanceTemplates) * [Regional](/compute/docs/reference/rest/v1/regionInstanceTemplates) You can reuse a global instance template in different regions whereas you can use a regional instance template in a specified region only. If you want to reduce cross-region dependency or achieve data residency, use a regional instance template. To create VMs, managed instance groups, and reservations, you can use either global or regional instance templates. For more information, read Instance Templates.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceTemplate
	{
		
		/// <summary>
		/// [Output Only] The creation timestamp for this instance template in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] A unique identifier for this instance template. The server defines this identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#instanceTemplate for instance templates.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceTemplate")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceTemplate";
		
		/// <summary>
		/// Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public InstanceProperties Properties { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the instance template resides. Only applicable for regional resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] The URL for this instance template. The server defines this URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The source instance used to create the template. You can provide this as a partial or full URL to the resource. For example, the following are valid values: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /instances/instance - projects/project/zones/zone/instances/instance 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceInstance")]
		public string SourceInstance { get; set; }
		
		/// <summary>
		/// A specification of the parameters to use when creating the instance template from a source instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceInstanceParams")]
		public SourceInstanceParams SourceInstanceParams { get; set; }
	}
	
	/// <summary>
	/// A specification of the parameters to use when creating the instance template from a source instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceInstanceParams
	{
		
		/// <summary>
		/// Attached disks configuration. If not provided, defaults are applied: For boot disk and any other R/W disks, the source images for each disk will be used. For read-only disks, they will be attached in read-only mode. Local SSD disks will be created as blank volumes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskConfigs")]
		public DiskInstantiationConfig[] DiskConfigs { get; set; }
	}
	
	/// <summary>
	/// Contains a list of InstanceTemplatesScopedList.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceTemplateAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InstanceTemplatesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, InstanceTemplatesScopedList> Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceTemplateAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceTemplateAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceTemplateAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceTemplatesScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of instance templates that are contained within the specified project and zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceTemplates")]
		public InstanceTemplate[] InstanceTemplates { get; set; }
		
		/// <summary>
		/// [Output Only] An informational warning that replaces the list of instance templates when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceTemplatesScopedListWarning Warning { get; set; }
	}
	
	public class InstanceTemplatesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceTemplatesScopedListWarningData[] InstanceTemplatesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceTemplatesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class InstanceTemplateAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceTemplateAggregatedListWarningData[] InstanceTemplateAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceTemplateAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A list of instance templates.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstanceTemplateList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InstanceTemplate resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InstanceTemplate[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#instanceTemplatesListResponse for instance template lists.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#instanceTemplateList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#instanceTemplateList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InstanceTemplateListWarning Warning { get; set; }
	}
	
	public class InstanceTemplateListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InstanceTemplateListWarningData[] InstanceTemplateListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InstanceTemplateListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesAddResourcePoliciesRequest
	{
		
		/// <summary>
		/// Resource policies to be added to this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public string[] ResourcePolicies { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesBulkInsertOperationMetadata
	{
		
		/// <summary>
		/// Status information per location (location name is key). Example key: zones/us-central1-a
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perLocationStatus")]
		public System.Collections.Generic.Dictionary<string, BulkInsertOperationStatus> PerLocationStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesGetEffectiveFirewallsResponse
	{
		
		/// <summary>
		/// Effective firewalls from firewall policies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallPolicys")]
		public InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy[] FirewallPolicys { get; set; }
		
		/// <summary>
		/// Effective firewalls on the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewalls")]
		public Firewall[] Firewalls { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy
	{
		
		/// <summary>
		/// [Output Only] Deprecated, please use short name instead. The display name of the firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The rules that apply to the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public FirewallPolicyRule[] Rules { get; set; }
		
		/// <summary>
		/// [Output Only] The short name of the firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
		
		/// <summary>
		/// [Output Only] The type of the firewall policy. Can be one of HIERARCHY, NETWORK, NETWORK_REGIONAL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIERARCHY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETWORK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETWORK_REGIONAL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesRemoveResourcePoliciesRequest
	{
		
		/// <summary>
		/// Resource policies to be removed from this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public string[] ResourcePolicies { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesSetLabelsRequest
	{
		
		/// <summary>
		/// Fingerprint of the previous set of labels for this resource, used to prevent conflicts. Provide the latest fingerprint value when making a request to add or change labels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesSetMachineResourcesRequest
	{
		
		/// <summary>
		/// A list of the type and count of accelerator cards attached to the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestAccelerators")]
		public AcceleratorConfig[] GuestAccelerators { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesSetMachineTypeRequest
	{
		
		/// <summary>
		/// Full or partial URL of the machine type resource. See Machine Types for a full list of machine types. For example: zones/us-central1-f/machineTypes/n1-standard-1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesSetMinCpuPlatformRequest
	{
		
		/// <summary>
		/// Minimum cpu/platform this instance should be started at.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minCpuPlatform")]
		public string MinCpuPlatform { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesSetNameRequest
	{
		
		/// <summary>
		/// The current name of this resource, used to prevent conflicts. Provide the latest name when making a request to change name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentName")]
		public string CurrentName { get; set; }
		
		/// <summary>
		/// The name to be applied to the instance. Needs to be RFC 1035 compliant.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesSetSecurityPolicyRequest
	{
		
		/// <summary>
		/// The network interfaces that the security policy will be applied to. Network interfaces use the nicN naming format. You can only set a security policy for network interfaces with an access config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaces")]
		public string[] NetworkInterfaces { get; set; }
		
		/// <summary>
		/// A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securityPolicy")]
		public string SecurityPolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesSetServiceAccountRequest
	{
		
		/// <summary>
		/// Email address of the service account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// The list of scopes to be made available for this service account.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scopes")]
		public string[] Scopes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InstancesStartWithEncryptionKeyRequest
	{
		
		/// <summary>
		/// Array of disks associated with this instance that are protected with a customer-supplied encryption key. In order to start the instance, the disk url and its corresponding key must be provided. If the disk is not protected with a customer-supplied encryption key it should not be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public CustomerEncryptionKeyProtectedDisk[] Disks { get; set; }
	}
	
	/// <summary>
	/// Represents an Interconnect resource. An Interconnect resource is a dedicated connection between the Google Cloud network and your on-premises network. For more information, read the Dedicated Interconnect Overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Interconnect
	{
		
		/// <summary>
		/// Administrative status of the interconnect. When this is set to true, the Interconnect is functional and can carry traffic. When set to false, no packets can be carried over the interconnect and no BGP routes are exchanged over it. By default, the status is set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminEnabled")]
		public System.Nullable<System.Boolean> AdminEnabled { get; set; }
		
		/// <summary>
		/// [Output only] List of features available for this Interconnect connection, which can take one of the following values: - MACSEC If present then the Interconnect connection is provisioned on MACsec capable hardware ports. If not present then the Interconnect connection is provisioned on non-MACsec capable ports and MACsec isn't supported and enabling MACsec fails.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableFeatures")]
		public string[] AvailableFeatures { get; set; }
		
		/// <summary>
		/// [Output Only] A list of CircuitInfo objects, that describe the individual circuits in this LAG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="circuitInfos")]
		public InterconnectCircuitInfo[] CircuitInfos { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// Customer name, to put in the Letter of Authorization as the party authorized to request a crossconnect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerName")]
		public string CustomerName { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] A list of outages expected for this Interconnect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expectedOutages")]
		public InterconnectOutageNotification[] ExpectedOutages { get; set; }
		
		/// <summary>
		/// [Output Only] IP address configured on the Google side of the Interconnect link. This can be used only for ping tests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="googleIpAddress")]
		public string GoogleIpAddress { get; set; }
		
		/// <summary>
		/// [Output Only] Google reference ID to be used when raising support tickets with Google or otherwise to debug backend connectivity issues.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="googleReferenceId")]
		public string GoogleReferenceId { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] A list of the URLs of all InterconnectAttachments configured to use this Interconnect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interconnectAttachments")]
		public string[] InterconnectAttachments { get; set; }
		
		/// <summary>
		/// Type of interconnect, which can take one of the following values: - PARTNER: A partner-managed interconnection shared between customers though a partner. - DEDICATED: A dedicated physical interconnection with the customer. Note that a value IT_PRIVATE has been deprecated in favor of DEDICATED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interconnectType")]
		public System.Nullable<InterconnectInterconnectType> InterconnectType { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#interconnect for interconnects.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#interconnect")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#interconnect";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this Interconnect, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an Interconnect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels for this resource. These can only be added or modified by the setLabels method. Each label key/value pair must comply with RFC1035. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Type of link requested, which can take one of the following values: - LINK_TYPE_ETHERNET_10G_LR: A 10G Ethernet with LR optics - LINK_TYPE_ETHERNET_100G_LR: A 100G Ethernet with LR optics. Note that this field indicates the speed of each of the links in the bundle, not the speed of the entire bundle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkType")]
		public System.Nullable<InterconnectLinkType> LinkType { get; set; }
		
		/// <summary>
		/// URL of the InterconnectLocation object that represents where this connection is to be provisioned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Configuration information for enabling Media Access Control security (MACsec) on this Cloud Interconnect connection between Google and your on-premises router.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macsec")]
		public InterconnectMacsec Macsec { get; set; }
		
		/// <summary>
		/// Enable or disable MACsec on this Interconnect connection. MACsec enablement fails if the MACsec object is not specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macsecEnabled")]
		public System.Nullable<System.Boolean> MacsecEnabled { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Email address to contact the customer NOC for operations and maintenance notifications regarding this Interconnect. If specified, this will be used for notifications in addition to all other forms described, such as Cloud Monitoring logs alerting and Cloud Notifications. This field is required for users who sign up for Cloud Interconnect using workforce identity federation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nocContactEmail")]
		public string NocContactEmail { get; set; }
		
		/// <summary>
		/// [Output Only] The current status of this Interconnect's functionality, which can take one of the following values: - OS_ACTIVE: A valid Interconnect, which is turned up and is ready to use. Attachments may be provisioned on this Interconnect. - OS_UNPROVISIONED: An Interconnect that has not completed turnup. No attachments may be provisioned on this Interconnect. - OS_UNDER_MAINTENANCE: An Interconnect that is undergoing internal maintenance. No attachments may be provisioned or updated on this Interconnect. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationalStatus")]
		public System.Nullable<InterconnectOperationalStatus> OperationalStatus { get; set; }
		
		/// <summary>
		/// [Output Only] IP address configured on the customer side of the Interconnect link. The customer should configure this IP address during turnup when prompted by Google NOC. This can be used only for ping tests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerIpAddress")]
		public string PeerIpAddress { get; set; }
		
		/// <summary>
		/// [Output Only] Number of links actually provisioned in this interconnect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisionedLinkCount")]
		public System.Nullable<System.Int32> ProvisionedLinkCount { get; set; }
		
		/// <summary>
		/// Indicates that this is a Cross-Cloud Interconnect. This field specifies the location outside of Google's network that the interconnect is connected to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteLocation")]
		public string RemoteLocation { get; set; }
		
		/// <summary>
		/// Optional. List of features requested for this Interconnect connection, which can take one of the following values: - MACSEC If specified then the connection is created on MACsec capable hardware ports. If not specified, the default value is false, which allocates non-MACsec capable ports first if available. This parameter can be provided only with Interconnect INSERT. It isn't valid for Interconnect PATCH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestedFeatures")]
		public string[] RequestedFeatures { get; set; }
		
		/// <summary>
		/// Target number of physical links in the link bundle, as requested by the customer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestedLinkCount")]
		public System.Nullable<System.Int32> RequestedLinkCount { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzs")]
		public System.Nullable<System.Boolean> SatisfiesPzs { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The current state of Interconnect functionality, which can take one of the following values: - ACTIVE: The Interconnect is valid, turned up and ready to use. Attachments may be provisioned on this Interconnect. - UNPROVISIONED: The Interconnect has not completed turnup. No attachments may be provisioned on this Interconnect. - UNDER_MAINTENANCE: The Interconnect is undergoing internal maintenance. No attachments may be provisioned or updated on this Interconnect. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<InterconnectState> State { get; set; }
	}
	
	/// <summary>
	/// Describes a single physical circuit between the Customer and Google. CircuitInfo objects are created by Google, so all fields are output only.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectCircuitInfo
	{
		
		/// <summary>
		/// Customer-side demarc ID for this circuit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerDemarcId")]
		public string CustomerDemarcId { get; set; }
		
		/// <summary>
		/// Google-assigned unique ID for this circuit. Assigned at circuit turn-up.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="googleCircuitId")]
		public string GoogleCircuitId { get; set; }
		
		/// <summary>
		/// Google-side demarc ID for this circuit. Assigned at circuit turn-up and provided by Google to the customer in the LOA.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="googleDemarcId")]
		public string GoogleDemarcId { get; set; }
	}
	
	/// <summary>
	/// Description of a planned outage on this Interconnect.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectOutageNotification
	{
		
		/// <summary>
		/// If issue_type is IT_PARTIAL_OUTAGE, a list of the Google-side circuit IDs that will be affected.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="affectedCircuits")]
		public string[] AffectedCircuits { get; set; }
		
		/// <summary>
		/// A description about the purpose of the outage.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Scheduled end time for the outage (milliseconds since Unix epoch).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// Form this outage is expected to take, which can take one of the following values: - OUTAGE: The Interconnect may be completely out of service for some or all of the specified window. - PARTIAL_OUTAGE: Some circuits comprising the Interconnect as a whole should remain up, but with reduced bandwidth. Note that the versions of this enum prefixed with "IT_" have been deprecated in favor of the unprefixed values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="issueType")]
		public System.Nullable<InterconnectOutageNotificationIssueType> IssueType { get; set; }
		
		/// <summary>
		/// Unique identifier for this outage notification.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The party that generated this notification, which can take the following value: - GOOGLE: this notification as generated by Google. Note that the value of NSRC_GOOGLE has been deprecated in favor of GOOGLE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public System.Nullable<InterconnectOutageNotificationSource> Source { get; set; }
		
		/// <summary>
		/// Scheduled start time for the outage (milliseconds since Unix epoch).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// State of this notification, which can take one of the following values: - ACTIVE: This outage notification is active. The event could be in the past, present, or future. See start_time and end_time for scheduling. - CANCELLED: The outage associated with this notification was cancelled before the outage was due to start. - COMPLETED: The outage associated with this notification is complete. Note that the versions of this enum prefixed with "NS_" have been deprecated in favor of the unprefixed values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<InterconnectOutageNotificationState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectOutageNotificationIssueType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IT_OUTAGE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IT_PARTIAL_OUTAGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OUTAGE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTIAL_OUTAGE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectOutageNotificationSource
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GOOGLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NSRC_GOOGLE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectOutageNotificationState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NS_ACTIVE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NS_CANCELED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectInterconnectType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEDICATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IT_PRIVATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTNER = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectLinkType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINK_TYPE_ETHERNET_100G_LR = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINK_TYPE_ETHERNET_10G_LR = 1,
	}
	
	/// <summary>
	/// Configuration information for enabling Media Access Control security (MACsec) on this Cloud Interconnect connection between Google and your on-premises router.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectMacsec
	{
		
		/// <summary>
		/// If set to true, the Interconnect connection is configured with a should-secure MACsec security policy, that allows the Google router to fallback to cleartext traffic if the MKA session cannot be established. By default, the Interconnect connection is configured with a must-secure security policy that drops all traffic if the MKA session cannot be established with your router.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failOpen")]
		public System.Nullable<System.Boolean> FailOpen { get; set; }
		
		/// <summary>
		/// Required. A keychain placeholder describing a set of named key objects along with their start times. A MACsec CKN/CAK is generated for each key in the key chain. Google router automatically picks the key with the most recent startTime when establishing or re-establishing a MACsec secure link.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preSharedKeys")]
		public InterconnectMacsecPreSharedKey[] PreSharedKeys { get; set; }
	}
	
	/// <summary>
	/// Describes a pre-shared key used to setup MACsec in static connectivity association key (CAK) mode.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectMacsecPreSharedKey
	{
		
		/// <summary>
		/// Required. A name for this pre-shared key. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A RFC3339 timestamp on or after which the key is valid. startTime can be in the future. If the keychain has a single key, startTime can be omitted. If the keychain has multiple keys, startTime is mandatory for each key. The start times of keys must be in increasing order. The start times of two consecutive keys must be at least 6 hours apart.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectOperationalStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OS_ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OS_UNPROVISIONED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNPROVISIONED = 1,
	}
	
	/// <summary>
	/// Represents an Interconnect Attachment (VLAN) resource. You can use Interconnect attachments (VLANS) to connect your Virtual Private Cloud networks to your on-premises networks through an Interconnect. For more information, read Creating VLAN Attachments.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectAttachment
	{
		
		/// <summary>
		/// Determines whether this Attachment will carry packets. Not present for PARTNER_PROVIDER.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adminEnabled")]
		public System.Nullable<System.Boolean> AdminEnabled { get; set; }
		
		/// <summary>
		/// Provisioned bandwidth capacity for the interconnect attachment. For attachments of type DEDICATED, the user can set the bandwidth. For attachments of type PARTNER, the Google Partner that is operating the interconnect must set the bandwidth. Output only for PARTNER type, mutable for PARTNER_PROVIDER and DEDICATED, and can take one of the following values: - BPS_50M: 50 Mbit/s - BPS_100M: 100 Mbit/s - BPS_200M: 200 Mbit/s - BPS_300M: 300 Mbit/s - BPS_400M: 400 Mbit/s - BPS_500M: 500 Mbit/s - BPS_1G: 1 Gbit/s - BPS_2G: 2 Gbit/s - BPS_5G: 5 Gbit/s - BPS_10G: 10 Gbit/s - BPS_20G: 20 Gbit/s - BPS_50G: 50 Gbit/s 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bandwidth")]
		public System.Nullable<InterconnectAttachmentBandwidth> Bandwidth { get; set; }
		
		/// <summary>
		/// This field is not available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="candidateIpv6Subnets")]
		public string[] CandidateIpv6Subnets { get; set; }
		
		/// <summary>
		/// Up to 16 candidate prefixes that can be used to restrict the allocation of cloudRouterIpAddress and customerRouterIpAddress for this attachment. All prefixes must be within link-local address space (169.254.0.0/16) and must be /29 or shorter (/28, /27, etc). Google will attempt to select an unused /29 from the supplied candidate prefix(es). The request will fail if all possible /29s are in use on Google's edge. If not supplied, Google will randomly select an unused /29 from all of link-local space.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="candidateSubnets")]
		public string[] CandidateSubnets { get; set; }
		
		/// <summary>
		/// [Output Only] IPv4 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudRouterIpAddress")]
		public string CloudRouterIpAddress { get; set; }
		
		/// <summary>
		/// [Output Only] IPv6 address + prefix length to be configured on Cloud Router Interface for this interconnect attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudRouterIpv6Address")]
		public string CloudRouterIpv6Address { get; set; }
		
		/// <summary>
		/// This field is not available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudRouterIpv6InterfaceId")]
		public string CloudRouterIpv6InterfaceId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="configurationConstraints")]
		public InterconnectAttachmentConfigurationConstraints ConfigurationConstraints { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// [Output Only] IPv4 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerRouterIpAddress")]
		public string CustomerRouterIpAddress { get; set; }
		
		/// <summary>
		/// [Output Only] IPv6 address + prefix length to be configured on the customer router subinterface for this interconnect attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerRouterIpv6Address")]
		public string CustomerRouterIpv6Address { get; set; }
		
		/// <summary>
		/// This field is not available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customerRouterIpv6InterfaceId")]
		public string CustomerRouterIpv6InterfaceId { get; set; }
		
		/// <summary>
		/// [Output Only] Dataplane version for this InterconnectAttachment. This field is only present for Dataplane version 2 and higher. Absence of this field in the API output indicates that the Dataplane is version 1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dataplaneVersion")]
		public System.Nullable<System.Int32> DataplaneVersion { get; set; }
		
		/// <summary>
		/// An optional description of this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Desired availability domain for the attachment. Only available for type PARTNER, at creation time, and can take one of the following values: - AVAILABILITY_DOMAIN_ANY - AVAILABILITY_DOMAIN_1 - AVAILABILITY_DOMAIN_2 For improved reliability, customers should configure a pair of attachments, one per availability domain. The selected availability domain will be provided to the Partner via the pairing key, so that the provisioned circuit will lie in the specified domain. If not specified, the value will default to AVAILABILITY_DOMAIN_ANY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="edgeAvailabilityDomain")]
		public System.Nullable<InterconnectAttachmentEdgeAvailabilityDomain> EdgeAvailabilityDomain { get; set; }
		
		/// <summary>
		/// Indicates the user-supplied encryption option of this VLAN attachment (interconnectAttachment). Can only be specified at attachment creation for PARTNER or DEDICATED attachments. Possible values are: - NONE - This is the default value, which means that the VLAN attachment carries unencrypted traffic. VMs are able to send traffic to, or receive traffic from, such a VLAN attachment. - IPSEC - The VLAN attachment carries only encrypted traffic that is encrypted by an IPsec device, such as an HA VPN gateway or third-party IPsec VPN. VMs cannot directly send traffic to, or receive traffic from, such a VLAN attachment. To use *HA VPN over Cloud Interconnect*, the VLAN attachment must be created with this option. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryption")]
		public System.Nullable<InterconnectAttachmentEncryption> Encryption { get; set; }
		
		/// <summary>
		/// [Output Only] Google reference ID, to be used when raising support tickets with Google or otherwise to debug backend connectivity issues. [Deprecated] This field is not used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="googleReferenceId")]
		public string GoogleReferenceId { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// URL of the underlying Interconnect object that this attachment's traffic will traverse through.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interconnect")]
		public string Interconnect { get; set; }
		
		/// <summary>
		/// A list of URLs of addresses that have been reserved for the VLAN attachment. Used only for the VLAN attachment that has the encryption option as IPSEC. The addresses must be regional internal IP address ranges. When creating an HA VPN gateway over the VLAN attachment, if the attachment is configured to use a regional internal IP address, then the VPN gateway's IP address is allocated from the IP address range specified here. For example, if the HA VPN gateway's interface 0 is paired to this VLAN attachment, then a regional internal IP address for the VPN gateway interface 0 will be allocated from the IP address specified for this VLAN attachment. If this field is not specified when creating the VLAN attachment, then later on when creating an HA VPN gateway on this VLAN attachment, the HA VPN gateway's IP address is allocated from the regional external IP address pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipsecInternalAddresses")]
		public string[] IpsecInternalAddresses { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#interconnectAttachment for interconnect attachments.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#interconnectAttachment")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#interconnectAttachment";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this InterconnectAttachment, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an InterconnectAttachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels for this resource. These can only be added or modified by the setLabels method. Each label key/value pair must comply with RFC1035. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Maximum Transmission Unit (MTU), in bytes, of packets passing through this interconnect attachment. Only 1440 and 1500 are allowed. If not specified, the value will default to 1440.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mtu")]
		public System.Nullable<System.Int32> Mtu { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] The current status of whether or not this interconnect attachment is functional, which can take one of the following values: - OS_ACTIVE: The attachment has been turned up and is ready to use. - OS_UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationalStatus")]
		public InterconnectOperationalStatus OperationalStatus { get; set; }
		
		/// <summary>
		/// [Output only for type PARTNER. Input only for PARTNER_PROVIDER. Not present for DEDICATED]. The opaque identifier of a PARTNER attachment used to initiate provisioning with a selected partner. Of the form "XXXXX/region/domain"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pairingKey")]
		public string PairingKey { get; set; }
		
		/// <summary>
		/// Optional BGP ASN for the router supplied by a Layer 3 Partner if they configured BGP on behalf of the customer. Output only for PARTNER type, input only for PARTNER_PROVIDER, not available for DEDICATED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partnerAsn")]
		public string PartnerAsn { get; set; }
		
		/// <summary>
		/// Informational metadata about Partner attachments from Partners to display to customers. These fields are propagated from PARTNER_PROVIDER attachments to their corresponding PARTNER attachments.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partnerMetadata")]
		public InterconnectAttachmentPartnerMetadata PartnerMetadata { get; set; }
		
		/// <summary>
		/// Information for an interconnect attachment when this belongs to an interconnect of type DEDICATED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateInterconnectInfo")]
		public InterconnectAttachmentPrivateInfo PrivateInterconnectInfo { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional interconnect attachment resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] If the attachment is on a Cross-Cloud Interconnect connection, this field contains the interconnect's remote location service provider. Example values: "Amazon Web Services" "Microsoft Azure". The field is set only for attachments on Cross-Cloud Interconnect connections. Its value is copied from the InterconnectRemoteLocation remoteService field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteService")]
		public string RemoteService { get; set; }
		
		/// <summary>
		/// URL of the Cloud Router to be used for dynamic routing. This router must be in the same region as this InterconnectAttachment. The InterconnectAttachment will automatically connect the Interconnect to the network & region within which the Cloud Router is configured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="router")]
		public string Router { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzs")]
		public System.Nullable<System.Boolean> SatisfiesPzs { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The stack type for this interconnect attachment to identify whether the IPv6 feature is enabled or not. If not specified, IPV4_ONLY will be used. This field can be both set at interconnect attachments creation and update interconnect attachment operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackType")]
		public NetworkInterfaceStackType StackType { get; set; }
		
		/// <summary>
		/// [Output Only] The current state of this attachment's functionality. Enum values ACTIVE and UNPROVISIONED are shared by DEDICATED/PRIVATE, PARTNER, and PARTNER_PROVIDER interconnect attachments, while enum values PENDING_PARTNER, PARTNER_REQUEST_RECEIVED, and PENDING_CUSTOMER are used for only PARTNER and PARTNER_PROVIDER interconnect attachments. This state can take one of the following values: - ACTIVE: The attachment has been turned up and is ready to use. - UNPROVISIONED: The attachment is not ready to use yet, because turnup is not complete. - PENDING_PARTNER: A newly-created PARTNER attachment that has not yet been configured on the Partner side. - PARTNER_REQUEST_RECEIVED: A PARTNER attachment is in the process of provisioning after a PARTNER_PROVIDER attachment was created that references it. - PENDING_CUSTOMER: A PARTNER or PARTNER_PROVIDER attachment that is waiting for a customer to activate it. - DEFUNCT: The attachment was deleted externally and is no longer functional. This could be because the associated Interconnect was removed, or because the other side of a Partner attachment was deleted. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<InterconnectAttachmentState> State { get; set; }
		
		/// <summary>
		/// Length of the IPv4 subnet mask. Allowed values: - 29 (default) - 30 The default value is 29, except for Cross-Cloud Interconnect connections that use an InterconnectRemoteLocation with a constraints.subnetLengthRange.min equal to 30. For example, connections that use an Azure remote location fall into this category. In these cases, the default value is 30, and requesting 29 returns an error. Where both 29 and 30 are allowed, 29 is preferred, because it gives Google Cloud Support more debugging visibility. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetLength")]
		public System.Nullable<System.Int32> SubnetLength { get; set; }
		
		/// <summary>
		/// The type of interconnect attachment this is, which can take one of the following values: - DEDICATED: an attachment to a Dedicated Interconnect. - PARTNER: an attachment to a Partner Interconnect, created by the customer. - PARTNER_PROVIDER: an attachment to a Partner Interconnect, created by the partner. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<InterconnectAttachmentType> Type { get; set; }
		
		/// <summary>
		/// The IEEE 802.1Q VLAN tag for this attachment, in the range 2-4093. Only specified at creation time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vlanTag8021q")]
		public System.Nullable<System.Int32> VlanTag8021q { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectAttachmentBandwidth
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_100M = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_10G = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_1G = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_200M = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_20G = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_2G = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_300M = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_400M = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_500M = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_50G = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_50M = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BPS_5G = 11,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectAttachmentConfigurationConstraints
	{
		
		/// <summary>
		/// [Output Only] Whether the attachment's BGP session requires/allows/disallows BGP MD5 authentication. This can take one of the following values: MD5_OPTIONAL, MD5_REQUIRED, MD5_UNSUPPORTED. For example, a Cross-Cloud Interconnect connection to a remote cloud provider that requires BGP MD5 authentication has the interconnectRemoteLocation attachment_configuration_constraints.bgp_md5 field set to MD5_REQUIRED, and that property is propagated to the attachment. Similarly, if BGP MD5 is MD5_UNSUPPORTED, an error is returned if MD5 is requested.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bgpMd5")]
		public System.Nullable<InterconnectAttachmentConfigurationConstraintsBgpMd5> BgpMd5 { get; set; }
		
		/// <summary>
		/// [Output Only] List of ASN ranges that the remote location is known to support. Formatted as an array of inclusive ranges {min: min-value, max: max-value}. For example, [{min: 123, max: 123}, {min: 64512, max: 65534}] allows the peer ASN to be 123 or anything in the range 64512-65534. This field is only advisory. Although the API accepts other ranges, these are the ranges that we recommend.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bgpPeerAsnRanges")]
		public InterconnectAttachmentConfigurationConstraintsBgpPeerASNRange[] BgpPeerAsnRanges { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectAttachmentConfigurationConstraintsBgpMd5
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MD5_OPTIONAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MD5_REQUIRED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MD5_UNSUPPORTED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectAttachmentConfigurationConstraintsBgpPeerASNRange
	{
		
		[System.Runtime.Serialization.DataMember(Name="max")]
		public System.Nullable<System.UInt32> Max { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="min")]
		public System.Nullable<System.UInt32> Min { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectAttachmentEdgeAvailabilityDomain
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVAILABILITY_DOMAIN_1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVAILABILITY_DOMAIN_2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVAILABILITY_DOMAIN_ANY = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectAttachmentEncryption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPSEC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 1,
	}
	
	/// <summary>
	/// Informational metadata about Partner attachments from Partners to display to customers. These fields are propagated from PARTNER_PROVIDER attachments to their corresponding PARTNER attachments.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectAttachmentPartnerMetadata
	{
		
		/// <summary>
		/// Plain text name of the Interconnect this attachment is connected to, as displayed in the Partner's portal. For instance "Chicago 1". This value may be validated to match approved Partner values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interconnectName")]
		public string InterconnectName { get; set; }
		
		/// <summary>
		/// Plain text name of the Partner providing this attachment. This value may be validated to match approved Partner values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partnerName")]
		public string PartnerName { get; set; }
		
		/// <summary>
		/// URL of the Partner's portal for this Attachment. Partners may customise this to be a deep link to the specific resource on the Partner portal. This value may be validated to match approved Partner values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portalUrl")]
		public string PortalUrl { get; set; }
	}
	
	/// <summary>
	/// Information for an interconnect attachment when this belongs to an interconnect of type DEDICATED.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectAttachmentPrivateInfo
	{
		
		/// <summary>
		/// [Output Only] 802.1q encapsulation tag to be used for traffic between Google and the customer, going to and from this network and region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag8021q")]
		public System.Nullable<System.UInt32> Tag8021q { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectAttachmentState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFUNCT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTNER_REQUEST_RECEIVED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_CUSTOMER = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_PARTNER = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNPROVISIONED = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectAttachmentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEDICATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTNER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PARTNER_PROVIDER = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectAttachmentAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InterconnectAttachmentsScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, InterconnectAttachmentsScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#interconnectAttachmentAggregatedList for aggregated lists of interconnect attachments.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#interconnectAttachmentAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#interconnectAttachmentAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InterconnectAttachmentAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectAttachmentsScopedList
	{
		
		/// <summary>
		/// A list of interconnect attachments contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interconnectAttachments")]
		public InterconnectAttachment[] InterconnectAttachments { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of addresses when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InterconnectAttachmentsScopedListWarning Warning { get; set; }
	}
	
	public class InterconnectAttachmentsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InterconnectAttachmentsScopedListWarningData[] InterconnectAttachmentsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InterconnectAttachmentsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class InterconnectAttachmentAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InterconnectAttachmentAggregatedListWarningData[] InterconnectAttachmentAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InterconnectAttachmentAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Response to the list request, and contains a list of interconnect attachments.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectAttachmentList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InterconnectAttachment resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InterconnectAttachment[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#interconnectAttachmentList for lists of interconnect attachments.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#interconnectAttachmentList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#interconnectAttachmentList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InterconnectAttachmentListWarning Warning { get; set; }
	}
	
	public class InterconnectAttachmentListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InterconnectAttachmentListWarningData[] InterconnectAttachmentListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InterconnectAttachmentListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Diagnostics information about the Interconnect connection, which contains detailed and current technical information about Google's side of the connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectDiagnostics
	{
		
		/// <summary>
		/// A list of InterconnectDiagnostics.ARPEntry objects, describing individual neighbors currently seen by the Google router in the ARP cache for the Interconnect. This will be empty when the Interconnect is not bundled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="arpCaches")]
		public InterconnectDiagnosticsARPEntry[] ArpCaches { get; set; }
		
		/// <summary>
		/// The aggregation type of the bundle interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bundleAggregationType")]
		public System.Nullable<InterconnectDiagnosticsBundleAggregationType> BundleAggregationType { get; set; }
		
		/// <summary>
		/// The operational status of the bundle interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bundleOperationalStatus")]
		public System.Nullable<InterconnectDiagnosticsBundleOperationalStatus> BundleOperationalStatus { get; set; }
		
		/// <summary>
		/// A list of InterconnectDiagnostics.LinkStatus objects, describing the status for each link on the Interconnect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public InterconnectDiagnosticsLinkStatus[] Links { get; set; }
		
		/// <summary>
		/// The MAC address of the Interconnect's bundle interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAddress")]
		public string MacAddress { get; set; }
	}
	
	/// <summary>
	/// Describing the ARP neighbor entries seen on this link
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectDiagnosticsARPEntry
	{
		
		/// <summary>
		/// The IP address of this ARP neighbor.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// The MAC address of this ARP neighbor.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macAddress")]
		public string MacAddress { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectDiagnosticsBundleAggregationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BUNDLE_AGGREGATION_TYPE_LACP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BUNDLE_AGGREGATION_TYPE_STATIC = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectDiagnosticsBundleOperationalStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BUNDLE_OPERATIONAL_STATUS_DOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BUNDLE_OPERATIONAL_STATUS_UP = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectDiagnosticsLinkStatus
	{
		
		/// <summary>
		/// A list of InterconnectDiagnostics.ARPEntry objects, describing the ARP neighbor entries seen on this link. This will be empty if the link is bundled
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="arpCaches")]
		public InterconnectDiagnosticsARPEntry[] ArpCaches { get; set; }
		
		/// <summary>
		/// The unique ID for this link assigned during turn up by Google.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="circuitId")]
		public string CircuitId { get; set; }
		
		/// <summary>
		/// The Demarc address assigned by Google and provided in the LoA.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="googleDemarc")]
		public string GoogleDemarc { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="lacpStatus")]
		public InterconnectDiagnosticsLinkLACPStatus LacpStatus { get; set; }
		
		/// <summary>
		/// Describes the status of MACsec encryption on the link.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macsec")]
		public InterconnectDiagnosticsMacsecStatus Macsec { get; set; }
		
		/// <summary>
		/// The operational status of the link.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationalStatus")]
		public System.Nullable<InterconnectDiagnosticsLinkStatusOperationalStatus> OperationalStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="receivingOpticalPower")]
		public InterconnectDiagnosticsLinkOpticalPower ReceivingOpticalPower { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="transmittingOpticalPower")]
		public InterconnectDiagnosticsLinkOpticalPower TransmittingOpticalPower { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectDiagnosticsLinkLACPStatus
	{
		
		/// <summary>
		/// System ID of the port on Google's side of the LACP exchange.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="googleSystemId")]
		public string GoogleSystemId { get; set; }
		
		/// <summary>
		/// System ID of the port on the neighbor's side of the LACP exchange.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="neighborSystemId")]
		public string NeighborSystemId { get; set; }
		
		/// <summary>
		/// The state of a LACP link, which can take one of the following values: - ACTIVE: The link is configured and active within the bundle. - DETACHED: The link is not configured within the bundle. This means that the rest of the object should be empty. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<InterconnectDiagnosticsLinkLACPStatusState> State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectDiagnosticsLinkLACPStatusState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DETACHED = 1,
	}
	
	/// <summary>
	/// Describes the status of MACsec encryption on the link.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectDiagnosticsMacsecStatus
	{
		
		/// <summary>
		/// Indicates the Connectivity Association Key Name (CKN) currently being used if MACsec is operational.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ckn")]
		public string Ckn { get; set; }
		
		/// <summary>
		/// Indicates whether or not MACsec is operational on this link.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operational")]
		public System.Nullable<System.Boolean> Operational { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectDiagnosticsLinkStatusOperationalStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINK_OPERATIONAL_STATUS_DOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINK_OPERATIONAL_STATUS_UP = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectDiagnosticsLinkOpticalPower
	{
		
		/// <summary>
		/// The status of the current value when compared to the warning and alarm levels for the receiving or transmitting transceiver. Possible states include: - OK: The value has not crossed a warning threshold. - LOW_WARNING: The value has crossed below the low warning threshold. - HIGH_WARNING: The value has crossed above the high warning threshold. - LOW_ALARM: The value has crossed below the low alarm threshold. - HIGH_ALARM: The value has crossed above the high alarm threshold. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<InterconnectDiagnosticsLinkOpticalPowerState> State { get; set; }
		
		/// <summary>
		/// Value of the current receiving or transmitting optical power, read in dBm. Take a known good optical value, give it a 10% margin and trigger warnings relative to that value. In general, a -7dBm warning and a -11dBm alarm are good optical value estimates for most links.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public System.Nullable<System.Single> Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectDiagnosticsLinkOpticalPowerState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIGH_ALARM = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIGH_WARNING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOW_ALARM = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOW_WARNING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OK = 4,
	}
	
	/// <summary>
	/// Response to the list request, and contains a list of interconnects.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Interconnect resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Interconnect[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#interconnectList for lists of interconnects.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#interconnectList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#interconnectList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InterconnectListWarning Warning { get; set; }
	}
	
	public class InterconnectListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InterconnectListWarningData[] InterconnectListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InterconnectListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents an Interconnect Attachment (VLAN) Location resource. You can use this resource to find location details about an Interconnect attachment (VLAN). For more information about interconnect attachments, read Creating VLAN Attachments.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectLocation
	{
		
		/// <summary>
		/// [Output Only] The postal address of the Point of Presence, each line in the address is separated by a newline character.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		/// <summary>
		/// [Output Only] Availability zone for this InterconnectLocation. Within a metropolitan area (metro), maintenance will not be simultaneously scheduled in more than one availability zone. Example: "zone1" or "zone2".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availabilityZone")]
		public string AvailabilityZone { get; set; }
		
		/// <summary>
		/// [Output only] List of features available at this InterconnectLocation, which can take one of the following values: - MACSEC 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableFeatures")]
		public string[] AvailableFeatures { get; set; }
		
		/// <summary>
		/// [Output only] List of link types available at this InterconnectLocation, which can take one of the following values: - LINK_TYPE_ETHERNET_10G_LR - LINK_TYPE_ETHERNET_100G_LR 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableLinkTypes")]
		public InterconnectLinkType[] AvailableLinkTypes { get; set; }
		
		/// <summary>
		/// [Output Only] Metropolitan area designator that indicates which city an interconnect is located. For example: "Chicago, IL", "Amsterdam, Netherlands".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// [Output Only] Continent for this location, which can take one of the following values: - AFRICA - ASIA_PAC - EUROPE - NORTH_AMERICA - SOUTH_AMERICA 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="continent")]
		public System.Nullable<InterconnectLocationContinent> Continent { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// [Output Only] An optional description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the provider for this facility (e.g., EQUINIX).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="facilityProvider")]
		public string FacilityProvider { get; set; }
		
		/// <summary>
		/// [Output Only] A provider-assigned Identifier for this facility (e.g., Ashburn-DC1).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="facilityProviderFacilityId")]
		public string FacilityProviderFacilityId { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#interconnectLocation for interconnect locations.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#interconnectLocation")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#interconnectLocation";
		
		/// <summary>
		/// [Output Only] Name of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] The peeringdb identifier for this facility (corresponding with a netfac type in peeringdb).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peeringdbFacilityId")]
		public string PeeringdbFacilityId { get; set; }
		
		/// <summary>
		/// [Output Only] A list of InterconnectLocation.RegionInfo objects, that describe parameters pertaining to the relation between this InterconnectLocation and various Google Cloud regions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="regionInfos")]
		public InterconnectLocationRegionInfo[] RegionInfos { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The status of this InterconnectLocation, which can take one of the following values: - CLOSED: The InterconnectLocation is closed and is unavailable for provisioning new Interconnects. - AVAILABLE: The InterconnectLocation is available for provisioning new Interconnects. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<InterconnectLocationStatus> Status { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportsPzs")]
		public System.Nullable<System.Boolean> SupportsPzs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectLocationContinent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AFRICA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASIA_PAC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		C_AFRICA = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		C_ASIA_PAC = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		C_EUROPE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		C_NORTH_AMERICA = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		C_SOUTH_AMERICA = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EUROPE = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORTH_AMERICA = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOUTH_AMERICA = 9,
	}
	
	/// <summary>
	/// Information about any potential InterconnectAttachments between an Interconnect at a specific InterconnectLocation, and a specific Cloud Region.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectLocationRegionInfo
	{
		
		/// <summary>
		/// Expected round-trip time in milliseconds, from this InterconnectLocation to a VM in this region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expectedRttMs")]
		public string ExpectedRttMs { get; set; }
		
		/// <summary>
		/// Identifies the network presence of this location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationPresence")]
		public System.Nullable<InterconnectLocationRegionInfoLocationPresence> LocationPresence { get; set; }
		
		/// <summary>
		/// URL for the region of this location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectLocationRegionInfoLocationPresence
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL_REGION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LP_GLOBAL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LP_LOCAL_REGION = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectLocationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVAILABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOSED = 1,
	}
	
	/// <summary>
	/// Response to the list request, and contains a list of interconnect locations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectLocationList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InterconnectLocation resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InterconnectLocation[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#interconnectLocationList for lists of interconnect locations.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#interconnectLocationList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#interconnectLocationList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InterconnectLocationListWarning Warning { get; set; }
	}
	
	public class InterconnectLocationListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InterconnectLocationListWarningData[] InterconnectLocationListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InterconnectLocationListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// MACsec configuration information for the Interconnect connection. Contains the generated Connectivity Association Key Name (CKN) and the key (CAK) for this Interconnect connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectMacsecConfig
	{
		
		/// <summary>
		/// A keychain placeholder describing a set of named key objects along with their start times. A MACsec CKN/CAK is generated for each key in the key chain. Google router automatically picks the key with the most recent startTime when establishing or re-establishing a MACsec secure link.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preSharedKeys")]
		public InterconnectMacsecConfigPreSharedKey[] PreSharedKeys { get; set; }
	}
	
	/// <summary>
	/// Describes a pre-shared key used to setup MACsec in static connectivity association key (CAK) mode.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectMacsecConfigPreSharedKey
	{
		
		/// <summary>
		/// An auto-generated Connectivity Association Key (CAK) for this key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cak")]
		public string Cak { get; set; }
		
		/// <summary>
		/// An auto-generated Connectivity Association Key Name (CKN) for this key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ckn")]
		public string Ckn { get; set; }
		
		/// <summary>
		/// User provided name for this pre-shared key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// User provided timestamp on or after which this key is valid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	/// <summary>
	/// Represents a Cross-Cloud Interconnect Remote Location resource. You can use this resource to find remote location details about an Interconnect attachment (VLAN).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectRemoteLocation
	{
		
		/// <summary>
		/// [Output Only] The postal address of the Point of Presence, each line in the address is separated by a newline character.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address")]
		public string Address { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="attachmentConfigurationConstraints")]
		public InterconnectAttachmentConfigurationConstraints AttachmentConfigurationConstraints { get; set; }
		
		/// <summary>
		/// [Output Only] Metropolitan area designator that indicates which city an interconnect is located. For example: "Chicago, IL", "Amsterdam, Netherlands".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="constraints")]
		public InterconnectRemoteLocationConstraints Constraints { get; set; }
		
		/// <summary>
		/// [Output Only] Continent for this location, which can take one of the following values: - AFRICA - ASIA_PAC - EUROPE - NORTH_AMERICA - SOUTH_AMERICA 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="continent")]
		public System.Nullable<InterconnectRemoteLocationContinent> Continent { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// [Output Only] An optional description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the provider for this facility (e.g., EQUINIX).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="facilityProvider")]
		public string FacilityProvider { get; set; }
		
		/// <summary>
		/// [Output Only] A provider-assigned Identifier for this facility (e.g., Ashburn-DC1).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="facilityProviderFacilityId")]
		public string FacilityProviderFacilityId { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#interconnectRemoteLocation for interconnect remote locations.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#interconnectRemoteLocation")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#interconnectRemoteLocation";
		
		/// <summary>
		/// [Output Only] Link Aggregation Control Protocol (LACP) constraints, which can take one of the following values: LACP_SUPPORTED, LACP_UNSUPPORTED
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lacp")]
		public System.Nullable<InterconnectRemoteLocationLacp> Lacp { get; set; }
		
		/// <summary>
		/// [Output Only] The maximum number of 100 Gbps ports supported in a link aggregation group (LAG). When linkType is 100 Gbps, requestedLinkCount cannot exceed max_lag_size_100_gbps.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxLagSize100Gbps")]
		public System.Nullable<System.Int32> MaxLagSize100Gbps { get; set; }
		
		/// <summary>
		/// [Output Only] The maximum number of 10 Gbps ports supported in a link aggregation group (LAG). When linkType is 10 Gbps, requestedLinkCount cannot exceed max_lag_size_10_gbps.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxLagSize10Gbps")]
		public System.Nullable<System.Int32> MaxLagSize10Gbps { get; set; }
		
		/// <summary>
		/// [Output Only] Name of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] The peeringdb identifier for this facility (corresponding with a netfac type in peeringdb).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peeringdbFacilityId")]
		public string PeeringdbFacilityId { get; set; }
		
		/// <summary>
		/// [Output Only] Permitted connections.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permittedConnections")]
		public InterconnectRemoteLocationPermittedConnections[] PermittedConnections { get; set; }
		
		/// <summary>
		/// [Output Only] Indicates the service provider present at the remote location. Example values: "Amazon Web Services", "Microsoft Azure".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteService")]
		public string RemoteService { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The status of this InterconnectRemoteLocation, which can take one of the following values: - CLOSED: The InterconnectRemoteLocation is closed and is unavailable for provisioning new Cross-Cloud Interconnects. - AVAILABLE: The InterconnectRemoteLocation is available for provisioning new Cross-Cloud Interconnects. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public InterconnectLocationStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectRemoteLocationConstraints
	{
		
		/// <summary>
		/// [Output Only] Port pair remote location constraints, which can take one of the following values: PORT_PAIR_UNCONSTRAINED_REMOTE_LOCATION, PORT_PAIR_MATCHING_REMOTE_LOCATION. GCP's API refers only to individual ports, but the UI uses this field when ordering a pair of ports, to prevent users from accidentally ordering something that is incompatible with their cloud provider. Specifically, when ordering a redundant pair of Cross-Cloud Interconnect ports, and one of them uses a remote location with portPairMatchingRemoteLocation set to matching, the UI requires that both ports use the same remote location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portPairRemoteLocation")]
		public System.Nullable<InterconnectRemoteLocationConstraintsPortPairRemoteLocation> PortPairRemoteLocation { get; set; }
		
		/// <summary>
		/// [Output Only] Port pair VLAN constraints, which can take one of the following values: PORT_PAIR_UNCONSTRAINED_VLAN, PORT_PAIR_MATCHING_VLAN
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portPairVlan")]
		public System.Nullable<InterconnectRemoteLocationConstraintsPortPairVlan> PortPairVlan { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subnetLengthRange")]
		public InterconnectRemoteLocationConstraintsSubnetLengthRange SubnetLengthRange { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectRemoteLocationConstraintsPortPairRemoteLocation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PORT_PAIR_MATCHING_REMOTE_LOCATION = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PORT_PAIR_UNCONSTRAINED_REMOTE_LOCATION = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectRemoteLocationConstraintsPortPairVlan
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PORT_PAIR_MATCHING_VLAN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PORT_PAIR_UNCONSTRAINED_VLAN = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectRemoteLocationConstraintsSubnetLengthRange
	{
		
		[System.Runtime.Serialization.DataMember(Name="max")]
		public System.Nullable<System.Int32> Max { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="min")]
		public System.Nullable<System.Int32> Min { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectRemoteLocationContinent
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AFRICA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASIA_PAC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EUROPE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORTH_AMERICA = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOUTH_AMERICA = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum InterconnectRemoteLocationLacp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LACP_SUPPORTED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LACP_UNSUPPORTED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectRemoteLocationPermittedConnections
	{
		
		/// <summary>
		/// [Output Only] URL of an Interconnect location that is permitted to connect to this Interconnect remote location.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interconnectLocation")]
		public string InterconnectLocation { get; set; }
	}
	
	/// <summary>
	/// Response to the list request, and contains a list of interconnect remote locations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectRemoteLocationList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InterconnectRemoteLocation resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InterconnectRemoteLocation[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#interconnectRemoteLocationList for lists of interconnect remote locations.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#interconnectRemoteLocationList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#interconnectRemoteLocationList";
		
		/// <summary>
		/// [Output Only] This token lets you get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public InterconnectRemoteLocationListWarning Warning { get; set; }
	}
	
	public class InterconnectRemoteLocationListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public InterconnectRemoteLocationListWarningData[] InterconnectRemoteLocationListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class InterconnectRemoteLocationListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Response for the InterconnectsGetDiagnosticsRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectsGetDiagnosticsResponse
	{
		
		/// <summary>
		/// Diagnostics information about the Interconnect connection, which contains detailed and current technical information about Google's side of the connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public InterconnectDiagnostics Result { get; set; }
	}
	
	/// <summary>
	/// Response for the InterconnectsGetMacsecConfigRequest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InterconnectsGetMacsecConfigResponse
	{
		
		/// <summary>
		/// end_interface: MixerGetResponseWithEtagBuilder
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// MACsec configuration information for the Interconnect connection. Contains the generated Connectivity Association Key Name (CKN) and the key (CAK) for this Interconnect connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public InterconnectMacsecConfig Result { get; set; }
	}
	
	/// <summary>
	/// Represents a License resource. A License represents billing and aggregate usage data for public and marketplace images. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class License
	{
		
		/// <summary>
		/// [Output Only] Deprecated. This field no longer reflects whether a license charges a usage fee.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chargesUseFee")]
		public System.Nullable<System.Boolean> ChargesUseFee { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional textual description of the resource; provided by the client when the resource is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#license for licenses.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#license")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#license";
		
		/// <summary>
		/// [Output Only] The unique code used to attach this license to images, snapshots, and disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseCode")]
		public string LicenseCode { get; set; }
		
		/// <summary>
		/// Name of the resource. The name must be 1-63 characters long and comply with RFC1035.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public LicenseResourceRequirements ResourceRequirements { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// If false, licenses will not be copied from the source resource when creating an image from a disk, disk from snapshot, or snapshot from disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transferable")]
		public System.Nullable<System.Boolean> Transferable { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LicenseResourceRequirements
	{
		
		/// <summary>
		/// Minimum number of guest cpus required to use the Instance. Enforced at Instance creation and Instance start.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minGuestCpuCount")]
		public System.Nullable<System.Int32> MinGuestCpuCount { get; set; }
		
		/// <summary>
		/// Minimum memory required to use the Instance. Enforced at Instance creation and Instance start.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minMemoryMb")]
		public System.Nullable<System.Int32> MinMemoryMb { get; set; }
	}
	
	/// <summary>
	/// Represents a License Code resource. A License Code is a unique identifier used to represent a license resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LicenseCode
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// [Output Only] Description of this License Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#licenseCode for licenses.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#licenseCode")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#licenseCode";
		
		/// <summary>
		/// [Output Only] URL and description aliases of Licenses with the same License Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseAlias")]
		public LicenseCodeLicenseAlias[] LicenseAlias { get; set; }
		
		/// <summary>
		/// [Output Only] Name of the resource. The name is 1-20 characters long and must be a valid 64 bit integer.
		/// Pattern: [0-9]{0,20}?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[0-9]{0,20}?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Current state of this License Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<LicenseCodeState> State { get; set; }
		
		/// <summary>
		/// [Output Only] If true, the license will remain attached when creating images or snapshots from disks. Otherwise, the license is not transferred.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="transferable")]
		public System.Nullable<System.Boolean> Transferable { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LicenseCodeLicenseAlias
	{
		
		/// <summary>
		/// [Output Only] Description of this License Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] URL of license corresponding to this License Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum LicenseCodeState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTRICTED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TERMINATED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LicensesListResponse
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of License resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public License[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public LicensesListResponseWarning Warning { get; set; }
	}
	
	public class LicensesListResponseWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public LicensesListResponseWarningData[] LicensesListResponseWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class LicensesListResponseWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LocalDisk
	{
		
		/// <summary>
		/// Specifies the number of such disks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskCount")]
		public System.Nullable<System.Int32> DiskCount { get; set; }
		
		/// <summary>
		/// Specifies the size of the disk in base-2 GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGb")]
		public System.Nullable<System.Int32> DiskSizeGb { get; set; }
		
		/// <summary>
		/// Specifies the desired disk type on the node. This disk type must be a local storage type (e.g.: local-ssd). Note that for nodeTemplates, this should be the name of the disk type and not its URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskType")]
		public string DiskType { get; set; }
	}
	
	/// <summary>
	/// Represents a machine image resource. A machine image is a Compute Engine resource that stores all the configuration, metadata, permissions, and data from one or more disks required to create a Virtual machine (VM) instance. For more information, see Machine images.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineImage
	{
		
		/// <summary>
		/// [Output Only] The creation timestamp for this machine image in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Input Only] Whether to attempt an application consistent machine image by informing the OS to prepare for the snapshot process.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestFlush")]
		public System.Nullable<System.Boolean> GuestFlush { get; set; }
		
		/// <summary>
		/// [Output Only] A unique identifier for this machine image. The server defines this identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="instanceProperties")]
		public InstanceProperties InstanceProperties { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#machineImage for machine image.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#machineImage")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#machineImage";
		
		[System.Runtime.Serialization.DataMember(Name="machineImageEncryptionKey")]
		public CustomerEncryptionKey MachineImageEncryptionKey { get; set; }
		
		/// <summary>
		/// Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzi")]
		public System.Nullable<System.Boolean> SatisfiesPzi { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzs")]
		public System.Nullable<System.Boolean> SatisfiesPzs { get; set; }
		
		/// <summary>
		/// An array of Machine Image specific properties for disks attached to the source instance
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="savedDisks")]
		public SavedDisk[] SavedDisks { get; set; }
		
		/// <summary>
		/// [Output Only] The URL for this machine image. The server defines this URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Input Only] The customer-supplied encryption key of the disks attached to the source instance. Required if the source disk is protected by a customer-supplied encryption key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDiskEncryptionKeys")]
		public SourceDiskEncryptionKey[] SourceDiskEncryptionKeys { get; set; }
		
		/// <summary>
		/// The source instance used to create the machine image. You can provide this as a partial or full URL to the resource. For example, the following are valid values: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /instances/instance - projects/project/zones/zone/instances/instance 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceInstance")]
		public string SourceInstance { get; set; }
		
		/// <summary>
		/// DEPRECATED: Please use compute#instanceProperties instead. New properties will not be added to this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceInstanceProperties")]
		public SourceInstanceProperties SourceInstanceProperties { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the machine image. One of the following values: INVALID, CREATING, READY, DELETING, and UPLOADING.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<MachineImageStatus> Status { get; set; }
		
		/// <summary>
		/// The regional or multi-regional Cloud Storage bucket location where the machine image is stored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageLocations")]
		public string[] StorageLocations { get; set; }
		
		/// <summary>
		/// [Output Only] Total size of the storage used by the machine image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="totalStorageBytes")]
		public string TotalStorageBytes { get; set; }
	}
	
	/// <summary>
	/// An instance-attached disk resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SavedDisk
	{
		
		/// <summary>
		/// [Output Only] The architecture of the attached disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public AttachedDiskArchitecture Architecture { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#savedDisk for attached disks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#savedDisk")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#savedDisk";
		
		/// <summary>
		/// Specifies a URL of the disk attached to the source instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDisk")]
		public string SourceDisk { get; set; }
		
		/// <summary>
		/// [Output Only] Size of the individual disk snapshot used by this machine image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageBytes")]
		public string StorageBytes { get; set; }
		
		/// <summary>
		/// [Output Only] An indicator whether storageBytes is in a stable state or it is being adjusted as a result of shared storage reallocation. This status can either be UPDATING, meaning the size of the snapshot is being updated, or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageBytesStatus")]
		public System.Nullable<SavedDiskStorageBytesStatus> StorageBytesStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SavedDiskStorageBytesStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UP_TO_DATE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceDiskEncryptionKey
	{
		
		[System.Runtime.Serialization.DataMember(Name="diskEncryptionKey")]
		public CustomerEncryptionKey DiskEncryptionKey { get; set; }
		
		/// <summary>
		/// URL of the disk attached to the source instance. This can be a full or valid partial URL. For example, the following are valid values: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /disks/disk - projects/project/zones/zone/disks/disk - zones/zone/disks/disk 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDisk")]
		public string SourceDisk { get; set; }
	}
	
	/// <summary>
	/// DEPRECATED: Please use compute#instanceProperties instead. New properties will not be added to this field.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SourceInstanceProperties
	{
		
		/// <summary>
		/// Enables instances created based on this machine image to send packets with source IP addresses other than their own and receive packets with destination IP addresses other than their own. If these instances will be used as an IP gateway or it will be set as the next-hop in a Route resource, specify true. If unsure, leave this set to false. See the Enable IP forwarding documentation for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canIpForward")]
		public System.Nullable<System.Boolean> CanIpForward { get; set; }
		
		/// <summary>
		/// Whether the instance created from this machine image should be protected against deletion.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deletionProtection")]
		public System.Nullable<System.Boolean> DeletionProtection { get; set; }
		
		/// <summary>
		/// An optional text description for the instances that are created from this machine image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// An array of disks that are associated with the instances that are created from this machine image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public SavedAttachedDisk[] Disks { get; set; }
		
		/// <summary>
		/// A list of guest accelerator cards' type and count to use for instances created from this machine image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestAccelerators")]
		public AcceleratorConfig[] GuestAccelerators { get; set; }
		
		/// <summary>
		/// KeyRevocationActionType of the instance. Supported options are "STOP" and "NONE". The default value is "NONE" if it is not specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyRevocationActionType")]
		public InstancePropertiesKeyRevocationActionType KeyRevocationActionType { get; set; }
		
		/// <summary>
		/// Labels to apply to instances that are created from this machine image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// The machine type to use for instances that are created from this machine image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
		
		/// <summary>
		/// A metadata key/value entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public Metadata Metadata { get; set; }
		
		/// <summary>
		/// Minimum cpu/platform to be used by instances created from this machine image. The instance may be scheduled on the specified or newer cpu/platform. Applicable values are the friendly names of CPU platforms, such as minCpuPlatform: "Intel Haswell" or minCpuPlatform: "Intel Sandy Bridge". For more information, read Specifying a Minimum CPU Platform.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minCpuPlatform")]
		public string MinCpuPlatform { get; set; }
		
		/// <summary>
		/// An array of network access configurations for this interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkInterfaces")]
		public NetworkInterface[] NetworkInterfaces { get; set; }
		
		/// <summary>
		/// Sets the scheduling options for an Instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduling")]
		public Scheduling Scheduling { get; set; }
		
		/// <summary>
		/// A list of service accounts with specified scopes. Access tokens for these service accounts are available to the instances that are created from this machine image. Use metadata queries to obtain the access tokens for these instances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAccounts")]
		public ServiceAccount[] ServiceAccounts { get; set; }
		
		/// <summary>
		/// A set of instance tags.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public Tags Tags { get; set; }
	}
	
	/// <summary>
	/// DEPRECATED: Please use compute#savedDisk instead. An instance-attached disk resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SavedAttachedDisk
	{
		
		/// <summary>
		/// Specifies whether the disk will be auto-deleted when the instance is deleted (but not when the disk is detached from the instance).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoDelete")]
		public System.Nullable<System.Boolean> AutoDelete { get; set; }
		
		/// <summary>
		/// Indicates that this is a boot disk. The virtual machine will use the first partition of the disk for its root filesystem.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="boot")]
		public System.Nullable<System.Boolean> Boot { get; set; }
		
		/// <summary>
		/// Specifies the name of the disk attached to the source instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deviceName")]
		public string DeviceName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="diskEncryptionKey")]
		public CustomerEncryptionKey DiskEncryptionKey { get; set; }
		
		/// <summary>
		/// The size of the disk in base-2 GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGb")]
		public string DiskSizeGb { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the disk type resource. For example: projects/project /zones/zone/diskTypes/pd-standard or pd-ssd
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskType")]
		public string DiskType { get; set; }
		
		/// <summary>
		/// A list of features to enable on the guest operating system. Applicable only for bootable images. Read Enabling guest operating system features to see a list of available options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestOsFeatures")]
		public GuestOsFeature[] GuestOsFeatures { get; set; }
		
		/// <summary>
		/// Specifies zero-based index of the disk that is attached to the source instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="index")]
		public System.Nullable<System.Int32> Index { get; set; }
		
		/// <summary>
		/// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interface")]
		public AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDiskInterface Interface { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#attachedDisk for attached disks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#savedAttachedDisk")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#savedAttachedDisk";
		
		/// <summary>
		/// [Output Only] Any valid publicly visible licenses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public string[] Licenses { get; set; }
		
		/// <summary>
		/// The mode in which this disk is attached to the source instance, either READ_WRITE or READ_ONLY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public AttachedDiskMode Mode { get; set; }
		
		/// <summary>
		/// Specifies a URL of the disk attached to the source instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// [Output Only] A size of the storage used by the disk's snapshot by this machine image.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageBytes")]
		public string StorageBytes { get; set; }
		
		/// <summary>
		/// [Output Only] An indicator whether storageBytes is in a stable state or it is being adjusted as a result of shared storage reallocation. This status can either be UPDATING, meaning the size of the snapshot is being updated, or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageBytesStatus")]
		public SavedDiskStorageBytesStatus StorageBytesStatus { get; set; }
		
		/// <summary>
		/// Specifies the type of the attached disk, either SCRATCH or PERSISTENT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public AttachedDiskType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum MachineImageStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPLOADING = 4,
	}
	
	/// <summary>
	/// A list of machine images.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineImageList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of MachineImage resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public MachineImage[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#machineImagesListResponse for machine image lists.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#machineImageList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#machineImageList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public MachineImageListWarning Warning { get; set; }
	}
	
	public class MachineImageListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MachineImageListWarningData[] MachineImageListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class MachineImageListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Machine Type resource. You can use specific machine types for your VM instances based on performance and pricing requirements. For more information, read Machine Types.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineType
	{
		
		/// <summary>
		/// [Output Only] A list of accelerator configurations assigned to this machine type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accelerators")]
		public MachineTypeAccelerators[] MachineTypeAccelerators { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// Deprecation status for a public resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public DeprecationStatus Deprecated { get; set; }
		
		/// <summary>
		/// [Output Only] An optional textual description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The number of virtual CPUs that are available to the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestCpus")]
		public System.Nullable<System.Int32> GuestCpus { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Deprecated] This property is deprecated and will never be populated with any relevant values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="imageSpaceGb")]
		public System.Nullable<System.Int32> ImageSpaceGb { get; set; }
		
		/// <summary>
		/// [Output Only] Whether this machine type has a shared CPU. See Shared-core machine types for more information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isSharedCpu")]
		public System.Nullable<System.Boolean> IsSharedCpu { get; set; }
		
		/// <summary>
		/// [Output Only] The type of the resource. Always compute#machineType for machine types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#machineType")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#machineType";
		
		/// <summary>
		/// [Output Only] Maximum persistent disks allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPersistentDisks")]
		public System.Nullable<System.Int32> MaximumPersistentDisks { get; set; }
		
		/// <summary>
		/// [Output Only] Maximum total persistent disks size (GB) allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maximumPersistentDisksSizeGb")]
		public string MaximumPersistentDisksSizeGb { get; set; }
		
		/// <summary>
		/// [Output Only] The amount of physical memory available to the instance, defined in MB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryMb")]
		public System.Nullable<System.Int32> MemoryMb { get; set; }
		
		/// <summary>
		/// [Output Only] Name of the resource.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] A list of extended scratch disks assigned to the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scratchDisks")]
		public MachineTypeScratchDisks[] MachineTypeScratchDisks { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the zone where the machine type resides, such as us-central1-a.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	public class MachineTypeAccelerators
	{
		
		/// <summary>
		/// Number of accelerator cards exposed to the guest.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestAcceleratorCount")]
		public System.Nullable<System.Int32> GuestAcceleratorCount { get; set; }
		
		/// <summary>
		/// The accelerator type resource name, not a full URL, e.g. nvidia-tesla-t4.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestAcceleratorType")]
		public string GuestAcceleratorType { get; set; }
	}
	
	public class MachineTypeScratchDisks
	{
		
		/// <summary>
		/// Size of the scratch disk, defined in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskGb")]
		public System.Nullable<System.Int32> DiskGb { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineTypeAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of MachineTypesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, MachineTypesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#machineTypeAggregatedList for aggregated lists of machine types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#machineTypeAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#machineTypeAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public MachineTypeAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineTypesScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of machine types contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineTypes")]
		public MachineType[] MachineTypes { get; set; }
		
		/// <summary>
		/// [Output Only] An informational warning that appears when the machine types list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public MachineTypesScopedListWarning Warning { get; set; }
	}
	
	public class MachineTypesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MachineTypesScopedListWarningData[] MachineTypesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class MachineTypesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class MachineTypeAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MachineTypeAggregatedListWarningData[] MachineTypeAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class MachineTypeAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of machine types.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MachineTypeList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of MachineType resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public MachineType[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#machineTypeList for lists of machine types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#machineTypeList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#machineTypeList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public MachineTypeListWarning Warning { get; set; }
	}
	
	public class MachineTypeListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public MachineTypeListWarningData[] MachineTypeListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class MachineTypeListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains NAT IP information of a NAT config (i.e. usage status, mode).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NatIpInfo
	{
		
		/// <summary>
		/// A list of all NAT IPs assigned to this NAT config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natIpInfoMappings")]
		public NatIpInfoNatIpInfoMapping[] NatIpInfoMappings { get; set; }
		
		/// <summary>
		/// Name of the NAT config which the NAT IP belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natName")]
		public string NatName { get; set; }
	}
	
	/// <summary>
	/// Contains information of a NAT IP.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NatIpInfoNatIpInfoMapping
	{
		
		/// <summary>
		/// Specifies whether NAT IP is auto or manual.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<NatIpInfoNatIpInfoMappingMode> Mode { get; set; }
		
		/// <summary>
		/// NAT IP address. For example: 203.0.113.11.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natIp")]
		public string NatIp { get; set; }
		
		/// <summary>
		/// Specifies whether NAT IP is currently serving at least one endpoint or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public System.Nullable<NatIpInfoNatIpInfoMappingUsage> Usage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NatIpInfoNatIpInfoMappingMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTO = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MANUAL = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NatIpInfoNatIpInfoMappingUsage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_USE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNUSED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NatIpInfoResponse
	{
		
		/// <summary>
		/// [Output Only] A list of NAT IP information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public NatIpInfo[] Result { get; set; }
	}
	
	/// <summary>
	/// Represents a VPC Network resource. Networks connect resources to each other and to the internet. For more information, read Virtual Private Cloud (VPC) Network.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Network
	{
		
		/// <summary>
		/// Deprecated in favor of subnet mode networks. The range of internal addresses that are legal on this network. This range is a CIDR specification, for example: 192.168.0.0/16. Provided by the client when the network is created.
		/// Pattern: [0-9]{1,3}(?:\.[0-9]{1,3}){3}/[0-9]{1,2}
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[0-9]{1,3}(?:\.[0-9]{1,3}){3}/[0-9]{1,2}")]
		public string IPv4Range { get; set; }
		
		/// <summary>
		/// Must be set to create a VPC network. If not set, a legacy network is created. When set to true, the VPC network is created in auto mode. When set to false, the VPC network is created in custom mode. An auto mode VPC network starts with one subnet per region. Each subnet has a predetermined range as described in Auto mode VPC network IP ranges. For custom mode VPC networks, you can add subnets using the subnetworks insert method.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoCreateSubnetworks")]
		public System.Nullable<System.Boolean> AutoCreateSubnetworks { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this field when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Enable ULA internal ipv6 on this network. Enabling this feature will assign a /48 from google defined ULA prefix fd20::/20. .
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableUlaInternalIpv6")]
		public System.Nullable<System.Boolean> EnableUlaInternalIpv6 { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the firewall policy the network is associated with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallPolicy")]
		public string FirewallPolicy { get; set; }
		
		/// <summary>
		/// [Output Only] The gateway address for default routing out of the network, selected by Google Cloud.
		/// Pattern: [0-9]{1,3}(?:\.[0-9]{1,3}){3}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gatewayIPv4")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[0-9]{1,3}(?:\.[0-9]{1,3}){3}")]
		public string GatewayIPv4 { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// When enabling ula internal ipv6, caller optionally can specify the /48 range they want from the google defined ULA prefix fd20::/20. The input must be a valid /48 ULA IPv6 address and must be within the fd20::/20. Operation will fail if the speficied /48 is already in used by another resource. If the field is not speficied, then a /48 range will be randomly allocated from fd20::/20 and returned via this field. .
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalIpv6Range")]
		public string InternalIpv6Range { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#network for networks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#network")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#network";
		
		/// <summary>
		/// Maximum Transmission Unit in bytes. The minimum value for this field is 1300 and the maximum value is 8896. The suggested value is 1500, which is the default MTU used on the Internet, or 8896 if you want to use Jumbo frames. If unspecified, the value defaults to 1460.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mtu")]
		public System.Nullable<System.Int32> Mtu { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all following characters (except for the last character) must be a dash, lowercase letter, or digit. The last character must be a lowercase letter or digit.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The network firewall policy enforcement order. Can be either AFTER_CLASSIC_FIREWALL or BEFORE_CLASSIC_FIREWALL. Defaults to AFTER_CLASSIC_FIREWALL if the field is not specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkFirewallPolicyEnforcementOrder")]
		public System.Nullable<NetworkNetworkFirewallPolicyEnforcementOrder> NetworkFirewallPolicyEnforcementOrder { get; set; }
		
		/// <summary>
		/// [Output Only] A list of network peerings for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerings")]
		public NetworkPeering[] Peerings { get; set; }
		
		/// <summary>
		/// A routing configuration attached to a network resource. The message includes the list of routers associated with the network, and a flag indicating the type of routing behavior to enforce network-wide.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routingConfig")]
		public NetworkRoutingConfig RoutingConfig { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource with the resource id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLinkWithId")]
		public string SelfLinkWithId { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined fully-qualified URLs for all subnetworks in this VPC network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetworks")]
		public string[] Subnetworks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkNetworkFirewallPolicyEnforcementOrder
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AFTER_CLASSIC_FIREWALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BEFORE_CLASSIC_FIREWALL = 1,
	}
	
	/// <summary>
	/// A network peering attached to a network resource. The message includes the peering name, peer network, peering state, and a flag indicating whether Google Compute Engine should automatically create routes for the peering.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkPeering
	{
		
		/// <summary>
		/// This field will be deprecated soon. Use the exchange_subnet_routes field instead. Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoCreateRoutes")]
		public System.Nullable<System.Boolean> AutoCreateRoutes { get; set; }
		
		/// <summary>
		/// Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exchangeSubnetRoutes")]
		public System.Nullable<System.Boolean> ExchangeSubnetRoutes { get; set; }
		
		/// <summary>
		/// Whether to export the custom routes to peer network. The default value is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportCustomRoutes")]
		public System.Nullable<System.Boolean> ExportCustomRoutes { get; set; }
		
		/// <summary>
		/// Whether subnet routes with public IP range are exported. The default value is true, all subnet routes are exported. IPv4 special-use ranges are always exported to peers and are not controlled by this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exportSubnetRoutesWithPublicIp")]
		public System.Nullable<System.Boolean> ExportSubnetRoutesWithPublicIp { get; set; }
		
		/// <summary>
		/// Whether to import the custom routes from peer network. The default value is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="importCustomRoutes")]
		public System.Nullable<System.Boolean> ImportCustomRoutes { get; set; }
		
		/// <summary>
		/// Whether subnet routes with public IP range are imported. The default value is false. IPv4 special-use ranges are always imported from peers and are not controlled by this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="importSubnetRoutesWithPublicIp")]
		public System.Nullable<System.Boolean> ImportSubnetRoutesWithPublicIp { get; set; }
		
		/// <summary>
		/// Name of this peering. Provided by the client when the peering is created. The name must comply with RFC1035. Specifically, the name must be 1-63 characters long and match regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all the following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The URL of the peer network. It can be either full URL or partial URL. The peer network may belong to a different project. If the partial URL does not contain project, it is assumed that the peer network is in the same project as the current network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// Maximum Transmission Unit in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerMtu")]
		public System.Nullable<System.Int32> PeerMtu { get; set; }
		
		/// <summary>
		/// Which IP version(s) of traffic and routes are allowed to be imported or exported between peer networks. The default value is IPV4_ONLY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackType")]
		public NetworkInterfaceStackType StackType { get; set; }
		
		/// <summary>
		/// [Output Only] State for the peering, either `ACTIVE` or `INACTIVE`. The peering is `ACTIVE` when there's a matching configuration in the peer network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<NetworkPeeringState> State { get; set; }
		
		/// <summary>
		/// [Output Only] Details about the current state of the peering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stateDetails")]
		public string StateDetails { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkPeeringState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 1,
	}
	
	/// <summary>
	/// A routing configuration attached to a network resource. The message includes the list of routers associated with the network, and a flag indicating the type of routing behavior to enforce network-wide.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkRoutingConfig
	{
		
		/// <summary>
		/// The network-wide routing mode to use. If set to REGIONAL, this network's Cloud Routers will only advertise routes with subnets of this network in the same region as the router. If set to GLOBAL, this network's Cloud Routers will advertise routes with all subnets of this network, across regions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routingMode")]
		public System.Nullable<NetworkRoutingConfigRoutingMode> RoutingMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkRoutingConfigRoutingMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGIONAL = 1,
	}
	
	/// <summary>
	/// NetworkAttachments A network attachment resource ...
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkAttachment
	{
		
		/// <summary>
		/// [Output Only] An array of connections for all the producers connected to this network attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionEndpoints")]
		public NetworkAttachmentConnectedEndpoint[] ConnectionEndpoints { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="connectionPreference")]
		public System.Nullable<NetworkAttachmentConnectionPreference> ConnectionPreference { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. An up-to-date fingerprint must be provided in order to patch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource type. The server generates this identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#networkAttachment")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkAttachment";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the network which the Network Attachment belongs to. Practically it is inferred by fetching the network of the first subnetwork associated. Because it is required that all the subnetworks must be from the same network, it is assured that the Network Attachment belongs to the same network as all the subnetworks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// Projects that are allowed to connect to this network attachment. The project can be specified using its id or number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="producerAcceptLists")]
		public string[] ProducerAcceptLists { get; set; }
		
		/// <summary>
		/// Projects that are not allowed to connect to this network attachment. The project can be specified using its id or number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="producerRejectLists")]
		public string[] ProducerRejectLists { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the network attachment resides. This field applies only to the region resource. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource's resource id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLinkWithId")]
		public string SelfLinkWithId { get; set; }
		
		/// <summary>
		/// An array of URLs where each entry is the URL of a subnet provided by the service consumer to use for endpoints in the producers that connect to this network attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetworks")]
		public string[] Subnetworks { get; set; }
	}
	
	/// <summary>
	/// [Output Only] A connection connected to this network attachment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkAttachmentConnectedEndpoint
	{
		
		/// <summary>
		/// The IPv4 address assigned to the producer instance network interface. This value will be a range in case of Serverless.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// The IPv6 address assigned to the producer instance network interface. This is only assigned when the stack types of both the instance network interface and the consumer subnet are IPv4_IPv6.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6Address")]
		public string Ipv6Address { get; set; }
		
		/// <summary>
		/// The project id or number of the interface to which the IP was assigned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="projectIdOrNum")]
		public string ProjectIdOrNum { get; set; }
		
		/// <summary>
		/// Alias IP ranges from the same subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryIpCidrRanges")]
		public string[] SecondaryIpCidrRanges { get; set; }
		
		/// <summary>
		/// The status of a connected endpoint to this network attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ForwardingRulePscConnectionStatus Status { get; set; }
		
		/// <summary>
		/// The subnetwork used to assign the IP to the producer instance network interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetwork")]
		public string Subnetwork { get; set; }
		
		/// <summary>
		/// [Output Only] The CIDR range of the subnet from which the IPv4 internal IP was allocated from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetworkCidrRange")]
		public string SubnetworkCidrRange { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkAttachmentConnectionPreference
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_AUTOMATIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_MANUAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 2,
	}
	
	/// <summary>
	/// Contains a list of NetworkAttachmentsScopedList.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkAttachmentAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NetworkAttachmentsScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, NetworkAttachmentsScopedList> Items { get; set; }
		
		[System.ComponentModel.DefaultValue("compute#networkAttachmentAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkAttachmentAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NetworkAttachmentAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkAttachmentsScopedList
	{
		
		/// <summary>
		/// A list of NetworkAttachments contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkAttachments")]
		public NetworkAttachment[] NetworkAttachments { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of network attachments when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NetworkAttachmentsScopedListWarning Warning { get; set; }
	}
	
	public class NetworkAttachmentsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkAttachmentsScopedListWarningData[] NetworkAttachmentsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NetworkAttachmentsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class NetworkAttachmentAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkAttachmentAggregatedListWarningData[] NetworkAttachmentAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NetworkAttachmentAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkAttachmentList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NetworkAttachment resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public NetworkAttachment[] Items { get; set; }
		
		[System.ComponentModel.DefaultValue("compute#networkAttachmentList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkAttachmentList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NetworkAttachmentListWarning Warning { get; set; }
	}
	
	public class NetworkAttachmentListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkAttachmentListWarningData[] NetworkAttachmentListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NetworkAttachmentListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Google Cloud Armor network edge security service resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEdgeSecurityService
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a NetworkEdgeSecurityService. An up-to-date fingerprint must be provided in order to update the NetworkEdgeSecurityService, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a NetworkEdgeSecurityService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output only] Type of the resource. Always compute#networkEdgeSecurityService for NetworkEdgeSecurityServices
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#networkEdgeSecurityService")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkEdgeSecurityService";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the resource resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The resource URL for the network edge security service associated with this network edge security service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securityPolicy")]
		public string SecurityPolicy { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource with the resource id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLinkWithId")]
		public string SelfLinkWithId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEdgeSecurityServiceAggregatedList
	{
		
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NetworkEdgeSecurityServicesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, NetworkEdgeSecurityServicesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#networkEdgeSecurityServiceAggregatedList for lists of Network Edge Security Services.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#networkEdgeSecurityServiceAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkEdgeSecurityServiceAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NetworkEdgeSecurityServiceAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEdgeSecurityServicesScopedList
	{
		
		/// <summary>
		/// A list of NetworkEdgeSecurityServices contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEdgeSecurityServices")]
		public NetworkEdgeSecurityService[] NetworkEdgeSecurityServices { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of security policies when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NetworkEdgeSecurityServicesScopedListWarning Warning { get; set; }
	}
	
	public class NetworkEdgeSecurityServicesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkEdgeSecurityServicesScopedListWarningData[] NetworkEdgeSecurityServicesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NetworkEdgeSecurityServicesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class NetworkEdgeSecurityServiceAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkEdgeSecurityServiceAggregatedListWarningData[] NetworkEdgeSecurityServiceAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NetworkEdgeSecurityServiceAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a collection of network endpoints. A network endpoint group (NEG) defines how a set of endpoints should be reached, whether they are reachable, and where they are located. For more information about using NEGs for different use cases, see Network endpoint groups overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroup
	{
		
		/// <summary>
		/// Metadata defined as annotations on the network endpoint group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public System.Collections.Generic.Dictionary<string, string> Annotations { get; set; }
		
		/// <summary>
		/// Configuration for an App Engine network endpoint group (NEG). The service is optional, may be provided explicitly or in the URL mask. The version is optional and can only be provided explicitly or in the URL mask when service is present. Note: App Engine service must be in the same project and located in the same region as the Serverless NEG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="appEngine")]
		public NetworkEndpointGroupAppEngine AppEngine { get; set; }
		
		/// <summary>
		/// Configuration for a Cloud Function network endpoint group (NEG). The function must be provided explicitly or in the URL mask. Note: Cloud Function must be in the same project and located in the same region as the Serverless NEG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudFunction")]
		public NetworkEndpointGroupCloudFunction CloudFunction { get; set; }
		
		/// <summary>
		/// Configuration for a Cloud Run network endpoint group (NEG). The service must be provided explicitly or in the URL mask. The tag is optional, may be provided explicitly or in the URL mask. Note: Cloud Run service must be in the same project and located in the same region as the Serverless NEG.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cloudRun")]
		public NetworkEndpointGroupCloudRun CloudRun { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// The default port used if the port number is not specified in the network endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultPort")]
		public System.Nullable<System.Int32> DefaultPort { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#networkEndpointGroup for network endpoint group.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#networkEndpointGroup")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkEndpointGroup";
		
		/// <summary>
		/// Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The URL of the network to which all network endpoints in the NEG belong. Uses "default" project network if unspecified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// Type of network endpoints in this network endpoint group. Can be one of GCE_VM_IP, GCE_VM_IP_PORT, NON_GCP_PRIVATE_IP_PORT, INTERNET_FQDN_PORT, INTERNET_IP_PORT, SERVERLESS, PRIVATE_SERVICE_CONNECT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEndpointType")]
		public System.Nullable<NetworkEndpointGroupNetworkEndpointType> NetworkEndpointType { get; set; }
		
		/// <summary>
		/// All data that is specifically relevant to only network endpoint groups of type PRIVATE_SERVICE_CONNECT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pscData")]
		public NetworkEndpointGroupPscData PscData { get; set; }
		
		/// <summary>
		/// The target service url used to set up private service connection to a Google API or a PSC Producer Service Attachment. An example value is: "asia-northeast3-cloudkms.googleapis.com"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pscTargetService")]
		public string PscTargetService { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the region where the network endpoint group is located.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output only] Number of network endpoints in the network endpoint group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		/// <summary>
		/// Optional URL of the subnetwork to which all network endpoints in the NEG belong.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetwork")]
		public string Subnetwork { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the zone where the network endpoint group is located.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	/// <summary>
	/// Configuration for an App Engine network endpoint group (NEG). The service is optional, may be provided explicitly or in the URL mask. The version is optional and can only be provided explicitly or in the URL mask when service is present. Note: App Engine service must be in the same project and located in the same region as the Serverless NEG.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupAppEngine
	{
		
		/// <summary>
		/// Optional serving service. The service name is case-sensitive and must be 1-63 characters long. Example value: "default", "my-service".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
		
		/// <summary>
		/// A template to parse service and version fields from a request URL. URL mask allows for routing to multiple App Engine services without having to create multiple Network Endpoint Groups and backend services. For example, the request URLs "foo1-dot-appname.appspot.com/v1" and "foo1-dot-appname.appspot.com/v2" can be backed by the same Serverless NEG with URL mask "<service>-dot-appname.appspot.com/<version>". The URL mask will parse them to { service = "foo1", version = "v1" } and { service = "foo1", version = "v2" } respectively.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlMask")]
		public string UrlMask { get; set; }
		
		/// <summary>
		/// Optional serving version. The version name is case-sensitive and must be 1-100 characters long. Example value: "v1", "v2".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Configuration for a Cloud Function network endpoint group (NEG). The function must be provided explicitly or in the URL mask. Note: Cloud Function must be in the same project and located in the same region as the Serverless NEG.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupCloudFunction
	{
		
		/// <summary>
		/// A user-defined name of the Cloud Function. The function name is case-sensitive and must be 1-63 characters long. Example value: "func1".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="function")]
		public string Function { get; set; }
		
		/// <summary>
		/// A template to parse function field from a request URL. URL mask allows for routing to multiple Cloud Functions without having to create multiple Network Endpoint Groups and backend services. For example, request URLs " mydomain.com/function1" and "mydomain.com/function2" can be backed by the same Serverless NEG with URL mask "/<function>". The URL mask will parse them to { function = "function1" } and { function = "function2" } respectively.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlMask")]
		public string UrlMask { get; set; }
	}
	
	/// <summary>
	/// Configuration for a Cloud Run network endpoint group (NEG). The service must be provided explicitly or in the URL mask. The tag is optional, may be provided explicitly or in the URL mask. Note: Cloud Run service must be in the same project and located in the same region as the Serverless NEG.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupCloudRun
	{
		
		/// <summary>
		/// Cloud Run service is the main resource of Cloud Run. The service must be 1-63 characters long, and comply with RFC1035. Example value: "run-service".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
		
		/// <summary>
		/// Optional Cloud Run tag represents the "named-revision" to provide additional fine-grained traffic routing information. The tag must be 1-63 characters long, and comply with RFC1035. Example value: "revision-0010".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tag")]
		public string Tag { get; set; }
		
		/// <summary>
		/// A template to parse <service> and <tag> fields from a request URL. URL mask allows for routing to multiple Run services without having to create multiple network endpoint groups and backend services. For example, request URLs "foo1.domain.com/bar1" and "foo1.domain.com/bar2" can be backed by the same Serverless Network Endpoint Group (NEG) with URL mask "<tag>.domain.com/<service>". The URL mask will parse them to { service="bar1", tag="foo1" } and { service="bar2", tag="foo2" } respectively.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlMask")]
		public string UrlMask { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkEndpointGroupNetworkEndpointType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GCE_VM_IP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GCE_VM_IP_PORT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNET_FQDN_PORT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNET_IP_PORT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NON_GCP_PRIVATE_IP_PORT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE_SERVICE_CONNECT = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVERLESS = 6,
	}
	
	/// <summary>
	/// All data that is specifically relevant to only network endpoint groups of type PRIVATE_SERVICE_CONNECT.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupPscData
	{
		
		/// <summary>
		/// [Output Only] Address allocated from given subnetwork for PSC. This IP address acts as a VIP for a PSC NEG, allowing it to act as an endpoint in L7 PSC-XLB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consumerPscAddress")]
		public string ConsumerPscAddress { get; set; }
		
		/// <summary>
		/// [Output Only] The PSC connection id of the PSC Network Endpoint Group Consumer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pscConnectionId")]
		public string PscConnectionId { get; set; }
		
		/// <summary>
		/// [Output Only] The connection status of the PSC Forwarding Rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pscConnectionStatus")]
		public ForwardingRulePscConnectionStatus PscConnectionStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NetworkEndpointGroupsScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, NetworkEndpointGroupsScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#networkEndpointGroupAggregatedList for aggregated lists of network endpoint groups.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#networkEndpointGroupAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkEndpointGroupAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NetworkEndpointGroupAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupsScopedList
	{
		
		/// <summary>
		/// [Output Only] The list of network endpoint groups that are contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEndpointGroups")]
		public NetworkEndpointGroup[] NetworkEndpointGroups { get; set; }
		
		/// <summary>
		/// [Output Only] An informational warning that replaces the list of network endpoint groups when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NetworkEndpointGroupsScopedListWarning Warning { get; set; }
	}
	
	public class NetworkEndpointGroupsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkEndpointGroupsScopedListWarningData[] NetworkEndpointGroupsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NetworkEndpointGroupsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class NetworkEndpointGroupAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkEndpointGroupAggregatedListWarningData[] NetworkEndpointGroupAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NetworkEndpointGroupAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NetworkEndpointGroup resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public NetworkEndpointGroup[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#networkEndpointGroupList for network endpoint group lists.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#networkEndpointGroupList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkEndpointGroupList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NetworkEndpointGroupListWarning Warning { get; set; }
	}
	
	public class NetworkEndpointGroupListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkEndpointGroupListWarningData[] NetworkEndpointGroupListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NetworkEndpointGroupListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupsAttachEndpointsRequest
	{
		
		/// <summary>
		/// The list of network endpoints to be attached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEndpoints")]
		public NetworkEndpoint[] NetworkEndpoints { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupsDetachEndpointsRequest
	{
		
		/// <summary>
		/// The list of network endpoints to be detached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEndpoints")]
		public NetworkEndpoint[] NetworkEndpoints { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupsListEndpointsRequest
	{
		
		/// <summary>
		/// Optional query parameter for showing the health status of each network endpoint. Valid options are SKIP or SHOW. If you don't specify this parameter, the health status of network endpoints will not be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthStatus")]
		public System.Nullable<NetworkEndpointGroupsListEndpointsRequestHealthStatus> HealthStatus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworkEndpointGroupsListEndpointsRequestHealthStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SHOW = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SKIP = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointGroupsListNetworkEndpoints
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NetworkEndpointWithHealthStatus resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public NetworkEndpointWithHealthStatus[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#networkEndpointGroupsListNetworkEndpoints for the list of network endpoints in the specified network endpoint group.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#networkEndpointGroupsListNetworkEndpoints")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkEndpointGroupsListNetworkEndpoints";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NetworkEndpointGroupsListNetworkEndpointsWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkEndpointWithHealthStatus
	{
		
		/// <summary>
		/// [Output only] The health status of network endpoint;
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healths")]
		public HealthStatusForNetworkEndpoint[] Healths { get; set; }
		
		/// <summary>
		/// The network endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEndpoint")]
		public NetworkEndpoint NetworkEndpoint { get; set; }
	}
	
	public class NetworkEndpointGroupsListNetworkEndpointsWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkEndpointGroupsListNetworkEndpointsWarningData[] NetworkEndpointGroupsListNetworkEndpointsWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NetworkEndpointGroupsListNetworkEndpointsWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of networks.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworkList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Network resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Network[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#networkList for lists of networks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#networkList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#networkList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NetworkListWarning Warning { get; set; }
	}
	
	public class NetworkListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NetworkListWarningData[] NetworkListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NetworkListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworksAddPeeringRequest
	{
		
		/// <summary>
		/// This field will be deprecated soon. Use exchange_subnet_routes in network_peering instead. Indicates whether full mesh connectivity is created and managed automatically between peered networks. Currently this field should always be true since Google Compute Engine will automatically create and manage subnetwork routes between two networks when peering state is ACTIVE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoCreateRoutes")]
		public System.Nullable<System.Boolean> AutoCreateRoutes { get; set; }
		
		/// <summary>
		/// Name of the peering, which should conform to RFC1035.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A network peering attached to a network resource. The message includes the peering name, peer network, peering state, and a flag indicating whether Google Compute Engine should automatically create routes for the peering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkPeering")]
		public NetworkPeering NetworkPeering { get; set; }
		
		/// <summary>
		/// URL of the peer network. It can be either full URL or partial URL. The peer network may belong to a different project. If the partial URL does not contain project, it is assumed that the peer network is in the same project as the current network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerNetwork")]
		public string PeerNetwork { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworksGetEffectiveFirewallsResponse
	{
		
		/// <summary>
		/// Effective firewalls from firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallPolicys")]
		public NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy[] FirewallPolicys { get; set; }
		
		/// <summary>
		/// Effective firewalls on the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewalls")]
		public Firewall[] Firewalls { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy
	{
		
		/// <summary>
		/// [Output Only] Deprecated, please use short name instead. The display name of the firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The rules that apply to the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public FirewallPolicyRule[] Rules { get; set; }
		
		/// <summary>
		/// [Output Only] The short name of the firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shortName")]
		public string ShortName { get; set; }
		
		/// <summary>
		/// [Output Only] The type of the firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIERARCHY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETWORK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworksRemovePeeringRequest
	{
		
		/// <summary>
		/// Name of the peering, which should conform to RFC1035.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NetworksUpdatePeeringRequest
	{
		
		/// <summary>
		/// A network peering attached to a network resource. The message includes the peering name, peer network, peering state, and a flag indicating whether Google Compute Engine should automatically create routes for the peering.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkPeering")]
		public NetworkPeering NetworkPeering { get; set; }
	}
	
	/// <summary>
	/// Represents a sole-tenant Node Group resource. A sole-tenant node is a physical server that is dedicated to hosting VM instances only for your specific project. Use sole-tenant nodes to keep your instances physically separated from instances in other projects, or to group your instances together on the same host hardware. For more information, read Sole-tenant nodes.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroup
	{
		
		[System.Runtime.Serialization.DataMember(Name="autoscalingPolicy")]
		public NodeGroupAutoscalingPolicy AutoscalingPolicy { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] The type of the resource. Always compute#nodeGroup for node group.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#nodeGroup")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#nodeGroup";
		
		/// <summary>
		/// An opaque location hint used to place the Node close to other resources. This field is for use by internal tools that use the public API. The location hint here on the NodeGroup overrides any location_hint present in the NodeTemplate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationHint")]
		public string LocationHint { get; set; }
		
		/// <summary>
		/// Specifies how to handle instances when a node in the group undergoes maintenance. Set to one of: DEFAULT, RESTART_IN_PLACE, or MIGRATE_WITHIN_NODE_GROUP. The default value is DEFAULT. For more information, see Maintenance policies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenancePolicy")]
		public System.Nullable<NodeGroupMaintenancePolicy> MaintenancePolicy { get; set; }
		
		/// <summary>
		/// Time window specified for daily maintenance operations. GCE's internal maintenance will be performed within this window.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceWindow")]
		public NodeGroupMaintenanceWindow MaintenanceWindow { get; set; }
		
		/// <summary>
		/// The name of the resource, provided by the client when initially creating the resource. The resource name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// URL of the node template to create the node group from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeTemplate")]
		public string NodeTemplate { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The share setting for reservations and sole tenancy node groups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shareSettings")]
		public ShareSettings ShareSettings { get; set; }
		
		/// <summary>
		/// [Output Only] The total number of nodes in the node group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<NodeGroupStatus> Status { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the zone where the node group resides, such as us-central1-a.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupAutoscalingPolicy
	{
		
		/// <summary>
		/// The maximum number of nodes that the group should have. Must be set if autoscaling is enabled. Maximum value allowed is 100.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxNodes")]
		public System.Nullable<System.Int32> MaxNodes { get; set; }
		
		/// <summary>
		/// The minimum number of nodes that the group should have.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minNodes")]
		public System.Nullable<System.Int32> MinNodes { get; set; }
		
		/// <summary>
		/// The autoscaling mode. Set to one of: ON, OFF, or ONLY_SCALE_OUT. For more information, see Autoscaler modes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mode")]
		public System.Nullable<NodeGroupAutoscalingPolicyMode> Mode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NodeGroupAutoscalingPolicyMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFF = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ON = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONLY_SCALE_OUT = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NodeGroupMaintenancePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAINTENANCE_POLICY_UNSPECIFIED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MIGRATE_WITHIN_NODE_GROUP = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTART_IN_PLACE = 3,
	}
	
	/// <summary>
	/// Time window specified for daily maintenance operations. GCE's internal maintenance will be performed within this window.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupMaintenanceWindow
	{
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maintenanceDuration")]
		public Duration MaintenanceDuration { get; set; }
		
		/// <summary>
		/// Start time of the window. This must be in UTC format that resolves to one of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NodeGroupStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NodeGroupsScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, NodeGroupsScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource.Always compute#nodeGroupAggregatedList for aggregated lists of node groups.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#nodeGroupAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#nodeGroupAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NodeGroupAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupsScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of node groups contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeGroups")]
		public NodeGroup[] NodeGroups { get; set; }
		
		/// <summary>
		/// [Output Only] An informational warning that appears when the nodeGroup list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NodeGroupsScopedListWarning Warning { get; set; }
	}
	
	public class NodeGroupsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeGroupsScopedListWarningData[] NodeGroupsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NodeGroupsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class NodeGroupAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeGroupAggregatedListWarningData[] NodeGroupAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NodeGroupAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of nodeGroups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NodeGroup resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public NodeGroup[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource.Always compute#nodeGroupList for lists of node groups.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#nodeGroupList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#nodeGroupList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NodeGroupListWarning Warning { get; set; }
	}
	
	public class NodeGroupListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeGroupListWarningData[] NodeGroupListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NodeGroupListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupNode
	{
		
		/// <summary>
		/// Accelerators for this node.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accelerators")]
		public AcceleratorConfig[] Accelerators { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="consumedResources")]
		public InstanceConsumptionInfo ConsumedResources { get; set; }
		
		/// <summary>
		/// CPU overcommit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuOvercommitType")]
		public System.Nullable<NodeGroupNodeCpuOvercommitType> CpuOvercommitType { get; set; }
		
		/// <summary>
		/// Local disk configurations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public LocalDisk[] Disks { get; set; }
		
		/// <summary>
		/// Instance data that shows consumed resources on the node.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceConsumptionData")]
		public InstanceConsumptionData[] InstanceConsumptionData { get; set; }
		
		/// <summary>
		/// Instances scheduled on this node.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
		
		/// <summary>
		/// The name of the node.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The type of this node.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeType")]
		public string NodeType { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzs")]
		public System.Nullable<System.Boolean> SatisfiesPzs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serverBinding")]
		public ServerBinding ServerBinding { get; set; }
		
		/// <summary>
		/// Server ID associated with this node.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverId")]
		public string ServerId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<NodeGroupNodeStatus> Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalResources")]
		public InstanceConsumptionInfo TotalResources { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NodeGroupNodeCpuOvercommitType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CPU_OVERCOMMIT_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServerBinding
	{
		
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<ServerBindingType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ServerBindingType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTART_NODE_ON_ANY_SERVER = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTART_NODE_ON_MINIMAL_SERVERS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVER_BINDING_TYPE_UNSPECIFIED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum NodeGroupNodeStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REPAIRING = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupsAddNodesRequest
	{
		
		/// <summary>
		/// Count of additional nodes to be added to the node group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="additionalNodeCount")]
		public System.Nullable<System.Int32> AdditionalNodeCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupsDeleteNodesRequest
	{
		
		/// <summary>
		/// Names of the nodes to delete.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodes")]
		public string[] Nodes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupsListNodes
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Node resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public NodeGroupNode[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute.nodeGroupsListNodes for the list of nodes in the specified node group.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#nodeGroupsListNodes")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#nodeGroupsListNodes";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NodeGroupsListNodesWarning Warning { get; set; }
	}
	
	public class NodeGroupsListNodesWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeGroupsListNodesWarningData[] NodeGroupsListNodesWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NodeGroupsListNodesWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupsSetNodeTemplateRequest
	{
		
		/// <summary>
		/// Full or partial URL of the node template resource to be updated for this node group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeTemplate")]
		public string NodeTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeGroupsSimulateMaintenanceEventRequest
	{
		
		/// <summary>
		/// Names of the nodes to go under maintenance simulation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodes")]
		public string[] Nodes { get; set; }
	}
	
	/// <summary>
	/// Represent a sole-tenant Node Template resource. You can use a template to define properties for nodes in a node group. For more information, read Creating node groups and instances.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeTemplate
	{
		
		[System.Runtime.Serialization.DataMember(Name="accelerators")]
		public AcceleratorConfig[] Accelerators { get; set; }
		
		/// <summary>
		/// CPU overcommit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuOvercommitType")]
		public NodeGroupNodeCpuOvercommitType CpuOvercommitType { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disks")]
		public LocalDisk[] Disks { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] The type of the resource. Always compute#nodeTemplate for node templates.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#nodeTemplate")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#nodeTemplate";
		
		/// <summary>
		/// The name of the resource, provided by the client when initially creating the resource. The resource name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Labels to use for node affinity, which will be used in instance scheduling.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeAffinityLabels")]
		public System.Collections.Generic.Dictionary<string, string> NodeAffinityLabels { get; set; }
		
		/// <summary>
		/// The node type to use for nodes group that are created from this template.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeType")]
		public string NodeType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nodeTypeFlexibility")]
		public NodeTemplateNodeTypeFlexibility NodeTypeFlexibility { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the region where the node template resides, such as us-central1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="serverBinding")]
		public ServerBinding ServerBinding { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the node template. One of the following values: CREATING, READY, and DELETING.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public NodeGroupStatus Status { get; set; }
		
		/// <summary>
		/// [Output Only] An optional, human-readable explanation of the status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeTemplateNodeTypeFlexibility
	{
		
		[System.Runtime.Serialization.DataMember(Name="cpus")]
		public string Cpus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="localSsd")]
		public string LocalSsd { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="memory")]
		public string Memory { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeTemplateAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NodeTemplatesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, NodeTemplatesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource.Always compute#nodeTemplateAggregatedList for aggregated lists of node templates.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#nodeTemplateAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#nodeTemplateAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NodeTemplateAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeTemplatesScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of node templates contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeTemplates")]
		public NodeTemplate[] NodeTemplates { get; set; }
		
		/// <summary>
		/// [Output Only] An informational warning that appears when the node templates list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NodeTemplatesScopedListWarning Warning { get; set; }
	}
	
	public class NodeTemplatesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeTemplatesScopedListWarningData[] NodeTemplatesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NodeTemplatesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class NodeTemplateAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeTemplateAggregatedListWarningData[] NodeTemplateAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NodeTemplateAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of node templates.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeTemplateList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NodeTemplate resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public NodeTemplate[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource.Always compute#nodeTemplateList for lists of node templates.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#nodeTemplateList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#nodeTemplateList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NodeTemplateListWarning Warning { get; set; }
	}
	
	public class NodeTemplateListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeTemplateListWarningData[] NodeTemplateListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NodeTemplateListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represent a sole-tenant Node Type resource. Each node within a node group must have a node type. A node type specifies the total amount of cores and memory for that node. Currently, the only available node type is n1-node-96-624 node type that has 96 vCPUs and 624 GB of memory, available in multiple zones. For more information read Node types.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeType
	{
		
		/// <summary>
		/// [Output Only] The CPU platform used by this node type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cpuPlatform")]
		public string CpuPlatform { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// Deprecation status for a public resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public DeprecationStatus Deprecated { get; set; }
		
		/// <summary>
		/// [Output Only] An optional textual description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The number of virtual CPUs that are available to the node type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestCpus")]
		public System.Nullable<System.Int32> GuestCpus { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] The type of the resource. Always compute#nodeType for node types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#nodeType")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#nodeType";
		
		/// <summary>
		/// [Output Only] Local SSD available to the node type, defined in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localSsdGb")]
		public System.Nullable<System.Int32> LocalSsdGb { get; set; }
		
		/// <summary>
		/// [Output Only] The amount of physical memory available to the node type, defined in MB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="memoryMb")]
		public System.Nullable<System.Int32> MemoryMb { get; set; }
		
		/// <summary>
		/// [Output Only] Name of the resource.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the zone where the node type resides, such as us-central1-a.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeTypeAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NodeTypesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, NodeTypesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource.Always compute#nodeTypeAggregatedList for aggregated lists of node types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#nodeTypeAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#nodeTypeAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NodeTypeAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeTypesScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of node types contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeTypes")]
		public NodeType[] NodeTypes { get; set; }
		
		/// <summary>
		/// [Output Only] An informational warning that appears when the node types list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NodeTypesScopedListWarning Warning { get; set; }
	}
	
	public class NodeTypesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeTypesScopedListWarningData[] NodeTypesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NodeTypesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class NodeTypeAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeTypeAggregatedListWarningData[] NodeTypeAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NodeTypeAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of node types.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeTypeList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NodeType resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public NodeType[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource.Always compute#nodeTypeList for lists of node types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#nodeTypeList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#nodeTypeList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NodeTypeListWarning Warning { get; set; }
	}
	
	public class NodeTypeListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NodeTypeListWarningData[] NodeTypeListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NodeTypeListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a notification endpoint. A notification endpoint resource defines an endpoint to receive notifications when there are status changes detected by the associated health check service. For more information, see Health checks overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationEndpoint
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Represents a gRPC setting that describes one gRPC notification endpoint and the retry duration attempting to send notification to this endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grpcSettings")]
		public NotificationEndpointGrpcSettings GrpcSettings { get; set; }
		
		/// <summary>
		/// [Output Only] A unique identifier for this resource type. The server generates this identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#notificationEndpoint for notification endpoints.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#notificationEndpoint")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#notificationEndpoint";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the notification endpoint resides. This field applies only to the regional resource. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
	}
	
	/// <summary>
	/// Represents a gRPC setting that describes one gRPC notification endpoint and the retry duration attempting to send notification to this endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationEndpointGrpcSettings
	{
		
		/// <summary>
		/// Optional. If specified, this field is used to set the authority header by the sender of notifications. See https://tools.ietf.org/html/rfc7540#section-8.1.2.3
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authority")]
		public string Authority { get; set; }
		
		/// <summary>
		/// Endpoint to which gRPC notifications are sent. This must be a valid gRPCLB DNS name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		/// <summary>
		/// Optional. If specified, this field is used to populate the "name" field in gRPC requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="payloadName")]
		public string PayloadName { get; set; }
		
		/// <summary>
		/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resendInterval")]
		public Duration ResendInterval { get; set; }
		
		/// <summary>
		/// How much time (in seconds) is spent attempting notification retries until a successful response is received. Default is 30s. Limit is 20m (1200s). Must be a positive number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retryDurationSec")]
		public System.Nullable<System.UInt32> RetryDurationSec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotificationEndpointList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of NotificationEndpoint resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public NotificationEndpoint[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#notificationEndpoint for notification endpoints.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#notificationEndpointList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#notificationEndpointList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public NotificationEndpointListWarning Warning { get; set; }
	}
	
	public class NotificationEndpointListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public NotificationEndpointListWarningData[] NotificationEndpointListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class NotificationEndpointListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents an Operation resource. Google Compute Engine has three Operation resources: * [Global](/compute/docs/reference/rest/v1/globalOperations) * [Regional](/compute/docs/reference/rest/v1/regionOperations) * [Zonal](/compute/docs/reference/rest/v1/zoneOperations) You can use an operation resource to manage asynchronous API requests. For more information, read Handling API responses. Operations can be global, regional or zonal. - For global operations, use the `globalOperations` resource. - For regional operations, use the `regionOperations` resource. - For zonal operations, use the `zoneOperations` resource. For more information, read Global, Regional, and Zonal Resources. Note that completed Operation resources have a limited retention period.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Operation
	{
		
		/// <summary>
		/// [Output Only] The value of `requestId` if you provided it in the request. Not present otherwise.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientOperationId")]
		public string ClientOperationId { get; set; }
		
		/// <summary>
		/// [Deprecated] This field is deprecated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// [Output Only] A textual description of the operation, which is set when the operation is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The time that this operation was completed. This value is in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endTime")]
		public string EndTime { get; set; }
		
		/// <summary>
		/// [Output Only] If errors are generated during processing of the operation, this field will be populated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public OperationError Error { get; set; }
		
		/// <summary>
		/// [Output Only] If the operation fails, this field contains the HTTP error message that was returned, such as `NOT FOUND`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpErrorMessage")]
		public string HttpErrorMessage { get; set; }
		
		/// <summary>
		/// [Output Only] If the operation fails, this field contains the HTTP error status code that was returned. For example, a `404` means the resource was not found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpErrorStatusCode")]
		public System.Nullable<System.Int32> HttpErrorStatusCode { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the operation. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] The time that this operation was requested. This value is in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="insertTime")]
		public string InsertTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="instancesBulkInsertOperationMetadata")]
		public InstancesBulkInsertOperationMetadata InstancesBulkInsertOperationMetadata { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always `compute#operation` for Operation resources.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#operation")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#operation";
		
		/// <summary>
		/// [Output Only] Name of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] An ID that represents a group of operations, such as when a group of operations results from a `bulkInsert` API request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationGroupId")]
		public string OperationGroupId { get; set; }
		
		/// <summary>
		/// [Output Only] The type of operation, such as `insert`, `update`, or `delete`, and so on.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationType")]
		public string OperationType { get; set; }
		
		/// <summary>
		/// [Output Only] An optional progress indicator that ranges from 0 to 100. There is no requirement that this be linear or support any granularity of operations. This should not be used to guess when the operation will be complete. This number should monotonically increase as the operation progresses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public System.Nullable<System.Int32> Progress { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the region where the operation resides. Only applicable when performing regional operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="setCommonInstanceMetadataOperationMetadata")]
		public SetCommonInstanceMetadataOperationMetadata SetCommonInstanceMetadataOperationMetadata { get; set; }
		
		/// <summary>
		/// [Output Only] The time that this operation was started by the server. This value is in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the operation, which can be one of the following: `PENDING`, `RUNNING`, or `DONE`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<OperationStatus> Status { get; set; }
		
		/// <summary>
		/// [Output Only] An optional textual description of the current status of the operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusMessage")]
		public string StatusMessage { get; set; }
		
		/// <summary>
		/// [Output Only] The unique target ID, which identifies a specific incarnation of the target resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetId")]
		public string TargetId { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the resource that the operation modifies. For operations related to creating a snapshot, this points to the persistent disk that the snapshot was created from.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetLink")]
		public string TargetLink { get; set; }
		
		/// <summary>
		/// [Output Only] User who requested the operation, for example: `user@example.com` or `alice_smith_identifier (global/workforcePools/example-com-us-employees)`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="user")]
		public string User { get; set; }
		
		/// <summary>
		/// [Output Only] If warning messages are generated during processing of the operation, this field will be populated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warnings")]
		public OperationWarnings[] OperationWarnings { get; set; }
		
		/// <summary>
		/// [Output Only] The URL of the zone where the operation resides. Only applicable when performing per-zone operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	public class OperationError
	{
		
		/// <summary>
		/// [Output Only] The array of errors encountered while processing this operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public OperationErrorErrors[] OperationErrorErrors { get; set; }
	}
	
	public class OperationErrorErrors
	{
		
		/// <summary>
		/// [Output Only] The error type identifier for this error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// [Output Only] An optional list of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorDetails")]
		public OperationErrorErrorsErrorDetails[] OperationErrorErrorsErrorDetails { get; set; }
		
		/// <summary>
		/// [Output Only] Indicates the field in the request that caused the error. This property is optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// [Output Only] An optional, human-readable error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class OperationErrorErrorsErrorDetails
	{
		
		/// <summary>
		/// Describes the cause of the error with structured details. Example of an error when contacting the "pubsub.googleapis.com" API when it is not enabled: { "reason": "API_DISABLED" "domain": "googleapis.com" "metadata": { "resource": "projects/123", "service": "pubsub.googleapis.com" } } This response indicates that the pubsub.googleapis.com API is not enabled. Example of an error that is returned when attempting to create a Spanner instance in a region that is out of stock: { "reason": "STOCKOUT" "domain": "spanner.googleapis.com", "metadata": { "availableRegions": "us-central1,us-east2" } }
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorInfo")]
		public ErrorInfo ErrorInfo { get; set; }
		
		/// <summary>
		/// Provides links to documentation or for performing an out of band action. For example, if a quota check failed with an error indicating the calling project hasn't enabled the accessed service, this can contain a URL pointing directly to the right place in the developer console to flip the bit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="help")]
		public Help Help { get; set; }
		
		/// <summary>
		/// Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localizedMessage")]
		public LocalizedMessage LocalizedMessage { get; set; }
		
		/// <summary>
		/// Additional details for quota exceeded error for resource quota.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quotaInfo")]
		public QuotaExceededInfo QuotaInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SetCommonInstanceMetadataOperationMetadata
	{
		
		/// <summary>
		/// [Output Only] The client operation id.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientOperationId")]
		public string ClientOperationId { get; set; }
		
		/// <summary>
		/// [Output Only] Status information per location (location name is key). Example key: zones/us-central1-a
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perLocationOperations")]
		public System.Collections.Generic.Dictionary<string, SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo> PerLocationOperations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo
	{
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public Status Error { get; set; }
		
		/// <summary>
		/// [Output Only] Status of the action, which can be one of the following: `PROPAGATING`, `PROPAGATED`, `ABANDONED`, `FAILED`, or `DONE`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfoState> State { get; set; }
	}
	
	/// <summary>
	/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Status
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfoState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABANDONED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROPAGATED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROPAGATING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum OperationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 2,
	}
	
	public class OperationWarnings
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public OperationWarningsData[] OperationWarningsData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class OperationWarningsData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OperationAggregatedList
	{
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] A map of scoped operation lists.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, OperationsScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always `compute#operationAggregatedList` for aggregated lists of operations.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#operationAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#operationAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than `maxResults`, use the `nextPageToken` as a value for the query parameter `pageToken` in the next list request. Subsequent list requests will have their own `nextPageToken` to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public OperationAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OperationsScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of operations contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public Operation[] Operations { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning which replaces the list of operations when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public OperationsScopedListWarning Warning { get; set; }
	}
	
	public class OperationsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public OperationsScopedListWarningData[] OperationsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class OperationsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class OperationAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public OperationAggregatedListWarningData[] OperationAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class OperationAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of Operation resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OperationList
	{
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] A list of Operation resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Operation[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always `compute#operations` for Operations resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#operationList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#operationList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than `maxResults`, use the `nextPageToken` as a value for the query parameter `pageToken` in the next list request. Subsequent list requests will have their own `nextPageToken` to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public OperationListWarning Warning { get; set; }
	}
	
	public class OperationListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public OperationListWarningData[] OperationListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class OperationListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Packet Mirroring resource. Packet Mirroring clones the traffic of specified instances in your Virtual Private Cloud (VPC) network and forwards it to a collector destination, such as an instance group of an internal TCP/UDP load balancer, for analysis or examination. For more information about setting up Packet Mirroring, see Using Packet Mirroring.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketMirroring
	{
		
		[System.Runtime.Serialization.DataMember(Name="collectorIlb")]
		public PacketMirroringForwardingRuleInfo CollectorIlb { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Indicates whether or not this packet mirroring takes effect. If set to FALSE, this packet mirroring policy will not be enforced on the network. The default is TRUE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable")]
		public System.Nullable<PacketMirroringEnable> Enable { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public PacketMirroringFilter Filter { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#packetMirroring for packet mirrorings.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#packetMirroring")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#packetMirroring";
		
		[System.Runtime.Serialization.DataMember(Name="mirroredResources")]
		public PacketMirroringMirroredResourceInfo MirroredResources { get; set; }
		
		/// <summary>
		/// Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="network")]
		public PacketMirroringNetworkInfo Network { get; set; }
		
		/// <summary>
		/// The priority of applying this configuration. Priority is used to break ties in cases where there is more than one matching rule. In the case of two rules that apply for a given Instance, the one with the lowest-numbered priority value wins. Default value is 1000. Valid range is 0 through 65535.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.UInt32> Priority { get; set; }
		
		/// <summary>
		/// [Output Only] URI of the region where the packetMirroring resides.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketMirroringForwardingRuleInfo
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the forwarding rule; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canonicalUrl")]
		public string CanonicalUrl { get; set; }
		
		/// <summary>
		/// Resource URL to the forwarding rule representing the ILB configured as destination of the mirrored traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PacketMirroringEnable
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FALSE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRUE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketMirroringFilter
	{
		
		/// <summary>
		/// Protocols that apply as filter on mirrored traffic. If no protocols are specified, all traffic that matches the specified CIDR ranges is mirrored. If neither cidrRanges nor IPProtocols is specified, all IPv4 traffic is mirrored.
		/// </summary>
		[System.Runtime.Serialization.DataMember()]
		public string[] IPProtocols { get; set; }
		
		/// <summary>
		/// One or more IPv4 or IPv6 CIDR ranges that apply as filter on the source (ingress) or destination (egress) IP in the IP header. If no ranges are specified, all IPv4 traffic that matches the specified IPProtocols is mirrored. If neither cidrRanges nor IPProtocols is specified, all IPv4 traffic is mirrored. To mirror all IPv4 and IPv6 traffic, use "0.0.0.0/0,::/0". Note: Support for IPv6 traffic is in preview.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cidrRanges")]
		public string[] CidrRanges { get; set; }
		
		/// <summary>
		/// Direction of traffic to mirror, either INGRESS, EGRESS, or BOTH. The default is BOTH.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="direction")]
		public System.Nullable<PacketMirroringFilterDirection> Direction { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PacketMirroringFilterDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOTH = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EGRESS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INGRESS = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketMirroringMirroredResourceInfo
	{
		
		/// <summary>
		/// A set of virtual machine instances that are being mirrored. They must live in zones contained in the same region as this packetMirroring. Note that this config will apply only to those network interfaces of the Instances that belong to the network specified in this packetMirroring. You may specify a maximum of 50 Instances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public PacketMirroringMirroredResourceInfoInstanceInfo[] Instances { get; set; }
		
		/// <summary>
		/// A set of subnetworks for which traffic from/to all VM instances will be mirrored. They must live in the same region as this packetMirroring. You may specify a maximum of 5 subnetworks.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetworks")]
		public PacketMirroringMirroredResourceInfoSubnetInfo[] Subnetworks { get; set; }
		
		/// <summary>
		/// A set of mirrored tags. Traffic from/to all VM instances that have one or more of these tags will be mirrored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketMirroringMirroredResourceInfoInstanceInfo
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the instance; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canonicalUrl")]
		public string CanonicalUrl { get; set; }
		
		/// <summary>
		/// Resource URL to the virtual machine instance which is being mirrored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketMirroringMirroredResourceInfoSubnetInfo
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the subnetwork; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canonicalUrl")]
		public string CanonicalUrl { get; set; }
		
		/// <summary>
		/// Resource URL to the subnetwork for which traffic from/to all VM instances will be mirrored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketMirroringNetworkInfo
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the network; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="canonicalUrl")]
		public string CanonicalUrl { get; set; }
		
		/// <summary>
		/// URL of the network resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	/// <summary>
	/// Contains a list of packetMirrorings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketMirroringAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of PacketMirroring resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, PacketMirroringsScopedList> Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#packetMirroringAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#packetMirroringAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public PacketMirroringAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketMirroringsScopedList
	{
		
		/// <summary>
		/// A list of packetMirrorings contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="packetMirrorings")]
		public PacketMirroring[] PacketMirrorings { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of packetMirrorings when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public PacketMirroringsScopedListWarning Warning { get; set; }
	}
	
	public class PacketMirroringsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PacketMirroringsScopedListWarningData[] PacketMirroringsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class PacketMirroringsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class PacketMirroringAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PacketMirroringAggregatedListWarningData[] PacketMirroringAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class PacketMirroringAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of PacketMirroring resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PacketMirroringList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of PacketMirroring resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public PacketMirroring[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#packetMirroring for packetMirrorings.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#packetMirroringList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#packetMirroringList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public PacketMirroringListWarning Warning { get; set; }
	}
	
	public class PacketMirroringListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PacketMirroringListWarningData[] PacketMirroringListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class PacketMirroringListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A matcher for the path portion of the URL. The BackendService from the longest-matched rule will serve the URL. If no rule was matched, the default service is used.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PathMatcher
	{
		
		[System.Runtime.Serialization.DataMember(Name="defaultRouteAction")]
		public HttpRouteAction DefaultRouteAction { get; set; }
		
		/// <summary>
		/// The full or partial URL to the BackendService resource. This URL is used if none of the pathRules or routeRules defined by this PathMatcher are matched. For example, the following are all valid URLs to a BackendService resource: - https://www.googleapis.com/compute/v1/projects/project /global/backendServices/backendService - compute/v1/projects/project/global/backendServices/backendService - global/backendServices/backendService If defaultRouteAction is also specified, advanced routing actions, such as URL rewrites, take effect before sending the request to the backend. However, if defaultService is specified, defaultRouteAction cannot contain any weightedBackendServices. Conversely, if defaultRouteAction specifies any weightedBackendServices, defaultService must not be specified. Only one of defaultService, defaultUrlRedirect , or defaultRouteAction.weightedBackendService must be set. Authorization requires one or more of the following Google IAM permissions on the specified resource default_service: - compute.backendBuckets.use - compute.backendServices.use 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultService")]
		public string DefaultService { get; set; }
		
		/// <summary>
		/// Specifies settings for an HTTP redirect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultUrlRedirect")]
		public HttpRedirectAction DefaultUrlRedirect { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The request and response header transformations that take effect before the request is passed along to the selected backendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerAction")]
		public HttpHeaderAction HeaderAction { get; set; }
		
		/// <summary>
		/// The name to which this PathMatcher is referred by the HostRule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of path rules. Use this list instead of routeRules when routing based on simple path matching is all that's required. The order by which path rules are specified does not matter. Matches are always done on the longest-path-first basis. For example: a pathRule with a path /a/b/c/* will match before /a/b/* irrespective of the order in which those paths appear in this list. Within a given pathMatcher, only one of pathRules or routeRules must be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathRules")]
		public PathRule[] PathRules { get; set; }
		
		/// <summary>
		/// The list of HTTP route rules. Use this list instead of pathRules when advanced route matching and routing actions are desired. routeRules are evaluated in order of priority, from the lowest to highest number. Within a given pathMatcher, you can set only one of pathRules or routeRules.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routeRules")]
		public HttpRouteRule[] RouteRules { get; set; }
	}
	
	/// <summary>
	/// A path-matching rule for a URL. If matched, will use the specified BackendService to handle the traffic arriving at this URL.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PathRule
	{
		
		/// <summary>
		/// The list of path patterns to match. Each must start with / and the only place a * is allowed is at the end following a /. The string fed to the path matcher does not include any text after the first ? or #, and those chars are not allowed here.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="paths")]
		public string[] Paths { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="routeAction")]
		public HttpRouteAction RouteAction { get; set; }
		
		/// <summary>
		/// The full or partial URL of the backend service resource to which traffic is directed if this rule is matched. If routeAction is also specified, advanced routing actions, such as URL rewrites, take effect before sending the request to the backend. However, if service is specified, routeAction cannot contain any weightedBackendServices. Conversely, if routeAction specifies any weightedBackendServices, service must not be specified. Only one of urlRedirect, service or routeAction.weightedBackendService must be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
		
		/// <summary>
		/// Specifies settings for an HTTP redirect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlRedirect")]
		public HttpRedirectAction UrlRedirect { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PreconfiguredWafSet
	{
		
		/// <summary>
		/// List of entities that are currently supported for WAF rules.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expressionSets")]
		public WafExpressionSet[] ExpressionSets { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WafExpressionSet
	{
		
		/// <summary>
		/// A list of alternate IDs. The format should be: - E.g. XSS-stable Generic suffix like "stable" is particularly useful if a policy likes to avail newer set of expressions without having to change the policy. A given alias name can't be used for more than one entity set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aliases")]
		public string[] Aliases { get; set; }
		
		/// <summary>
		/// List of available expressions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expressions")]
		public WafExpressionSetExpression[] Expressions { get; set; }
		
		/// <summary>
		/// Google specified expression set ID. The format should be: - E.g. XSS-20170329 required
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class WafExpressionSetExpression
	{
		
		/// <summary>
		/// Expression ID should uniquely identify the origin of the expression. E.g. owasp-crs-v020901-id973337 identifies Owasp core rule set version 2.9.1 rule id 973337. The ID could be used to determine the individual attack definition that has been detected. It could also be used to exclude it from the policy in case of false positive. required
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The sensitivity value associated with the WAF rule ID. This corresponds to the ModSecurity paranoia level, ranging from 1 to 4. 0 is reserved for opt-in only rules.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sensitivity")]
		public System.Nullable<System.Int32> Sensitivity { get; set; }
	}
	
	/// <summary>
	/// Represents a Project resource. A project is used to organize resources in a Google Cloud Platform environment. For more information, read about the Resource Hierarchy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Project
	{
		
		/// <summary>
		/// A metadata key/value entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commonInstanceMetadata")]
		public Metadata CommonInstanceMetadata { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// This signifies the default network tier used for configuring resources of the project and can only take the following values: PREMIUM, STANDARD. Initially the default network tier is PREMIUM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultNetworkTier")]
		public AccessConfigNetworkTier DefaultNetworkTier { get; set; }
		
		/// <summary>
		/// [Output Only] Default service account used by VMs running in this project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultServiceAccount")]
		public string DefaultServiceAccount { get; set; }
		
		/// <summary>
		/// An optional textual description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Restricted features enabled for use on this project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabledFeatures")]
		public string[] EnabledFeatures { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server. This is *not* the project ID, and is just a unique ID used by Compute Engine to identify resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#project for projects.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#project")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#project";
		
		/// <summary>
		/// The project ID. For example: my-example-project. Use the project ID to make requests to Compute Engine.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] Quotas assigned to this project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quotas")]
		public Quota[] Quotas { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The location in Cloud Storage and naming method of the daily usage report. Contains bucket_name and report_name prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usageExportLocation")]
		public UsageExportLocation UsageExportLocation { get; set; }
		
		/// <summary>
		/// [Output Only] Default internal DNS setting used by VMs running in this project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmDnsSetting")]
		public System.Nullable<ProjectVmDnsSetting> VmDnsSetting { get; set; }
		
		/// <summary>
		/// [Output Only] The role this project has in a shared VPC configuration. Currently, only projects with the host role, which is specified by the value HOST, are differentiated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xpnProjectStatus")]
		public System.Nullable<ProjectXpnProjectStatus> XpnProjectStatus { get; set; }
	}
	
	/// <summary>
	/// A quotas entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Quota
	{
		
		/// <summary>
		/// [Output Only] Quota limit for this metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="limit")]
		public System.Nullable<System.Double> Limit { get; set; }
		
		/// <summary>
		/// [Output Only] Name of the quota metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metric")]
		public System.Nullable<QuotaMetric> Metric { get; set; }
		
		/// <summary>
		/// [Output Only] Owning resource. This is the resource on which this quota is applied.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="owner")]
		public string Owner { get; set; }
		
		/// <summary>
		/// [Output Only] Current usage of this metric.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public System.Nullable<System.Double> Usage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum QuotaMetric
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		A2_CPUS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AFFINITY_GROUPS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTOSCALERS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKEND_BUCKETS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKEND_SERVICES = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		C2D_CPUS = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		C2_CPUS = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		C3_CPUS = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITMENTS = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_A2_CPUS = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_C2D_CPUS = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_C2_CPUS = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_C3_CPUS = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_CPUS = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_E2_CPUS = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_LICENSES = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_LOCAL_SSD_TOTAL_GB = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_M3_CPUS = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_MEMORY_OPTIMIZED_CPUS = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_N2A_CPUS = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_N2D_CPUS = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_N2_CPUS = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_NVIDIA_A100_80GB_GPUS = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_NVIDIA_A100_GPUS = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_NVIDIA_H100_GPUS = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_NVIDIA_K80_GPUS = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_NVIDIA_L4_GPUS = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_NVIDIA_P100_GPUS = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_NVIDIA_P4_GPUS = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_NVIDIA_T4_GPUS = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_NVIDIA_V100_GPUS = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_T2A_CPUS = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMITTED_T2D_CPUS = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CPUS = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CPUS_ALL_REGIONS = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISKS_TOTAL_GB = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		E2_CPUS = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL_MANAGED_FORWARDING_RULES = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL_NETWORK_LB_FORWARDING_RULES = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL_PROTOCOL_FORWARDING_RULES = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL_VPN_GATEWAYS = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIREWALLS = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FORWARDING_RULES = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL_EXTERNAL_MANAGED_BACKEND_SERVICES = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL_EXTERNAL_MANAGED_FORWARDING_RULES = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL_EXTERNAL_PROXY_LB_BACKEND_SERVICES = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL_INTERNAL_ADDRESSES = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL_INTERNAL_MANAGED_BACKEND_SERVICES = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL_INTERNAL_TRAFFIC_DIRECTOR_BACKEND_SERVICES = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GPUS_ALL_REGIONS = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HEALTH_CHECKS = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IMAGES = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INSTANCES = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INSTANCE_GROUPS = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INSTANCE_GROUP_MANAGERS = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INSTANCE_TEMPLATES = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERCONNECTS = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERCONNECT_ATTACHMENTS_PER_REGION = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERCONNECT_ATTACHMENTS_TOTAL_MBPS = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERCONNECT_TOTAL_GBPS = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL_ADDRESSES = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL_TRAFFIC_DIRECTOR_FORWARDING_RULES = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_PLACE_SNAPSHOTS = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_USE_ADDRESSES = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_USE_BACKUP_SCHEDULES = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN_USE_SNAPSHOT_SCHEDULES = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL_SSD_TOTAL_GB = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		M1_CPUS = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		M2_CPUS = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		M3_CPUS = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MACHINE_IMAGES = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		N2A_CPUS = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		N2D_CPUS = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		N2_CPUS = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETWORKS = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETWORK_ATTACHMENTS = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETWORK_ENDPOINT_GROUPS = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETWORK_FIREWALL_POLICIES = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NET_LB_SECURITY_POLICIES_PER_REGION = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NET_LB_SECURITY_POLICY_RULES_PER_REGION = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NET_LB_SECURITY_POLICY_RULE_ATTRIBUTES_PER_REGION = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NODE_GROUPS = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NODE_TEMPLATES = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_A100_80GB_GPUS = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_A100_GPUS = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_K80_GPUS = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_L4_GPUS = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_P100_GPUS = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_P100_VWS_GPUS = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_P4_GPUS = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_P4_VWS_GPUS = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_T4_GPUS = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_T4_VWS_GPUS = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NVIDIA_V100_GPUS = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PACKET_MIRRORINGS = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PD_EXTREME_TOTAL_PROVISIONED_IOPS = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_CPUS = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_LOCAL_SSD_GB = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_A100_80GB_GPUS = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_A100_GPUS = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_H100_GPUS = 100,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_K80_GPUS = 101,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_L4_GPUS = 102,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_P100_GPUS = 103,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_P100_VWS_GPUS = 104,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_P4_GPUS = 105,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_P4_VWS_GPUS = 106,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_T4_GPUS = 107,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_T4_VWS_GPUS = 108,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_NVIDIA_V100_GPUS = 109,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_TPU_LITE_DEVICE_V5 = 110,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_TPU_LITE_PODSLICE_V5 = 111,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREEMPTIBLE_TPU_PODSLICE_V4 = 112,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PSC_ILB_CONSUMER_FORWARDING_RULES_PER_PRODUCER_NETWORK = 113,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PSC_INTERNAL_LB_FORWARDING_RULES = 114,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC_ADVERTISED_PREFIXES = 115,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC_DELEGATED_PREFIXES = 116,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGIONAL_AUTOSCALERS = 117,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGIONAL_EXTERNAL_MANAGED_BACKEND_SERVICES = 118,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGIONAL_EXTERNAL_NETWORK_LB_BACKEND_SERVICES = 119,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGIONAL_INSTANCE_GROUP_MANAGERS = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGIONAL_INTERNAL_LB_BACKEND_SERVICES = 121,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGIONAL_INTERNAL_MANAGED_BACKEND_SERVICES = 122,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESERVATIONS = 123,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESOURCE_POLICIES = 124,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ROUTERS = 125,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ROUTES = 126,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECURITY_POLICIES = 127,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECURITY_POLICIES_PER_REGION = 128,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECURITY_POLICY_ADVANCED_RULES_PER_REGION = 129,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECURITY_POLICY_CEVAL_RULES = 130,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECURITY_POLICY_RULES = 131,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SECURITY_POLICY_RULES_PER_REGION = 132,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SERVICE_ATTACHMENTS = 133,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SNAPSHOTS = 134,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SSD_TOTAL_GB = 135,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SSL_CERTIFICATES = 136,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATIC_ADDRESSES = 137,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATIC_BYOIP_ADDRESSES = 138,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATIC_EXTERNAL_IPV6_ADDRESS_RANGES = 139,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUBNETWORKS = 140,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2A_CPUS = 141,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		T2D_CPUS = 142,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TARGET_HTTPS_PROXIES = 143,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TARGET_HTTP_PROXIES = 144,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TARGET_INSTANCES = 145,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TARGET_POOLS = 146,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TARGET_SSL_PROXIES = 147,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TARGET_TCP_PROXIES = 148,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TARGET_VPN_GATEWAYS = 149,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TPU_LITE_DEVICE_V5 = 150,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TPU_LITE_PODSLICE_V5 = 151,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TPU_PODSLICE_V4 = 152,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		URL_MAPS = 153,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPN_GATEWAYS = 154,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VPN_TUNNELS = 155,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XPN_SERVICE_PROJECTS = 156,
	}
	
	/// <summary>
	/// The location in Cloud Storage and naming method of the daily usage report. Contains bucket_name and report_name prefix.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UsageExportLocation
	{
		
		/// <summary>
		/// The name of an existing bucket in Cloud Storage where the usage report object is stored. The Google Service Account is granted write access to this bucket. This can either be the bucket name by itself, such as example-bucket, or the bucket name with gs:// or https://storage.googleapis.com/ in front of it, such as gs://example-bucket.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bucketName")]
		public string BucketName { get; set; }
		
		/// <summary>
		/// An optional prefix for the name of the usage report object stored in bucketName. If not supplied, defaults to usage_gce. The report is stored as a CSV file named report_name_prefix_gce_YYYYMMDD.csv where YYYYMMDD is the day of the usage according to Pacific Time. If you supply a prefix, it should conform to Cloud Storage object naming conventions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reportNamePrefix")]
		public string ReportNamePrefix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ProjectVmDnsSetting
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL_DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED_VM_DNS_SETTING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZONAL_DEFAULT = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZONAL_ONLY = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ProjectXpnProjectStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HOST = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED_XPN_PROJECT_STATUS = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectsDisableXpnResourceRequest
	{
		
		/// <summary>
		/// Service resource (a.k.a service project) ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xpnResource")]
		public XpnResourceId XpnResource { get; set; }
	}
	
	/// <summary>
	/// Service resource (a.k.a service project) ID.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class XpnResourceId
	{
		
		/// <summary>
		/// The ID of the service resource. In the case of projects, this field supports project id (e.g., my-project-123) and project number (e.g. 12345678).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The type of the service resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<XpnResourceIdType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum XpnResourceIdType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROJECT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XPN_RESOURCE_TYPE_UNSPECIFIED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectsEnableXpnResourceRequest
	{
		
		/// <summary>
		/// Service resource (a.k.a service project) ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xpnResource")]
		public XpnResourceId XpnResource { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectsGetXpnResources
	{
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#projectsGetXpnResources for lists of service resources (a.k.a service projects)
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#projectsGetXpnResources")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#projectsGetXpnResources";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// Service resources (a.k.a service projects) attached to this project as their shared VPC host.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resources")]
		public XpnResourceId[] Resources { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectsListXpnHostsRequest
	{
		
		/// <summary>
		/// Optional organization ID managed by Cloud Resource Manager, for which to list shared VPC host projects. If not specified, the organization will be inferred from the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public string Organization { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProjectsSetDefaultNetworkTierRequest
	{
		
		/// <summary>
		/// Default network tier to be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkTier")]
		public AccessConfigNetworkTier NetworkTier { get; set; }
	}
	
	/// <summary>
	/// A public advertised prefix represents an aggregated IP prefix or netblock which customers bring to cloud. The IP prefix is a single unit of route advertisement and is announced globally to the internet.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicAdvertisedPrefix
	{
		
		/// <summary>
		/// [Output Only] The version of BYOIP API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="byoipApiVersion")]
		public System.Nullable<PublicAdvertisedPrefixByoipApiVersion> ByoipApiVersion { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The address to be used for reverse DNS verification.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dnsVerificationIp")]
		public string DnsVerificationIp { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a new PublicAdvertisedPrefix. An up-to-date fingerprint must be provided in order to update the PublicAdvertisedPrefix, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a PublicAdvertisedPrefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource type. The server generates this identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The address range, in CIDR format, represented by this public advertised prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipCidrRange")]
		public string IpCidrRange { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#publicAdvertisedPrefix for public advertised prefixes.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#publicAdvertisedPrefix")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#publicAdvertisedPrefix";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies how child public delegated prefix will be scoped. It could be one of following values: - `REGIONAL`: The public delegated prefix is regional only. The provisioning will take a few minutes. - `GLOBAL`: The public delegated prefix is global only. The provisioning will take ~4 weeks. - `GLOBAL_AND_REGIONAL` [output only]: The public delegated prefixes is BYOIP V1 legacy prefix. This is output only value and no longer supported in BYOIP V2. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pdpScope")]
		public System.Nullable<PublicAdvertisedPrefixPdpScope> PdpScope { get; set; }
		
		/// <summary>
		/// [Output Only] The list of public delegated prefixes that exist for this public advertised prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicDelegatedPrefixs")]
		public PublicAdvertisedPrefixPublicDelegatedPrefix[] PublicDelegatedPrefixs { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The shared secret to be used for reverse DNS verification.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharedSecret")]
		public string SharedSecret { get; set; }
		
		/// <summary>
		/// The status of the public advertised prefix. Possible values include: - `INITIAL`: RPKI validation is complete. - `PTR_CONFIGURED`: User has configured the PTR. - `VALIDATED`: Reverse DNS lookup is successful. - `REVERSE_DNS_LOOKUP_FAILED`: Reverse DNS lookup failed. - `PREFIX_CONFIGURATION_IN_PROGRESS`: The prefix is being configured. - `PREFIX_CONFIGURATION_COMPLETE`: The prefix is fully configured. - `PREFIX_REMOVAL_IN_PROGRESS`: The prefix is being removed. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<PublicAdvertisedPrefixStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PublicAdvertisedPrefixByoipApiVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		V1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		V2 = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PublicAdvertisedPrefixPdpScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL_AND_REGIONAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGIONAL = 2,
	}
	
	/// <summary>
	/// Represents a CIDR range which can be used to assign addresses.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicAdvertisedPrefixPublicDelegatedPrefix
	{
		
		/// <summary>
		/// The IP address range of the public delegated prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipRange")]
		public string IpRange { get; set; }
		
		/// <summary>
		/// The name of the public delegated prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The project number of the public delegated prefix
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="project")]
		public string Project { get; set; }
		
		/// <summary>
		/// The region of the public delegated prefix if it is regional. If absent, the prefix is global.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The status of the public delegated prefix. Possible values are: INITIALIZING: The public delegated prefix is being initialized and addresses cannot be created yet. ANNOUNCED: The public delegated prefix is active.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PublicAdvertisedPrefixStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANNOUNCED_TO_INTERNET = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INITIAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREFIX_CONFIGURATION_COMPLETE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREFIX_CONFIGURATION_IN_PROGRESS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREFIX_REMOVAL_IN_PROGRESS = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PTR_CONFIGURED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY_TO_ANNOUNCE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVERSE_DNS_LOOKUP_FAILED = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VALIDATED = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicAdvertisedPrefixList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of PublicAdvertisedPrefix resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public PublicAdvertisedPrefix[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#publicAdvertisedPrefix for public advertised prefixes.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#publicAdvertisedPrefixList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#publicAdvertisedPrefixList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public PublicAdvertisedPrefixListWarning Warning { get; set; }
	}
	
	public class PublicAdvertisedPrefixListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PublicAdvertisedPrefixListWarningData[] PublicAdvertisedPrefixListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class PublicAdvertisedPrefixListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A PublicDelegatedPrefix resource represents an IP block within a PublicAdvertisedPrefix that is configured within a single cloud scope (global or region). IPs in the block can be allocated to resources within that scope. Public delegated prefixes may be further broken up into smaller IP blocks in the same scope as the parent block.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicDelegatedPrefix
	{
		
		/// <summary>
		/// [Output Only] The version of BYOIP API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="byoipApiVersion")]
		public PublicAdvertisedPrefixByoipApiVersion ByoipApiVersion { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a new PublicDelegatedPrefix. An up-to-date fingerprint must be provided in order to update the PublicDelegatedPrefix, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a PublicDelegatedPrefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource type. The server generates this identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The IP address range, in CIDR format, represented by this public delegated prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipCidrRange")]
		public string IpCidrRange { get; set; }
		
		/// <summary>
		/// If true, the prefix will be live migrated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isLiveMigration")]
		public System.Nullable<System.Boolean> IsLiveMigration { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#publicDelegatedPrefix for public delegated prefixes.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#publicDelegatedPrefix")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#publicDelegatedPrefix";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The URL of parent prefix. Either PublicAdvertisedPrefix or PublicDelegatedPrefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentPrefix")]
		public string ParentPrefix { get; set; }
		
		/// <summary>
		/// The list of sub public delegated prefixes that exist for this public delegated prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicDelegatedSubPrefixs")]
		public PublicDelegatedPrefixPublicDelegatedSubPrefix[] PublicDelegatedSubPrefixs { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the public delegated prefix resides. This field applies only to the region resource. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the public delegated prefix, which can be one of following values: - `INITIALIZING` The public delegated prefix is being initialized and addresses cannot be created yet. - `READY_TO_ANNOUNCE` The public delegated prefix is a live migration prefix and is active. - `ANNOUNCED` The public delegated prefix is active. - `DELETING` The public delegated prefix is being deprovsioned. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<PublicDelegatedPrefixStatus> Status { get; set; }
	}
	
	/// <summary>
	/// Represents a sub PublicDelegatedPrefix.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicDelegatedPrefixPublicDelegatedSubPrefix
	{
		
		/// <summary>
		/// Name of the project scoping this PublicDelegatedSubPrefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delegateeProject")]
		public string DelegateeProject { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The IP address range, in CIDR format, represented by this sub public delegated prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipCidrRange")]
		public string IpCidrRange { get; set; }
		
		/// <summary>
		/// Whether the sub prefix is delegated to create Address resources in the delegatee project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isAddress")]
		public System.Nullable<System.Boolean> IsAddress { get; set; }
		
		/// <summary>
		/// The name of the sub public delegated prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] The region of the sub public delegated prefix if it is regional. If absent, the sub prefix is global.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the sub public delegated prefix.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public NetworkPeeringState Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum PublicDelegatedPrefixStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANNOUNCED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANNOUNCED_TO_GOOGLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ANNOUNCED_TO_INTERNET = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INITIALIZING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY_TO_ANNOUNCE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicDelegatedPrefixAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of PublicDelegatedPrefixesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, PublicDelegatedPrefixesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#publicDelegatedPrefixAggregatedList for aggregated lists of public delegated prefixes.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#publicDelegatedPrefixAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#publicDelegatedPrefixAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public PublicDelegatedPrefixAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicDelegatedPrefixesScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of PublicDelegatedPrefixes contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publicDelegatedPrefixes")]
		public PublicDelegatedPrefix[] PublicDelegatedPrefixes { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning which replaces the list of public delegated prefixes when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public PublicDelegatedPrefixesScopedListWarning Warning { get; set; }
	}
	
	public class PublicDelegatedPrefixesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PublicDelegatedPrefixesScopedListWarningData[] PublicDelegatedPrefixesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class PublicDelegatedPrefixesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class PublicDelegatedPrefixAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PublicDelegatedPrefixAggregatedListWarningData[] PublicDelegatedPrefixAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class PublicDelegatedPrefixAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicDelegatedPrefixList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of PublicDelegatedPrefix resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public PublicDelegatedPrefix[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#publicDelegatedPrefixList for public delegated prefixes.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#publicDelegatedPrefixList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#publicDelegatedPrefixList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public PublicDelegatedPrefixListWarning Warning { get; set; }
	}
	
	public class PublicDelegatedPrefixListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public PublicDelegatedPrefixListWarningData[] PublicDelegatedPrefixListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class PublicDelegatedPrefixListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Region resource. A region is a geographical area where a resource is located. For more information, read Regions and Zones.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Region
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// Deprecation status for a public resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public DeprecationStatus Deprecated { get; set; }
		
		/// <summary>
		/// [Output Only] Textual description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#region for regions.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#region")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#region";
		
		/// <summary>
		/// [Output Only] Name of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] Quotas assigned to this region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quotas")]
		public Quota[] Quotas { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Status of the region, either UP or DOWN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<RegionStatus> Status { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportsPzs")]
		public System.Nullable<System.Boolean> SupportsPzs { get; set; }
		
		/// <summary>
		/// [Output Only] A list of zones available in this region, in the form of resource URLs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RegionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UP = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionAddressesMoveRequest
	{
		
		/// <summary>
		/// An optional destination address description if intended to be different from the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The URL of the destination address to move to. This can be a full or partial URL. For example, the following are all valid URLs to a address: - https://www.googleapis.com/compute/v1/projects/project/regions/region /addresses/address - projects/project/regions/region/addresses/address Note that destination project must be different from the source project. So /regions/region/addresses/address is not valid partial url.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationAddress")]
		public string DestinationAddress { get; set; }
	}
	
	/// <summary>
	/// Contains a list of autoscalers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionAutoscalerList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Autoscaler resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Autoscaler[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#regionAutoscalerList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#regionAutoscalerList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RegionAutoscalerListWarning Warning { get; set; }
	}
	
	public class RegionAutoscalerListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RegionAutoscalerListWarningData[] RegionAutoscalerListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RegionAutoscalerListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionDiskTypeList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of DiskType resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public DiskType[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#regionDiskTypeList for region disk types.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#regionDiskTypeList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#regionDiskTypeList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RegionDiskTypeListWarning Warning { get; set; }
	}
	
	public class RegionDiskTypeListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RegionDiskTypeListWarningData[] RegionDiskTypeListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RegionDiskTypeListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionDisksAddResourcePoliciesRequest
	{
		
		/// <summary>
		/// Resource policies to be added to this disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public string[] ResourcePolicies { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionDisksRemoveResourcePoliciesRequest
	{
		
		/// <summary>
		/// Resource policies to be removed from this disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public string[] ResourcePolicies { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionDisksResizeRequest
	{
		
		/// <summary>
		/// The new size of the regional persistent disk, which is specified in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public string SizeGb { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionDisksStartAsyncReplicationRequest
	{
		
		/// <summary>
		/// The secondary disk to start asynchronous replication to. You can provide this as a partial or full URL to the resource. For example, the following are valid values: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /disks/disk - https://www.googleapis.com/compute/v1/projects/project/regions/region /disks/disk - projects/project/zones/zone/disks/disk - projects/project/regions/region/disks/disk - zones/zone/disks/disk - regions/region/disks/disk 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asyncSecondaryDisk")]
		public string AsyncSecondaryDisk { get; set; }
	}
	
	/// <summary>
	/// Contains a list of InstanceGroup resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InstanceGroup resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InstanceGroup[] Items { get; set; }
		
		/// <summary>
		/// The resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#regionInstanceGroupList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#regionInstanceGroupList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RegionInstanceGroupListWarning Warning { get; set; }
	}
	
	public class RegionInstanceGroupListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RegionInstanceGroupListWarningData[] RegionInstanceGroupListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RegionInstanceGroupListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// RegionInstanceGroupManagers.deletePerInstanceConfigs
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagerDeleteInstanceConfigReq
	{
		
		/// <summary>
		/// The list of instance names for which we want to delete per-instance configs on this managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="names")]
		public string[] Names { get; set; }
	}
	
	/// <summary>
	/// Contains a list of managed instance groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagerList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InstanceGroupManager resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InstanceGroupManager[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] The resource type, which is always compute#instanceGroupManagerList for a list of managed instance groups that exist in th regional scope.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#regionInstanceGroupManagerList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#regionInstanceGroupManagerList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RegionInstanceGroupManagerListWarning Warning { get; set; }
	}
	
	public class RegionInstanceGroupManagerListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RegionInstanceGroupManagerListWarningData[] RegionInstanceGroupManagerListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RegionInstanceGroupManagerListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// RegionInstanceGroupManagers.patchPerInstanceConfigs
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagerPatchInstanceConfigReq
	{
		
		/// <summary>
		/// The list of per-instance configurations to insert or patch on this managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perInstanceConfigs")]
		public PerInstanceConfig[] PerInstanceConfigs { get; set; }
	}
	
	/// <summary>
	/// RegionInstanceGroupManagers.updatePerInstanceConfigs
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagerUpdateInstanceConfigReq
	{
		
		/// <summary>
		/// The list of per-instance configurations to insert or patch on this managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="perInstanceConfigs")]
		public PerInstanceConfig[] PerInstanceConfigs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagersAbandonInstancesRequest
	{
		
		/// <summary>
		/// The URLs of one or more instances to abandon. This can be a full URL or a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
	}
	
	/// <summary>
	/// RegionInstanceGroupManagers.applyUpdatesToInstances
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagersApplyUpdatesRequest
	{
		
		/// <summary>
		/// Flag to update all instances instead of specified list of “instances”. If the flag is set to true then the instances may not be specified in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allInstances")]
		public System.Nullable<System.Boolean> AllInstances { get; set; }
		
		/// <summary>
		/// The list of URLs of one or more instances for which you want to apply updates. Each URL can be a full URL or a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
		
		/// <summary>
		/// The minimal action that you want to perform on each instance during the update: - REPLACE: At minimum, delete the instance and create it again. - RESTART: Stop the instance and start it again. - REFRESH: Do not stop the instance and limit disruption as much as possible. - NONE: Do not disrupt the instance at all. By default, the minimum action is NONE. If your update requires a more disruptive action than you set with this flag, the necessary action is performed to execute the update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimalAction")]
		public InstanceGroupManagerUpdatePolicyMinimalAction MinimalAction { get; set; }
		
		/// <summary>
		/// The most disruptive action that you want to perform on each instance during the update: - REPLACE: Delete the instance and create it again. - RESTART: Stop the instance and start it again. - REFRESH: Do not stop the instance and limit disruption as much as possible. - NONE: Do not disrupt the instance at all. By default, the most disruptive allowed action is REPLACE. If your update requires a more disruptive action than you set with this flag, the update request will fail.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mostDisruptiveAllowedAction")]
		public InstanceGroupManagerUpdatePolicyMinimalAction MostDisruptiveAllowedAction { get; set; }
	}
	
	/// <summary>
	/// RegionInstanceGroupManagers.createInstances
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagersCreateInstancesRequest
	{
		
		/// <summary>
		/// [Required] List of specifications of per-instance configs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public PerInstanceConfig[] Instances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagersDeleteInstancesRequest
	{
		
		/// <summary>
		/// The URLs of one or more instances to delete. This can be a full URL or a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
		
		/// <summary>
		/// Specifies whether the request should proceed despite the inclusion of instances that are not members of the group or that are already in the process of being deleted or abandoned. If this field is set to `false` and such an instance is specified in the request, the operation fails. The operation always fails if the request contains a malformed instance URL or a reference to an instance that exists in a zone or region other than the group's zone or region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="skipInstancesOnValidationError")]
		public System.Nullable<System.Boolean> SkipInstancesOnValidationError { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagersListErrorsResponse
	{
		
		/// <summary>
		/// [Output Only] The list of errors of the managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InstanceManagedByIgmError[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagersListInstanceConfigsResp
	{
		
		/// <summary>
		/// [Output Only] The list of PerInstanceConfig.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public PerInstanceConfig[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RegionInstanceGroupManagersListInstanceConfigsRespWarning Warning { get; set; }
	}
	
	public class RegionInstanceGroupManagersListInstanceConfigsRespWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RegionInstanceGroupManagersListInstanceConfigsRespWarningData[] RegionInstanceGroupManagersListInstanceConfigsRespWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RegionInstanceGroupManagersListInstanceConfigsRespWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagersListInstancesResponse
	{
		
		/// <summary>
		/// A list of managed instances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managedInstances")]
		public ManagedInstance[] ManagedInstances { get; set; }
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagersRecreateRequest
	{
		
		/// <summary>
		/// The URLs of one or more instances to recreate. This can be a full URL or a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagersSetTargetPoolsRequest
	{
		
		/// <summary>
		/// Fingerprint of the target pools information, which is a hash of the contents. This field is used for optimistic locking when you update the target pool entries. This field is optional.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// The URL of all TargetPool resources to which instances in the instanceGroup field are added. The target pools automatically apply to all of the instances in the managed instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPools")]
		public string[] TargetPools { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupManagersSetTemplateRequest
	{
		
		/// <summary>
		/// URL of the InstanceTemplate resource from which all new instances will be created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceTemplate")]
		public string InstanceTemplate { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupsListInstances
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of InstanceWithNamedPorts resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public InstanceWithNamedPorts[] Items { get; set; }
		
		/// <summary>
		/// The resource type.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#regionInstanceGroupsListInstances")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#regionInstanceGroupsListInstances";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RegionInstanceGroupsListInstancesWarning Warning { get; set; }
	}
	
	public class RegionInstanceGroupsListInstancesWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RegionInstanceGroupsListInstancesWarningData[] RegionInstanceGroupsListInstancesWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RegionInstanceGroupsListInstancesWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupsListInstancesRequest
	{
		
		/// <summary>
		/// Instances in which state should be returned. Valid options are: 'ALL', 'RUNNING'. By default, it lists all instances.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceState")]
		public InstanceGroupsListInstancesRequestInstanceState InstanceState { get; set; }
		
		/// <summary>
		/// Name of port user is interested in. It is optional. If it is set, only information about this ports will be returned. If it is not set, all the named ports will be returned. Always lists all instances.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="portName")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string PortName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionInstanceGroupsSetNamedPortsRequest
	{
		
		/// <summary>
		/// The fingerprint of the named ports information for this instance group. Use this optional property to prevent conflicts when multiple users change the named ports settings concurrently. Obtain the fingerprint with the instanceGroups.get method. Then, include the fingerprint in your request to ensure that you do not overwrite changes that were applied from another concurrent request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// The list of named ports to set for this instance group.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namedPorts")]
		public NamedPort[] NamedPorts { get; set; }
	}
	
	/// <summary>
	/// Contains a list of region resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Region resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Region[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#regionList for lists of regions.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#regionList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#regionList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RegionListWarning Warning { get; set; }
	}
	
	public class RegionListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RegionListWarningData[] RegionListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RegionListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionNetworkEndpointGroupsAttachEndpointsRequest
	{
		
		/// <summary>
		/// The list of network endpoints to be attached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEndpoints")]
		public NetworkEndpoint[] NetworkEndpoints { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionNetworkEndpointGroupsDetachEndpointsRequest
	{
		
		/// <summary>
		/// The list of network endpoints to be detached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkEndpoints")]
		public NetworkEndpoint[] NetworkEndpoints { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse
	{
		
		/// <summary>
		/// Effective firewalls from firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewallPolicys")]
		public RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicy[] FirewallPolicys { get; set; }
		
		/// <summary>
		/// Effective firewalls on the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="firewalls")]
		public Firewall[] Firewalls { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicy
	{
		
		/// <summary>
		/// [Output Only] The display name of the firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="displayName")]
		public string DisplayName { get; set; }
		
		/// <summary>
		/// [Output Only] The name of the firewall policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The rules that apply to the network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public FirewallPolicyRule[] Rules { get; set; }
		
		/// <summary>
		/// [Output Only] The type of the firewall policy. Can be one of HIERARCHY, NETWORK, NETWORK_REGIONAL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicyType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionSetLabelsRequest
	{
		
		/// <summary>
		/// The fingerprint of the previous set of labels for this resource, used to detect conflicts. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels. Make a get() request to the resource to get the latest fingerprint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// The labels to set for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionSetPolicyRequest
	{
		
		/// <summary>
		/// Flatten Policy to create a backwacd compatible wire-format. Deprecated. Use 'policy' to specify bindings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindings")]
		public Binding[] Bindings { get; set; }
		
		/// <summary>
		/// Flatten Policy to create a backward compatible wire-format. Deprecated. Use 'policy' to specify the etag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public Policy Policy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionTargetHttpsProxiesSetSslCertificatesRequest
	{
		
		/// <summary>
		/// New set of SslCertificate resources to associate with this TargetHttpsProxy resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslCertificates")]
		public string[] SslCertificates { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RegionUrlMapsValidateRequest
	{
		
		/// <summary>
		/// Represents a URL Map resource. Compute Engine has two URL Map resources: * [Global](/compute/docs/reference/rest/v1/urlMaps) * [Regional](/compute/docs/reference/rest/v1/regionUrlMaps) A URL map resource is a component of certain types of cloud load balancers and Traffic Director: * urlMaps are used by global external Application Load Balancers, classic Application Load Balancers, and cross-region internal Application Load Balancers. * regionUrlMaps are used by internal Application Load Balancers, regional external Application Load Balancers and regional internal Application Load Balancers. For a list of supported URL map features by the load balancer type, see the Load balancing features: Routing and traffic management table. For a list of supported URL map features for Traffic Director, see the Traffic Director features: Routing and traffic management table. This resource defines mappings from hostnames and URL paths to either a backend service or a backend bucket. To use the global urlMaps resource, the backend service must have a loadBalancingScheme of either EXTERNAL or INTERNAL_SELF_MANAGED. To use the regionUrlMaps resource, the backend service must have a loadBalancingScheme of INTERNAL_MANAGED. For more information, read URL Map Concepts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public UrlMap Resource { get; set; }
	}
	
	/// <summary>
	/// Represents a URL Map resource. Compute Engine has two URL Map resources: * [Global](/compute/docs/reference/rest/v1/urlMaps) * [Regional](/compute/docs/reference/rest/v1/regionUrlMaps) A URL map resource is a component of certain types of cloud load balancers and Traffic Director: * urlMaps are used by global external Application Load Balancers, classic Application Load Balancers, and cross-region internal Application Load Balancers. * regionUrlMaps are used by internal Application Load Balancers, regional external Application Load Balancers and regional internal Application Load Balancers. For a list of supported URL map features by the load balancer type, see the Load balancing features: Routing and traffic management table. For a list of supported URL map features for Traffic Director, see the Traffic Director features: Routing and traffic management table. This resource defines mappings from hostnames and URL paths to either a backend service or a backend bucket. To use the global urlMaps resource, the backend service must have a loadBalancingScheme of either EXTERNAL or INTERNAL_SELF_MANAGED. To use the regionUrlMaps resource, the backend service must have a loadBalancingScheme of INTERNAL_MANAGED. For more information, read URL Map Concepts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlMap
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="defaultRouteAction")]
		public HttpRouteAction DefaultRouteAction { get; set; }
		
		/// <summary>
		/// The full or partial URL of the defaultService resource to which traffic is directed if none of the hostRules match. If defaultRouteAction is also specified, advanced routing actions, such as URL rewrites, take effect before sending the request to the backend. However, if defaultService is specified, defaultRouteAction cannot contain any weightedBackendServices. Conversely, if routeAction specifies any weightedBackendServices, service must not be specified. Only one of defaultService, defaultUrlRedirect , or defaultRouteAction.weightedBackendService must be set. defaultService has no effect when the URL map is bound to a target gRPC proxy that has the validateForProxyless field set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultService")]
		public string DefaultService { get; set; }
		
		/// <summary>
		/// Specifies settings for an HTTP redirect.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultUrlRedirect")]
		public HttpRedirectAction DefaultUrlRedirect { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field is ignored when inserting a UrlMap. An up-to-date fingerprint must be provided in order to update the UrlMap, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a UrlMap.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// The request and response header transformations that take effect before the request is passed along to the selected backendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerAction")]
		public HttpHeaderAction HeaderAction { get; set; }
		
		/// <summary>
		/// The list of host rules to use against the URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostRules")]
		public HostRule[] HostRules { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#urlMaps for url maps.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#urlMap")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#urlMap";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The list of named PathMatchers to use against the URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathMatchers")]
		public PathMatcher[] PathMatchers { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional URL map resides. This field is not applicable to global URL maps. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The list of expected URL mapping tests. Request to update the UrlMap succeeds only if all test cases pass. You can specify a maximum of 100 tests per UrlMap. Not supported when the URL map is bound to a target gRPC proxy that has validateForProxyless field set to true.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tests")]
		public UrlMapTest[] Tests { get; set; }
	}
	
	/// <summary>
	/// Message for the expected URL mappings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlMapTest
	{
		
		/// <summary>
		/// Description of this test case.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The expected output URL evaluated by the load balancer containing the scheme, host, path and query parameters. For rules that forward requests to backends, the test passes only when expectedOutputUrl matches the request forwarded by the load balancer to backends. For rules with urlRewrite, the test verifies that the forwarded request matches hostRewrite and pathPrefixRewrite in the urlRewrite action. When service is specified, expectedOutputUrl`s scheme is ignored. For rules with urlRedirect, the test passes only if expectedOutputUrl matches the URL in the load balancer's redirect response. If urlRedirect specifies https_redirect, the test passes only if the scheme in expectedOutputUrl is also set to HTTPS. If urlRedirect specifies strip_query, the test passes only if expectedOutputUrl does not contain any query parameters. expectedOutputUrl is optional when service is specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expectedOutputUrl")]
		public string ExpectedOutputUrl { get; set; }
		
		/// <summary>
		/// For rules with urlRedirect, the test passes only if expectedRedirectResponseCode matches the HTTP status code in load balancer's redirect response. expectedRedirectResponseCode cannot be set when service is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expectedRedirectResponseCode")]
		public System.Nullable<System.Int32> ExpectedRedirectResponseCode { get; set; }
		
		/// <summary>
		/// HTTP headers for this request. If headers contains a host header, then host must also match the header value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public UrlMapTestHeader[] Headers { get; set; }
		
		/// <summary>
		/// Host portion of the URL. If headers contains a host header, then host must also match the header value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// Path portion of the URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Expected BackendService or BackendBucket resource the given URL should be mapped to. The service field cannot be set if expectedRedirectResponseCode is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
	}
	
	/// <summary>
	/// HTTP headers used in UrlMapTests.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlMapTestHeader
	{
		
		/// <summary>
		/// Header name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Header value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of reservations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReservationAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Allocation resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, ReservationsScopedList> Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#reservationAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#reservationAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ReservationAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReservationsScopedList
	{
		
		/// <summary>
		/// A list of reservations contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservations")]
		public Reservation[] Reservations { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of reservations when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ReservationsScopedListWarning Warning { get; set; }
	}
	
	public class ReservationsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ReservationsScopedListWarningData[] ReservationsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ReservationsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class ReservationAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ReservationAggregatedListWarningData[] ReservationAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ReservationAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReservationList
	{
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] A list of Allocation resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Reservation[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource.Always compute#reservationsList for listsof reservations
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#reservationList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#reservationList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ReservationListWarning Warning { get; set; }
	}
	
	public class ReservationListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ReservationListWarningData[] ReservationListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ReservationListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ReservationsResizeRequest
	{
		
		/// <summary>
		/// Number of allocated resources can be resized with minimum = 1 and maximum = 1000.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="specificSkuCount")]
		public string SpecificSkuCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourceGroupReference
	{
		
		/// <summary>
		/// A URI referencing one of the instance groups or network endpoint groups listed in the backend service.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="group")]
		public string Group { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePoliciesScopedList
	{
		
		/// <summary>
		/// A list of resourcePolicies contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePolicies")]
		public ResourcePolicy[] ResourcePolicies { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of resourcePolicies when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ResourcePoliciesScopedListWarning Warning { get; set; }
	}
	
	/// <summary>
	/// Represents a Resource Policy resource. You can use resource policies to schedule actions for some Compute Engine resources. For example, you can use them to schedule persistent disk snapshots.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicy
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Resource policy for disk consistency groups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskConsistencyGroupPolicy")]
		public ResourcePolicyDiskConsistencyGroupPolicy DiskConsistencyGroupPolicy { get; set; }
		
		/// <summary>
		/// A GroupPlacementPolicy specifies resource placement configuration. It specifies the failure bucket separation as well as network locality
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="groupPlacementPolicy")]
		public ResourcePolicyGroupPlacementPolicy GroupPlacementPolicy { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// An InstanceSchedulePolicy specifies when and how frequent certain operations are performed on the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceSchedulePolicy")]
		public ResourcePolicyInstanceSchedulePolicy InstanceSchedulePolicy { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#resource_policies for resource policies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#resourcePolicy")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#resourcePolicy";
		
		/// <summary>
		/// The name of the resource, provided by the client when initially creating the resource. The resource name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// Contains output only fields. Use this sub-message for all output fields set on ResourcePolicy. The internal structure of this "status" field should mimic the structure of ResourcePolicy proto specification.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceStatus")]
		public ResourcePolicyResourceStatus ResourceStatus { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined fully-qualified URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// A snapshot schedule policy specifies when and how frequently snapshots are to be created for the target disk. Also specifies how many and how long these scheduled snapshots should be retained.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotSchedulePolicy")]
		public ResourcePolicySnapshotSchedulePolicy SnapshotSchedulePolicy { get; set; }
		
		/// <summary>
		/// [Output Only] The status of resource policy creation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<ResourcePolicyStatus> Status { get; set; }
	}
	
	/// <summary>
	/// Resource policy for disk consistency groups.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyDiskConsistencyGroupPolicy
	{
	}
	
	/// <summary>
	/// A GroupPlacementPolicy specifies resource placement configuration. It specifies the failure bucket separation as well as network locality
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyGroupPlacementPolicy
	{
		
		/// <summary>
		/// The number of availability domains to spread instances across. If two instances are in different availability domain, they are not in the same low latency network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availabilityDomainCount")]
		public System.Nullable<System.Int32> AvailabilityDomainCount { get; set; }
		
		/// <summary>
		/// Specifies network collocation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="collocation")]
		public System.Nullable<ResourcePolicyGroupPlacementPolicyCollocation> Collocation { get; set; }
		
		/// <summary>
		/// Number of VMs in this placement group. Google does not recommend that you use this field unless you use a compact policy and you want your policy to work only if it contains this exact number of VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmCount")]
		public System.Nullable<System.Int32> VmCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ResourcePolicyGroupPlacementPolicyCollocation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COLLOCATED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED_COLLOCATION = 1,
	}
	
	/// <summary>
	/// An InstanceSchedulePolicy specifies when and how frequent certain operations are performed on the instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyInstanceSchedulePolicy
	{
		
		/// <summary>
		/// The expiration time of the schedule. The timestamp is an RFC3339 string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expirationTime")]
		public string ExpirationTime { get; set; }
		
		/// <summary>
		/// The start time of the schedule. The timestamp is an RFC3339 string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
		
		/// <summary>
		/// Specifies the time zone to be used in interpreting Schedule.schedule. The value of this field must be a time zone name from the tz database: https://wikipedia.org/wiki/Tz_database.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeZone")]
		public string TimeZone { get; set; }
		
		/// <summary>
		/// Schedule for an instance operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmStartSchedule")]
		public ResourcePolicyInstanceSchedulePolicySchedule VmStartSchedule { get; set; }
		
		/// <summary>
		/// Schedule for an instance operation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmStopSchedule")]
		public ResourcePolicyInstanceSchedulePolicySchedule VmStopSchedule { get; set; }
	}
	
	/// <summary>
	/// Schedule for an instance operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyInstanceSchedulePolicySchedule
	{
		
		/// <summary>
		/// Specifies the frequency for the operation, using the unix-cron format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public string Schedule { get; set; }
	}
	
	/// <summary>
	/// Contains output only fields. Use this sub-message for all output fields set on ResourcePolicy. The internal structure of this "status" field should mimic the structure of ResourcePolicy proto specification.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyResourceStatus
	{
		
		[System.Runtime.Serialization.DataMember(Name="instanceSchedulePolicy")]
		public ResourcePolicyResourceStatusInstanceSchedulePolicyStatus InstanceSchedulePolicy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyResourceStatusInstanceSchedulePolicyStatus
	{
		
		/// <summary>
		/// [Output Only] The last time the schedule successfully ran. The timestamp is an RFC3339 string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastRunStartTime")]
		public string LastRunStartTime { get; set; }
		
		/// <summary>
		/// [Output Only] The next time the schedule is planned to run. The actual time might be slightly different. The timestamp is an RFC3339 string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextRunStartTime")]
		public string NextRunStartTime { get; set; }
	}
	
	/// <summary>
	/// A snapshot schedule policy specifies when and how frequently snapshots are to be created for the target disk. Also specifies how many and how long these scheduled snapshots should be retained.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicySnapshotSchedulePolicy
	{
		
		/// <summary>
		/// Policy for retention of scheduled snapshots.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retentionPolicy")]
		public ResourcePolicySnapshotSchedulePolicyRetentionPolicy RetentionPolicy { get; set; }
		
		/// <summary>
		/// A schedule for disks where the schedueled operations are performed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public ResourcePolicySnapshotSchedulePolicySchedule Schedule { get; set; }
		
		/// <summary>
		/// Specified snapshot properties for scheduled snapshots created by this policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotProperties")]
		public ResourcePolicySnapshotSchedulePolicySnapshotProperties SnapshotProperties { get; set; }
	}
	
	/// <summary>
	/// Policy for retention of scheduled snapshots.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicySnapshotSchedulePolicyRetentionPolicy
	{
		
		/// <summary>
		/// Maximum age of the snapshot that is allowed to be kept.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxRetentionDays")]
		public System.Nullable<System.Int32> MaxRetentionDays { get; set; }
		
		/// <summary>
		/// Specifies the behavior to apply to scheduled snapshots when the source disk is deleted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="onSourceDiskDelete")]
		public System.Nullable<ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete> OnSourceDiskDelete { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ResourcePolicySnapshotSchedulePolicyRetentionPolicyOnSourceDiskDelete
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		APPLY_RETENTION_POLICY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KEEP_AUTO_SNAPSHOTS = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED_ON_SOURCE_DISK_DELETE = 2,
	}
	
	/// <summary>
	/// A schedule for disks where the schedueled operations are performed.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicySnapshotSchedulePolicySchedule
	{
		
		/// <summary>
		/// Time window specified for daily operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dailySchedule")]
		public ResourcePolicyDailyCycle DailySchedule { get; set; }
		
		/// <summary>
		/// Time window specified for hourly operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hourlySchedule")]
		public ResourcePolicyHourlyCycle HourlySchedule { get; set; }
		
		/// <summary>
		/// Time window specified for weekly operations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="weeklySchedule")]
		public ResourcePolicyWeeklyCycle WeeklySchedule { get; set; }
	}
	
	/// <summary>
	/// Time window specified for daily operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyDailyCycle
	{
		
		/// <summary>
		/// Defines a schedule with units measured in days. The value determines how many days pass between the start of each cycle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="daysInCycle")]
		public System.Nullable<System.Int32> DaysInCycle { get; set; }
		
		/// <summary>
		/// [Output only] A predetermined duration for the window, automatically chosen to be the smallest possible in the given scenario.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// Start time of the window. This must be in UTC format that resolves to one of 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example, both 13:00-5 and 08:00 are valid.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	/// <summary>
	/// Time window specified for hourly operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyHourlyCycle
	{
		
		/// <summary>
		/// [Output only] Duration of the time window, automatically chosen to be smallest possible in the given scenario.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// Defines a schedule with units measured in hours. The value determines how many hours pass between the start of each cycle.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hoursInCycle")]
		public System.Nullable<System.Int32> HoursInCycle { get; set; }
		
		/// <summary>
		/// Time within the window to start the operations. It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	/// <summary>
	/// Time window specified for weekly operations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyWeeklyCycle
	{
		
		/// <summary>
		/// Up to 7 intervals/windows, one for each day of the week.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dayOfWeeks")]
		public ResourcePolicyWeeklyCycleDayOfWeek[] DayOfWeeks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyWeeklyCycleDayOfWeek
	{
		
		/// <summary>
		/// Defines a schedule that runs on specific days of the week. Specify one or more days. The following options are available: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="day")]
		public System.Nullable<ResourcePolicyWeeklyCycleDayOfWeekDay> Day { get; set; }
		
		/// <summary>
		/// [Output only] Duration of the time window, automatically chosen to be smallest possible in the given scenario.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// Time within the window to start the operations. It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="startTime")]
		public string StartTime { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ResourcePolicyWeeklyCycleDayOfWeekDay
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FRIDAY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MONDAY = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SATURDAY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUNDAY = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THURSDAY = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TUESDAY = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEDNESDAY = 7,
	}
	
	/// <summary>
	/// Specified snapshot properties for scheduled snapshots created by this policy.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicySnapshotSchedulePolicySnapshotProperties
	{
		
		/// <summary>
		/// Chain name that the snapshot is created in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chainName")]
		public string ChainName { get; set; }
		
		/// <summary>
		/// Indication to perform a 'guest aware' snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestFlush")]
		public System.Nullable<System.Boolean> GuestFlush { get; set; }
		
		/// <summary>
		/// Labels to apply to scheduled snapshots. These can be later modified by the setLabels method. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Cloud Storage bucket storage location of the auto snapshot (regional or multi-regional).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageLocations")]
		public string[] StorageLocations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ResourcePolicyStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 4,
	}
	
	public class ResourcePoliciesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourcePoliciesScopedListWarningData[] ResourcePoliciesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ResourcePoliciesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of resourcePolicies.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyAggregatedList
	{
		
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of ResourcePolicy resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, ResourcePoliciesScopedList> Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#resourcePolicyAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#resourcePolicyAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ResourcePolicyAggregatedListWarning Warning { get; set; }
	}
	
	public class ResourcePolicyAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourcePolicyAggregatedListWarningData[] ResourcePolicyAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ResourcePolicyAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ResourcePolicyList
	{
		
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] A list of ResourcePolicy resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ResourcePolicy[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource.Always compute#resourcePoliciesList for listsof resourcePolicies
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#resourcePolicyList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#resourcePolicyList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ResourcePolicyListWarning Warning { get; set; }
	}
	
	public class ResourcePolicyListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ResourcePolicyListWarningData[] ResourcePolicyListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ResourcePolicyListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Route resource. A route defines a path from VM instances in the VPC network to a specific destination. This destination can be inside or outside the VPC network. For more information, read the Routes overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Route
	{
		
		/// <summary>
		/// [Output Only] AS path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asPaths")]
		public RouteAsPath[] AsPaths { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this field when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The destination range of outgoing packets that this route applies to. Both IPv4 and IPv6 are supported. Must specify an IPv4 range (e.g. 192.0.2.0/24) or an IPv6 range in RFC 4291 format (e.g. 2001:db8::/32). IPv6 range will be displayed using RFC 5952 compressed format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destRange")]
		public string DestRange { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of this resource. Always compute#routes for Route resources.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#route")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#route";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all following characters (except for the last character) must be a dash, lowercase letter, or digit. The last character must be a lowercase letter or digit.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Fully-qualified URL of the network that this route applies to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// The URL to a gateway that should handle matching packets. You can only specify the internet gateway using a full or partial valid URL: projects/ project/global/gateways/default-internet-gateway
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextHopGateway")]
		public string NextHopGateway { get; set; }
		
		/// <summary>
		/// [Output Only] The full resource name of the Network Connectivity Center hub that will handle matching packets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextHopHub")]
		public string NextHopHub { get; set; }
		
		/// <summary>
		/// The URL to a forwarding rule of type loadBalancingScheme=INTERNAL that should handle matching packets or the IP address of the forwarding Rule. For example, the following are all valid URLs: - 10.128.0.56 - https://www.googleapis.com/compute/v1/projects/project/regions/region /forwardingRules/forwardingRule - regions/region/forwardingRules/forwardingRule 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextHopIlb")]
		public string NextHopIlb { get; set; }
		
		/// <summary>
		/// The URL to an instance that should handle matching packets. You can specify this as a full or partial URL. For example: https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextHopInstance")]
		public string NextHopInstance { get; set; }
		
		/// <summary>
		/// The network IP address of an instance that should handle matching packets. Both IPv6 address and IPv4 addresses are supported. Must specify an IPv4 address in dot-decimal notation (e.g. 192.0.2.99) or an IPv6 address in RFC 4291 format (e.g. 2001:db8::2d9:51:0:0 or 2001:db8:0:0:2d9:51:0:0). IPv6 addresses will be displayed using RFC 5952 compressed format (e.g. 2001:db8::2d9:51:0:0). Should never be an IPv4-mapped IPv6 address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextHopIp")]
		public string NextHopIp { get; set; }
		
		/// <summary>
		/// The URL of the local network if it should handle matching packets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextHopNetwork")]
		public string NextHopNetwork { get; set; }
		
		/// <summary>
		/// [Output Only] The network peering name that should handle matching packets, which should conform to RFC1035.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextHopPeering")]
		public string NextHopPeering { get; set; }
		
		/// <summary>
		/// The URL to a VpnTunnel that should handle matching packets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextHopVpnTunnel")]
		public string NextHopVpnTunnel { get; set; }
		
		/// <summary>
		/// The priority of this route. Priority is used to break ties in cases where there is more than one matching route of equal prefix length. In cases where multiple routes have equal prefix length, the one with the lowest-numbered priority value wins. The default value is `1000`. The priority value must be from `0` to `65535`, inclusive.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.UInt32> Priority { get; set; }
		
		/// <summary>
		/// [Output only] The status of the route.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routeStatus")]
		public System.Nullable<RouteRouteStatus> RouteStatus { get; set; }
		
		/// <summary>
		/// [Output Only] The type of this route, which can be one of the following values: - 'TRANSIT' for a transit route that this router learned from another Cloud Router and will readvertise to one of its BGP peers - 'SUBNET' for a route from a subnet of the VPC - 'BGP' for a route learned from a BGP peer of this router - 'STATIC' for a static route
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routeType")]
		public System.Nullable<RouteRouteType> RouteType { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined fully-qualified URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// A list of instance tags to which this route applies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public string[] Tags { get; set; }
		
		/// <summary>
		/// [Output Only] If potential misconfigurations are detected for this route, this field will be populated with warning messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warnings")]
		public RouteWarnings[] RouteWarnings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouteAsPath
	{
		
		/// <summary>
		/// [Output Only] The AS numbers of the AS Path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asLists")]
		public int[] AsLists { get; set; }
		
		/// <summary>
		/// [Output Only] The type of the AS Path, which can be one of the following values: - 'AS_SET': unordered set of autonomous systems that the route in has traversed - 'AS_SEQUENCE': ordered set of autonomous systems that the route has traversed - 'AS_CONFED_SEQUENCE': ordered set of Member Autonomous Systems in the local confederation that the route has traversed - 'AS_CONFED_SET': unordered set of Member Autonomous Systems in the local confederation that the route has traversed 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pathSegmentType")]
		public System.Nullable<RouteAsPathPathSegmentType> PathSegmentType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouteAsPathPathSegmentType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AS_CONFED_SEQUENCE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AS_CONFED_SET = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AS_SEQUENCE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AS_SET = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouteRouteStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DROPPED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouteRouteType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BGP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATIC = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUBNET = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRANSIT = 3,
	}
	
	public class RouteWarnings
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RouteWarningsData[] RouteWarningsData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RouteWarningsData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of Route resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouteList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Route resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Route[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#routeList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#routeList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RouteListWarning Warning { get; set; }
	}
	
	public class RouteListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RouteListWarningData[] RouteListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RouteListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Cloud Router resource. For more information about Cloud Router, read the Cloud Router overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Router
	{
		
		[System.Runtime.Serialization.DataMember(Name="bgp")]
		public RouterBgp Bgp { get; set; }
		
		/// <summary>
		/// BGP information that must be configured into the routing stack to establish BGP peering. This information must specify the peer ASN and either the interface name, IP address, or peer IP address. Please refer to RFC4273.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bgpPeers")]
		public RouterBgpPeer[] BgpPeers { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Indicates if a router is dedicated for use with encrypted VLAN attachments (interconnectAttachments).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptedInterconnectRouter")]
		public System.Nullable<System.Boolean> EncryptedInterconnectRouter { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Router interfaces. To create a BGP peer that uses a router interface, the interface must have one of the following fields specified: - linkedVpnTunnel - linkedInterconnectAttachment - subnetwork You can create a router interface without any of these fields specified. However, you cannot create a BGP peer that uses that interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaces")]
		public RouterInterface[] Interfaces { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#router for routers.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#router")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#router";
		
		/// <summary>
		/// Keys used for MD5 authentication.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5AuthenticationKeys")]
		public RouterMd5AuthenticationKey[] Md5AuthenticationKeys { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of NAT services created in this router.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nats")]
		public RouterNat[] Nats { get; set; }
		
		/// <summary>
		/// URI of the network to which this router belongs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// [Output Only] URI of the region where the router resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterBgp
	{
		
		/// <summary>
		/// User-specified flag to indicate which mode to use for advertisement. The options are DEFAULT or CUSTOM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertiseMode")]
		public System.Nullable<RouterBgpAdvertiseMode> AdvertiseMode { get; set; }
		
		/// <summary>
		/// User-specified list of prefix groups to advertise in custom mode. This field can only be populated if advertise_mode is CUSTOM and is advertised to all peers of the router. These groups will be advertised in addition to any specified prefixes. Leave this field blank to advertise no custom groups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisedGroups")]
		public string[] AdvertisedGroups { get; set; }
		
		/// <summary>
		/// User-specified list of individual IP ranges to advertise in custom mode. This field can only be populated if advertise_mode is CUSTOM and is advertised to all peers of the router. These IP ranges will be advertised in addition to any specified groups. Leave this field blank to advertise no custom IP ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisedIpRanges")]
		public RouterAdvertisedIpRange[] AdvertisedIpRanges { get; set; }
		
		/// <summary>
		/// Local BGP Autonomous System Number (ASN). Must be an RFC6996 private ASN, either 16-bit or 32-bit. The value will be fixed for this router resource. All VPN tunnels that link to this router will have the same local ASN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="asn")]
		public System.Nullable<System.UInt32> Asn { get; set; }
		
		/// <summary>
		/// The interval in seconds between BGP keepalive messages that are sent to the peer. Hold time is three times the interval at which keepalive messages are sent, and the hold time is the maximum number of seconds allowed to elapse between successive keepalive messages that BGP receives from a peer. BGP will use the smaller of either the local hold time value or the peer's hold time value as the hold time for the BGP connection between the two peers. If set, this value must be between 20 and 60. The default is 20.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keepaliveInterval")]
		public System.Nullable<System.UInt32> KeepaliveInterval { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouterBgpAdvertiseMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEFAULT = 1,
	}
	
	/// <summary>
	/// Description-tagged IP ranges for the router to advertise.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterAdvertisedIpRange
	{
		
		/// <summary>
		/// User-specified description for the IP range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// The IP range to advertise. The value must be a CIDR-formatted string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="range")]
		public string Range { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterBgpPeer
	{
		
		/// <summary>
		/// User-specified flag to indicate which mode to use for advertisement.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertiseMode")]
		public RouterBgpAdvertiseMode AdvertiseMode { get; set; }
		
		/// <summary>
		/// User-specified list of prefix groups to advertise in custom mode, which currently supports the following option: - ALL_SUBNETS: Advertises all of the router's own VPC subnets. This excludes any routes learned for subnets that use VPC Network Peering. Note that this field can only be populated if advertise_mode is CUSTOM and overrides the list defined for the router (in the "bgp" message). These groups are advertised in addition to any specified prefixes. Leave this field blank to advertise no custom groups.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisedGroups")]
		public string[] AdvertisedGroups { get; set; }
		
		/// <summary>
		/// User-specified list of individual IP ranges to advertise in custom mode. This field can only be populated if advertise_mode is CUSTOM and overrides the list defined for the router (in the "bgp" message). These IP ranges are advertised in addition to any specified groups. Leave this field blank to advertise no custom IP ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisedIpRanges")]
		public RouterAdvertisedIpRange[] AdvertisedIpRanges { get; set; }
		
		/// <summary>
		/// The priority of routes advertised to this BGP peer. Where there is more than one matching route of maximum length, the routes with the lowest priority value win.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisedRoutePriority")]
		public System.Nullable<System.UInt32> AdvertisedRoutePriority { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bfd")]
		public RouterBgpPeerBfd Bfd { get; set; }
		
		/// <summary>
		/// A list of user-defined custom learned route IP address ranges for a BGP session.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customLearnedIpRanges")]
		public RouterBgpPeerCustomLearnedIpRange[] CustomLearnedIpRanges { get; set; }
		
		/// <summary>
		/// The user-defined custom learned route priority for a BGP session. This value is applied to all custom learned route ranges for the session. You can choose a value from `0` to `65335`. If you don't provide a value, Google Cloud assigns a priority of `100` to the ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customLearnedRoutePriority")]
		public System.Nullable<System.Int32> CustomLearnedRoutePriority { get; set; }
		
		/// <summary>
		/// The status of the BGP peer connection. If set to FALSE, any active session with the peer is terminated and all associated routing information is removed. If set to TRUE, the peer connection can be established with routing information. The default is TRUE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable")]
		public PacketMirroringEnable Enable { get; set; }
		
		/// <summary>
		/// Enable IPv6 traffic over BGP Peer. If not specified, it is disabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableIpv6")]
		public System.Nullable<System.Boolean> EnableIpv6 { get; set; }
		
		/// <summary>
		/// Name of the interface the BGP peer is associated with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interfaceName")]
		public string InterfaceName { get; set; }
		
		/// <summary>
		/// IP address of the interface inside Google Cloud Platform. Only IPv4 is supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// IPv6 address of the interface inside Google Cloud Platform.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6NexthopAddress")]
		public string Ipv6NexthopAddress { get; set; }
		
		/// <summary>
		/// [Output Only] The resource that configures and manages this BGP peer. - MANAGED_BY_USER is the default value and can be managed by you or other users - MANAGED_BY_ATTACHMENT is a BGP peer that is configured and managed by Cloud Interconnect, specifically by an InterconnectAttachment of type PARTNER. Google automatically creates, updates, and deletes this type of BGP peer when the PARTNER InterconnectAttachment is created, updated, or deleted. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managementType")]
		public System.Nullable<RouterBgpPeerManagementType> ManagementType { get; set; }
		
		/// <summary>
		/// Present if MD5 authentication is enabled for the peering. Must be the name of one of the entries in the Router.md5_authentication_keys. The field must comply with RFC1035.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5AuthenticationKeyName")]
		public string Md5AuthenticationKeyName { get; set; }
		
		/// <summary>
		/// Name of this BGP peer. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Peer BGP Autonomous System Number (ASN). Each BGP interface may use a different value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerAsn")]
		public System.Nullable<System.UInt32> PeerAsn { get; set; }
		
		/// <summary>
		/// IP address of the BGP interface outside Google Cloud Platform. Only IPv4 is supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerIpAddress")]
		public string PeerIpAddress { get; set; }
		
		/// <summary>
		/// IPv6 address of the BGP interface outside Google Cloud Platform.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerIpv6NexthopAddress")]
		public string PeerIpv6NexthopAddress { get; set; }
		
		/// <summary>
		/// URI of the VM instance that is used as third-party router appliances such as Next Gen Firewalls, Virtual Routers, or Router Appliances. The VM instance must be located in zones contained in the same region as this Cloud Router. The VM instance is the peer side of the BGP session.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routerApplianceInstance")]
		public string RouterApplianceInstance { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterBgpPeerBfd
	{
		
		/// <summary>
		/// The minimum interval, in milliseconds, between BFD control packets received from the peer router. The actual value is negotiated between the two routers and is equal to the greater of this value and the transmit interval of the other router. If set, this value must be between 1000 and 30000. The default is 1000.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minReceiveInterval")]
		public System.Nullable<System.UInt32> MinReceiveInterval { get; set; }
		
		/// <summary>
		/// The minimum interval, in milliseconds, between BFD control packets transmitted to the peer router. The actual value is negotiated between the two routers and is equal to the greater of this value and the corresponding receive interval of the other router. If set, this value must be between 1000 and 30000. The default is 1000.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minTransmitInterval")]
		public System.Nullable<System.UInt32> MinTransmitInterval { get; set; }
		
		/// <summary>
		/// The number of consecutive BFD packets that must be missed before BFD declares that a peer is unavailable. If set, the value must be a value between 5 and 16. The default is 5.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="multiplier")]
		public System.Nullable<System.UInt32> Multiplier { get; set; }
		
		/// <summary>
		/// The BFD session initialization mode for this BGP peer. If set to ACTIVE, the Cloud Router will initiate the BFD session for this BGP peer. If set to PASSIVE, the Cloud Router will wait for the peer router to initiate the BFD session for this BGP peer. If set to DISABLED, BFD is disabled for this BGP peer. The default is DISABLED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sessionInitializationMode")]
		public BfdStatusBfdSessionInitializationMode SessionInitializationMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterBgpPeerCustomLearnedIpRange
	{
		
		/// <summary>
		/// The custom learned route IP address range. Must be a valid CIDR-formatted prefix. If an IP address is provided without a subnet mask, it is interpreted as, for IPv4, a `/32` singular IP address range, and, for IPv6, `/128`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="range")]
		public string Range { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouterBgpPeerManagementType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MANAGED_BY_ATTACHMENT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MANAGED_BY_USER = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterInterface
	{
		
		/// <summary>
		/// IP address and range of the interface. The IP range must be in the RFC3927 link-local IP address space. The value must be a CIDR-formatted string, for example: 169.254.0.1/30. NOTE: Do not truncate the address as it represents the IP address of the interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipRange")]
		public string IpRange { get; set; }
		
		/// <summary>
		/// URI of the linked Interconnect attachment. It must be in the same region as the router. Each interface can have one linked resource, which can be a VPN tunnel, an Interconnect attachment, or a subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkedInterconnectAttachment")]
		public string LinkedInterconnectAttachment { get; set; }
		
		/// <summary>
		/// URI of the linked VPN tunnel, which must be in the same region as the router. Each interface can have one linked resource, which can be a VPN tunnel, an Interconnect attachment, or a subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkedVpnTunnel")]
		public string LinkedVpnTunnel { get; set; }
		
		/// <summary>
		/// [Output Only] The resource that configures and manages this interface. - MANAGED_BY_USER is the default value and can be managed directly by users. - MANAGED_BY_ATTACHMENT is an interface that is configured and managed by Cloud Interconnect, specifically, by an InterconnectAttachment of type PARTNER. Google automatically creates, updates, and deletes this type of interface when the PARTNER InterconnectAttachment is created, updated, or deleted. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managementType")]
		public RouterBgpPeerManagementType ManagementType { get; set; }
		
		/// <summary>
		/// Name of this interface entry. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The regional private internal IP address that is used to establish BGP sessions to a VM instance acting as a third-party Router Appliance, such as a Next Gen Firewall, a Virtual Router, or an SD-WAN VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateIpAddress")]
		public string PrivateIpAddress { get; set; }
		
		/// <summary>
		/// Name of the interface that will be redundant with the current interface you are creating. The redundantInterface must belong to the same Cloud Router as the interface here. To establish the BGP session to a Router Appliance VM, you must create two BGP peers. The two BGP peers must be attached to two separate interfaces that are redundant with each other. The redundant_interface must be 1-63 characters long, and comply with RFC1035. Specifically, the redundant_interface must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redundantInterface")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string RedundantInterface { get; set; }
		
		/// <summary>
		/// The URI of the subnetwork resource that this interface belongs to, which must be in the same region as the Cloud Router. When you establish a BGP session to a VM instance using this interface, the VM instance must belong to the same subnetwork as the subnetwork specified here.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetwork")]
		public string Subnetwork { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterMd5AuthenticationKey
	{
		
		/// <summary>
		/// [Input only] Value of the key. For patch and update calls, it can be skipped to copy the value from the previous configuration. This is allowed if the key with the same name existed before the operation. Maximum length is 80 characters. Can only contain printable ASCII characters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// Name used to identify the key. Must be unique within a router. Must be referenced by exactly one bgpPeer. Must comply with RFC1035.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Represents a Nat resource. It enables the VMs within the specified subnetworks to access Internet without external IP addresses. It specifies a list of subnetworks (and the ranges within) that want to use NAT. Customers can also provide the external IPs that would be used for NAT. GCP would auto-allocate ephemeral IPs if no external IPs are provided.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterNat
	{
		
		/// <summary>
		/// The network tier to use when automatically reserving NAT IP addresses. Must be one of: PREMIUM, STANDARD. If not specified, then the current project-level default tier is used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoNetworkTier")]
		public AccessConfigNetworkTier AutoNetworkTier { get; set; }
		
		/// <summary>
		/// A list of URLs of the IP resources to be drained. These IPs must be valid static external IPs that have been assigned to the NAT. These IPs should be used for updating/patching a NAT only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="drainNatIps")]
		public string[] DrainNatIps { get; set; }
		
		/// <summary>
		/// Enable Dynamic Port Allocation. If not specified, it is disabled by default. If set to true, - Dynamic Port Allocation will be enabled on this NAT config. - enableEndpointIndependentMapping cannot be set to true. - If minPorts is set, minPortsPerVm must be set to a power of two greater than or equal to 32. If minPortsPerVm is not set, a minimum of 32 ports will be allocated to a VM from this NAT config. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableDynamicPortAllocation")]
		public System.Nullable<System.Boolean> EnableDynamicPortAllocation { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enableEndpointIndependentMapping")]
		public System.Nullable<System.Boolean> EnableEndpointIndependentMapping { get; set; }
		
		/// <summary>
		/// List of NAT-ted endpoint types supported by the Nat Gateway. If the list is empty, then it will be equivalent to include ENDPOINT_TYPE_VM
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endpointTypes")]
		public string[] EndpointTypes { get; set; }
		
		/// <summary>
		/// Timeout (in seconds) for ICMP connections. Defaults to 30s if not set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="icmpIdleTimeoutSec")]
		public System.Nullable<System.Int32> IcmpIdleTimeoutSec { get; set; }
		
		/// <summary>
		/// Configuration of logging on a NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public RouterNatLogConfig LogConfig { get; set; }
		
		/// <summary>
		/// Maximum number of ports allocated to a VM from this NAT config when Dynamic Port Allocation is enabled. If Dynamic Port Allocation is not enabled, this field has no effect. If Dynamic Port Allocation is enabled, and this field is set, it must be set to a power of two greater than minPortsPerVm, or 64 if minPortsPerVm is not set. If Dynamic Port Allocation is enabled and this field is not set, a maximum of 65536 ports will be allocated to a VM from this NAT config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxPortsPerVm")]
		public System.Nullable<System.Int32> MaxPortsPerVm { get; set; }
		
		/// <summary>
		/// Minimum number of ports allocated to a VM from this NAT config. If not set, a default number of ports is allocated to a VM. This is rounded up to the nearest power of 2. For example, if the value of this field is 50, at least 64 ports are allocated to a VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minPortsPerVm")]
		public System.Nullable<System.Int32> MinPortsPerVm { get; set; }
		
		/// <summary>
		/// Unique name of this Nat service. The name must be 1-63 characters long and comply with RFC1035.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specify the NatIpAllocateOption, which can take one of the following values: - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When there are not enough specified Nat IPs, the Nat service fails for new VMs. - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers can't specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be empty. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natIpAllocateOption")]
		public System.Nullable<RouterNatNatIpAllocateOption> NatIpAllocateOption { get; set; }
		
		/// <summary>
		/// A list of URLs of the IP resources used for this Nat service. These IP addresses must be valid static external IP addresses assigned to the project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natIps")]
		public string[] NatIps { get; set; }
		
		/// <summary>
		/// A list of rules associated with this NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public RouterNatRule[] Rules { get; set; }
		
		/// <summary>
		/// Specify the Nat option, which can take one of the following values: - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork are allowed to Nat. - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in every Subnetwork are allowed to Nat. - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified in the field subnetwork below) The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field contains ALL_SUBNETWORKS_ALL_IP_RANGES then there should not be any other Router.Nat section in any Router for this network in this region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceSubnetworkIpRangesToNat")]
		public System.Nullable<RouterNatSourceSubnetworkIpRangesToNat> SourceSubnetworkIpRangesToNat { get; set; }
		
		/// <summary>
		/// A list of Subnetwork resources whose traffic should be translated by NAT Gateway. It is used only when LIST_OF_SUBNETWORKS is selected for the SubnetworkIpRangeToNatOption above.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetworks")]
		public RouterNatSubnetworkToNat[] Subnetworks { get; set; }
		
		/// <summary>
		/// Timeout (in seconds) for TCP established connections. Defaults to 1200s if not set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tcpEstablishedIdleTimeoutSec")]
		public System.Nullable<System.Int32> TcpEstablishedIdleTimeoutSec { get; set; }
		
		/// <summary>
		/// Timeout (in seconds) for TCP connections that are in TIME_WAIT state. Defaults to 120s if not set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tcpTimeWaitTimeoutSec")]
		public System.Nullable<System.Int32> TcpTimeWaitTimeoutSec { get; set; }
		
		/// <summary>
		/// Timeout (in seconds) for TCP transitory connections. Defaults to 30s if not set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tcpTransitoryIdleTimeoutSec")]
		public System.Nullable<System.Int32> TcpTransitoryIdleTimeoutSec { get; set; }
		
		/// <summary>
		/// Indicates whether this NAT is used for public or private IP translation. If unspecified, it defaults to PUBLIC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<RouterNatType> Type { get; set; }
		
		/// <summary>
		/// Timeout (in seconds) for UDP connections. Defaults to 30s if not set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="udpIdleTimeoutSec")]
		public System.Nullable<System.Int32> UdpIdleTimeoutSec { get; set; }
	}
	
	/// <summary>
	/// Configuration of logging on a NAT.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterNatLogConfig
	{
		
		/// <summary>
		/// Indicates whether or not to export logs. This is false by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable")]
		public System.Nullable<System.Boolean> Enable { get; set; }
		
		/// <summary>
		/// Specify the desired filtering of logs on this NAT. If unspecified, logs are exported for all connections handled by this NAT. This option can take one of the following values: - ERRORS_ONLY: Export logs only for connection failures. - TRANSLATIONS_ONLY: Export logs only for successful connections. - ALL: Export logs for all connections, successful and unsuccessful. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public System.Nullable<RouterNatLogConfigFilter> Filter { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouterNatLogConfigFilter
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ERRORS_ONLY = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TRANSLATIONS_ONLY = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouterNatNatIpAllocateOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTO_ONLY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MANUAL_ONLY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterNatRule
	{
		
		[System.Runtime.Serialization.DataMember(Name="action")]
		public RouterNatRuleAction Action { get; set; }
		
		/// <summary>
		/// An optional description of this rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// CEL expression that specifies the match condition that egress traffic from a VM is evaluated against. If it evaluates to true, the corresponding `action` is enforced. The following examples are valid match expressions for public NAT: "inIpRange(destination.ip, '1.1.0.0/16') || inIpRange(destination.ip, '2.2.0.0/16')" "destination.ip == '1.1.0.1' || destination.ip == '8.8.8.8'" The following example is a valid match expression for private NAT: "nexthop.hub == '//networkconnectivity.googleapis.com/projects/my-project/locations/global/hubs/hub-1'"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="match")]
		public string Match { get; set; }
		
		/// <summary>
		/// An integer uniquely identifying a rule in the list. The rule number must be a positive value between 0 and 65000, and must be unique among rules within a NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleNumber")]
		public System.Nullable<System.UInt32> RuleNumber { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterNatRuleAction
	{
		
		/// <summary>
		/// A list of URLs of the IP resources used for this NAT rule. These IP addresses must be valid static external IP addresses assigned to the project. This field is used for public NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceNatActiveIps")]
		public string[] SourceNatActiveIps { get; set; }
		
		/// <summary>
		/// A list of URLs of the subnetworks used as source ranges for this NAT Rule. These subnetworks must have purpose set to PRIVATE_NAT. This field is used for private NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceNatActiveRanges")]
		public string[] SourceNatActiveRanges { get; set; }
		
		/// <summary>
		/// A list of URLs of the IP resources to be drained. These IPs must be valid static external IPs that have been assigned to the NAT. These IPs should be used for updating/patching a NAT rule only. This field is used for public NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceNatDrainIps")]
		public string[] SourceNatDrainIps { get; set; }
		
		/// <summary>
		/// A list of URLs of subnetworks representing source ranges to be drained. This is only supported on patch/update, and these subnetworks must have previously been used as active ranges in this NAT Rule. This field is used for private NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceNatDrainRanges")]
		public string[] SourceNatDrainRanges { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouterNatSourceSubnetworkIpRangesToNat
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_SUBNETWORKS_ALL_IP_RANGES = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LIST_OF_SUBNETWORKS = 2,
	}
	
	/// <summary>
	/// Defines the IP ranges that want to use NAT for a subnetwork.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterNatSubnetworkToNat
	{
		
		/// <summary>
		/// URL for the subnetwork resource that will use NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// A list of the secondary ranges of the Subnetwork that are allowed to use NAT. This can be populated only if "LIST_OF_SECONDARY_IP_RANGES" is one of the values in source_ip_ranges_to_nat.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryIpRangeNames")]
		public string[] SecondaryIpRangeNames { get; set; }
		
		/// <summary>
		/// Specify the options for NAT ranges in the Subnetwork. All options of a single value are valid except NAT_IP_RANGE_OPTION_UNSPECIFIED. The only valid option with multiple values is: ["PRIMARY_IP_RANGE", "LIST_OF_SECONDARY_IP_RANGES"] Default: [ALL_IP_RANGES]
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceIpRangesToNat")]
		public string[] SourceIpRangesToNat { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouterNatType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC = 1,
	}
	
	/// <summary>
	/// Contains a list of routers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Router resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, RoutersScopedList> Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#routerAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#routerAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RouterAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoutersScopedList
	{
		
		/// <summary>
		/// A list of routers contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routers")]
		public Router[] Routers { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of routers when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RoutersScopedListWarning Warning { get; set; }
	}
	
	public class RoutersScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RoutersScopedListWarningData[] RoutersScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RoutersScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class RouterAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RouterAggregatedListWarningData[] RouterAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RouterAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of Router resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Router resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Router[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#router for routers.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#routerList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#routerList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public RouterListWarning Warning { get; set; }
	}
	
	public class RouterListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public RouterListWarningData[] RouterListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class RouterListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterStatus
	{
		
		/// <summary>
		/// Best routes for this router's network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bestRoutes")]
		public Route[] BestRoutes { get; set; }
		
		/// <summary>
		/// Best routes learned by this router.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bestRoutesForRouter")]
		public Route[] BestRoutesForRouter { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="bgpPeerStatus")]
		public RouterStatusBgpPeerStatus[] BgpPeerStatus { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="natStatus")]
		public RouterStatusNatStatus[] NatStatus { get; set; }
		
		/// <summary>
		/// URI of the network to which this router belongs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterStatusBgpPeerStatus
	{
		
		/// <summary>
		/// Routes that were advertised to the remote BGP peer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="advertisedRoutes")]
		public Route[] AdvertisedRoutes { get; set; }
		
		/// <summary>
		/// Next free: 15
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bfdStatus")]
		public BfdStatus BfdStatus { get; set; }
		
		/// <summary>
		/// Enable IPv6 traffic over BGP Peer. If not specified, it is disabled by default.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableIpv6")]
		public System.Nullable<System.Boolean> EnableIpv6 { get; set; }
		
		/// <summary>
		/// IP address of the local BGP interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
		
		/// <summary>
		/// IPv6 address of the local BGP interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6NexthopAddress")]
		public string Ipv6NexthopAddress { get; set; }
		
		/// <summary>
		/// URL of the VPN tunnel that this BGP peer controls.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linkedVpnTunnel")]
		public string LinkedVpnTunnel { get; set; }
		
		/// <summary>
		/// Informs whether MD5 authentication is enabled on this BGP peer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="md5AuthEnabled")]
		public System.Nullable<System.Boolean> Md5AuthEnabled { get; set; }
		
		/// <summary>
		/// Name of this BGP peer. Unique within the Routers resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Number of routes learned from the remote BGP Peer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numLearnedRoutes")]
		public System.Nullable<System.UInt32> NumLearnedRoutes { get; set; }
		
		/// <summary>
		/// IP address of the remote BGP interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerIpAddress")]
		public string PeerIpAddress { get; set; }
		
		/// <summary>
		/// IPv6 address of the remote BGP interface.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerIpv6NexthopAddress")]
		public string PeerIpv6NexthopAddress { get; set; }
		
		/// <summary>
		/// [Output only] URI of the VM instance that is used as third-party router appliances such as Next Gen Firewalls, Virtual Routers, or Router Appliances. The VM instance is the peer side of the BGP session.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="routerApplianceInstance")]
		public string RouterApplianceInstance { get; set; }
		
		/// <summary>
		/// The state of the BGP session. For a list of possible values for this field, see BGP session states.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
		
		/// <summary>
		/// Status of the BGP peer: {UP, DOWN}
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<RouterStatusBgpPeerStatusStatus> Status { get; set; }
		
		/// <summary>
		/// Indicates why particular status was returned.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="statusReason")]
		public System.Nullable<RouterStatusBgpPeerStatusStatusReason> StatusReason { get; set; }
		
		/// <summary>
		/// Time this session has been up. Format: 14 years, 51 weeks, 6 days, 23 hours, 59 minutes, 59 seconds
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uptime")]
		public string Uptime { get; set; }
		
		/// <summary>
		/// Time this session has been up, in seconds. Format: 145
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uptimeSeconds")]
		public string UptimeSeconds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouterStatusBgpPeerStatusStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UP = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum RouterStatusBgpPeerStatusStatusReason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MD5_AUTH_INTERNAL_PROBLEM = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATUS_REASON_UNSPECIFIED = 1,
	}
	
	/// <summary>
	/// Status of a NAT contained in this router.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterStatusNatStatus
	{
		
		/// <summary>
		/// A list of IPs auto-allocated for NAT. Example: ["1.1.1.1", "129.2.16.89"]
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoAllocatedNatIps")]
		public string[] AutoAllocatedNatIps { get; set; }
		
		/// <summary>
		/// A list of IPs auto-allocated for NAT that are in drain mode. Example: ["1.1.1.1", "179.12.26.133"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="drainAutoAllocatedNatIps")]
		public string[] DrainAutoAllocatedNatIps { get; set; }
		
		/// <summary>
		/// A list of IPs user-allocated for NAT that are in drain mode. Example: ["1.1.1.1", "179.12.26.133"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="drainUserAllocatedNatIps")]
		public string[] DrainUserAllocatedNatIps { get; set; }
		
		/// <summary>
		/// The number of extra IPs to allocate. This will be greater than 0 only if user-specified IPs are NOT enough to allow all configured VMs to use NAT. This value is meaningful only when auto-allocation of NAT IPs is *not* used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minExtraNatIpsNeeded")]
		public System.Nullable<System.Int32> MinExtraNatIpsNeeded { get; set; }
		
		/// <summary>
		/// Unique name of this NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Number of VM endpoints (i.e., Nics) that can use NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numVmEndpointsWithNatMappings")]
		public System.Nullable<System.Int32> NumVmEndpointsWithNatMappings { get; set; }
		
		/// <summary>
		/// Status of rules in this NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleStatus")]
		public RouterStatusNatStatusNatRuleStatus[] RuleStatus { get; set; }
		
		/// <summary>
		/// A list of fully qualified URLs of reserved IP address resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userAllocatedNatIpResources")]
		public string[] UserAllocatedNatIpResources { get; set; }
		
		/// <summary>
		/// A list of IPs user-allocated for NAT. They will be raw IP strings like "179.12.26.133".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userAllocatedNatIps")]
		public string[] UserAllocatedNatIps { get; set; }
	}
	
	/// <summary>
	/// Status of a NAT Rule contained in this NAT.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterStatusNatStatusNatRuleStatus
	{
		
		/// <summary>
		/// A list of active IPs for NAT. Example: ["1.1.1.1", "179.12.26.133"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="activeNatIps")]
		public string[] ActiveNatIps { get; set; }
		
		/// <summary>
		/// A list of IPs for NAT that are in drain mode. Example: ["1.1.1.1", "179.12.26.133"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="drainNatIps")]
		public string[] DrainNatIps { get; set; }
		
		/// <summary>
		/// The number of extra IPs to allocate. This will be greater than 0 only if the existing IPs in this NAT Rule are NOT enough to allow all configured VMs to use NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minExtraIpsNeeded")]
		public System.Nullable<System.Int32> MinExtraIpsNeeded { get; set; }
		
		/// <summary>
		/// Number of VM endpoints (i.e., NICs) that have NAT Mappings from this NAT Rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numVmEndpointsWithNatMappings")]
		public System.Nullable<System.Int32> NumVmEndpointsWithNatMappings { get; set; }
		
		/// <summary>
		/// Rule number of the rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleNumber")]
		public System.Nullable<System.Int32> RuleNumber { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RouterStatusResponse
	{
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#routerStatusResponse")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#routerStatusResponse";
		
		[System.Runtime.Serialization.DataMember(Name="result")]
		public RouterStatus Result { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RoutersPreviewResponse
	{
		
		/// <summary>
		/// Represents a Cloud Router resource. For more information about Cloud Router, read the Cloud Router overview.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public Router Resource { get; set; }
	}
	
	/// <summary>
	/// An instance's screenshot.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Screenshot
	{
		
		/// <summary>
		/// [Output Only] The Base64-encoded screenshot data.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#screenshot for the screenshots.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#screenshot")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#screenshot";
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPoliciesAggregatedList
	{
		
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of SecurityPoliciesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, SecurityPoliciesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#securityPolicyAggregatedList for lists of Security Policies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#securityPoliciesAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#securityPoliciesAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SecurityPoliciesAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPoliciesScopedList
	{
		
		/// <summary>
		/// A list of SecurityPolicies contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securityPolicies")]
		public SecurityPolicy[] SecurityPolicies { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of security policies when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SecurityPoliciesScopedListWarning Warning { get; set; }
	}
	
	/// <summary>
	/// Represents a Google Cloud Armor security policy resource. Only external backend services that use load balancers can reference a security policy. For more information, see Google Cloud Armor security policy overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicy
	{
		
		/// <summary>
		/// Configuration options for Cloud Armor Adaptive Protection (CAAP).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="adaptiveProtectionConfig")]
		public SecurityPolicyAdaptiveProtectionConfig AdaptiveProtectionConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="advancedOptionsConfig")]
		public SecurityPolicyAdvancedOptionsConfig AdvancedOptionsConfig { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="ddosProtectionConfig")]
		public SecurityPolicyDdosProtectionConfig DdosProtectionConfig { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Specifies a fingerprint for this resource, which is essentially a hash of the metadata's contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update metadata. You must always provide an up-to-date fingerprint hash in order to update or change metadata, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make get() request to the security policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output only] Type of the resource. Always compute#securityPolicyfor security policies
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#securityPolicy")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#securityPolicy";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this security policy, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels. To see the latest fingerprint, make get() request to the security policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels for this resource. These can only be added or modified by the setLabels method. Each label key/value pair must comply with RFC1035. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recaptchaOptionsConfig")]
		public SecurityPolicyRecaptchaOptionsConfig RecaptchaOptionsConfig { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional security policy resides. This field is not applicable to global security policies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// A list of rules that belong to this policy. There must always be a default rule which is a rule with priority 2147483647 and match all condition (for the match condition this means match "*" for srcIpRanges and for the networkMatch condition every field must be either match "*" or not set). If no rules are provided when creating a security policy, a default rule with action "allow" will be added.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public SecurityPolicyRule[] Rules { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The type indicates the intended use of the security policy. - CLOUD_ARMOR: Cloud Armor backend security policies can be configured to filter incoming HTTP requests targeting backend services. They filter requests before they hit the origin servers. - CLOUD_ARMOR_EDGE: Cloud Armor edge security policies can be configured to filter incoming HTTP requests targeting backend services (including Cloud CDN-enabled) as well as backend buckets (Cloud Storage). They filter requests before the request is served from Google's cache. - CLOUD_ARMOR_INTERNAL_SERVICE: Cloud Armor internal service policies can be configured to filter HTTP requests targeting services managed by Traffic Director in a service mesh. They filter requests before the request is served from the application. - CLOUD_ARMOR_NETWORK: Cloud Armor network policies can be configured to filter packets targeting network load balancing resources such as backend services, target pools, target instances, and instances with external IPs. They filter requests before the request is served from the application. This field can be set only at resource creation time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<SecurityPolicyType> Type { get; set; }
		
		/// <summary>
		/// Definitions of user-defined fields for CLOUD_ARMOR_NETWORK policies. A user-defined field consists of up to 4 bytes extracted from a fixed offset in the packet, relative to the IPv4, IPv6, TCP, or UDP header, with an optional mask to select certain bits. Rules may then specify matching values for these fields. Example: userDefinedFields: - name: "ipv4_fragment_offset" base: IPV4 offset: 6 size: 2 mask: "0x1fff"
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userDefinedFields")]
		public SecurityPolicyUserDefinedField[] UserDefinedFields { get; set; }
	}
	
	/// <summary>
	/// Configuration options for Cloud Armor Adaptive Protection (CAAP).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyAdaptiveProtectionConfig
	{
		
		/// <summary>
		/// Configuration options for L7 DDoS detection. This field is only supported in Global Security Policies of type CLOUD_ARMOR.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="layer7DdosDefenseConfig")]
		public SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig Layer7DdosDefenseConfig { get; set; }
	}
	
	/// <summary>
	/// Configuration options for L7 DDoS detection. This field is only supported in Global Security Policies of type CLOUD_ARMOR.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig
	{
		
		/// <summary>
		/// If set to true, enables CAAP for L7 DDoS detection. This field is only supported in Global Security Policies of type CLOUD_ARMOR.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable")]
		public System.Nullable<System.Boolean> Enable { get; set; }
		
		/// <summary>
		/// Rule visibility can be one of the following: STANDARD - opaque rules. (default) PREMIUM - transparent rules. This field is only supported in Global Security Policies of type CLOUD_ARMOR.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleVisibility")]
		public System.Nullable<SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility> RuleVisibility { get; set; }
		
		/// <summary>
		/// Configuration options for layer7 adaptive protection for various customizable thresholds.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thresholdConfigs")]
		public SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig[] ThresholdConfigs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigRuleVisibility
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREMIUM = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="autoDeployConfidenceThreshold")]
		public System.Nullable<System.Single> AutoDeployConfidenceThreshold { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="autoDeployExpirationSec")]
		public System.Nullable<System.Int32> AutoDeployExpirationSec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="autoDeployImpactedBaselineThreshold")]
		public System.Nullable<System.Single> AutoDeployImpactedBaselineThreshold { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="autoDeployLoadThreshold")]
		public System.Nullable<System.Single> AutoDeployLoadThreshold { get; set; }
		
		/// <summary>
		/// The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the security policy.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyAdvancedOptionsConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="jsonCustomConfig")]
		public SecurityPolicyAdvancedOptionsConfigJsonCustomConfig JsonCustomConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="jsonParsing")]
		public System.Nullable<SecurityPolicyAdvancedOptionsConfigJsonParsing> JsonParsing { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logLevel")]
		public System.Nullable<SecurityPolicyAdvancedOptionsConfigLogLevel> LogLevel { get; set; }
		
		/// <summary>
		/// An optional list of case-insensitive request header names to use for resolving the callers client IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userIpRequestHeaders")]
		public string[] UserIpRequestHeaders { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyAdvancedOptionsConfigJsonCustomConfig
	{
		
		/// <summary>
		/// A list of custom Content-Type header values to apply the JSON parsing. As per RFC 1341, a Content-Type header value has the following format: Content-Type := type "/" subtype *[";" parameter] When configuring a custom Content-Type header value, only the type/subtype needs to be specified, and the parameters should be excluded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contentTypes")]
		public string[] ContentTypes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SecurityPolicyAdvancedOptionsConfigJsonParsing
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD_WITH_GRAPHQL = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SecurityPolicyAdvancedOptionsConfigLogLevel
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NORMAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VERBOSE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyDdosProtectionConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="ddosProtection")]
		public System.Nullable<SecurityPolicyDdosProtectionConfigDdosProtection> DdosProtection { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SecurityPolicyDdosProtectionConfigDdosProtection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ADVANCED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRecaptchaOptionsConfig
	{
		
		/// <summary>
		/// An optional field to supply a reCAPTCHA site key to be used for all the rules using the redirect action with the type of GOOGLE_RECAPTCHA under the security policy. The specified site key needs to be created from the reCAPTCHA API. The user is responsible for the validity of the specified site key. If not specified, a Google-managed site key is used. This field is only supported in Global Security Policies of type CLOUD_ARMOR.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectSiteKey")]
		public string RedirectSiteKey { get; set; }
	}
	
	/// <summary>
	/// Represents a rule that describes one or more match conditions along with the action to be taken when traffic matches this condition (allow or deny).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRule
	{
		
		/// <summary>
		/// The Action to perform when the rule is matched. The following are the valid actions: - allow: allow access to target. - deny(STATUS): deny access to target, returns the HTTP response code specified. Valid values for `STATUS` are 403, 404, and 502. - rate_based_ban: limit client traffic to the configured threshold and ban the client if the traffic exceeds the threshold. Configure parameters for this action in RateLimitOptions. Requires rate_limit_options to be set. - redirect: redirect to a different target. This can either be an internal reCAPTCHA redirect, or an external URL-based redirect via a 302 response. Parameters for this action can be configured via redirectOptions. This action is only supported in Global Security Policies of type CLOUD_ARMOR. - throttle: limit client traffic to the configured threshold. Configure parameters for this action in rateLimitOptions. Requires rate_limit_options to be set for this. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="action")]
		public string Action { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="headerAction")]
		public SecurityPolicyRuleHttpHeaderAction HeaderAction { get; set; }
		
		/// <summary>
		/// [Output only] Type of the resource. Always compute#securityPolicyRule for security policy rules
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#securityPolicyRule")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#securityPolicyRule";
		
		/// <summary>
		/// Represents a match condition that incoming traffic is evaluated against. Exactly one field must be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="match")]
		public SecurityPolicyRuleMatcher Match { get; set; }
		
		/// <summary>
		/// Represents a match condition that incoming network traffic is evaluated against.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkMatch")]
		public SecurityPolicyRuleNetworkMatcher NetworkMatch { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="preconfiguredWafConfig")]
		public SecurityPolicyRulePreconfiguredWafConfig PreconfiguredWafConfig { get; set; }
		
		/// <summary>
		/// If set to true, the specified action is not enforced.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="preview")]
		public System.Nullable<System.Boolean> Preview { get; set; }
		
		/// <summary>
		/// An integer indicating the priority of a rule in the list. The priority must be a positive value between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest priority.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priority")]
		public System.Nullable<System.Int32> Priority { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rateLimitOptions")]
		public SecurityPolicyRuleRateLimitOptions RateLimitOptions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="redirectOptions")]
		public SecurityPolicyRuleRedirectOptions RedirectOptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleHttpHeaderAction
	{
		
		/// <summary>
		/// The list of request headers to add or overwrite if they're already present.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestHeadersToAdds")]
		public SecurityPolicyRuleHttpHeaderActionHttpHeaderOption[] RequestHeadersToAdds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleHttpHeaderActionHttpHeaderOption
	{
		
		/// <summary>
		/// The name of the header to set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerName")]
		public string HeaderName { get; set; }
		
		/// <summary>
		/// The value to set the named header to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headerValue")]
		public string HeaderValue { get; set; }
	}
	
	/// <summary>
	/// Represents a match condition that incoming traffic is evaluated against. Exactly one field must be specified.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleMatcher
	{
		
		[System.Runtime.Serialization.DataMember(Name="config")]
		public SecurityPolicyRuleMatcherConfig Config { get; set; }
		
		/// <summary>
		/// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at https://github.com/google/cel-spec. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expr")]
		public Expr Expr { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exprOptions")]
		public SecurityPolicyRuleMatcherExprOptions ExprOptions { get; set; }
		
		/// <summary>
		/// Preconfigured versioned expression. If this field is specified, config must also be specified. Available preconfigured expressions along with their requirements are: SRC_IPS_V1 - must specify the corresponding src_ip_range field in config.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="versionedExpr")]
		public System.Nullable<SecurityPolicyRuleMatcherVersionedExpr> VersionedExpr { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleMatcherConfig
	{
		
		/// <summary>
		/// CIDR IP address range. Maximum number of src_ip_ranges allowed is 10.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcIpRanges")]
		public string[] SrcIpRanges { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleMatcherExprOptions
	{
		
		[System.Runtime.Serialization.DataMember(Name="recaptchaOptions")]
		public SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions RecaptchaOptions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions
	{
		
		/// <summary>
		/// A list of site keys to be used during the validation of reCAPTCHA action-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionTokenSiteKeys")]
		public string[] ActionTokenSiteKeys { get; set; }
		
		/// <summary>
		/// A list of site keys to be used during the validation of reCAPTCHA session-tokens. The provided site keys need to be created from reCAPTCHA API under the same project where the security policy is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sessionTokenSiteKeys")]
		public string[] SessionTokenSiteKeys { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SecurityPolicyRuleMatcherVersionedExpr
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SRC_IPS_V1 = 0,
	}
	
	/// <summary>
	/// Represents a match condition that incoming network traffic is evaluated against.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleNetworkMatcher
	{
		
		/// <summary>
		/// Destination IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destIpRanges")]
		public string[] DestIpRanges { get; set; }
		
		/// <summary>
		/// Destination port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destPorts")]
		public string[] DestPorts { get; set; }
		
		/// <summary>
		/// IPv4 protocol / IPv6 next header (after extension headers). Each element can be an 8-bit unsigned decimal number (e.g. "6"), range (e.g. "253-254"), or one of the following protocol names: "tcp", "udp", "icmp", "esp", "ah", "ipip", or "sctp".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipProtocols")]
		public string[] IpProtocols { get; set; }
		
		/// <summary>
		/// BGP Autonomous System Number associated with the source IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcAsns")]
		public int[] SrcAsns { get; set; }
		
		/// <summary>
		/// Source IPv4/IPv6 addresses or CIDR prefixes, in standard text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcIpRanges")]
		public string[] SrcIpRanges { get; set; }
		
		/// <summary>
		/// Source port numbers for TCP/UDP/SCTP. Each element can be a 16-bit unsigned decimal number (e.g. "80") or range (e.g. "0-1023").
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcPorts")]
		public string[] SrcPorts { get; set; }
		
		/// <summary>
		/// Two-letter ISO 3166-1 alpha-2 country code associated with the source IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="srcRegionCodes")]
		public string[] SrcRegionCodes { get; set; }
		
		/// <summary>
		/// User-defined fields. Each element names a defined field and lists the matching values for that field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userDefinedFields")]
		public SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch[] UserDefinedFields { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch
	{
		
		/// <summary>
		/// Name of the user-defined field, as given in the definition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Matching values of the field. Each element can be a 32-bit unsigned decimal or hexadecimal (starting with "0x") number (e.g. "64") or range (e.g. "0x400-0x7ff").
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRulePreconfiguredWafConfig
	{
		
		/// <summary>
		/// A list of exclusions to apply during preconfigured WAF evaluation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exclusions")]
		public SecurityPolicyRulePreconfiguredWafConfigExclusion[] Exclusions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRulePreconfiguredWafConfigExclusion
	{
		
		/// <summary>
		/// A list of request cookie names whose value will be excluded from inspection during preconfigured WAF evaluation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestCookiesToExclude")]
		public SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams[] RequestCookiesToExclude { get; set; }
		
		/// <summary>
		/// A list of request header names whose value will be excluded from inspection during preconfigured WAF evaluation.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestHeadersToExclude")]
		public SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams[] RequestHeadersToExclude { get; set; }
		
		/// <summary>
		/// A list of request query parameter names whose value will be excluded from inspection during preconfigured WAF evaluation. Note that the parameter can be in the query string or in the POST body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestQueryParamsToExclude")]
		public SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams[] RequestQueryParamsToExclude { get; set; }
		
		/// <summary>
		/// A list of request URIs from the request line to be excluded from inspection during preconfigured WAF evaluation. When specifying this field, the query or fragment part should be excluded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestUrisToExclude")]
		public SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams[] RequestUrisToExclude { get; set; }
		
		/// <summary>
		/// A list of target rule IDs under the WAF rule set to apply the preconfigured WAF exclusion. If omitted, it refers to all the rule IDs under the WAF rule set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetRuleIds")]
		public string[] TargetRuleIds { get; set; }
		
		/// <summary>
		/// Target WAF rule set to apply the preconfigured WAF exclusion.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetRuleSet")]
		public string TargetRuleSet { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams
	{
		
		/// <summary>
		/// The match operator for the field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="op")]
		public System.Nullable<SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsOp> Op { get; set; }
		
		/// <summary>
		/// The value of the field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="val")]
		public string Val { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParamsOp
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONTAINS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENDS_WITH = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EQUALS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EQUALS_ANY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARTS_WITH = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleRateLimitOptions
	{
		
		/// <summary>
		/// Can only be specified if the action for the rule is "rate_based_ban". If specified, determines the time (in seconds) the traffic will continue to be banned by the rate limit after the rate falls below the threshold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="banDurationSec")]
		public System.Nullable<System.Int32> BanDurationSec { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="banThreshold")]
		public SecurityPolicyRuleRateLimitOptionsThreshold BanThreshold { get; set; }
		
		/// <summary>
		/// Action to take for requests that are under the configured rate limit threshold. Valid option is "allow" only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="conformAction")]
		public string ConformAction { get; set; }
		
		/// <summary>
		/// Determines the key to enforce the rate_limit_threshold on. Possible values are: - ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKey" is not configured. - IP: The source IP address of the request is the key. Each IP has this limit enforced separately. - HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL. - XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP. - HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL. - HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes. - SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session. - REGION_CODE: The country/region from which the request originates. - TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL. - USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceOnKey")]
		public System.Nullable<SecurityPolicyRuleRateLimitOptionsEnforceOnKey> EnforceOnKey { get; set; }
		
		/// <summary>
		/// If specified, any combination of values of enforce_on_key_type/enforce_on_key_name is treated as the key on which ratelimit threshold/action is enforced. You can specify up to 3 enforce_on_key_configs. If enforce_on_key_configs is specified, enforce_on_key must not be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceOnKeyConfigs")]
		public SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig[] EnforceOnKeyConfigs { get; set; }
		
		/// <summary>
		/// Rate limit key name applicable only for the following key types: HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value. HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceOnKeyName")]
		public string EnforceOnKeyName { get; set; }
		
		/// <summary>
		/// Action to take for requests that are above the configured rate limit threshold, to either deny with a specified HTTP response code, or redirect to a different endpoint. Valid options are `deny(STATUS)`, where valid values for `STATUS` are 403, 404, 429, and 502, and `redirect`, where the redirect parameters come from `exceedRedirectOptions` below. The `redirect` action is only supported in Global Security Policies of type CLOUD_ARMOR.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exceedAction")]
		public string ExceedAction { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exceedRedirectOptions")]
		public SecurityPolicyRuleRedirectOptions ExceedRedirectOptions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rateLimitThreshold")]
		public SecurityPolicyRuleRateLimitOptionsThreshold RateLimitThreshold { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleRateLimitOptionsThreshold
	{
		
		/// <summary>
		/// Number of HTTP(S) requests for calculating the threshold.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public System.Nullable<System.Int32> Count { get; set; }
		
		/// <summary>
		/// Interval over which the threshold is computed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="intervalSec")]
		public System.Nullable<System.Int32> IntervalSec { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SecurityPolicyRuleRateLimitOptionsEnforceOnKey
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP_COOKIE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP_HEADER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP_PATH = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IP = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGION_CODE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SNI = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS_JA3_FINGERPRINT = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		USER_IP = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XFF_IP = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig
	{
		
		/// <summary>
		/// Rate limit key name applicable only for the following key types: HTTP_HEADER -- Name of the HTTP header whose value is taken as the key value. HTTP_COOKIE -- Name of the HTTP cookie whose value is taken as the key value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceOnKeyName")]
		public string EnforceOnKeyName { get; set; }
		
		/// <summary>
		/// Determines the key to enforce the rate_limit_threshold on. Possible values are: - ALL: A single rate limit threshold is applied to all the requests matching this rule. This is the default value if "enforceOnKeyConfigs" is not configured. - IP: The source IP address of the request is the key. Each IP has this limit enforced separately. - HTTP_HEADER: The value of the HTTP header whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the header value. If no such header is present in the request, the key type defaults to ALL. - XFF_IP: The first IP address (i.e. the originating client IP address) specified in the list of IPs under X-Forwarded-For HTTP header. If no such header is present or the value is not a valid IP, the key defaults to the source IP address of the request i.e. key type IP. - HTTP_COOKIE: The value of the HTTP cookie whose name is configured under "enforceOnKeyName". The key value is truncated to the first 128 bytes of the cookie value. If no such cookie is present in the request, the key type defaults to ALL. - HTTP_PATH: The URL path of the HTTP request. The key value is truncated to the first 128 bytes. - SNI: Server name indication in the TLS session of the HTTPS request. The key value is truncated to the first 128 bytes. The key type defaults to ALL on a HTTP session. - REGION_CODE: The country/region from which the request originates. - TLS_JA3_FINGERPRINT: JA3 TLS/SSL fingerprint if the client connects using HTTPS, HTTP/2 or HTTP/3. If not available, the key type defaults to ALL. - USER_IP: The IP address of the originating client, which is resolved based on "userIpRequestHeaders" configured with the security policy. If there is no "userIpRequestHeaders" configuration or an IP address cannot be resolved from it, the key type defaults to IP. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enforceOnKeyType")]
		public SecurityPolicyRuleRateLimitOptionsEnforceOnKey EnforceOnKeyType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyRuleRedirectOptions
	{
		
		/// <summary>
		/// Target for the redirect action. This is required if the type is EXTERNAL_302 and cannot be specified for GOOGLE_RECAPTCHA.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
		
		/// <summary>
		/// Type of the redirect action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<SecurityPolicyRuleRedirectOptionsType> Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SecurityPolicyRuleRedirectOptionsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXTERNAL_302 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GOOGLE_RECAPTCHA = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SecurityPolicyType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOUD_ARMOR = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOUD_ARMOR_EDGE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLOUD_ARMOR_NETWORK = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyUserDefinedField
	{
		
		/// <summary>
		/// The base relative to which 'offset' is measured. Possible values are: - IPV4: Points to the beginning of the IPv4 header. - IPV6: Points to the beginning of the IPv6 header. - TCP: Points to the beginning of the TCP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments. - UDP: Points to the beginning of the UDP header, skipping over any IPv4 options or IPv6 extension headers. Not present for non-first fragments. required
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="base")]
		public System.Nullable<SecurityPolicyUserDefinedFieldBase> Base { get; set; }
		
		/// <summary>
		/// If specified, apply this mask (bitwise AND) to the field to ignore bits before matching. Encoded as a hexadecimal number (starting with "0x"). The last byte of the field (in network byte order) corresponds to the least significant byte of the mask.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mask")]
		public string Mask { get; set; }
		
		/// <summary>
		/// The name of this field. Must be unique within the policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Offset of the first byte of the field (in network byte order) relative to 'base'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="offset")]
		public System.Nullable<System.Int32> Offset { get; set; }
		
		/// <summary>
		/// Size of the field in bytes. Valid values: 1-4.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int32> Size { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SecurityPolicyUserDefinedFieldBase
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPV4 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IPV6 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TCP = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UDP = 3,
	}
	
	public class SecurityPoliciesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SecurityPoliciesScopedListWarningData[] SecurityPoliciesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SecurityPoliciesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class SecurityPoliciesAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SecurityPoliciesAggregatedListWarningData[] SecurityPoliciesAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SecurityPoliciesAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPoliciesListPreconfiguredExpressionSetsResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="preconfiguredExpressionSets")]
		public SecurityPoliciesWafConfig PreconfiguredExpressionSets { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPoliciesWafConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="wafRules")]
		public PreconfiguredWafSet WafRules { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of SecurityPolicy resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public SecurityPolicy[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#securityPolicyList for listsof securityPolicies
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#securityPolicyList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#securityPolicyList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SecurityPolicyListWarning Warning { get; set; }
	}
	
	public class SecurityPolicyListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SecurityPolicyListWarningData[] SecurityPolicyListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SecurityPolicyListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SecurityPolicyReference
	{
		
		[System.Runtime.Serialization.DataMember(Name="securityPolicy")]
		public string SecurityPolicy { get; set; }
	}
	
	/// <summary>
	/// An instance serial console output.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SerialPortOutput
	{
		
		/// <summary>
		/// [Output Only] The contents of the console output.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#serialPortOutput for serial port output.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#serialPortOutput")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#serialPortOutput";
		
		/// <summary>
		/// [Output Only] The position of the next byte of content, regardless of whether the content exists, following the output returned in the `contents` property. Use this value in the next request as the start parameter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next")]
		public string Next { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The starting byte position of the output that was returned. This should match the start parameter sent with the request. If the serial console output exceeds the size of the buffer (1 MB), older output is overwritten by newer content. The output start value will indicate the byte position of the output that was returned, which might be different than the `start` value that was specified in the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="start")]
		public string Start { get; set; }
	}
	
	/// <summary>
	/// Represents a ServiceAttachment resource. A service attachment represents a service that a producer has exposed. It encapsulates the load balancer which fronts the service runs and a list of NAT IP ranges that the producers uses to represent the consumers connecting to the service.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceAttachment
	{
		
		/// <summary>
		/// [Output Only] An array of connections for all the consumers connected to this service attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectedEndpoints")]
		public ServiceAttachmentConnectedEndpoint[] ConnectedEndpoints { get; set; }
		
		/// <summary>
		/// The connection preference of service attachment. The value can be set to ACCEPT_AUTOMATIC. An ACCEPT_AUTOMATIC service attachment is one that always accepts the connection from consumer forwarding rules.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionPreference")]
		public System.Nullable<ServiceAttachmentConnectionPreference> ConnectionPreference { get; set; }
		
		/// <summary>
		/// Projects that are allowed to connect to this service attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consumerAcceptLists")]
		public ServiceAttachmentConsumerProjectLimit[] ConsumerAcceptLists { get; set; }
		
		/// <summary>
		/// Projects that are not allowed to connect to this service attachment. The project can be specified using its id or number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consumerRejectLists")]
		public string[] ConsumerRejectLists { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// If specified, the domain name will be used during the integration between the PSC connected endpoints and the Cloud DNS. For example, this is a valid domain name: "p.mycompany.com.". Current max number of domain names supported is 1.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domainNames")]
		public string[] DomainNames { get; set; }
		
		/// <summary>
		/// If true, enable the proxy protocol which is for supplying client TCP/IP address data in TCP connections that traverse proxies on their way to destination servers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableProxyProtocol")]
		public System.Nullable<System.Boolean> EnableProxyProtocol { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a ServiceAttachment. An up-to-date fingerprint must be provided in order to patch/update the ServiceAttachment; otherwise, the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve the ServiceAttachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource type. The server generates this identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#serviceAttachment for service attachments.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#serviceAttachment")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#serviceAttachment";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// An array of URLs where each entry is the URL of a subnet provided by the service producer to use for NAT in this service attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natSubnets")]
		public string[] NatSubnets { get; set; }
		
		/// <summary>
		/// The URL of a forwarding rule with loadBalancingScheme INTERNAL* that is serving the endpoint identified by this service attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="producerForwardingRule")]
		public string ProducerForwardingRule { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pscServiceAttachmentId")]
		public Uint128 PscServiceAttachmentId { get; set; }
		
		/// <summary>
		/// This flag determines whether a consumer accept/reject list change can reconcile the statuses of existing ACCEPTED or REJECTED PSC endpoints. - If false, connection policy update will only affect existing PENDING PSC endpoints. Existing ACCEPTED/REJECTED endpoints will remain untouched regardless how the connection policy is modified . - If true, update will affect both PENDING and ACCEPTED/REJECTED PSC endpoints. For example, an ACCEPTED PSC endpoint will be moved to REJECTED if its project is added to the reject list. For newly created service attachment, this boolean defaults to false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reconcileConnections")]
		public System.Nullable<System.Boolean> ReconcileConnections { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the service attachment resides. This field applies only to the region resource. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The URL of a service serving the endpoint identified by this service attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetService")]
		public string TargetService { get; set; }
	}
	
	/// <summary>
	/// [Output Only] A connection connected to this service attachment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceAttachmentConnectedEndpoint
	{
		
		/// <summary>
		/// The url of the consumer network.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="consumerNetwork")]
		public string ConsumerNetwork { get; set; }
		
		/// <summary>
		/// The url of a connected endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
		
		/// <summary>
		/// The PSC connection id of the connected endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pscConnectionId")]
		public string PscConnectionId { get; set; }
		
		/// <summary>
		/// The status of a connected endpoint to this service attachment.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ForwardingRulePscConnectionStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ServiceAttachmentConnectionPreference
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_AUTOMATIC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACCEPT_MANUAL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECTION_PREFERENCE_UNSPECIFIED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceAttachmentConsumerProjectLimit
	{
		
		/// <summary>
		/// The value of the limit to set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionLimit")]
		public System.Nullable<System.UInt32> ConnectionLimit { get; set; }
		
		/// <summary>
		/// The network URL for the network to set the limit for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkUrl")]
		public string NetworkUrl { get; set; }
		
		/// <summary>
		/// The project id or number for the project to set the limit for.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="projectIdOrNum")]
		public string ProjectIdOrNum { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Uint128
	{
		
		[System.Runtime.Serialization.DataMember(Name="high")]
		public string High { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="low")]
		public string Low { get; set; }
	}
	
	/// <summary>
	/// Contains a list of ServiceAttachmentsScopedList.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceAttachmentAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of ServiceAttachmentsScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, ServiceAttachmentsScopedList> Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#serviceAttachmentAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#serviceAttachmentAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ServiceAttachmentAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceAttachmentsScopedList
	{
		
		/// <summary>
		/// A list of ServiceAttachments contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceAttachments")]
		public ServiceAttachment[] ServiceAttachments { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of service attachments when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ServiceAttachmentsScopedListWarning Warning { get; set; }
	}
	
	public class ServiceAttachmentsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ServiceAttachmentsScopedListWarningData[] ServiceAttachmentsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ServiceAttachmentsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class ServiceAttachmentAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ServiceAttachmentAggregatedListWarningData[] ServiceAttachmentAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ServiceAttachmentAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceAttachmentList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of ServiceAttachment resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public ServiceAttachment[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#serviceAttachment for service attachments.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#serviceAttachmentList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#serviceAttachmentList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ServiceAttachmentListWarning Warning { get; set; }
	}
	
	public class ServiceAttachmentListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ServiceAttachmentListWarningData[] ServiceAttachmentListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ServiceAttachmentListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A Shielded Instance Identity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ShieldedInstanceIdentity
	{
		
		/// <summary>
		/// A Shielded Instance Identity Entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionKey")]
		public ShieldedInstanceIdentityEntry EncryptionKey { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#shieldedInstanceIdentity for shielded Instance identity entry.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#shieldedInstanceIdentity")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#shieldedInstanceIdentity";
		
		/// <summary>
		/// A Shielded Instance Identity Entry.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="signingKey")]
		public ShieldedInstanceIdentityEntry SigningKey { get; set; }
	}
	
	/// <summary>
	/// A Shielded Instance Identity Entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ShieldedInstanceIdentityEntry
	{
		
		/// <summary>
		/// A PEM-encoded X.509 certificate. This field can be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ekCert")]
		public string EkCert { get; set; }
		
		/// <summary>
		/// A PEM-encoded public key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ekPub")]
		public string EkPub { get; set; }
	}
	
	/// <summary>
	/// Represents a customer-supplied Signing Key used by Cloud CDN Signed URLs
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SignedUrlKey
	{
		
		/// <summary>
		/// Name of the key. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyName")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string KeyName { get; set; }
		
		/// <summary>
		/// 128-bit key value used for signing the URL. The key value must be a valid RFC 4648 Section 5 base64url encoded string.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyValue")]
		public string KeyValue { get; set; }
	}
	
	/// <summary>
	/// Represents a Persistent Disk Snapshot resource. You can use snapshots to back up data on a regular interval. For more information, read Creating persistent disk snapshots.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Snapshot
	{
		
		/// <summary>
		/// [Output Only] The architecture of the snapshot. Valid values are ARM64 or X86_64.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="architecture")]
		public AttachedDiskArchitecture Architecture { get; set; }
		
		/// <summary>
		/// [Output Only] Set to true if snapshots are automatically created by applying resource policy on the target disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoCreated")]
		public System.Nullable<System.Boolean> AutoCreated { get; set; }
		
		/// <summary>
		/// Creates the new snapshot in the snapshot chain labeled with the specified name. The chain name must be 1-63 characters long and comply with RFC1035. This is an uncommon option only for advanced service owners who needs to create separate snapshot chains, for example, for chargeback tracking. When you describe your snapshot resource, this field is visible only if it has a non-empty value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="chainName")]
		public string ChainName { get; set; }
		
		/// <summary>
		/// [Output Only] Size in bytes of the snapshot at creation time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationSizeBytes")]
		public string CreationSizeBytes { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] Size of the source disk, specified in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGb")]
		public string DiskSizeGb { get; set; }
		
		/// <summary>
		/// [Output Only] Number of bytes downloaded to restore a snapshot to a disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadBytes")]
		public string DownloadBytes { get; set; }
		
		/// <summary>
		/// Whether this snapshot is created from a confidential compute mode disk. [Output Only]: This field is not set by user, but from source disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableConfidentialCompute")]
		public System.Nullable<System.Boolean> EnableConfidentialCompute { get; set; }
		
		/// <summary>
		/// [Output Only] A list of features to enable on the guest operating system. Applicable only for bootable images. Read Enabling guest operating system features to see a list of available options.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="guestOsFeatures")]
		public GuestOsFeature[] GuestOsFeatures { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#snapshot for Snapshot resources.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#snapshot")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#snapshot";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this snapshot, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels to apply to this snapshot. These can be later modified by the setLabels method. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// [Output Only] Integer license codes indicating which licenses are attached to this snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenseCodes")]
		public string[] LicenseCodes { get; set; }
		
		/// <summary>
		/// [Output Only] A list of public visible licenses that apply to this snapshot. This can be because the original image had licenses attached (such as a Windows image).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="licenses")]
		public string[] Licenses { get; set; }
		
		/// <summary>
		/// An opaque location hint used to place the snapshot close to other resources. This field is for use by internal tools that use the public API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locationHint")]
		public string LocationHint { get; set; }
		
		/// <summary>
		/// Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzi")]
		public System.Nullable<System.Boolean> SatisfiesPzi { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="satisfiesPzs")]
		public System.Nullable<System.Boolean> SatisfiesPzs { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="snapshotEncryptionKey")]
		public CustomerEncryptionKey SnapshotEncryptionKey { get; set; }
		
		/// <summary>
		/// Indicates the type of the snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="snapshotType")]
		public System.Nullable<SnapshotSnapshotType> SnapshotType { get; set; }
		
		/// <summary>
		/// The source disk used to create this snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDisk")]
		public string SourceDisk { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceDiskEncryptionKey")]
		public CustomerEncryptionKey SourceDiskEncryptionKey { get; set; }
		
		/// <summary>
		/// The source disk whose recovery checkpoint will be used to create this snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDiskForRecoveryCheckpoint")]
		public string SourceDiskForRecoveryCheckpoint { get; set; }
		
		/// <summary>
		/// [Output Only] The ID value of the disk used to create this snapshot. This value may be used to determine whether the snapshot was taken from the current or a previous instance of a given disk name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDiskId")]
		public string SourceDiskId { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the resource policy which created this scheduled snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceSnapshotSchedulePolicy")]
		public string SourceSnapshotSchedulePolicy { get; set; }
		
		/// <summary>
		/// [Output Only] ID of the resource policy which created this scheduled snapshot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceSnapshotSchedulePolicyId")]
		public string SourceSnapshotSchedulePolicyId { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the snapshot. This can be CREATING, DELETING, FAILED, READY, or UPLOADING.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<SnapshotStatus> Status { get; set; }
		
		/// <summary>
		/// [Output Only] A size of the storage used by the snapshot. As snapshots share storage, this number is expected to change with snapshot creation/deletion.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageBytes")]
		public string StorageBytes { get; set; }
		
		/// <summary>
		/// [Output Only] An indicator whether storageBytes is in a stable state or it is being adjusted as a result of shared storage reallocation. This status can either be UPDATING, meaning the size of the snapshot is being updated, or UP_TO_DATE, meaning the size of the snapshot is up-to-date.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageBytesStatus")]
		public SavedDiskStorageBytesStatus StorageBytesStatus { get; set; }
		
		/// <summary>
		/// Cloud Storage bucket storage location of the snapshot (regional or multi-regional).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageLocations")]
		public string[] StorageLocations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SnapshotSnapshotType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ARCHIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STANDARD = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SnapshotStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPLOADING = 4,
	}
	
	/// <summary>
	/// Contains a list of Snapshot resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Snapshot resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Snapshot[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#snapshotList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#snapshotList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SnapshotListWarning Warning { get; set; }
	}
	
	public class SnapshotListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SnapshotListWarningData[] SnapshotListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SnapshotListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotSettings
	{
		
		[System.Runtime.Serialization.DataMember(Name="storageLocation")]
		public SnapshotSettingsStorageLocationSettings StorageLocation { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotSettingsStorageLocationSettings
	{
		
		/// <summary>
		/// When the policy is SPECIFIC_LOCATIONS, snapshots will be stored in the locations listed in this field. Keys are GCS bucket locations.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="locations")]
		public System.Collections.Generic.Dictionary<string, SnapshotSettingsStorageLocationSettingsStorageLocationPreference> Locations { get; set; }
		
		/// <summary>
		/// The chosen location policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public System.Nullable<SnapshotSettingsStorageLocationSettingsPolicy> Policy { get; set; }
	}
	
	/// <summary>
	/// A structure for specifying storage locations.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SnapshotSettingsStorageLocationSettingsStorageLocationPreference
	{
		
		/// <summary>
		/// Name of the location. It should be one of the GCS buckets.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SnapshotSettingsStorageLocationSettingsPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL_REGION = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEAREST_MULTI_REGION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SPECIFIC_LOCATIONS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STORAGE_LOCATION_POLICY_UNSPECIFIED = 3,
	}
	
	/// <summary>
	/// Represents an SSL certificate resource. Google Compute Engine has two SSL certificate resources: * [Global](/compute/docs/reference/rest/v1/sslCertificates) * [Regional](/compute/docs/reference/rest/v1/regionSslCertificates) The global SSL certificates (sslCertificates) are used by: - Global external Application Load Balancers - Classic Application Load Balancers - Proxy Network Load Balancers (with target SSL proxies) The regional SSL certificates (regionSslCertificates) are used by: - Regional external Application Load Balancers - Regional internal Application Load Balancers Optionally, certificate file contents that you upload can contain a set of up to five PEM-encoded certificates. The API call creates an object (sslCertificate) that holds this data. You can use SSL keys and certificates to secure connections to a load balancer. For more information, read Creating and using SSL certificates, SSL certificates quotas and limits, and Troubleshooting SSL certificates.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslCertificate
	{
		
		/// <summary>
		/// A value read into memory from a certificate file. The certificate file must be in PEM format. The certificate chain must be no greater than 5 certs long. The chain must include at least one intermediate cert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] Expire time of the certificate. RFC3339
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expireTime")]
		public string ExpireTime { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#sslCertificate for SSL certificates.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#sslCertificate")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#sslCertificate";
		
		/// <summary>
		/// Configuration and status of a managed SSL certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="managed")]
		public SslCertificateManagedSslCertificate Managed { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// A value read into memory from a write-only private key file. The private key file must be in PEM format. For security, only insert requests include this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateKey")]
		public string PrivateKey { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional SSL Certificate resides. This field is not applicable to global SSL Certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Configuration and status of a self-managed SSL certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfManaged")]
		public SslCertificateSelfManagedSslCertificate SelfManaged { get; set; }
		
		/// <summary>
		/// [Output Only] Domains associated with the certificate via Subject Alternative Name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public string[] SubjectAlternativeNames { get; set; }
		
		/// <summary>
		/// (Optional) Specifies the type of SSL certificate, either "SELF_MANAGED" or "MANAGED". If not specified, the certificate is self-managed and the fields certificate and private_key are used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<SslCertificateType> Type { get; set; }
	}
	
	/// <summary>
	/// Configuration and status of a managed SSL certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslCertificateManagedSslCertificate
	{
		
		/// <summary>
		/// [Output only] Detailed statuses of the domains specified for managed certificate resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domainStatus")]
		public System.Collections.Generic.Dictionary<string, SslCertificateManagedSslCertificateDomainStatus> DomainStatus { get; set; }
		
		/// <summary>
		/// The domains for which a managed SSL certificate will be generated. Each Google-managed SSL certificate supports up to the [maximum number of domains per Google-managed SSL certificate](/load-balancing/docs/quotas#ssl_certificates).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// [Output only] Status of the managed certificate resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<SslCertificateManagedSslCertificateStatus> Status { get; set; }
	}
	
	public enum SslCertificateManagedSslCertificateDomainStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOMAIN_STATUS_UNSPECIFIED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED_CAA_CHECKING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED_CAA_FORBIDDEN = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED_NOT_VISIBLE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED_RATE_LIMITED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROVISIONING = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SslCertificateManagedSslCertificateStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MANAGED_CERTIFICATE_STATUS_UNSPECIFIED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROVISIONING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROVISIONING_FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROVISIONING_FAILED_PERMANENTLY = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RENEWAL_FAILED = 5,
	}
	
	/// <summary>
	/// Configuration and status of a self-managed SSL certificate.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslCertificateSelfManagedSslCertificate
	{
		
		/// <summary>
		/// A local certificate file. The certificate must be in PEM format. The certificate chain must be no greater than 5 certs long. The chain must include at least one intermediate cert.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
		
		/// <summary>
		/// A write-only private key in PEM format. Only insert requests will include this field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateKey")]
		public string PrivateKey { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SslCertificateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MANAGED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SELF_MANAGED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TYPE_UNSPECIFIED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslCertificateAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of SslCertificatesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, SslCertificatesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#sslCertificateAggregatedList for lists of SSL Certificates.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#sslCertificateAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#sslCertificateAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SslCertificateAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslCertificatesScopedList
	{
		
		/// <summary>
		/// List of SslCertificates contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslCertificates")]
		public SslCertificate[] SslCertificates { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of backend services when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SslCertificatesScopedListWarning Warning { get; set; }
	}
	
	public class SslCertificatesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SslCertificatesScopedListWarningData[] SslCertificatesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SslCertificatesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class SslCertificateAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SslCertificateAggregatedListWarningData[] SslCertificateAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SslCertificateAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of SslCertificate resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslCertificateList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of SslCertificate resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public SslCertificate[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#sslCertificateList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#sslCertificateList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SslCertificateListWarning Warning { get; set; }
	}
	
	public class SslCertificateListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SslCertificateListWarningData[] SslCertificateListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SslCertificateListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslPoliciesAggregatedList
	{
		
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of SslPoliciesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, SslPoliciesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#sslPolicyAggregatedList for lists of SSL Policies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#sslPoliciesAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#sslPoliciesAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SslPoliciesAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslPoliciesScopedList
	{
		
		/// <summary>
		/// A list of SslPolicies contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslPolicies")]
		public SslPolicy[] SslPolicies { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of SSL policies when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SslPoliciesScopedListWarning Warning { get; set; }
	}
	
	/// <summary>
	/// Represents an SSL Policy resource. Use SSL policies to control SSL features, such as versions and cipher suites, that are offered by Application Load Balancers and proxy Network Load Balancers. For more information, read SSL policies overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslPolicy
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// A list of features enabled when the selected profile is CUSTOM. The method returns the set of features that can be specified in this list. This field must be empty if the profile is not CUSTOM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="customFeatures")]
		public string[] CustomFeatures { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The list of features enabled in the SSL policy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enabledFeatures")]
		public string[] EnabledFeatures { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a SslPolicy. An up-to-date fingerprint must be provided in order to update the SslPolicy, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an SslPolicy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output only] Type of the resource. Always compute#sslPolicyfor SSL policies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#sslPolicy")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#sslPolicy";
		
		/// <summary>
		/// The minimum version of SSL protocol that can be used by the clients to establish a connection with the load balancer. This can be one of TLS_1_0, TLS_1_1, TLS_1_2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minTlsVersion")]
		public System.Nullable<SslPolicyMinTlsVersion> MinTlsVersion { get; set; }
		
		/// <summary>
		/// Name of the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Profile specifies the set of SSL features that can be used by the load balancer when negotiating SSL with clients. This can be one of COMPATIBLE, MODERN, RESTRICTED, or CUSTOM. If using CUSTOM, the set of SSL features to enable must be specified in the customFeatures field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="profile")]
		public System.Nullable<SslPolicyProfile> Profile { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional SSL policy resides. This field is not applicable to global SSL policies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] If potential misconfigurations are detected for this SSL policy, this field will be populated with warning messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warnings")]
		public SslPolicyWarnings[] SslPolicyWarnings { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SslPolicyMinTlsVersion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS_1_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS_1_1 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TLS_1_2 = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SslPolicyProfile
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPATIBLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MODERN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTRICTED = 3,
	}
	
	public class SslPolicyWarnings
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SslPolicyWarningsData[] SslPolicyWarningsData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SslPolicyWarningsData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class SslPoliciesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SslPoliciesScopedListWarningData[] SslPoliciesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SslPoliciesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class SslPoliciesAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SslPoliciesAggregatedListWarningData[] SslPoliciesAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SslPoliciesAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslPoliciesList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of SslPolicy resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public SslPolicy[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#sslPoliciesList for lists of sslPolicies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#sslPoliciesList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#sslPoliciesList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SslPoliciesListWarning Warning { get; set; }
	}
	
	public class SslPoliciesListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SslPoliciesListWarningData[] SslPoliciesListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SslPoliciesListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslPoliciesListAvailableFeaturesResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="features")]
		public string[] Features { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SslPolicyReference
	{
		
		/// <summary>
		/// URL of the SSL policy resource. Set this to empty string to clear any existing SSL policy associated with the target proxy resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslPolicy")]
		public string SslPolicy { get; set; }
	}
	
	/// <summary>
	/// Represents a Subnetwork resource. A subnetwork (also known as a subnet) is a logical partition of a Virtual Private Cloud network with one primary IP range and zero or more secondary IP ranges. For more information, read Virtual Private Cloud (VPC) Network.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Subnetwork
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource. This field can be set only at resource creation time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Whether to enable flow logging for this subnetwork. If this field is not explicitly set, it will not appear in get listings. If not set the default behavior is determined by the org policy, if there is no org policy specified, then it will default to disabled. This field isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enableFlowLogs")]
		public System.Nullable<System.Boolean> EnableFlowLogs { get; set; }
		
		/// <summary>
		/// The external IPv6 address range that is owned by this subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalIpv6Prefix")]
		public string ExternalIpv6Prefix { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a Subnetwork. An up-to-date fingerprint must be provided in order to update the Subnetwork, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a Subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The gateway address for default routes to reach destination addresses outside this subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="gatewayAddress")]
		public string GatewayAddress { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] The internal IPv6 address range that is assigned to this subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalIpv6Prefix")]
		public string InternalIpv6Prefix { get; set; }
		
		/// <summary>
		/// The range of internal addresses that are owned by this subnetwork. Provide this property when you create the subnetwork. For example, 10.0.0.0/8 or 100.64.0.0/10. Ranges must be unique and non-overlapping within a network. Only IPv4 is supported. This field is set at resource creation time. The range can be any range listed in the Valid ranges list. The range can be expanded after creation using expandIpCidrRange.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipCidrRange")]
		public string IpCidrRange { get; set; }
		
		/// <summary>
		/// The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation or the first time the subnet is updated into IPV4_IPV6 dual stack.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6AccessType")]
		public NetworkInterfaceIpv6AccessType Ipv6AccessType { get; set; }
		
		/// <summary>
		/// [Output Only] This field is for internal use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6CidrRange")]
		public string Ipv6CidrRange { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#subnetwork for Subnetwork resources.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#subnetwork")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#subnetwork";
		
		/// <summary>
		/// The available logging options for this subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="logConfig")]
		public SubnetworkLogConfig LogConfig { get; set; }
		
		/// <summary>
		/// The name of the resource, provided by the client when initially creating the resource. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// The URL of the network to which this subnetwork belongs, provided by the client when initially creating the subnetwork. This field can be set only at resource creation time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// Whether the VMs in this subnet can access Google services without assigned external IP addresses. This field can be both set at resource creation time and updated using setPrivateIpGoogleAccess.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateIpGoogleAccess")]
		public System.Nullable<System.Boolean> PrivateIpGoogleAccess { get; set; }
		
		/// <summary>
		/// This field is for internal use. This field can be both set at resource creation time and updated using patch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="privateIpv6GoogleAccess")]
		public System.Nullable<SubnetworkPrivateIpv6GoogleAccess> PrivateIpv6GoogleAccess { get; set; }
		
		/// <summary>
		/// The purpose of the resource. This field can be either PRIVATE, GLOBAL_MANAGED_PROXY, REGIONAL_MANAGED_PROXY, PRIVATE_SERVICE_CONNECT, or PRIVATE is the default purpose for user-created subnets or subnets that are automatically created in auto mode networks. Subnets with purpose set to GLOBAL_MANAGED_PROXY or REGIONAL_MANAGED_PROXY are user-created subnetworks that are reserved for Envoy-based load balancers. A subnet with purpose set to PRIVATE_SERVICE_CONNECT is used to publish services using Private Service Connect. If unspecified, the subnet purpose defaults to PRIVATE. The enableFlowLogs field isn't supported if the subnet purpose field is set to GLOBAL_MANAGED_PROXY or REGIONAL_MANAGED_PROXY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="purpose")]
		public System.Nullable<SubnetworkPurpose> Purpose { get; set; }
		
		/// <summary>
		/// URL of the region where the Subnetwork resides. This field can be set only at resource creation time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// The URL of the reserved internal range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedInternalRange")]
		public string ReservedInternalRange { get; set; }
		
		/// <summary>
		/// The role of subnetwork. Currently, this field is only used when purpose is set to GLOBAL_MANAGED_PROXY or REGIONAL_MANAGED_PROXY. The value can be set to ACTIVE or BACKUP. An ACTIVE subnetwork is one that is currently being used for Envoy-based load balancers in a region. A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining. This field can be updated with a patch request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public System.Nullable<SubnetworkRole> Role { get; set; }
		
		/// <summary>
		/// An array of configurations for secondary IP ranges for VM instances contained in this subnetwork. The primary IP of such VM must belong to the primary ipCidrRange of the subnetwork. The alias IPs may belong to either primary or secondary ranges. This field can be updated with a patch request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryIpRanges")]
		public SubnetworkSecondaryRange[] SecondaryIpRanges { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The stack type for the subnet. If set to IPV4_ONLY, new VMs in the subnet are assigned IPv4 addresses only. If set to IPV4_IPV6, new VMs in the subnet can be assigned both IPv4 and IPv6 addresses. If not specified, IPV4_ONLY is used. This field can be both set at resource creation time and updated using patch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackType")]
		public NetworkInterfaceStackType StackType { get; set; }
		
		/// <summary>
		/// [Output Only] The state of the subnetwork, which can be one of the following values: READY: Subnetwork is created and ready to use DRAINING: only applicable to subnetworks that have the purpose set to INTERNAL_HTTPS_LOAD_BALANCER and indicates that connections to the load balancer are being drained. A subnetwork that is draining cannot be used or modified until it reaches a status of READY
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<SubnetworkState> State { get; set; }
	}
	
	/// <summary>
	/// The available logging options for this subnetwork.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubnetworkLogConfig
	{
		
		/// <summary>
		/// Can only be specified if VPC flow logging for this subnetwork is enabled. Toggles the aggregation interval for collecting flow logs. Increasing the interval time will reduce the amount of generated flow logs for long lasting connections. Default is an interval of 5 seconds per connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregationInterval")]
		public System.Nullable<SubnetworkLogConfigAggregationInterval> AggregationInterval { get; set; }
		
		/// <summary>
		/// Whether to enable flow logging for this subnetwork. If this field is not explicitly set, it will not appear in get listings. If not set the default behavior is determined by the org policy, if there is no org policy specified, then it will default to disabled. Flow logging isn't supported if the subnet purpose field is set to REGIONAL_MANAGED_PROXY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enable")]
		public System.Nullable<System.Boolean> Enable { get; set; }
		
		/// <summary>
		/// Can only be specified if VPC flow logs for this subnetwork is enabled. The filter expression is used to define which VPC flow logs should be exported to Cloud Logging.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filterExpr")]
		public string FilterExpr { get; set; }
		
		/// <summary>
		/// Can only be specified if VPC flow logging for this subnetwork is enabled. The value of the field must be in [0, 1]. Set the sampling rate of VPC flow logs within the subnetwork where 1.0 means all collected logs are reported and 0.0 means no logs are reported. Default is 0.5 unless otherwise specified by the org policy, which means half of all collected logs are reported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="flowSampling")]
		public System.Nullable<System.Single> FlowSampling { get; set; }
		
		/// <summary>
		/// Can only be specified if VPC flow logs for this subnetwork is enabled. Configures whether all, none or a subset of metadata fields should be added to the reported VPC flow logs. Default is EXCLUDE_ALL_METADATA.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Nullable<SubnetworkLogConfigMetadata> Metadata { get; set; }
		
		/// <summary>
		/// Can only be specified if VPC flow logs for this subnetwork is enabled and "metadata" was set to CUSTOM_METADATA.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadataFields")]
		public string[] MetadataFields { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SubnetworkLogConfigAggregationInterval
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERVAL_10_MIN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERVAL_15_MIN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERVAL_1_MIN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERVAL_30_SEC = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERVAL_5_MIN = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERVAL_5_SEC = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SubnetworkLogConfigMetadata
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOM_METADATA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXCLUDE_ALL_METADATA = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCLUDE_ALL_METADATA = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SubnetworkPrivateIpv6GoogleAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLE_GOOGLE_ACCESS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SubnetworkPurpose
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GLOBAL_MANAGED_PROXY = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL_HTTPS_LOAD_BALANCER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE_NAT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE_RFC_1918 = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE_SERVICE_CONNECT = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGIONAL_MANAGED_PROXY = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SubnetworkRole
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BACKUP = 1,
	}
	
	/// <summary>
	/// Represents a secondary IP range of a subnetwork.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubnetworkSecondaryRange
	{
		
		/// <summary>
		/// The range of IP addresses belonging to this subnetwork secondary range. Provide this property when you create the subnetwork. Ranges must be unique and non-overlapping with all primary and secondary IP ranges within a network. Only IPv4 is supported. The range can be any range listed in the Valid ranges list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipCidrRange")]
		public string IpCidrRange { get; set; }
		
		/// <summary>
		/// The name associated with this subnetwork secondary range, used when adding an alias IP range to a VM instance. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rangeName")]
		public string RangeName { get; set; }
		
		/// <summary>
		/// The URL of the reserved internal range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reservedInternalRange")]
		public string ReservedInternalRange { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum SubnetworkState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DRAINING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubnetworkAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of SubnetworksScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, SubnetworksScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#subnetworkAggregatedList for aggregated lists of subnetworks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#subnetworkAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#subnetworkAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SubnetworkAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubnetworksScopedList
	{
		
		/// <summary>
		/// A list of subnetworks contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetworks")]
		public Subnetwork[] Subnetworks { get; set; }
		
		/// <summary>
		/// An informational warning that appears when the list of addresses is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SubnetworksScopedListWarning Warning { get; set; }
	}
	
	public class SubnetworksScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SubnetworksScopedListWarningData[] SubnetworksScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SubnetworksScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class SubnetworkAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SubnetworkAggregatedListWarningData[] SubnetworkAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SubnetworkAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of Subnetwork resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubnetworkList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Subnetwork resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Subnetwork[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#subnetworkList for lists of subnetworks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#subnetworkList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#subnetworkList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public SubnetworkListWarning Warning { get; set; }
	}
	
	public class SubnetworkListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public SubnetworkListWarningData[] SubnetworkListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class SubnetworkListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubnetworksExpandIpCidrRangeRequest
	{
		
		/// <summary>
		/// The IP (in CIDR format or netmask) of internal addresses that are legal on this Subnetwork. This range should be disjoint from other subnetworks within this network. This range can only be larger than (i.e. a superset of) the range previously defined before the update.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipCidrRange")]
		public string IpCidrRange { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SubnetworksSetPrivateIpGoogleAccessRequest
	{
		
		[System.Runtime.Serialization.DataMember(Name="privateIpGoogleAccess")]
		public System.Nullable<System.Boolean> PrivateIpGoogleAccess { get; set; }
	}
	
	/// <summary>
	/// Represents a Target gRPC Proxy resource. A target gRPC proxy is a component of load balancers intended for load balancing gRPC traffic. Only global forwarding rules with load balancing scheme INTERNAL_SELF_MANAGED can reference a target gRPC proxy. The target gRPC Proxy references a URL map that specifies how traffic is routed to gRPC backend services.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetGrpcProxy
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a TargetGrpcProxy. An up-to-date fingerprint must be provided in order to patch/update the TargetGrpcProxy; otherwise, the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve the TargetGrpcProxy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource type. The server generates this identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#targetGrpcProxy for target grpc proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetGrpcProxy")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetGrpcProxy";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL with id for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLinkWithId")]
		public string SelfLinkWithId { get; set; }
		
		/// <summary>
		/// URL to the UrlMap resource that defines the mapping from URL to the BackendService. The protocol field in the BackendService must be set to GRPC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlMap")]
		public string UrlMap { get; set; }
		
		/// <summary>
		/// If true, indicates that the BackendServices referenced by the urlMap may be accessed by gRPC applications without using a sidecar proxy. This will enable configuration checks on urlMap and its referenced BackendServices to not allow unsupported features. A gRPC application must use "xds:///" scheme in the target URI of the service it is connecting to. If false, indicates that the BackendServices referenced by the urlMap will be accessed by gRPC applications via a sidecar proxy. In this case, a gRPC application must not use "xds:///" scheme in the target URI of the service it is connecting to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validateForProxyless")]
		public System.Nullable<System.Boolean> ValidateForProxyless { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetGrpcProxyList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetGrpcProxy resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TargetGrpcProxy[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#targetGrpcProxy for target grpc proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetGrpcProxyList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetGrpcProxyList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetGrpcProxyListWarning Warning { get; set; }
	}
	
	public class TargetGrpcProxyListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetGrpcProxyListWarningData[] TargetGrpcProxyListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetGrpcProxyListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpProxiesScopedList
	{
		
		/// <summary>
		/// A list of TargetHttpProxies contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetHttpProxies")]
		public TargetHttpProxy[] TargetHttpProxies { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of backend services when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetHttpProxiesScopedListWarning Warning { get; set; }
	}
	
	/// <summary>
	/// Represents a Target HTTP Proxy resource. Google Compute Engine has two Target HTTP Proxy resources: * [Global](/compute/docs/reference/rest/v1/targetHttpProxies) * [Regional](/compute/docs/reference/rest/v1/regionTargetHttpProxies) A target HTTP proxy is a component of Google Cloud HTTP load balancers. * targetHttpProxies are used by global external Application Load Balancers, classic Application Load Balancers, cross-region internal Application Load Balancers, and Traffic Director. * regionTargetHttpProxies are used by regional internal Application Load Balancers and regional external Application Load Balancers. Forwarding rules reference a target HTTP proxy, and the target proxy then references a URL map. For more information, read Using Target Proxies and Forwarding rule concepts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpProxy
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a TargetHttpProxy. An up-to-date fingerprint must be provided in order to patch/update the TargetHttpProxy; otherwise, the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve the TargetHttpProxy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// Specifies how long to keep a connection open, after completing a response, while there is no matching traffic (in seconds). If an HTTP keep-alive is not specified, a default value (610 seconds) will be used. For global external Application Load Balancers, the minimum allowed value is 5 seconds and the maximum allowed value is 1200 seconds. For classic Application Load Balancers, this option is not supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpKeepAliveTimeoutSec")]
		public System.Nullable<System.Int32> HttpKeepAliveTimeoutSec { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetHttpProxy for target HTTP proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetHttpProxy")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetHttpProxy";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// This field only applies when the forwarding rule that references this target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED. When this field is set to true, Envoy proxies set up inbound traffic interception and bind to the IP address and port specified in the forwarding rule. This is generally useful when using Traffic Director to configure Envoy as a gateway or middle proxy (in other words, not a sidecar proxy). The Envoy proxy listens for inbound requests and handles requests when it receives them. The default is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyBind")]
		public System.Nullable<System.Boolean> ProxyBind { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional Target HTTP Proxy resides. This field is not applicable to global Target HTTP Proxies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// URL to the UrlMap resource that defines the mapping from URL to the BackendService.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlMap")]
		public string UrlMap { get; set; }
	}
	
	public class TargetHttpProxiesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetHttpProxiesScopedListWarningData[] TargetHttpProxiesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetHttpProxiesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpProxyAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetHttpProxiesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, TargetHttpProxiesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetHttpProxyAggregatedList for lists of Target HTTP Proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetHttpProxyAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetHttpProxyAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
	}
	
	/// <summary>
	/// A list of TargetHttpProxy resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpProxyList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetHttpProxy resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TargetHttpProxy[] Items { get; set; }
		
		/// <summary>
		/// Type of resource. Always compute#targetHttpProxyList for lists of target HTTP proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetHttpProxyList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetHttpProxyList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetHttpProxyListWarning Warning { get; set; }
	}
	
	public class TargetHttpProxyListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetHttpProxyListWarningData[] TargetHttpProxyListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetHttpProxyListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpsProxiesScopedList
	{
		
		/// <summary>
		/// A list of TargetHttpsProxies contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetHttpsProxies")]
		public TargetHttpsProxy[] TargetHttpsProxies { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of backend services when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetHttpsProxiesScopedListWarning Warning { get; set; }
	}
	
	/// <summary>
	/// Represents a Target HTTPS Proxy resource. Google Compute Engine has two Target HTTPS Proxy resources: * [Global](/compute/docs/reference/rest/v1/targetHttpsProxies) * [Regional](/compute/docs/reference/rest/v1/regionTargetHttpsProxies) A target HTTPS proxy is a component of GCP HTTPS load balancers. * targetHttpProxies are used by global external Application Load Balancers, classic Application Load Balancers, cross-region internal Application Load Balancers, and Traffic Director. * regionTargetHttpProxies are used by regional internal Application Load Balancers and regional external Application Load Balancers. Forwarding rules reference a target HTTPS proxy, and the target proxy then references a URL map. For more information, read Using Target Proxies and Forwarding rule concepts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpsProxy
	{
		
		/// <summary>
		/// Optional. A URL referring to a networksecurity.AuthorizationPolicy resource that describes how the proxy should authorize inbound traffic. If left blank, access will not be restricted by an authorization policy. Refer to the AuthorizationPolicy resource for additional details. authorizationPolicy only applies to a global TargetHttpsProxy attached to globalForwardingRules with the loadBalancingScheme set to INTERNAL_SELF_MANAGED. Note: This field currently has no impact.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authorizationPolicy")]
		public string AuthorizationPolicy { get; set; }
		
		/// <summary>
		/// URL of a certificate map that identifies a certificate map associated with the given target proxy. This field can only be set for global target proxies. If set, sslCertificates will be ignored. Accepted format is //certificatemanager.googleapis.com/projects/{project }/locations/{location}/certificateMaps/{resourceName}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateMap")]
		public string CertificateMap { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Fingerprint of this resource. A hash of the contents stored in this object. This field is used in optimistic locking. This field will be ignored when inserting a TargetHttpsProxy. An up-to-date fingerprint must be provided in order to patch the TargetHttpsProxy; otherwise, the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve the TargetHttpsProxy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fingerprint")]
		public string Fingerprint { get; set; }
		
		/// <summary>
		/// Specifies how long to keep a connection open, after completing a response, while there is no matching traffic (in seconds). If an HTTP keep-alive is not specified, a default value (610 seconds) will be used. For global external Application Load Balancers, the minimum allowed value is 5 seconds and the maximum allowed value is 1200 seconds. For classic Application Load Balancers, this option is not supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="httpKeepAliveTimeoutSec")]
		public System.Nullable<System.Int32> HttpKeepAliveTimeoutSec { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetHttpsProxy for target HTTPS proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetHttpsProxy")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetHttpsProxy";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// This field only applies when the forwarding rule that references this target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED. When this field is set to true, Envoy proxies set up inbound traffic interception and bind to the IP address and port specified in the forwarding rule. This is generally useful when using Traffic Director to configure Envoy as a gateway or middle proxy (in other words, not a sidecar proxy). The Envoy proxy listens for inbound requests and handles requests when it receives them. The default is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyBind")]
		public System.Nullable<System.Boolean> ProxyBind { get; set; }
		
		/// <summary>
		/// Specifies the QUIC override policy for this TargetHttpsProxy resource. This setting determines whether the load balancer attempts to negotiate QUIC with clients. You can specify NONE, ENABLE, or DISABLE. - When quic-override is set to NONE, Google manages whether QUIC is used. - When quic-override is set to ENABLE, the load balancer uses QUIC when possible. - When quic-override is set to DISABLE, the load balancer doesn't use QUIC. - If the quic-override flag is not specified, NONE is implied. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quicOverride")]
		public System.Nullable<TargetHttpsProxyQuicOverride> QuicOverride { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional TargetHttpsProxy resides. This field is not applicable to global TargetHttpsProxies.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Optional. A URL referring to a networksecurity.ServerTlsPolicy resource that describes how the proxy should authenticate inbound traffic. serverTlsPolicy only applies to a global TargetHttpsProxy attached to globalForwardingRules with the loadBalancingScheme set to INTERNAL_SELF_MANAGED or EXTERNAL or EXTERNAL_MANAGED. For details which ServerTlsPolicy resources are accepted with INTERNAL_SELF_MANAGED and which with EXTERNAL, EXTERNAL_MANAGED loadBalancingScheme consult ServerTlsPolicy documentation. If left blank, communications are not encrypted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverTlsPolicy")]
		public string ServerTlsPolicy { get; set; }
		
		/// <summary>
		/// URLs to SslCertificate resources that are used to authenticate connections between users and the load balancer. At least one SSL certificate must be specified. Currently, you may specify up to 15 SSL certificates. sslCertificates do not apply when the load balancing scheme is set to INTERNAL_SELF_MANAGED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslCertificates")]
		public string[] SslCertificates { get; set; }
		
		/// <summary>
		/// URL of SslPolicy resource that will be associated with the TargetHttpsProxy resource. If not set, the TargetHttpsProxy resource has no SSL policy configured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslPolicy")]
		public string SslPolicy { get; set; }
		
		/// <summary>
		/// A fully-qualified or valid partial URL to the UrlMap resource that defines the mapping from URL to the BackendService. For example, the following are all valid URLs for specifying a URL map: - https://www.googleapis.compute/v1/projects/project/global/urlMaps/ url-map - projects/project/global/urlMaps/url-map - global/urlMaps/url-map 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlMap")]
		public string UrlMap { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TargetHttpsProxyQuicOverride
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DISABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENABLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 2,
	}
	
	public class TargetHttpsProxiesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetHttpsProxiesScopedListWarningData[] TargetHttpsProxiesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetHttpsProxiesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpsProxiesSetCertificateMapRequest
	{
		
		/// <summary>
		/// URL of the Certificate Map to associate with this TargetHttpsProxy. Accepted format is //certificatemanager.googleapis.com/projects/{project }/locations/{location}/certificateMaps/{resourceName}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateMap")]
		public string CertificateMap { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpsProxiesSetQuicOverrideRequest
	{
		
		/// <summary>
		/// QUIC policy for the TargetHttpsProxy resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="quicOverride")]
		public TargetHttpsProxyQuicOverride QuicOverride { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpsProxiesSetSslCertificatesRequest
	{
		
		/// <summary>
		/// New set of SslCertificate resources to associate with this TargetHttpsProxy resource. At least one SSL certificate must be specified. Currently, you may specify up to 15 SSL certificates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslCertificates")]
		public string[] SslCertificates { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpsProxyAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetHttpsProxiesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, TargetHttpsProxiesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetHttpsProxyAggregatedList for lists of Target HTTP Proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetHttpsProxyAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetHttpsProxyAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetHttpsProxyAggregatedListWarning Warning { get; set; }
	}
	
	public class TargetHttpsProxyAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetHttpsProxyAggregatedListWarningData[] TargetHttpsProxyAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetHttpsProxyAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of TargetHttpsProxy resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetHttpsProxyList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetHttpsProxy resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TargetHttpsProxy[] Items { get; set; }
		
		/// <summary>
		/// Type of resource. Always compute#targetHttpsProxyList for lists of target HTTPS proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetHttpsProxyList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetHttpsProxyList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetHttpsProxyListWarning Warning { get; set; }
	}
	
	public class TargetHttpsProxyListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetHttpsProxyListWarningData[] TargetHttpsProxyListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetHttpsProxyListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Target Instance resource. You can use a target instance to handle traffic for one or more forwarding rules, which is ideal for forwarding protocol traffic that is managed by a single source. For example, ESP, AH, TCP, or UDP. For more information, read Target instances.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetInstance
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A URL to the virtual machine instance that handles traffic for this target instance. When creating a target instance, you can provide the fully-qualified URL or a valid partial URL to the desired virtual machine. For example, the following are all valid URLs: - https://www.googleapis.com/compute/v1/projects/project/zones/zone /instances/instance - projects/project/zones/zone/instances/instance - zones/zone/instances/instance 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public string Instance { get; set; }
		
		/// <summary>
		/// [Output Only] The type of the resource. Always compute#targetInstance for target instances.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetInstance")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetInstance";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Must have a value of NO_NAT. Protocol forwarding delivers packets while preserving the destination IP address of the forwarding rule referencing the target instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natPolicy")]
		public System.Nullable<TargetInstanceNatPolicy> NatPolicy { get; set; }
		
		/// <summary>
		/// The URL of the network this target instance uses to forward traffic. If not specified, the traffic will be forwarded to the network that the default network interface belongs to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// [Output Only] The resource URL for the security policy associated with this target instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securityPolicy")]
		public string SecurityPolicy { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the zone where the target instance resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zone")]
		public string Zone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TargetInstanceNatPolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_NAT = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetInstanceAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetInstance resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, TargetInstancesScopedList> Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetInstanceAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetInstanceAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetInstanceAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetInstancesScopedList
	{
		
		/// <summary>
		/// A list of target instances contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetInstances")]
		public TargetInstance[] TargetInstances { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of addresses when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetInstancesScopedListWarning Warning { get; set; }
	}
	
	public class TargetInstancesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetInstancesScopedListWarningData[] TargetInstancesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetInstancesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class TargetInstanceAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetInstanceAggregatedListWarningData[] TargetInstanceAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetInstanceAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of TargetInstance resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetInstanceList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetInstance resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TargetInstance[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetInstanceList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetInstanceList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetInstanceListWarning Warning { get; set; }
	}
	
	public class TargetInstanceListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetInstanceListWarningData[] TargetInstanceListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetInstanceListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Target Pool resource. Target pools are used with external passthrough Network Load Balancers. A target pool references member instances, an associated legacy HttpHealthCheck resource, and, optionally, a backup target pool. For more information, read Using target pools.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetPool
	{
		
		/// <summary>
		/// The server-defined URL for the resource. This field is applicable only when the containing target pool is serving a forwarding rule as the primary pool, and its failoverRatio field is properly set to a value between [0, 1]. backupPool and failoverRatio together define the fallback behavior of the primary target pool: if the ratio of the healthy instances in the primary pool is at or below failoverRatio, traffic arriving at the load-balanced IP will be directed to the backup pool. In case where failoverRatio and backupPool are not set, or all the instances in the backup pool are unhealthy, the traffic will be directed back to the primary pool in the "force" mode, where traffic will be spread to the healthy instances with the best effort, or to all instances when no instance is healthy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="backupPool")]
		public string BackupPool { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// This field is applicable only when the containing target pool is serving a forwarding rule as the primary pool (i.e., not as a backup pool to some other target pool). The value of the field must be in [0, 1]. If set, backupPool must also be set. They together define the fallback behavior of the primary target pool: if the ratio of the healthy instances in the primary pool is at or below this number, traffic arriving at the load-balanced IP will be directed to the backup pool. In case where failoverRatio is not set or all the instances in the backup pool are unhealthy, the traffic will be directed back to the primary pool in the "force" mode, where traffic will be spread to the healthy instances with the best effort, or to all instances when no instance is healthy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failoverRatio")]
		public System.Nullable<System.Single> FailoverRatio { get; set; }
		
		/// <summary>
		/// The URL of the HttpHealthCheck resource. A member instance in this pool is considered healthy if and only if the health checks pass. Only legacy HttpHealthChecks are supported. Only one health check may be specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthChecks")]
		public string[] HealthChecks { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of resource URLs to the virtual machine instances serving this pool. They must live in zones contained in the same region as this pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public string[] Instances { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#targetPool for target pools.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetPool")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetPool";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the target pool resides.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] The resource URL for the security policy associated with this target pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="securityPolicy")]
		public string SecurityPolicy { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Session affinity option, must be one of the following values: NONE: Connections from the same client IP may go to any instance in the pool. CLIENT_IP: Connections from the same client IP will go to the same instance in the pool while that instance remains healthy. CLIENT_IP_PROTO: Connections from the same client IP with the same IP protocol will go to the same instance in the pool while that instance remains healthy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sessionAffinity")]
		public BackendServiceSessionAffinity SessionAffinity { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetPoolAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetPool resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, TargetPoolsScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetPoolAggregatedList for aggregated lists of target pools.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetPoolAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetPoolAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetPoolAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetPoolsScopedList
	{
		
		/// <summary>
		/// A list of target pools contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetPools")]
		public TargetPool[] TargetPools { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of addresses when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetPoolsScopedListWarning Warning { get; set; }
	}
	
	public class TargetPoolsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetPoolsScopedListWarningData[] TargetPoolsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetPoolsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class TargetPoolAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetPoolAggregatedListWarningData[] TargetPoolAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetPoolAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetPoolInstanceHealth
	{
		
		[System.Runtime.Serialization.DataMember(Name="healthStatus")]
		public HealthStatus[] HealthStatus { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetPoolInstanceHealth when checking the health of an instance.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetPoolInstanceHealth")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetPoolInstanceHealth";
	}
	
	/// <summary>
	/// Contains a list of TargetPool resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetPoolList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetPool resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TargetPool[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetPoolList for lists of target pools.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetPoolList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetPoolList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetPoolListWarning Warning { get; set; }
	}
	
	public class TargetPoolListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetPoolListWarningData[] TargetPoolListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetPoolListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetPoolsAddHealthCheckRequest
	{
		
		/// <summary>
		/// The HttpHealthCheck to add to the target pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthChecks")]
		public HealthCheckReference[] HealthChecks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetPoolsAddInstanceRequest
	{
		
		/// <summary>
		/// A full or partial URL to an instance to add to this target pool. This can be a full or partial URL. For example, the following are valid URLs: - https://www.googleapis.com/compute/v1/projects/project-id/zones/zone /instances/instance-name - projects/project-id/zones/zone/instances/instance-name - zones/zone/instances/instance-name 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public InstanceReference[] Instances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetPoolsRemoveHealthCheckRequest
	{
		
		/// <summary>
		/// Health check URL to be removed. This can be a full or valid partial URL. For example, the following are valid URLs: - https://www.googleapis.com/compute/beta/projects/project /global/httpHealthChecks/health-check - projects/project/global/httpHealthChecks/health-check - global/httpHealthChecks/health-check 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="healthChecks")]
		public HealthCheckReference[] HealthChecks { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetPoolsRemoveInstanceRequest
	{
		
		/// <summary>
		/// URLs of the instances to be removed from target pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public InstanceReference[] Instances { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetReference
	{
		
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetSslProxiesSetBackendServiceRequest
	{
		
		/// <summary>
		/// The URL of the new BackendService resource for the targetSslProxy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetSslProxiesSetCertificateMapRequest
	{
		
		/// <summary>
		/// URL of the Certificate Map to associate with this TargetSslProxy. Accepted format is //certificatemanager.googleapis.com/projects/{project }/locations/{location}/certificateMaps/{resourceName}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateMap")]
		public string CertificateMap { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetSslProxiesSetProxyHeaderRequest
	{
		
		/// <summary>
		/// The new type of proxy header to append before sending data to the backend. NONE or PROXY_V1 are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyHeader")]
		public HTTP2HealthCheckProxyHeader ProxyHeader { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetSslProxiesSetSslCertificatesRequest
	{
		
		/// <summary>
		/// New set of URLs to SslCertificate resources to associate with this TargetSslProxy. At least one SSL certificate must be specified. Currently, you may specify up to 15 SSL certificates.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslCertificates")]
		public string[] SslCertificates { get; set; }
	}
	
	/// <summary>
	/// Represents a Target SSL Proxy resource. A target SSL proxy is a component of a Proxy Network Load Balancer. The forwarding rule references the target SSL proxy, and the target proxy then references a backend service. For more information, read Proxy Network Load Balancer overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetSslProxy
	{
		
		/// <summary>
		/// URL of a certificate map that identifies a certificate map associated with the given target proxy. This field can only be set for global target proxies. If set, sslCertificates will be ignored. Accepted format is //certificatemanager.googleapis.com/projects/{project }/locations/{location}/certificateMaps/{resourceName}.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateMap")]
		public string CertificateMap { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#targetSslProxy for target SSL proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetSslProxy")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetSslProxy";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyHeader")]
		public HTTP2HealthCheckProxyHeader ProxyHeader { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// URL to the BackendService resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
		
		/// <summary>
		/// URLs to SslCertificate resources that are used to authenticate connections to Backends. At least one SSL certificate must be specified. Currently, you may specify up to 15 SSL certificates. sslCertificates do not apply when the load balancing scheme is set to INTERNAL_SELF_MANAGED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslCertificates")]
		public string[] SslCertificates { get; set; }
		
		/// <summary>
		/// URL of SslPolicy resource that will be associated with the TargetSslProxy resource. If not set, the TargetSslProxy resource will not have any SSL policy configured.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sslPolicy")]
		public string SslPolicy { get; set; }
	}
	
	/// <summary>
	/// Contains a list of TargetSslProxy resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetSslProxyList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetSslProxy resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TargetSslProxy[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetSslProxyList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetSslProxyList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetSslProxyListWarning Warning { get; set; }
	}
	
	public class TargetSslProxyListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetSslProxyListWarningData[] TargetSslProxyListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetSslProxyListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetTcpProxiesScopedList
	{
		
		/// <summary>
		/// A list of TargetTcpProxies contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetTcpProxies")]
		public TargetTcpProxy[] TargetTcpProxies { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of backend services when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetTcpProxiesScopedListWarning Warning { get; set; }
	}
	
	/// <summary>
	/// Represents a Target TCP Proxy resource. A target TCP proxy is a component of a Proxy Network Load Balancer. The forwarding rule references the target TCP proxy, and the target proxy then references a backend service. For more information, read Proxy Network Load Balancer overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetTcpProxy
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#targetTcpProxy for target TCP proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetTcpProxy")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetTcpProxy";
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// This field only applies when the forwarding rule that references this target proxy has a loadBalancingScheme set to INTERNAL_SELF_MANAGED. When this field is set to true, Envoy proxies set up inbound traffic interception and bind to the IP address and port specified in the forwarding rule. This is generally useful when using Traffic Director to configure Envoy as a gateway or middle proxy (in other words, not a sidecar proxy). The Envoy proxy listens for inbound requests and handles requests when it receives them. The default is false.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyBind")]
		public System.Nullable<System.Boolean> ProxyBind { get; set; }
		
		/// <summary>
		/// Specifies the type of proxy header to append before sending data to the backend, either NONE or PROXY_V1. The default is NONE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyHeader")]
		public HTTP2HealthCheckProxyHeader ProxyHeader { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the regional TCP proxy resides. This field is not applicable to global TCP proxy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// URL to the BackendService resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
	}
	
	public class TargetTcpProxiesScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetTcpProxiesScopedListWarningData[] TargetTcpProxiesScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetTcpProxiesScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetTcpProxiesSetBackendServiceRequest
	{
		
		/// <summary>
		/// The URL of the new BackendService resource for the targetTcpProxy.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="service")]
		public string Service { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetTcpProxiesSetProxyHeaderRequest
	{
		
		/// <summary>
		/// The new type of proxy header to append before sending data to the backend. NONE or PROXY_V1 are allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="proxyHeader")]
		public HTTP2HealthCheckProxyHeader ProxyHeader { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetTcpProxyAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetTcpProxiesScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, TargetTcpProxiesScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetTcpProxyAggregatedList for lists of Target TCP Proxies.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetTcpProxyAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetTcpProxyAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetTcpProxyAggregatedListWarning Warning { get; set; }
	}
	
	public class TargetTcpProxyAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetTcpProxyAggregatedListWarningData[] TargetTcpProxyAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetTcpProxyAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of TargetTcpProxy resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetTcpProxyList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetTcpProxy resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TargetTcpProxy[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetTcpProxyList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetTcpProxyList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetTcpProxyListWarning Warning { get; set; }
	}
	
	public class TargetTcpProxyListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetTcpProxyListWarningData[] TargetTcpProxyListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetTcpProxyListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Target VPN Gateway resource. The target VPN gateway resource represents a Classic Cloud VPN gateway. For more information, read the the Cloud VPN Overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetVpnGateway
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] A list of URLs to the ForwardingRule resources. ForwardingRules are created using compute.forwardingRules.insert and associated with a VPN gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forwardingRules")]
		public string[] ForwardingRules { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetVpnGateway for target VPN gateways.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetVpnGateway")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetVpnGateway";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this TargetVpnGateway, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a TargetVpnGateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels for this resource. These can only be added or modified by the setLabels method. Each label key/value pair must comply with RFC1035. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// URL of the network to which this VPN gateway is attached. Provided by the client when the VPN gateway is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the target VPN gateway resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the VPN gateway, which can be one of the following: CREATING, READY, FAILED, or DELETING.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<TargetVpnGatewayStatus> Status { get; set; }
		
		/// <summary>
		/// [Output Only] A list of URLs to VpnTunnel resources. VpnTunnels are created using the compute.vpntunnels.insert method and associated with a VPN gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tunnels")]
		public string[] Tunnels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum TargetVpnGatewayStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		READY = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetVpnGatewayAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetVpnGateway resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, TargetVpnGatewaysScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetVpnGateway for target VPN gateways.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetVpnGatewayAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetVpnGatewayAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetVpnGatewayAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetVpnGatewaysScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of target VPN gateways contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetVpnGateways")]
		public TargetVpnGateway[] TargetVpnGateways { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning which replaces the list of addresses when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetVpnGatewaysScopedListWarning Warning { get; set; }
	}
	
	public class TargetVpnGatewaysScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetVpnGatewaysScopedListWarningData[] TargetVpnGatewaysScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetVpnGatewaysScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class TargetVpnGatewayAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetVpnGatewayAggregatedListWarningData[] TargetVpnGatewayAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetVpnGatewayAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of TargetVpnGateway resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TargetVpnGatewayList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of TargetVpnGateway resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public TargetVpnGateway[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#targetVpnGateway for target VPN gateways.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#targetVpnGatewayList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#targetVpnGatewayList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public TargetVpnGatewayListWarning Warning { get; set; }
	}
	
	public class TargetVpnGatewayListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public TargetVpnGatewayListWarningData[] TargetVpnGatewayListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class TargetVpnGatewayListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TestFailure
	{
		
		/// <summary>
		/// The actual output URL evaluated by a load balancer containing the scheme, host, path and query parameters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actualOutputUrl")]
		public string ActualOutputUrl { get; set; }
		
		/// <summary>
		/// Actual HTTP status code for rule with `urlRedirect` calculated by load balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actualRedirectResponseCode")]
		public System.Nullable<System.Int32> ActualRedirectResponseCode { get; set; }
		
		/// <summary>
		/// BackendService or BackendBucket returned by load balancer.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actualService")]
		public string ActualService { get; set; }
		
		/// <summary>
		/// The expected output URL evaluated by a load balancer containing the scheme, host, path and query parameters.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expectedOutputUrl")]
		public string ExpectedOutputUrl { get; set; }
		
		/// <summary>
		/// Expected HTTP status code for rule with `urlRedirect` calculated by load balancer
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expectedRedirectResponseCode")]
		public System.Nullable<System.Int32> ExpectedRedirectResponseCode { get; set; }
		
		/// <summary>
		/// Expected BackendService or BackendBucket resource the given URL should be mapped to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expectedService")]
		public string ExpectedService { get; set; }
		
		/// <summary>
		/// HTTP headers of the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public UrlMapTestHeader[] Headers { get; set; }
		
		/// <summary>
		/// Host portion of the URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="host")]
		public string Host { get; set; }
		
		/// <summary>
		/// Path portion including query parameters in the URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TestPermissionsRequest
	{
		
		/// <summary>
		/// The set of permissions to check for the 'resource'. Permissions with wildcards (such as '*' or 'storage.*') are not allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public string[] Permissions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TestPermissionsResponse
	{
		
		/// <summary>
		/// A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permissions")]
		public string[] Permissions { get; set; }
	}
	
	/// <summary>
	/// Contains a list of UrlMap resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlMapList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of UrlMap resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public UrlMap[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#urlMapList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#urlMapList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public UrlMapListWarning Warning { get; set; }
	}
	
	public class UrlMapListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public UrlMapListWarningData[] UrlMapListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class UrlMapListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlMapReference
	{
		
		[System.Runtime.Serialization.DataMember(Name="urlMap")]
		public string UrlMap { get; set; }
	}
	
	/// <summary>
	/// Message representing the validation result for a UrlMap.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlMapValidationResult
	{
		
		[System.Runtime.Serialization.DataMember(Name="loadErrors")]
		public string[] LoadErrors { get; set; }
		
		/// <summary>
		/// Whether the given UrlMap can be successfully loaded. If false, 'loadErrors' indicates the reasons.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadSucceeded")]
		public System.Nullable<System.Boolean> LoadSucceeded { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="testFailures")]
		public TestFailure[] TestFailures { get; set; }
		
		/// <summary>
		/// If successfully loaded, this field indicates whether the test passed. If false, 'testFailures's indicate the reason of failure.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="testPassed")]
		public System.Nullable<System.Boolean> TestPassed { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlMapsAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of UrlMapsScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, UrlMapsScopedList> Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#urlMapsAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#urlMapsAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public UrlMapsAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlMapsScopedList
	{
		
		/// <summary>
		/// A list of UrlMaps contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="urlMaps")]
		public UrlMap[] UrlMaps { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of backend services when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public UrlMapsScopedListWarning Warning { get; set; }
	}
	
	public class UrlMapsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public UrlMapsScopedListWarningData[] UrlMapsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class UrlMapsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class UrlMapsAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public UrlMapsAggregatedListWarningData[] UrlMapsAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class UrlMapsAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlMapsValidateRequest
	{
		
		/// <summary>
		/// Specifies the load balancer type(s) this validation request is for. Use EXTERNAL_MANAGED for global external Application Load Balancers and regional external Application Load Balancers. Use EXTERNAL for classic Application Load Balancers. Use INTERNAL_MANAGED for internal Application Load Balancers. For more information, refer to Choosing a load balancer. If unspecified, the load balancing scheme will be inferred from the backend service resources this URL map references. If that can not be inferred (for example, this URL map only references backend buckets, or this Url map is for rewrites and redirects only and doesn't reference any backends), EXTERNAL will be used as the default type. If specified, the scheme(s) must not conflict with the load balancing scheme of the backend service resources this Url map references.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loadBalancingSchemes")]
		public string[] LoadBalancingSchemes { get; set; }
		
		/// <summary>
		/// Represents a URL Map resource. Compute Engine has two URL Map resources: * [Global](/compute/docs/reference/rest/v1/urlMaps) * [Regional](/compute/docs/reference/rest/v1/regionUrlMaps) A URL map resource is a component of certain types of cloud load balancers and Traffic Director: * urlMaps are used by global external Application Load Balancers, classic Application Load Balancers, and cross-region internal Application Load Balancers. * regionUrlMaps are used by internal Application Load Balancers, regional external Application Load Balancers and regional internal Application Load Balancers. For a list of supported URL map features by the load balancer type, see the Load balancing features: Routing and traffic management table. For a list of supported URL map features for Traffic Director, see the Traffic Director features: Routing and traffic management table. This resource defines mappings from hostnames and URL paths to either a backend service or a backend bucket. To use the global urlMaps resource, the backend service must have a loadBalancingScheme of either EXTERNAL or INTERNAL_SELF_MANAGED. To use the regionUrlMaps resource, the backend service must have a loadBalancingScheme of INTERNAL_MANAGED. For more information, read URL Map Concepts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public UrlMap Resource { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UrlMapsValidateResponse
	{
		
		/// <summary>
		/// Message representing the validation result for a UrlMap.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public UrlMapValidationResult Result { get; set; }
	}
	
	/// <summary>
	/// Subnetwork which the current user has compute.subnetworks.use permission on.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UsableSubnetwork
	{
		
		/// <summary>
		/// [Output Only] The external IPv6 address range that is assigned to this subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="externalIpv6Prefix")]
		public string ExternalIpv6Prefix { get; set; }
		
		/// <summary>
		/// [Output Only] The internal IPv6 address range that is assigned to this subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalIpv6Prefix")]
		public string InternalIpv6Prefix { get; set; }
		
		/// <summary>
		/// The range of internal addresses that are owned by this subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipCidrRange")]
		public string IpCidrRange { get; set; }
		
		/// <summary>
		/// The access type of IPv6 address this subnet holds. It's immutable and can only be specified during creation or the first time the subnet is updated into IPV4_IPV6 dual stack.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipv6AccessType")]
		public NetworkInterfaceIpv6AccessType Ipv6AccessType { get; set; }
		
		/// <summary>
		/// Network URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// The purpose of the resource. This field can be either PRIVATE, GLOBAL_MANAGED_PROXY, REGIONAL_MANAGED_PROXY, PRIVATE_SERVICE_CONNECT, or PRIVATE is the default purpose for user-created subnets or subnets that are automatically created in auto mode networks. Subnets with purpose set to GLOBAL_MANAGED_PROXY or REGIONAL_MANAGED_PROXY are user-created subnetworks that are reserved for Envoy-based load balancers. A subnet with purpose set to PRIVATE_SERVICE_CONNECT is used to publish services using Private Service Connect. If unspecified, the subnet purpose defaults to PRIVATE. The enableFlowLogs field isn't supported if the subnet purpose field is set to GLOBAL_MANAGED_PROXY or REGIONAL_MANAGED_PROXY.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="purpose")]
		public SubnetworkPurpose Purpose { get; set; }
		
		/// <summary>
		/// The role of subnetwork. Currently, this field is only used when purpose is set to GLOBAL_MANAGED_PROXY or REGIONAL_MANAGED_PROXY. The value can be set to ACTIVE or BACKUP. An ACTIVE subnetwork is one that is currently being used for Envoy-based load balancers in a region. A BACKUP subnetwork is one that is ready to be promoted to ACTIVE or is currently draining. This field can be updated with a patch request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="role")]
		public SubnetworkRole Role { get; set; }
		
		/// <summary>
		/// Secondary IP ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secondaryIpRanges")]
		public UsableSubnetworkSecondaryRange[] SecondaryIpRanges { get; set; }
		
		/// <summary>
		/// The stack type for the subnet. If set to IPV4_ONLY, new VMs in the subnet are assigned IPv4 addresses only. If set to IPV4_IPV6, new VMs in the subnet can be assigned both IPv4 and IPv6 addresses. If not specified, IPV4_ONLY is used. This field can be both set at resource creation time and updated using patch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackType")]
		public NetworkInterfaceStackType StackType { get; set; }
		
		/// <summary>
		/// Subnetwork URL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subnetwork")]
		public string Subnetwork { get; set; }
	}
	
	/// <summary>
	/// Secondary IP range of a usable subnetwork.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UsableSubnetworkSecondaryRange
	{
		
		/// <summary>
		/// The range of IP addresses belonging to this subnetwork secondary range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipCidrRange")]
		public string IpCidrRange { get; set; }
		
		/// <summary>
		/// The name associated with this subnetwork secondary range, used when adding an alias IP range to a VM instance. The name must be 1-63 characters long, and comply with RFC1035. The name must be unique within the subnetwork.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rangeName")]
		public string RangeName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UsableSubnetworksAggregatedList
	{
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output] A list of usable subnetwork URLs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public UsableSubnetwork[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#usableSubnetworksAggregatedList for aggregated lists of usable subnetworks.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#usableSubnetworksAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#usableSubnetworksAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results. In special cases listUsable may return 0 subnetworks and nextPageToken which still should be used to get the next page of results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public UsableSubnetworksAggregatedListWarning Warning { get; set; }
	}
	
	public class UsableSubnetworksAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public UsableSubnetworksAggregatedListWarningData[] UsableSubnetworksAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class UsableSubnetworksAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contain information of Nat mapping for a VM endpoint (i.e., NIC).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmEndpointNatMappings
	{
		
		/// <summary>
		/// Name of the VM instance which the endpoint belongs to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceName")]
		public string InstanceName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="interfaceNatMappings")]
		public VmEndpointNatMappingsInterfaceNatMappings[] InterfaceNatMappings { get; set; }
	}
	
	/// <summary>
	/// Contain information of Nat mapping for an interface of this endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmEndpointNatMappingsInterfaceNatMappings
	{
		
		/// <summary>
		/// List of all drain IP:port-range mappings assigned to this interface. These ranges are inclusive, that is, both the first and the last ports can be used for NAT. Example: ["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="drainNatIpPortRanges")]
		public string[] DrainNatIpPortRanges { get; set; }
		
		/// <summary>
		/// A list of all IP:port-range mappings assigned to this interface. These ranges are inclusive, that is, both the first and the last ports can be used for NAT. Example: ["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natIpPortRanges")]
		public string[] NatIpPortRanges { get; set; }
		
		/// <summary>
		/// Total number of drain ports across all NAT IPs allocated to this interface. It equals to the aggregated port number in the field drain_nat_ip_port_ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numTotalDrainNatPorts")]
		public System.Nullable<System.Int32> NumTotalDrainNatPorts { get; set; }
		
		/// <summary>
		/// Total number of ports across all NAT IPs allocated to this interface. It equals to the aggregated port number in the field nat_ip_port_ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numTotalNatPorts")]
		public System.Nullable<System.Int32> NumTotalNatPorts { get; set; }
		
		/// <summary>
		/// Information about mappings provided by rules in this NAT.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleMappings")]
		public VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings[] RuleMappings { get; set; }
		
		/// <summary>
		/// Alias IP range for this interface endpoint. It will be a private (RFC 1918) IP range. Examples: "10.33.4.55/32", or "192.168.5.0/24".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceAliasIpRange")]
		public string SourceAliasIpRange { get; set; }
		
		/// <summary>
		/// Primary IP of the VM for this NIC.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceVirtualIp")]
		public string SourceVirtualIp { get; set; }
	}
	
	/// <summary>
	/// Contains information of NAT Mappings provided by a NAT Rule.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings
	{
		
		/// <summary>
		/// List of all drain IP:port-range mappings assigned to this interface by this rule. These ranges are inclusive, that is, both the first and the last ports can be used for NAT. Example: ["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="drainNatIpPortRanges")]
		public string[] DrainNatIpPortRanges { get; set; }
		
		/// <summary>
		/// A list of all IP:port-range mappings assigned to this interface by this rule. These ranges are inclusive, that is, both the first and the last ports can be used for NAT. Example: ["2.2.2.2:12345-12355", "1.1.1.1:2234-2234"].
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="natIpPortRanges")]
		public string[] NatIpPortRanges { get; set; }
		
		/// <summary>
		/// Total number of drain ports across all NAT IPs allocated to this interface by this rule. It equals the aggregated port number in the field drain_nat_ip_port_ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numTotalDrainNatPorts")]
		public System.Nullable<System.Int32> NumTotalDrainNatPorts { get; set; }
		
		/// <summary>
		/// Total number of ports across all NAT IPs allocated to this interface by this rule. It equals the aggregated port number in the field nat_ip_port_ranges.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numTotalNatPorts")]
		public System.Nullable<System.Int32> NumTotalNatPorts { get; set; }
		
		/// <summary>
		/// Rule number of the NAT Rule.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ruleNumber")]
		public System.Nullable<System.Int32> RuleNumber { get; set; }
	}
	
	/// <summary>
	/// Contains a list of VmEndpointNatMappings.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VmEndpointNatMappingsList
	{
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#vmEndpointNatMappingsList for lists of Nat mappings of VM endpoints.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#vmEndpointNatMappingsList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#vmEndpointNatMappingsList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] A list of Nat mapping information of VM endpoints.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public VmEndpointNatMappings[] Result { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public VmEndpointNatMappingsListWarning Warning { get; set; }
	}
	
	public class VmEndpointNatMappingsListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VmEndpointNatMappingsListWarningData[] VmEndpointNatMappingsListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class VmEndpointNatMappingsListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a HA VPN gateway. HA VPN is a high-availability (HA) Cloud VPN solution that lets you securely connect your on-premises network to your Google Cloud Virtual Private Cloud network through an IPsec VPN connection in a single region. For more information about Cloud HA VPN solutions, see Cloud VPN topologies .
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnGateway
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#vpnGateway for VPN gateways.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#vpnGateway")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#vpnGateway";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this VpnGateway, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a VpnGateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels for this resource. These can only be added or modified by the setLabels method. Each label key/value pair must comply with RFC1035. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// URL of the network to which this VPN gateway is attached. Provided by the client when the VPN gateway is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="network")]
		public string Network { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the VPN gateway resides.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// The stack type for this VPN gateway to identify the IP protocols that are enabled. Possible values are: IPV4_ONLY, IPV4_IPV6. If not specified, IPV4_ONLY will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stackType")]
		public NetworkInterfaceStackType StackType { get; set; }
		
		/// <summary>
		/// The list of VPN interfaces associated with this VPN gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnInterfaces")]
		public VpnGatewayVpnGatewayInterface[] VpnInterfaces { get; set; }
	}
	
	/// <summary>
	/// A VPN gateway interface.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnGatewayVpnGatewayInterface
	{
		
		/// <summary>
		/// [Output Only] Numeric identifier for this VPN interface associated with the VPN gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.UInt32> Id { get; set; }
		
		/// <summary>
		/// URL of the VLAN attachment (interconnectAttachment) resource for this VPN gateway interface. When the value of this field is present, the VPN gateway is used for HA VPN over Cloud Interconnect; all egress or ingress traffic for this VPN gateway interface goes through the specified VLAN attachment resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="interconnectAttachment")]
		public string InterconnectAttachment { get; set; }
		
		/// <summary>
		/// [Output Only] IP address for this VPN interface associated with the VPN gateway. The IP address could be either a regional external IP address or a regional internal IP address. The two IP addresses for a VPN gateway must be all regional external or regional internal IP addresses. There cannot be a mix of regional external IP addresses and regional internal IP addresses. For HA VPN over Cloud Interconnect, the IP addresses for both interfaces could either be regional internal IP addresses or regional external IP addresses. For regular (non HA VPN over Cloud Interconnect) HA VPN tunnels, the IP address must be a regional external IP address.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipAddress")]
		public string IpAddress { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnGatewayAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of VpnGateway resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, VpnGatewaysScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#vpnGateway for VPN gateways.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#vpnGatewayAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#vpnGatewayAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public VpnGatewayAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnGatewaysScopedList
	{
		
		/// <summary>
		/// [Output Only] A list of VPN gateways contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnGateways")]
		public VpnGateway[] VpnGateways { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning which replaces the list of addresses when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public VpnGatewaysScopedListWarning Warning { get; set; }
	}
	
	public class VpnGatewaysScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VpnGatewaysScopedListWarningData[] VpnGatewaysScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class VpnGatewaysScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class VpnGatewayAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VpnGatewayAggregatedListWarningData[] VpnGatewayAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class VpnGatewayAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of VpnGateway resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnGatewayList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of VpnGateway resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public VpnGateway[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#vpnGateway for VPN gateways.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#vpnGatewayList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#vpnGatewayList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public VpnGatewayListWarning Warning { get; set; }
	}
	
	public class VpnGatewayListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VpnGatewayListWarningData[] VpnGatewayListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class VpnGatewayListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnGatewayStatus
	{
		
		/// <summary>
		/// List of VPN connection for this VpnGateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnConnections")]
		public VpnGatewayStatusVpnConnection[] VpnConnections { get; set; }
	}
	
	/// <summary>
	/// A VPN connection contains all VPN tunnels connected from this VpnGateway to the same peer gateway. The peer gateway could either be an external VPN gateway or a Google Cloud VPN gateway.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnGatewayStatusVpnConnection
	{
		
		/// <summary>
		/// URL reference to the peer external VPN gateways to which the VPN tunnels in this VPN connection are connected. This field is mutually exclusive with peer_gcp_gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerExternalGateway")]
		public string PeerExternalGateway { get; set; }
		
		/// <summary>
		/// URL reference to the peer side VPN gateways to which the VPN tunnels in this VPN connection are connected. This field is mutually exclusive with peer_gcp_gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerGcpGateway")]
		public string PeerGcpGateway { get; set; }
		
		/// <summary>
		/// Describes the high availability requirement state for the VPN connection between this Cloud VPN gateway and a peer gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public VpnGatewayStatusHighAvailabilityRequirementState State { get; set; }
		
		/// <summary>
		/// List of VPN tunnels that are in this VPN connection.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tunnels")]
		public VpnGatewayStatusTunnel[] Tunnels { get; set; }
	}
	
	/// <summary>
	/// Describes the high availability requirement state for the VPN connection between this Cloud VPN gateway and a peer gateway.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnGatewayStatusHighAvailabilityRequirementState
	{
		
		/// <summary>
		/// Indicates the high availability requirement state for the VPN connection. Valid values are CONNECTION_REDUNDANCY_MET, CONNECTION_REDUNDANCY_NOT_MET.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<VpnGatewayStatusHighAvailabilityRequirementStateState> State { get; set; }
		
		/// <summary>
		/// Indicates the reason why the VPN connection does not meet the high availability redundancy criteria/requirement. Valid values is INCOMPLETE_TUNNELS_COVERAGE.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unsatisfiedReason")]
		public System.Nullable<VpnGatewayStatusHighAvailabilityRequirementStateUnsatisfiedReason> UnsatisfiedReason { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VpnGatewayStatusHighAvailabilityRequirementStateState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECTION_REDUNDANCY_MET = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONNECTION_REDUNDANCY_NOT_MET = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VpnGatewayStatusHighAvailabilityRequirementStateUnsatisfiedReason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCOMPLETE_TUNNELS_COVERAGE = 0,
	}
	
	/// <summary>
	/// Contains some information about a VPN tunnel.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnGatewayStatusTunnel
	{
		
		/// <summary>
		/// The VPN gateway interface this VPN tunnel is associated with.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localGatewayInterface")]
		public System.Nullable<System.UInt32> LocalGatewayInterface { get; set; }
		
		/// <summary>
		/// The peer gateway interface this VPN tunnel is connected to, the peer gateway could either be an external VPN gateway or a Google Cloud VPN gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerGatewayInterface")]
		public System.Nullable<System.UInt32> PeerGatewayInterface { get; set; }
		
		/// <summary>
		/// URL reference to the VPN tunnel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tunnelUrl")]
		public string TunnelUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnGatewaysGetStatusResponse
	{
		
		[System.Runtime.Serialization.DataMember(Name="result")]
		public VpnGatewayStatus Result { get; set; }
	}
	
	/// <summary>
	/// Represents a Cloud VPN Tunnel resource. For more information about VPN, read the the Cloud VPN Overview.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnTunnel
	{
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// An optional description of this resource. Provide this property when you create the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] Detailed status message for the VPN tunnel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="detailedStatus")]
		public string DetailedStatus { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// IKE protocol version to use when establishing the VPN tunnel with the peer VPN gateway. Acceptable IKE versions are 1 or 2. The default version is 2.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ikeVersion")]
		public System.Nullable<System.Int32> IkeVersion { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#vpnTunnel")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#vpnTunnel";
		
		/// <summary>
		/// A fingerprint for the labels being applied to this VpnTunnel, which is essentially a hash of the labels set used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve a VpnTunnel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// Labels for this resource. These can only be added or modified by the setLabels method. Each label key/value pair must comply with RFC1035. Label values may be empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Local traffic selector to use when establishing the VPN tunnel with the peer VPN gateway. The value should be a CIDR formatted string, for example: 192.168.0.0/16. The ranges must be disjoint. Only IPv4 is supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localTrafficSelector")]
		public string[] LocalTrafficSelector { get; set; }
		
		/// <summary>
		/// Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
		/// Pattern: [a-z](?:[-a-z0-9]{0,61}[a-z0-9])?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		[System.ComponentModel.DataAnnotations.RegularExpressionAttribute(@"[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?")]
		public string Name { get; set; }
		
		/// <summary>
		/// URL of the peer side external VPN gateway to which this VPN tunnel is connected. Provided by the client when the VPN tunnel is created. This field is exclusive with the field peerGcpGateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerExternalGateway")]
		public string PeerExternalGateway { get; set; }
		
		/// <summary>
		/// The interface ID of the external VPN gateway to which this VPN tunnel is connected. Provided by the client when the VPN tunnel is created. Possible values are: `0`, `1`, `2`, `3`. The number of IDs in use depends on the external VPN gateway redundancy type.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerExternalGatewayInterface")]
		public System.Nullable<System.Int32> PeerExternalGatewayInterface { get; set; }
		
		/// <summary>
		/// URL of the peer side HA VPN gateway to which this VPN tunnel is connected. Provided by the client when the VPN tunnel is created. This field can be used when creating highly available VPN from VPC network to VPC network, the field is exclusive with the field peerExternalGateway. If provided, the VPN tunnel will automatically use the same vpnGatewayInterface ID in the peer Google Cloud VPN gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerGcpGateway")]
		public string PeerGcpGateway { get; set; }
		
		/// <summary>
		/// IP address of the peer VPN gateway. Only IPv4 is supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="peerIp")]
		public string PeerIp { get; set; }
		
		/// <summary>
		/// [Output Only] URL of the region where the VPN tunnel resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// Remote traffic selectors to use when establishing the VPN tunnel with the peer VPN gateway. The value should be a CIDR formatted string, for example: 192.168.0.0/16. The ranges should be disjoint. Only IPv4 is supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="remoteTrafficSelector")]
		public string[] RemoteTrafficSelector { get; set; }
		
		/// <summary>
		/// URL of the router resource to be used for dynamic routing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="router")]
		public string Router { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// Shared secret used to set the secure session between the Cloud VPN gateway and the peer VPN gateway.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharedSecret")]
		public string SharedSecret { get; set; }
		
		/// <summary>
		/// Hash of the shared secret.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sharedSecretHash")]
		public string SharedSecretHash { get; set; }
		
		/// <summary>
		/// [Output Only] The status of the VPN tunnel, which can be one of the following: - PROVISIONING: Resource is being allocated for the VPN tunnel. - WAITING_FOR_FULL_CONFIG: Waiting to receive all VPN-related configs from the user. Network, TargetVpnGateway, VpnTunnel, ForwardingRule, and Route resources are needed to setup the VPN tunnel. - FIRST_HANDSHAKE: Successful first handshake with the peer VPN. - ESTABLISHED: Secure session is successfully established with the peer VPN. - NETWORK_ERROR: Deprecated, replaced by NO_INCOMING_PACKETS - AUTHORIZATION_ERROR: Auth error (for example, bad shared secret). - NEGOTIATION_FAILURE: Handshake failed. - DEPROVISIONING: Resources are being deallocated for the VPN tunnel. - FAILED: Tunnel creation has failed and the tunnel is not ready to be used. - NO_INCOMING_PACKETS: No incoming packets from peer. - REJECTED: Tunnel configuration was rejected, can be result of being denied access. - ALLOCATING_RESOURCES: Cloud VPN is in the process of allocating all required resources. - STOPPED: Tunnel is stopped due to its Forwarding Rules being deleted for Classic VPN tunnels or the project is in frozen state. - PEER_IDENTITY_MISMATCH: Peer identity does not match peer IP, probably behind NAT. - TS_NARROWING_NOT_ALLOWED: Traffic selector narrowing not allowed for an HA-VPN tunnel. 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<VpnTunnelStatus> Status { get; set; }
		
		/// <summary>
		/// URL of the Target VPN gateway with which this VPN tunnel is associated. Provided by the client when the VPN tunnel is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetVpnGateway")]
		public string TargetVpnGateway { get; set; }
		
		/// <summary>
		/// URL of the VPN gateway with which this VPN tunnel is associated. Provided by the client when the VPN tunnel is created. This must be used (instead of target_vpn_gateway) if a High Availability VPN gateway resource is created.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnGateway")]
		public string VpnGateway { get; set; }
		
		/// <summary>
		/// The interface ID of the VPN gateway with which this VPN tunnel is associated. Possible values are: `0`, `1`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnGatewayInterface")]
		public System.Nullable<System.Int32> VpnGatewayInterface { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum VpnTunnelStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALLOCATING_RESOURCES = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTHORIZATION_ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEPROVISIONING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ESTABLISHED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIRST_HANDSHAKE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NEGOTIATION_FAILURE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NETWORK_ERROR = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_INCOMING_PACKETS = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROVISIONING = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REJECTED = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STOPPED = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WAITING_FOR_FULL_CONFIG = 12,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnTunnelAggregatedList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of VpnTunnelsScopedList resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public System.Collections.Generic.Dictionary<string, VpnTunnelsScopedList> Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#vpnTunnelAggregatedList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#vpnTunnelAggregatedList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Unreachable resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachables")]
		public string[] Unreachables { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public VpnTunnelAggregatedListWarning Warning { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnTunnelsScopedList
	{
		
		/// <summary>
		/// A list of VPN tunnels contained in this scope.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vpnTunnels")]
		public VpnTunnel[] VpnTunnels { get; set; }
		
		/// <summary>
		/// Informational warning which replaces the list of addresses when the list is empty.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public VpnTunnelsScopedListWarning Warning { get; set; }
	}
	
	public class VpnTunnelsScopedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VpnTunnelsScopedListWarningData[] VpnTunnelsScopedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class VpnTunnelsScopedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	public class VpnTunnelAggregatedListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VpnTunnelAggregatedListWarningData[] VpnTunnelAggregatedListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class VpnTunnelAggregatedListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Contains a list of VpnTunnel resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpnTunnelList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of VpnTunnel resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public VpnTunnel[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#vpnTunnel for VPN tunnels.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#vpnTunnelList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#vpnTunnelList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public VpnTunnelListWarning Warning { get; set; }
	}
	
	public class VpnTunnelListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public VpnTunnelListWarningData[] VpnTunnelListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class VpnTunnelListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class XpnHostList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] A list of shared VPC host project URLs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Project[] Items { get; set; }
		
		/// <summary>
		/// [Output Only] Type of resource. Always compute#xpnHostList for lists of shared VPC hosts.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#xpnHostList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#xpnHostList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public XpnHostListWarning Warning { get; set; }
	}
	
	public class XpnHostListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public XpnHostListWarningData[] XpnHostListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class XpnHostListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Represents a Zone resource. A zone is a deployment area. These deployment areas are subsets of a region. For example the zone us-east1-a is located in the us-east1 region. For more information, read Regions and Zones.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Zone
	{
		
		/// <summary>
		/// [Output Only] Available cpu/platform selections for the zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="availableCpuPlatforms")]
		public string[] AvailableCpuPlatforms { get; set; }
		
		/// <summary>
		/// [Output Only] Creation timestamp in RFC3339 text format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="creationTimestamp")]
		public string CreationTimestamp { get; set; }
		
		/// <summary>
		/// Deprecation status for a public resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deprecated")]
		public DeprecationStatus Deprecated { get; set; }
		
		/// <summary>
		/// [Output Only] Textual description of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// [Output Only] Type of the resource. Always compute#zone for zones.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#zone")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#zone";
		
		/// <summary>
		/// [Output Only] Name of the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// [Output Only] Full URL reference to the region which hosts the zone.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for the resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Status of the zone, either UP or DOWN.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public RegionStatus Status { get; set; }
		
		/// <summary>
		/// [Output Only] Reserved for future use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="supportsPzs")]
		public System.Nullable<System.Boolean> SupportsPzs { get; set; }
	}
	
	/// <summary>
	/// Contains a list of zone resources.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ZoneList
	{
		
		/// <summary>
		/// [Output Only] Unique identifier for the resource; defined by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A list of Zone resources.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="items")]
		public Zone[] Items { get; set; }
		
		/// <summary>
		/// Type of resource.
		/// </summary>
		[System.ComponentModel.DefaultValue("compute#zoneList")]
		[System.Runtime.Serialization.DataMember(Name="kind")]
		public string Kind { get; set; } = "compute#zoneList";
		
		/// <summary>
		/// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// [Output Only] Server-defined URL for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selfLink")]
		public string SelfLink { get; set; }
		
		/// <summary>
		/// [Output Only] Informational warning message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="warning")]
		public ZoneListWarning Warning { get; set; }
	}
	
	public class ZoneListWarning
	{
		
		/// <summary>
		/// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public AcceleratorTypesScopedListWarningCode Code { get; set; }
		
		/// <summary>
		/// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" } 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public ZoneListWarningData[] ZoneListWarningData { get; set; }
		
		/// <summary>
		/// [Output Only] A human-readable description of the warning code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	public class ZoneListWarningData
	{
		
		/// <summary>
		/// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// [Output Only] A warning data value corresponding to the key.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ZoneSetLabelsRequest
	{
		
		/// <summary>
		/// The fingerprint of the previous set of labels for this resource, used to detect conflicts. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels. Make a get() request to the resource to get the latest fingerprint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labelFingerprint")]
		public string LabelFingerprint { get; set; }
		
		/// <summary>
		/// The labels to set for this resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ZoneSetPolicyRequest
	{
		
		/// <summary>
		/// Flatten Policy to create a backwacd compatible wire-format. Deprecated. Use 'policy' to specify bindings.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindings")]
		public Binding[] Bindings { get; set; }
		
		/// <summary>
		/// Flatten Policy to create a backward compatible wire-format. Deprecated. Use 'policy' to specify the etag.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public Policy Policy { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists all the policies that have been configured for the specified folder or organization.
		/// Compute_firewallPolicies_list locations/global/firewallPolicies
		/// </summary>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="parentId">Parent ID for this request. The ID can be either be "folders/[FOLDER_ID]" if the parent is a folder or "organizations/[ORGANIZATION_ID]" if the parent is an organization.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicyList> Compute_firewallPolicies_listAsync(string filter, int maxResults, string orderBy, string pageToken, string parentId, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies?filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new policy in the specified project using the data included in the request.
		/// Compute_firewallPolicies_insert locations/global/firewallPolicies
		/// </summary>
		/// <param name="parentId">Parent ID for this request. The ID can be either be "folders/[FOLDER_ID]" if the parent is a folder or "organizations/[ORGANIZATION_ID]" if the parent is an organization.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewallPolicies_insertAsync(string parentId, string requestId, FirewallPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies?parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists associations of a specified target, i.e., organization or folder.
		/// Compute_firewallPolicies_listAssociations locations/global/firewallPolicies/listAssociations
		/// </summary>
		/// <param name="targetResource">The target resource to list associations. It is an organization, or a folder.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPoliciesListAssociationsResponse> Compute_firewallPolicies_listAssociationsAsync(string targetResource, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/listAssociations?targetResource=" + (targetResource==null? "" : System.Uri.EscapeDataString(targetResource));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPoliciesListAssociationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified policy.
		/// Compute_firewallPolicies_delete locations/global/firewallPolicies/{firewallPolicy}
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewallPolicies_deleteAsync(string firewallPolicy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified firewall policy.
		/// Compute_firewallPolicies_get locations/global/firewallPolicies/{firewallPolicy}
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to get.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicy> Compute_firewallPolicies_getAsync(string firewallPolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified policy with the data included in the request.
		/// Compute_firewallPolicies_patch locations/global/firewallPolicies/{firewallPolicy}
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewallPolicies_patchAsync(string firewallPolicy, string requestId, FirewallPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts an association for the specified firewall policy.
		/// Compute_firewallPolicies_addAssociation locations/global/firewallPolicies/{firewallPolicy}/addAssociation
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="replaceExistingAssociation">Indicates whether or not to replace it if an association of the attachment already exists. This is false by default, in which case an error will be returned if an association already exists.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewallPolicies_addAssociationAsync(string firewallPolicy, bool replaceExistingAssociation, string requestId, FirewallPolicyAssociation requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/addAssociation&replaceExistingAssociation="+replaceExistingAssociation+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts a rule into a firewall policy.
		/// Compute_firewallPolicies_addRule locations/global/firewallPolicies/{firewallPolicy}/addRule
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewallPolicies_addRuleAsync(string firewallPolicy, string requestId, FirewallPolicyRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/addRule&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Copies rules to the specified firewall policy.
		/// Compute_firewallPolicies_cloneRules locations/global/firewallPolicies/{firewallPolicy}/cloneRules
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="sourceFirewallPolicy">The firewall policy from which to copy rules.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewallPolicies_cloneRulesAsync(string firewallPolicy, string requestId, string sourceFirewallPolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/cloneRules&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&sourceFirewallPolicy=" + (sourceFirewallPolicy==null? "" : System.Uri.EscapeDataString(sourceFirewallPolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an association with the specified name.
		/// Compute_firewallPolicies_getAssociation locations/global/firewallPolicies/{firewallPolicy}/getAssociation
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to which the queried rule belongs.</param>
		/// <param name="name">The name of the association to get from the firewall policy.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicyAssociation> Compute_firewallPolicies_getAssociationAsync(string firewallPolicy, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/getAssociation&name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicyAssociation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a rule of the specified priority.
		/// Compute_firewallPolicies_getRule locations/global/firewallPolicies/{firewallPolicy}/getRule
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to which the queried rule belongs.</param>
		/// <param name="priority">The priority of the rule to get from the firewall policy.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicyRule> Compute_firewallPolicies_getRuleAsync(string firewallPolicy, int priority, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/getRule&priority="+priority;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicyRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Moves the specified firewall policy.
		/// Compute_firewallPolicies_move locations/global/firewallPolicies/{firewallPolicy}/move
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="parentId">The new parent of the firewall policy. The ID can be either be "folders/[FOLDER_ID]" if the parent is a folder or "organizations/[ORGANIZATION_ID]" if the parent is an organization.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewallPolicies_moveAsync(string firewallPolicy, string parentId, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/move&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches a rule of the specified priority.
		/// Compute_firewallPolicies_patchRule locations/global/firewallPolicies/{firewallPolicy}/patchRule
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="priority">The priority of the rule to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewallPolicies_patchRuleAsync(string firewallPolicy, int priority, string requestId, FirewallPolicyRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/patchRule&priority="+priority+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes an association for the specified firewall policy.
		/// Compute_firewallPolicies_removeAssociation locations/global/firewallPolicies/{firewallPolicy}/removeAssociation
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="name">Name for the attachment that will be removed.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewallPolicies_removeAssociationAsync(string firewallPolicy, string name, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/removeAssociation&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a rule of the specified priority.
		/// Compute_firewallPolicies_removeRule locations/global/firewallPolicies/{firewallPolicy}/removeRule
		/// </summary>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="priority">The priority of the rule to remove from the firewall policy.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewallPolicies_removeRuleAsync(string firewallPolicy, int priority, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/removeRule&priority="+priority+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_firewallPolicies_getIamPolicy locations/global/firewallPolicies/{resource}/getIamPolicy
		/// </summary>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_firewallPolicies_getIamPolicyAsync(string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_firewallPolicies_setIamPolicy locations/global/firewallPolicies/{resource}/setIamPolicy
		/// </summary>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_firewallPolicies_setIamPolicyAsync(string resource, GlobalOrganizationSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_firewallPolicies_testIamPermissions locations/global/firewallPolicies/{resource}/testIamPermissions
		/// </summary>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_firewallPolicies_testIamPermissionsAsync(string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/firewallPolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of Operation resources contained within the specified organization.
		/// Compute_globalOrganizationOperations_list locations/global/operations
		/// </summary>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="parentId">Parent ID for this request.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<OperationList> Compute_globalOrganizationOperations_listAsync(string filter, int maxResults, string orderBy, string pageToken, string parentId, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/operations?filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OperationList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified Operations resource.
		/// Compute_globalOrganizationOperations_delete locations/global/operations/{operation}
		/// </summary>
		/// <param name="operation">Name of the Operations resource to delete.</param>
		/// <param name="parentId">Parent ID for this request.</param>
		/// <returns>Successful response</returns>
		public async Task Compute_globalOrganizationOperations_deleteAsync(string operation, string parentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the specified Operations resource. Gets a list of operations by making a `list()` request.
		/// Compute_globalOrganizationOperations_get locations/global/operations/{operation}
		/// </summary>
		/// <param name="operation">Name of the Operations resource to return.</param>
		/// <param name="parentId">Parent ID for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalOrganizationOperations_getAsync(string operation, string parentId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "locations/global/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation))+"&parentId=" + (parentId==null? "" : System.Uri.EscapeDataString(parentId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified Project resource. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is especially recommended for unused quota information (the `quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need. For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request.
		/// Compute_projects_get projects/{project}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Project> Compute_projects_getAsync(string project, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of accelerator types.
		/// Compute_acceleratorTypes_aggregatedList projects/{project}/aggregated/acceleratorTypes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<AcceleratorTypeAggregatedList> Compute_acceleratorTypes_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/acceleratorTypes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AcceleratorTypeAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of addresses.
		/// Compute_addresses_aggregatedList projects/{project}/aggregated/addresses
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<AddressAggregatedList> Compute_addresses_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/addresses&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AddressAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of autoscalers.
		/// Compute_autoscalers_aggregatedList projects/{project}/aggregated/autoscalers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<AutoscalerAggregatedList> Compute_autoscalers_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/autoscalers&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AutoscalerAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all BackendService resources, regional and global, available to the specified project.
		/// Compute_backendServices_aggregatedList projects/{project}/aggregated/backendServices
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendServiceAggregatedList> Compute_backendServices_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/backendServices&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendServiceAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of commitments by region.
		/// Compute_regionCommitments_aggregatedList projects/{project}/aggregated/commitments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<CommitmentAggregatedList> Compute_regionCommitments_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/commitments&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CommitmentAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of disk types.
		/// Compute_diskTypes_aggregatedList projects/{project}/aggregated/diskTypes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<DiskTypeAggregatedList> Compute_diskTypes_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/diskTypes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DiskTypeAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of persistent disks.
		/// Compute_disks_aggregatedList projects/{project}/aggregated/disks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<DiskAggregatedList> Compute_disks_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/disks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DiskAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of forwarding rules.
		/// Compute_forwardingRules_aggregatedList projects/{project}/aggregated/forwardingRules
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ForwardingRuleAggregatedList> Compute_forwardingRules_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/forwardingRules&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ForwardingRuleAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all HealthCheck resources, regional and global, available to the specified project.
		/// Compute_healthChecks_aggregatedList projects/{project}/aggregated/healthChecks
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<HealthChecksAggregatedList> Compute_healthChecks_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/healthChecks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HealthChecksAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of managed instance groups and groups them by zone.
		/// Compute_instanceGroupManagers_aggregatedList projects/{project}/aggregated/instanceGroupManagers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroupManagerAggregatedList> Compute_instanceGroupManagers_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/instanceGroupManagers&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroupManagerAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of instance groups and sorts them by zone.
		/// Compute_instanceGroups_aggregatedList projects/{project}/aggregated/instanceGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroupAggregatedList> Compute_instanceGroups_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/instanceGroups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroupAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all InstanceTemplates resources, regional and global, available to the specified project.
		/// Compute_instanceTemplates_aggregatedList projects/{project}/aggregated/instanceTemplates
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceTemplateAggregatedList> Compute_instanceTemplates_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/instanceTemplates&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceTemplateAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of all of the instances in your project across all regions and zones. The performance of this method degrades when a filter is specified on a project that has a very large number of instances.
		/// Compute_instances_aggregatedList projects/{project}/aggregated/instances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceAggregatedList> Compute_instances_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/instances&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of interconnect attachments.
		/// Compute_interconnectAttachments_aggregatedList projects/{project}/aggregated/interconnectAttachments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InterconnectAttachmentAggregatedList> Compute_interconnectAttachments_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/interconnectAttachments&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InterconnectAttachmentAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of machine types.
		/// Compute_machineTypes_aggregatedList projects/{project}/aggregated/machineTypes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<MachineTypeAggregatedList> Compute_machineTypes_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/machineTypes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MachineTypeAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all NetworkAttachment resources, regional and global, available to the specified project.
		/// Compute_networkAttachments_aggregatedList projects/{project}/aggregated/networkAttachments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkAttachmentAggregatedList> Compute_networkAttachments_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/networkAttachments&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkAttachmentAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all NetworkEdgeSecurityService resources available to the specified project.
		/// Compute_networkEdgeSecurityServices_aggregatedList projects/{project}/aggregated/networkEdgeSecurityServices
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEdgeSecurityServiceAggregatedList> Compute_networkEdgeSecurityServices_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/networkEdgeSecurityServices&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEdgeSecurityServiceAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of network endpoint groups and sorts them by zone.
		/// Compute_networkEndpointGroups_aggregatedList projects/{project}/aggregated/networkEndpointGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEndpointGroupAggregatedList> Compute_networkEndpointGroups_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/networkEndpointGroups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEndpointGroupAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of node groups. Note: use nodeGroups.listNodes for more details about each group.
		/// Compute_nodeGroups_aggregatedList projects/{project}/aggregated/nodeGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NodeGroupAggregatedList> Compute_nodeGroups_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/nodeGroups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeGroupAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of node templates.
		/// Compute_nodeTemplates_aggregatedList projects/{project}/aggregated/nodeTemplates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NodeTemplateAggregatedList> Compute_nodeTemplates_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/nodeTemplates&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeTemplateAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of node types.
		/// Compute_nodeTypes_aggregatedList projects/{project}/aggregated/nodeTypes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NodeTypeAggregatedList> Compute_nodeTypes_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/nodeTypes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeTypeAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of all operations.
		/// Compute_globalOperations_aggregatedList projects/{project}/aggregated/operations
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<OperationAggregatedList> Compute_globalOperations_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/operations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OperationAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of packetMirrorings.
		/// Compute_packetMirrorings_aggregatedList projects/{project}/aggregated/packetMirrorings
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<PacketMirroringAggregatedList> Compute_packetMirrorings_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/packetMirrorings&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PacketMirroringAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all PublicDelegatedPrefix resources owned by the specific project across all scopes.
		/// Compute_publicDelegatedPrefixes_aggregatedList projects/{project}/aggregated/publicDelegatedPrefixes
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<PublicDelegatedPrefixAggregatedList> Compute_publicDelegatedPrefixes_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/publicDelegatedPrefixes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PublicDelegatedPrefixAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of reservations.
		/// Compute_reservations_aggregatedList projects/{project}/aggregated/reservations
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ReservationAggregatedList> Compute_reservations_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/reservations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReservationAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of resource policies.
		/// Compute_resourcePolicies_aggregatedList projects/{project}/aggregated/resourcePolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ResourcePolicyAggregatedList> Compute_resourcePolicies_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/resourcePolicies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourcePolicyAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of routers.
		/// Compute_routers_aggregatedList projects/{project}/aggregated/routers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RouterAggregatedList> Compute_routers_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/routers&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RouterAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all SecurityPolicy resources, regional and global, available to the specified project.
		/// Compute_securityPolicies_aggregatedList projects/{project}/aggregated/securityPolicies
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SecurityPoliciesAggregatedList> Compute_securityPolicies_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/securityPolicies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SecurityPoliciesAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all ServiceAttachment resources, regional and global, available to the specified project.
		/// Compute_serviceAttachments_aggregatedList projects/{project}/aggregated/serviceAttachments
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ServiceAttachmentAggregatedList> Compute_serviceAttachments_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/serviceAttachments&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ServiceAttachmentAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all SslCertificate resources, regional and global, available to the specified project.
		/// Compute_sslCertificates_aggregatedList projects/{project}/aggregated/sslCertificates
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SslCertificateAggregatedList> Compute_sslCertificates_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/sslCertificates&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslCertificateAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all SslPolicy resources, regional and global, available to the specified project.
		/// Compute_sslPolicies_aggregatedList projects/{project}/aggregated/sslPolicies
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SslPoliciesAggregatedList> Compute_sslPolicies_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/sslPolicies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslPoliciesAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of subnetworks.
		/// Compute_subnetworks_aggregatedList projects/{project}/aggregated/subnetworks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SubnetworkAggregatedList> Compute_subnetworks_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/subnetworks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SubnetworkAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of all usable subnetworks in the project.
		/// Compute_subnetworks_listUsable projects/{project}/aggregated/subnetworks/listUsable
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<UsableSubnetworksAggregatedList> Compute_subnetworks_listUsableAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/subnetworks/listUsable&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UsableSubnetworksAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all TargetHttpProxy resources, regional and global, available to the specified project.
		/// Compute_targetHttpProxies_aggregatedList projects/{project}/aggregated/targetHttpProxies
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetHttpProxyAggregatedList> Compute_targetHttpProxies_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/targetHttpProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetHttpProxyAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all TargetHttpsProxy resources, regional and global, available to the specified project.
		/// Compute_targetHttpsProxies_aggregatedList projects/{project}/aggregated/targetHttpsProxies
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetHttpsProxyAggregatedList> Compute_targetHttpsProxies_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/targetHttpsProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetHttpsProxyAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of target instances.
		/// Compute_targetInstances_aggregatedList projects/{project}/aggregated/targetInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetInstanceAggregatedList> Compute_targetInstances_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/targetInstances&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetInstanceAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of target pools.
		/// Compute_targetPools_aggregatedList projects/{project}/aggregated/targetPools
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetPoolAggregatedList> Compute_targetPools_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/targetPools&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetPoolAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all TargetTcpProxy resources, regional and global, available to the specified project.
		/// Compute_targetTcpProxies_aggregatedList projects/{project}/aggregated/targetTcpProxies
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetTcpProxyAggregatedList> Compute_targetTcpProxies_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/targetTcpProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetTcpProxyAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of target VPN gateways.
		/// Compute_targetVpnGateways_aggregatedList projects/{project}/aggregated/targetVpnGateways
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetVpnGatewayAggregatedList> Compute_targetVpnGateways_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/targetVpnGateways&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetVpnGatewayAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of all UrlMap resources, regional and global, available to the specified project.
		/// Compute_urlMaps_aggregatedList projects/{project}/aggregated/urlMaps
		/// </summary>
		/// <param name="project">Name of the project scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<UrlMapsAggregatedList> Compute_urlMaps_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/urlMaps&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UrlMapsAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of VPN gateways.
		/// Compute_vpnGateways_aggregatedList projects/{project}/aggregated/vpnGateways
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<VpnGatewayAggregatedList> Compute_vpnGateways_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/vpnGateways&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VpnGatewayAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of VPN tunnels.
		/// Compute_vpnTunnels_aggregatedList projects/{project}/aggregated/vpnTunnels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="includeAllScopes">Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<VpnTunnelAggregatedList> Compute_vpnTunnels_aggregatedListAsync(string project, string filter, bool includeAllScopes, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, string serviceProjectNumber, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/aggregated/vpnTunnels&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&includeAllScopes="+includeAllScopes+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess+"&serviceProjectNumber=" + (serviceProjectNumber==null? "" : System.Uri.EscapeDataString(serviceProjectNumber));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VpnTunnelAggregatedList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable this project as a shared VPC host project.
		/// Compute_projects_disableXpnHost projects/{project}/disableXpnHost
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_projects_disableXpnHostAsync(string project, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/disableXpnHost&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Disable a service resource (also known as service project) associated with this host project.
		/// Compute_projects_disableXpnResource projects/{project}/disableXpnResource
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_projects_disableXpnResourceAsync(string project, string requestId, ProjectsDisableXpnResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/disableXpnResource&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Enable this project as a shared VPC host project.
		/// Compute_projects_enableXpnHost projects/{project}/enableXpnHost
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_projects_enableXpnHostAsync(string project, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/enableXpnHost&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Enable service resource (a.k.a service project) for a host project, so that subnets in the host project can be used by instances in the service project.
		/// Compute_projects_enableXpnResource projects/{project}/enableXpnResource
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_projects_enableXpnResourceAsync(string project, string requestId, ProjectsEnableXpnResourceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/enableXpnResource&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the shared VPC host project that this project links to. May be empty if no link exists.
		/// Compute_projects_getXpnHost projects/{project}/getXpnHost
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Project> Compute_projects_getXpnHostAsync(string project, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/getXpnHost";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Project>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets service resources (a.k.a service project) associated with this host project.
		/// Compute_projects_getXpnResources projects/{project}/getXpnResources
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ProjectsGetXpnResources> Compute_projects_getXpnResourcesAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/getXpnResources&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ProjectsGetXpnResources>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of global addresses.
		/// Compute_globalAddresses_list projects/{project}/global/addresses
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<AddressList> Compute_globalAddresses_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/addresses&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AddressList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an address resource in the specified project by using the data included in the request.
		/// Compute_globalAddresses_insert projects/{project}/global/addresses
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalAddresses_insertAsync(string project, string requestId, Address requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/addresses&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified address resource.
		/// Compute_globalAddresses_delete projects/{project}/global/addresses/{address}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="address">Name of the address resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalAddresses_deleteAsync(string project, string address, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/addresses/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified address resource.
		/// Compute_globalAddresses_get projects/{project}/global/addresses/{address}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="address">Name of the address resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Address> Compute_globalAddresses_getAsync(string project, string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/addresses/"+ (address==null? "" : System.Uri.EscapeDataString(address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Address>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Moves the specified address resource from one project to another project.
		/// Compute_globalAddresses_move projects/{project}/global/addresses/{address}/move
		/// </summary>
		/// <param name="project">Source project ID which the Address is moved from.</param>
		/// <param name="address">Name of the address resource to move.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalAddresses_moveAsync(string project, string address, string requestId, GlobalAddressesMoveRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/addresses/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/move&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on a GlobalAddress. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_globalAddresses_setLabels projects/{project}/global/addresses/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalAddresses_setLabelsAsync(string project, string resource, GlobalSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/addresses/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of BackendBucket resources available to the specified project.
		/// Compute_backendBuckets_list projects/{project}/global/backendBuckets
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendBucketList> Compute_backendBuckets_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendBucketList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a BackendBucket resource in the specified project using the data included in the request.
		/// Compute_backendBuckets_insert projects/{project}/global/backendBuckets
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendBuckets_insertAsync(string project, string requestId, BackendBucket requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified BackendBucket resource.
		/// Compute_backendBuckets_delete projects/{project}/global/backendBuckets/{backendBucket}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendBucket">Name of the BackendBucket resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendBuckets_deleteAsync(string project, string backendBucket, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets/"+ (backendBucket==null? "" : System.Uri.EscapeDataString(backendBucket))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified BackendBucket resource.
		/// Compute_backendBuckets_get projects/{project}/global/backendBuckets/{backendBucket}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendBucket">Name of the BackendBucket resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendBucket> Compute_backendBuckets_getAsync(string project, string backendBucket, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets/"+ (backendBucket==null? "" : System.Uri.EscapeDataString(backendBucket));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendBucket>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified BackendBucket resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_backendBuckets_patch projects/{project}/global/backendBuckets/{backendBucket}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendBucket">Name of the BackendBucket resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendBuckets_patchAsync(string project, string backendBucket, string requestId, BackendBucket requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets/"+ (backendBucket==null? "" : System.Uri.EscapeDataString(backendBucket))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the specified BackendBucket resource with the data included in the request.
		/// Compute_backendBuckets_update projects/{project}/global/backendBuckets/{backendBucket}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendBucket">Name of the BackendBucket resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendBuckets_updateAsync(string project, string backendBucket, string requestId, BackendBucket requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets/"+ (backendBucket==null? "" : System.Uri.EscapeDataString(backendBucket))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds a key for validating requests with signed URLs for this backend bucket.
		/// Compute_backendBuckets_addSignedUrlKey projects/{project}/global/backendBuckets/{backendBucket}/addSignedUrlKey
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendBucket">Name of the BackendBucket resource to which the Signed URL Key should be added. The name should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendBuckets_addSignedUrlKeyAsync(string project, string backendBucket, string requestId, SignedUrlKey requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets/"+ (backendBucket==null? "" : System.Uri.EscapeDataString(backendBucket))+"/addSignedUrlKey&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a key for validating requests with signed URLs for this backend bucket.
		/// Compute_backendBuckets_deleteSignedUrlKey projects/{project}/global/backendBuckets/{backendBucket}/deleteSignedUrlKey
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendBucket">Name of the BackendBucket resource to which the Signed URL Key should be added. The name should conform to RFC1035.</param>
		/// <param name="keyName">The name of the Signed URL Key to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendBuckets_deleteSignedUrlKeyAsync(string project, string backendBucket, string keyName, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets/"+ (backendBucket==null? "" : System.Uri.EscapeDataString(backendBucket))+"/deleteSignedUrlKey&keyName=" + (keyName==null? "" : System.Uri.EscapeDataString(keyName))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the edge security policy for the specified backend bucket.
		/// Compute_backendBuckets_setEdgeSecurityPolicy projects/{project}/global/backendBuckets/{backendBucket}/setEdgeSecurityPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendBucket">Name of the BackendBucket resource to which the security policy should be set. The name should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendBuckets_setEdgeSecurityPolicyAsync(string project, string backendBucket, string requestId, SecurityPolicyReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets/"+ (backendBucket==null? "" : System.Uri.EscapeDataString(backendBucket))+"/setEdgeSecurityPolicy&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_backendBuckets_getIamPolicy projects/{project}/global/backendBuckets/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_backendBuckets_getIamPolicyAsync(string project, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_backendBuckets_setIamPolicy projects/{project}/global/backendBuckets/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_backendBuckets_setIamPolicyAsync(string project, string resource, GlobalSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_backendBuckets_testIamPermissions projects/{project}/global/backendBuckets/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_backendBuckets_testIamPermissionsAsync(string project, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendBuckets/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of BackendService resources available to the specified project.
		/// Compute_backendServices_list projects/{project}/global/backendServices
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendServiceList> Compute_backendServices_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendServiceList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a BackendService resource in the specified project using the data included in the request. For more information, see Backend services overview .
		/// Compute_backendServices_insert projects/{project}/global/backendServices
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendServices_insertAsync(string project, string requestId, BackendService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of all usable backend services in the specified project.
		/// Compute_backendServices_listUsable projects/{project}/global/backendServices/listUsable
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendServiceListUsable> Compute_backendServices_listUsableAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/listUsable&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendServiceListUsable>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified BackendService resource.
		/// Compute_backendServices_delete projects/{project}/global/backendServices/{backendService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendService">Name of the BackendService resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendServices_deleteAsync(string project, string backendService, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified BackendService resource.
		/// Compute_backendServices_get projects/{project}/global/backendServices/{backendService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendService">Name of the BackendService resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendService> Compute_backendServices_getAsync(string project, string backendService, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendService>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified BackendService resource with the data included in the request. For more information, see Backend services overview. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_backendServices_patch projects/{project}/global/backendServices/{backendService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendService">Name of the BackendService resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendServices_patchAsync(string project, string backendService, string requestId, BackendService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the specified BackendService resource with the data included in the request. For more information, see Backend services overview.
		/// Compute_backendServices_update projects/{project}/global/backendServices/{backendService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendService">Name of the BackendService resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendServices_updateAsync(string project, string backendService, string requestId, BackendService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds a key for validating requests with signed URLs for this backend service.
		/// Compute_backendServices_addSignedUrlKey projects/{project}/global/backendServices/{backendService}/addSignedUrlKey
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendService">Name of the BackendService resource to which the Signed URL Key should be added. The name should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendServices_addSignedUrlKeyAsync(string project, string backendService, string requestId, SignedUrlKey requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"/addSignedUrlKey&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a key for validating requests with signed URLs for this backend service.
		/// Compute_backendServices_deleteSignedUrlKey projects/{project}/global/backendServices/{backendService}/deleteSignedUrlKey
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendService">Name of the BackendService resource to which the Signed URL Key should be added. The name should conform to RFC1035.</param>
		/// <param name="keyName">The name of the Signed URL Key to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendServices_deleteSignedUrlKeyAsync(string project, string backendService, string keyName, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"/deleteSignedUrlKey&keyName=" + (keyName==null? "" : System.Uri.EscapeDataString(keyName))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the most recent health check results for this BackendService. Example request body: { "group": "/zones/us-east1-b/instanceGroups/lb-backend-example" }
		/// Compute_backendServices_getHealth projects/{project}/global/backendServices/{backendService}/getHealth
		/// </summary>
		/// <param name="backendService">Name of the BackendService resource to which the queried instance belongs.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendServiceGroupHealth> Compute_backendServices_getHealthAsync(string project, string backendService, ResourceGroupReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"/getHealth";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendServiceGroupHealth>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the edge security policy for the specified backend service.
		/// Compute_backendServices_setEdgeSecurityPolicy projects/{project}/global/backendServices/{backendService}/setEdgeSecurityPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendService">Name of the BackendService resource to which the edge security policy should be set. The name should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendServices_setEdgeSecurityPolicyAsync(string project, string backendService, string requestId, SecurityPolicyReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"/setEdgeSecurityPolicy&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the Google Cloud Armor security policy for the specified backend service. For more information, see Google Cloud Armor Overview
		/// Compute_backendServices_setSecurityPolicy projects/{project}/global/backendServices/{backendService}/setSecurityPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="backendService">Name of the BackendService resource to which the security policy should be set. The name should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_backendServices_setSecurityPolicyAsync(string project, string backendService, string requestId, SecurityPolicyReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"/setSecurityPolicy&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_backendServices_getIamPolicy projects/{project}/global/backendServices/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_backendServices_getIamPolicyAsync(string project, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_backendServices_setIamPolicy projects/{project}/global/backendServices/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_backendServices_setIamPolicyAsync(string project, string resource, GlobalSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_backendServices_testIamPermissions projects/{project}/global/backendServices/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_backendServices_testIamPermissionsAsync(string project, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/backendServices/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of ExternalVpnGateway available to the specified project.
		/// Compute_externalVpnGateways_list projects/{project}/global/externalVpnGateways
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ExternalVpnGatewayList> Compute_externalVpnGateways_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/externalVpnGateways&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExternalVpnGatewayList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a ExternalVpnGateway in the specified project using the data included in the request.
		/// Compute_externalVpnGateways_insert projects/{project}/global/externalVpnGateways
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_externalVpnGateways_insertAsync(string project, string requestId, ExternalVpnGateway requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/externalVpnGateways&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified externalVpnGateway.
		/// Compute_externalVpnGateways_delete projects/{project}/global/externalVpnGateways/{externalVpnGateway}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="externalVpnGateway">Name of the externalVpnGateways to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_externalVpnGateways_deleteAsync(string project, string externalVpnGateway, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/externalVpnGateways/"+ (externalVpnGateway==null? "" : System.Uri.EscapeDataString(externalVpnGateway))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified externalVpnGateway. Get a list of available externalVpnGateways by making a list() request.
		/// Compute_externalVpnGateways_get projects/{project}/global/externalVpnGateways/{externalVpnGateway}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="externalVpnGateway">Name of the externalVpnGateway to return.</param>
		/// <returns>Successful response</returns>
		public async Task<ExternalVpnGateway> Compute_externalVpnGateways_getAsync(string project, string externalVpnGateway, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/externalVpnGateways/"+ (externalVpnGateway==null? "" : System.Uri.EscapeDataString(externalVpnGateway));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExternalVpnGateway>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on an ExternalVpnGateway. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_externalVpnGateways_setLabels projects/{project}/global/externalVpnGateways/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_externalVpnGateways_setLabelsAsync(string project, string resource, GlobalSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/externalVpnGateways/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_externalVpnGateways_testIamPermissions projects/{project}/global/externalVpnGateways/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_externalVpnGateways_testIamPermissionsAsync(string project, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/externalVpnGateways/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all the policies that have been configured for the specified project.
		/// Compute_networkFirewallPolicies_list projects/{project}/global/firewallPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicyList> Compute_networkFirewallPolicies_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new policy in the specified project using the data included in the request.
		/// Compute_networkFirewallPolicies_insert projects/{project}/global/firewallPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkFirewallPolicies_insertAsync(string project, string requestId, FirewallPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified policy.
		/// Compute_networkFirewallPolicies_delete projects/{project}/global/firewallPolicies/{firewallPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkFirewallPolicies_deleteAsync(string project, string firewallPolicy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified network firewall policy.
		/// Compute_networkFirewallPolicies_get projects/{project}/global/firewallPolicies/{firewallPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to get.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicy> Compute_networkFirewallPolicies_getAsync(string project, string firewallPolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified policy with the data included in the request.
		/// Compute_networkFirewallPolicies_patch projects/{project}/global/firewallPolicies/{firewallPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkFirewallPolicies_patchAsync(string project, string firewallPolicy, string requestId, FirewallPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts an association for the specified firewall policy.
		/// Compute_networkFirewallPolicies_addAssociation projects/{project}/global/firewallPolicies/{firewallPolicy}/addAssociation
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="replaceExistingAssociation">Indicates whether or not to replace it if an association of the attachment already exists. This is false by default, in which case an error will be returned if an association already exists.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkFirewallPolicies_addAssociationAsync(string project, string firewallPolicy, bool replaceExistingAssociation, string requestId, FirewallPolicyAssociation requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/addAssociation&replaceExistingAssociation="+replaceExistingAssociation+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts a rule into a firewall policy.
		/// Compute_networkFirewallPolicies_addRule projects/{project}/global/firewallPolicies/{firewallPolicy}/addRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="maxPriority">When rule.priority is not specified, auto choose a unused priority between minPriority and maxPriority>. This field is exclusive with rule.priority.</param>
		/// <param name="minPriority">When rule.priority is not specified, auto choose a unused priority between minPriority and maxPriority>. This field is exclusive with rule.priority.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkFirewallPolicies_addRuleAsync(string project, string firewallPolicy, int maxPriority, int minPriority, string requestId, FirewallPolicyRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/addRule&maxPriority="+maxPriority+"&minPriority="+minPriority+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Copies rules to the specified firewall policy.
		/// Compute_networkFirewallPolicies_cloneRules projects/{project}/global/firewallPolicies/{firewallPolicy}/cloneRules
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="sourceFirewallPolicy">The firewall policy from which to copy rules.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkFirewallPolicies_cloneRulesAsync(string project, string firewallPolicy, string requestId, string sourceFirewallPolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/cloneRules&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&sourceFirewallPolicy=" + (sourceFirewallPolicy==null? "" : System.Uri.EscapeDataString(sourceFirewallPolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an association with the specified name.
		/// Compute_networkFirewallPolicies_getAssociation projects/{project}/global/firewallPolicies/{firewallPolicy}/getAssociation
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to which the queried association belongs.</param>
		/// <param name="name">The name of the association to get from the firewall policy.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicyAssociation> Compute_networkFirewallPolicies_getAssociationAsync(string project, string firewallPolicy, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/getAssociation&name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicyAssociation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a rule of the specified priority.
		/// Compute_networkFirewallPolicies_getRule projects/{project}/global/firewallPolicies/{firewallPolicy}/getRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to which the queried rule belongs.</param>
		/// <param name="priority">The priority of the rule to get from the firewall policy.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicyRule> Compute_networkFirewallPolicies_getRuleAsync(string project, string firewallPolicy, int priority, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/getRule&priority="+priority;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicyRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches a rule of the specified priority.
		/// Compute_networkFirewallPolicies_patchRule projects/{project}/global/firewallPolicies/{firewallPolicy}/patchRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="priority">The priority of the rule to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkFirewallPolicies_patchRuleAsync(string project, string firewallPolicy, int priority, string requestId, FirewallPolicyRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/patchRule&priority="+priority+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes an association for the specified firewall policy.
		/// Compute_networkFirewallPolicies_removeAssociation projects/{project}/global/firewallPolicies/{firewallPolicy}/removeAssociation
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="name">Name for the attachment that will be removed.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkFirewallPolicies_removeAssociationAsync(string project, string firewallPolicy, string name, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/removeAssociation&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a rule of the specified priority.
		/// Compute_networkFirewallPolicies_removeRule projects/{project}/global/firewallPolicies/{firewallPolicy}/removeRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="priority">The priority of the rule to remove from the firewall policy.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkFirewallPolicies_removeRuleAsync(string project, string firewallPolicy, int priority, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/removeRule&priority="+priority+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_networkFirewallPolicies_getIamPolicy projects/{project}/global/firewallPolicies/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_networkFirewallPolicies_getIamPolicyAsync(string project, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_networkFirewallPolicies_setIamPolicy projects/{project}/global/firewallPolicies/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_networkFirewallPolicies_setIamPolicyAsync(string project, string resource, GlobalSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_networkFirewallPolicies_testIamPermissions projects/{project}/global/firewallPolicies/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_networkFirewallPolicies_testIamPermissionsAsync(string project, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewallPolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of firewall rules available to the specified project.
		/// Compute_firewalls_list projects/{project}/global/firewalls
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallList> Compute_firewalls_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewalls&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a firewall rule in the specified project using the data included in the request.
		/// Compute_firewalls_insert projects/{project}/global/firewalls
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewalls_insertAsync(string project, string requestId, Firewall requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewalls&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified firewall.
		/// Compute_firewalls_delete projects/{project}/global/firewalls/{firewall}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewall">Name of the firewall rule to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewalls_deleteAsync(string project, string firewall, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewalls/"+ (firewall==null? "" : System.Uri.EscapeDataString(firewall))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified firewall.
		/// Compute_firewalls_get projects/{project}/global/firewalls/{firewall}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewall">Name of the firewall rule to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Firewall> Compute_firewalls_getAsync(string project, string firewall, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewalls/"+ (firewall==null? "" : System.Uri.EscapeDataString(firewall));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Firewall>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified firewall rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_firewalls_patch projects/{project}/global/firewalls/{firewall}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewall">Name of the firewall rule to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewalls_patchAsync(string project, string firewall, string requestId, Firewall requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewalls/"+ (firewall==null? "" : System.Uri.EscapeDataString(firewall))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the specified firewall rule with the data included in the request. Note that all fields will be updated if using PUT, even fields that are not specified. To update individual fields, please use PATCH instead.
		/// Compute_firewalls_update projects/{project}/global/firewalls/{firewall}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="firewall">Name of the firewall rule to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_firewalls_updateAsync(string project, string firewall, string requestId, Firewall requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/firewalls/"+ (firewall==null? "" : System.Uri.EscapeDataString(firewall))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of GlobalForwardingRule resources available to the specified project.
		/// Compute_globalForwardingRules_list projects/{project}/global/forwardingRules
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ForwardingRuleList> Compute_globalForwardingRules_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/forwardingRules&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ForwardingRuleList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a GlobalForwardingRule resource in the specified project using the data included in the request.
		/// Compute_globalForwardingRules_insert projects/{project}/global/forwardingRules
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalForwardingRules_insertAsync(string project, string requestId, ForwardingRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/forwardingRules&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified GlobalForwardingRule resource.
		/// Compute_globalForwardingRules_delete projects/{project}/global/forwardingRules/{forwardingRule}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="forwardingRule">Name of the ForwardingRule resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalForwardingRules_deleteAsync(string project, string forwardingRule, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/forwardingRules/"+ (forwardingRule==null? "" : System.Uri.EscapeDataString(forwardingRule))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified GlobalForwardingRule resource. Gets a list of available forwarding rules by making a list() request.
		/// Compute_globalForwardingRules_get projects/{project}/global/forwardingRules/{forwardingRule}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="forwardingRule">Name of the ForwardingRule resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<ForwardingRule> Compute_globalForwardingRules_getAsync(string project, string forwardingRule, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/forwardingRules/"+ (forwardingRule==null? "" : System.Uri.EscapeDataString(forwardingRule));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ForwardingRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified forwarding rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. Currently, you can only patch the network_tier field.
		/// Compute_globalForwardingRules_patch projects/{project}/global/forwardingRules/{forwardingRule}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="forwardingRule">Name of the ForwardingRule resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalForwardingRules_patchAsync(string project, string forwardingRule, string requestId, ForwardingRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/forwardingRules/"+ (forwardingRule==null? "" : System.Uri.EscapeDataString(forwardingRule))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes target URL for the GlobalForwardingRule resource. The new target should be of the same type as the old target.
		/// Compute_globalForwardingRules_setTarget projects/{project}/global/forwardingRules/{forwardingRule}/setTarget
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="forwardingRule">Name of the ForwardingRule resource in which target is to be set.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalForwardingRules_setTargetAsync(string project, string forwardingRule, string requestId, TargetReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/forwardingRules/"+ (forwardingRule==null? "" : System.Uri.EscapeDataString(forwardingRule))+"/setTarget&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on the specified resource. To learn more about labels, read the Labeling resources documentation.
		/// Compute_globalForwardingRules_setLabels projects/{project}/global/forwardingRules/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalForwardingRules_setLabelsAsync(string project, string resource, GlobalSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/forwardingRules/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of HealthCheck resources available to the specified project.
		/// Compute_healthChecks_list projects/{project}/global/healthChecks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<HealthCheckList> Compute_healthChecks_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/healthChecks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HealthCheckList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a HealthCheck resource in the specified project using the data included in the request.
		/// Compute_healthChecks_insert projects/{project}/global/healthChecks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_healthChecks_insertAsync(string project, string requestId, HealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/healthChecks&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified HealthCheck resource.
		/// Compute_healthChecks_delete projects/{project}/global/healthChecks/{healthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="healthCheck">Name of the HealthCheck resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_healthChecks_deleteAsync(string project, string healthCheck, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/healthChecks/"+ (healthCheck==null? "" : System.Uri.EscapeDataString(healthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified HealthCheck resource.
		/// Compute_healthChecks_get projects/{project}/global/healthChecks/{healthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="healthCheck">Name of the HealthCheck resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<HealthCheck> Compute_healthChecks_getAsync(string project, string healthCheck, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/healthChecks/"+ (healthCheck==null? "" : System.Uri.EscapeDataString(healthCheck));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HealthCheck>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a HealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_healthChecks_patch projects/{project}/global/healthChecks/{healthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="healthCheck">Name of the HealthCheck resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_healthChecks_patchAsync(string project, string healthCheck, string requestId, HealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/healthChecks/"+ (healthCheck==null? "" : System.Uri.EscapeDataString(healthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a HealthCheck resource in the specified project using the data included in the request.
		/// Compute_healthChecks_update projects/{project}/global/healthChecks/{healthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="healthCheck">Name of the HealthCheck resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_healthChecks_updateAsync(string project, string healthCheck, string requestId, HealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/healthChecks/"+ (healthCheck==null? "" : System.Uri.EscapeDataString(healthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of HttpHealthCheck resources available to the specified project.
		/// Compute_httpHealthChecks_list projects/{project}/global/httpHealthChecks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpHealthCheckList> Compute_httpHealthChecks_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpHealthChecks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HttpHealthCheckList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a HttpHealthCheck resource in the specified project using the data included in the request.
		/// Compute_httpHealthChecks_insert projects/{project}/global/httpHealthChecks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_httpHealthChecks_insertAsync(string project, string requestId, HttpHealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpHealthChecks&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified HttpHealthCheck resource.
		/// Compute_httpHealthChecks_delete projects/{project}/global/httpHealthChecks/{httpHealthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="httpHealthCheck">Name of the HttpHealthCheck resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_httpHealthChecks_deleteAsync(string project, string httpHealthCheck, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpHealthChecks/"+ (httpHealthCheck==null? "" : System.Uri.EscapeDataString(httpHealthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified HttpHealthCheck resource.
		/// Compute_httpHealthChecks_get projects/{project}/global/httpHealthChecks/{httpHealthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="httpHealthCheck">Name of the HttpHealthCheck resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpHealthCheck> Compute_httpHealthChecks_getAsync(string project, string httpHealthCheck, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpHealthChecks/"+ (httpHealthCheck==null? "" : System.Uri.EscapeDataString(httpHealthCheck));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HttpHealthCheck>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a HttpHealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_httpHealthChecks_patch projects/{project}/global/httpHealthChecks/{httpHealthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="httpHealthCheck">Name of the HttpHealthCheck resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_httpHealthChecks_patchAsync(string project, string httpHealthCheck, string requestId, HttpHealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpHealthChecks/"+ (httpHealthCheck==null? "" : System.Uri.EscapeDataString(httpHealthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a HttpHealthCheck resource in the specified project using the data included in the request.
		/// Compute_httpHealthChecks_update projects/{project}/global/httpHealthChecks/{httpHealthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="httpHealthCheck">Name of the HttpHealthCheck resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_httpHealthChecks_updateAsync(string project, string httpHealthCheck, string requestId, HttpHealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpHealthChecks/"+ (httpHealthCheck==null? "" : System.Uri.EscapeDataString(httpHealthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of HttpsHealthCheck resources available to the specified project.
		/// Compute_httpsHealthChecks_list projects/{project}/global/httpsHealthChecks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpsHealthCheckList> Compute_httpsHealthChecks_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpsHealthChecks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HttpsHealthCheckList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a HttpsHealthCheck resource in the specified project using the data included in the request.
		/// Compute_httpsHealthChecks_insert projects/{project}/global/httpsHealthChecks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_httpsHealthChecks_insertAsync(string project, string requestId, HttpsHealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpsHealthChecks&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified HttpsHealthCheck resource.
		/// Compute_httpsHealthChecks_delete projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="httpsHealthCheck">Name of the HttpsHealthCheck resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_httpsHealthChecks_deleteAsync(string project, string httpsHealthCheck, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpsHealthChecks/"+ (httpsHealthCheck==null? "" : System.Uri.EscapeDataString(httpsHealthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified HttpsHealthCheck resource.
		/// Compute_httpsHealthChecks_get projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="httpsHealthCheck">Name of the HttpsHealthCheck resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<HttpsHealthCheck> Compute_httpsHealthChecks_getAsync(string project, string httpsHealthCheck, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpsHealthChecks/"+ (httpsHealthCheck==null? "" : System.Uri.EscapeDataString(httpsHealthCheck));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HttpsHealthCheck>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a HttpsHealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_httpsHealthChecks_patch projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="httpsHealthCheck">Name of the HttpsHealthCheck resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_httpsHealthChecks_patchAsync(string project, string httpsHealthCheck, string requestId, HttpsHealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpsHealthChecks/"+ (httpsHealthCheck==null? "" : System.Uri.EscapeDataString(httpsHealthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a HttpsHealthCheck resource in the specified project using the data included in the request.
		/// Compute_httpsHealthChecks_update projects/{project}/global/httpsHealthChecks/{httpsHealthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="httpsHealthCheck">Name of the HttpsHealthCheck resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_httpsHealthChecks_updateAsync(string project, string httpsHealthCheck, string requestId, HttpsHealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/httpsHealthChecks/"+ (httpsHealthCheck==null? "" : System.Uri.EscapeDataString(httpsHealthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of custom images available to the specified project. Custom images are images you create that belong to your project. This method does not get any images that belong to other projects, including publicly-available images, like Debian 8. If you want to get a list of publicly-available images, use this method to make a request to the respective image project, such as debian-cloud or windows-cloud.
		/// Compute_images_list projects/{project}/global/images
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ImageList> Compute_images_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an image in the specified project using the data included in the request.
		/// Compute_images_insert projects/{project}/global/images
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="forceCreate">Force image creation if true.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_images_insertAsync(string project, bool forceCreate, string requestId, Image requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images&forceCreate="+forceCreate+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the latest image that is part of an image family and is not deprecated. For more information on image families, see Public image families documentation.
		/// Compute_images_getFromFamily projects/{project}/global/images/family/{family}
		/// </summary>
		/// <param name="project">The image project that the image belongs to. For example, to get a CentOS image, specify centos-cloud as the image project.</param>
		/// <param name="family">Name of the image family to search for.</param>
		/// <returns>Successful response</returns>
		public async Task<Image> Compute_images_getFromFamilyAsync(string project, string family, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images/family/"+ (family==null? "" : System.Uri.EscapeDataString(family));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Image>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified image.
		/// Compute_images_delete projects/{project}/global/images/{image}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="image">Name of the image resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_images_deleteAsync(string project, string image, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images/"+ (image==null? "" : System.Uri.EscapeDataString(image))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified image.
		/// Compute_images_get projects/{project}/global/images/{image}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="image">Name of the image resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Image> Compute_images_getAsync(string project, string image, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images/"+ (image==null? "" : System.Uri.EscapeDataString(image));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Image>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified image with the data included in the request. Only the following fields can be modified: family, description, deprecation status.
		/// Compute_images_patch projects/{project}/global/images/{image}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="image">Name of the image resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_images_patchAsync(string project, string image, string requestId, Image requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images/"+ (image==null? "" : System.Uri.EscapeDataString(image))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the deprecation status of an image. If an empty request body is given, clears the deprecation status instead.
		/// Compute_images_deprecate projects/{project}/global/images/{image}/deprecate
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="image">Image name.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_images_deprecateAsync(string project, string image, string requestId, DeprecationStatus requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images/"+ (image==null? "" : System.Uri.EscapeDataString(image))+"/deprecate&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_images_getIamPolicy projects/{project}/global/images/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_images_getIamPolicyAsync(string project, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_images_setIamPolicy projects/{project}/global/images/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_images_setIamPolicyAsync(string project, string resource, GlobalSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on an image. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_images_setLabels projects/{project}/global/images/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_images_setLabelsAsync(string project, string resource, GlobalSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_images_testIamPermissions projects/{project}/global/images/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_images_testIamPermissionsAsync(string project, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/images/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of instance templates that are contained within the specified project.
		/// Compute_instanceTemplates_list projects/{project}/global/instanceTemplates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceTemplateList> Compute_instanceTemplates_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/instanceTemplates&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceTemplateList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an instance template in the specified project using the data that is included in the request. If you are creating a new template to update an existing instance group, your new instance template must use the same network or, if applicable, the same subnetwork as the original template.
		/// Compute_instanceTemplates_insert projects/{project}/global/instanceTemplates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceTemplates_insertAsync(string project, string requestId, InstanceTemplate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/instanceTemplates&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified instance template. Deleting an instance template is permanent and cannot be undone. It is not possible to delete templates that are already in use by a managed instance group.
		/// Compute_instanceTemplates_delete projects/{project}/global/instanceTemplates/{instanceTemplate}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="instanceTemplate">The name of the instance template to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceTemplates_deleteAsync(string project, string instanceTemplate, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/instanceTemplates/"+ (instanceTemplate==null? "" : System.Uri.EscapeDataString(instanceTemplate))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified instance template.
		/// Compute_instanceTemplates_get projects/{project}/global/instanceTemplates/{instanceTemplate}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="instanceTemplate">The name of the instance template.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceTemplate> Compute_instanceTemplates_getAsync(string project, string instanceTemplate, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/instanceTemplates/"+ (instanceTemplate==null? "" : System.Uri.EscapeDataString(instanceTemplate));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceTemplate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_instanceTemplates_getIamPolicy projects/{project}/global/instanceTemplates/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_instanceTemplates_getIamPolicyAsync(string project, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/instanceTemplates/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_instanceTemplates_setIamPolicy projects/{project}/global/instanceTemplates/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_instanceTemplates_setIamPolicyAsync(string project, string resource, GlobalSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/instanceTemplates/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_instanceTemplates_testIamPermissions projects/{project}/global/instanceTemplates/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_instanceTemplates_testIamPermissionsAsync(string project, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/instanceTemplates/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of interconnect locations available to the specified project.
		/// Compute_interconnectLocations_list projects/{project}/global/interconnectLocations
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InterconnectLocationList> Compute_interconnectLocations_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnectLocations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InterconnectLocationList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the details for the specified interconnect location. Gets a list of available interconnect locations by making a list() request.
		/// Compute_interconnectLocations_get projects/{project}/global/interconnectLocations/{interconnectLocation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="interconnectLocation">Name of the interconnect location to return.</param>
		/// <returns>Successful response</returns>
		public async Task<InterconnectLocation> Compute_interconnectLocations_getAsync(string project, string interconnectLocation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnectLocations/"+ (interconnectLocation==null? "" : System.Uri.EscapeDataString(interconnectLocation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InterconnectLocation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of interconnect remote locations available to the specified project.
		/// Compute_interconnectRemoteLocations_list projects/{project}/global/interconnectRemoteLocations
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InterconnectRemoteLocationList> Compute_interconnectRemoteLocations_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnectRemoteLocations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InterconnectRemoteLocationList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the details for the specified interconnect remote location. Gets a list of available interconnect remote locations by making a list() request.
		/// Compute_interconnectRemoteLocations_get projects/{project}/global/interconnectRemoteLocations/{interconnectRemoteLocation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="interconnectRemoteLocation">Name of the interconnect remote location to return.</param>
		/// <returns>Successful response</returns>
		public async Task<InterconnectRemoteLocation> Compute_interconnectRemoteLocations_getAsync(string project, string interconnectRemoteLocation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnectRemoteLocations/"+ (interconnectRemoteLocation==null? "" : System.Uri.EscapeDataString(interconnectRemoteLocation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InterconnectRemoteLocation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of Interconnects available to the specified project.
		/// Compute_interconnects_list projects/{project}/global/interconnects
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InterconnectList> Compute_interconnects_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnects&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InterconnectList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an Interconnect in the specified project using the data included in the request.
		/// Compute_interconnects_insert projects/{project}/global/interconnects
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_interconnects_insertAsync(string project, string requestId, Interconnect requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnects&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified Interconnect.
		/// Compute_interconnects_delete projects/{project}/global/interconnects/{interconnect}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="interconnect">Name of the interconnect to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_interconnects_deleteAsync(string project, string interconnect, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnects/"+ (interconnect==null? "" : System.Uri.EscapeDataString(interconnect))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified Interconnect. Get a list of available Interconnects by making a list() request.
		/// Compute_interconnects_get projects/{project}/global/interconnects/{interconnect}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="interconnect">Name of the interconnect to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Interconnect> Compute_interconnects_getAsync(string project, string interconnect, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnects/"+ (interconnect==null? "" : System.Uri.EscapeDataString(interconnect));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Interconnect>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified Interconnect with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_interconnects_patch projects/{project}/global/interconnects/{interconnect}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="interconnect">Name of the interconnect to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_interconnects_patchAsync(string project, string interconnect, string requestId, Interconnect requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnects/"+ (interconnect==null? "" : System.Uri.EscapeDataString(interconnect))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the interconnectDiagnostics for the specified Interconnect. In the event of a global outage, do not use this API to make decisions about where to redirect your network traffic. Unlike a VLAN attachment, which is regional, a Cloud Interconnect connection is a global resource. A global outage can prevent this API from functioning properly.
		/// Compute_interconnects_getDiagnostics projects/{project}/global/interconnects/{interconnect}/getDiagnostics
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="interconnect">Name of the interconnect resource to query.</param>
		/// <returns>Successful response</returns>
		public async Task<InterconnectsGetDiagnosticsResponse> Compute_interconnects_getDiagnosticsAsync(string project, string interconnect, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnects/"+ (interconnect==null? "" : System.Uri.EscapeDataString(interconnect))+"/getDiagnostics";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InterconnectsGetDiagnosticsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the interconnectMacsecConfig for the specified Interconnect.
		/// Compute_interconnects_getMacsecConfig projects/{project}/global/interconnects/{interconnect}/getMacsecConfig
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="interconnect">Name of the interconnect resource to query.</param>
		/// <returns>Successful response</returns>
		public async Task<InterconnectsGetMacsecConfigResponse> Compute_interconnects_getMacsecConfigAsync(string project, string interconnect, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnects/"+ (interconnect==null? "" : System.Uri.EscapeDataString(interconnect))+"/getMacsecConfig";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InterconnectsGetMacsecConfigResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on an Interconnect. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_interconnects_setLabels projects/{project}/global/interconnects/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_interconnects_setLabelsAsync(string project, string resource, GlobalSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/interconnects/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Return a specified license code. License codes are mirrored across all projects that have permissions to read the License Code. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
		/// Compute_licenseCodes_get projects/{project}/global/licenseCodes/{licenseCode}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="licenseCode">Number corresponding to the License code resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<LicenseCode> Compute_licenseCodes_getAsync(string project, string licenseCode, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/licenseCodes/"+ (licenseCode==null? "" : System.Uri.EscapeDataString(licenseCode));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LicenseCode>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
		/// Compute_licenseCodes_testIamPermissions projects/{project}/global/licenseCodes/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_licenseCodes_testIamPermissionsAsync(string project, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/licenseCodes/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of licenses available in the specified project. This method does not get any licenses that belong to other projects, including licenses attached to publicly-available images, like Debian 9. If you want to get a list of publicly-available licenses, use this method to make a request to the respective image project, such as debian-cloud or windows-cloud. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
		/// Compute_licenses_list projects/{project}/global/licenses
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<LicensesListResponse> Compute_licenses_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/licenses&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<LicensesListResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a License resource in the specified project. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
		/// Compute_licenses_insert projects/{project}/global/licenses
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_licenses_insertAsync(string project, string requestId, License requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/licenses&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified license. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
		/// Compute_licenses_delete projects/{project}/global/licenses/{license}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="license">Name of the license resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_licenses_deleteAsync(string project, string license, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/licenses/"+ (license==null? "" : System.Uri.EscapeDataString(license))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified License resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
		/// Compute_licenses_get projects/{project}/global/licenses/{license}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="license">Name of the License resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<License> Compute_licenses_getAsync(string project, string license, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/licenses/"+ (license==null? "" : System.Uri.EscapeDataString(license));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<License>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
		/// Compute_licenses_getIamPolicy projects/{project}/global/licenses/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_licenses_getIamPolicyAsync(string project, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/licenses/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
		/// Compute_licenses_setIamPolicy projects/{project}/global/licenses/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_licenses_setIamPolicyAsync(string project, string resource, GlobalSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/licenses/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
		/// Compute_licenses_testIamPermissions projects/{project}/global/licenses/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_licenses_testIamPermissionsAsync(string project, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/licenses/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of machine images that are contained within the specified project.
		/// Compute_machineImages_list projects/{project}/global/machineImages
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<MachineImageList> Compute_machineImages_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/machineImages&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MachineImageList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a machine image in the specified project using the data that is included in the request. If you are creating a new machine image to update an existing instance, your new machine image should use the same network or, if applicable, the same subnetwork as the original instance.
		/// Compute_machineImages_insert projects/{project}/global/machineImages
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="sourceInstance">Required. Source instance that is used to create the machine image from.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_machineImages_insertAsync(string project, string requestId, string sourceInstance, MachineImage requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/machineImages&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&sourceInstance=" + (sourceInstance==null? "" : System.Uri.EscapeDataString(sourceInstance));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified machine image. Deleting a machine image is permanent and cannot be undone.
		/// Compute_machineImages_delete projects/{project}/global/machineImages/{machineImage}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="machineImage">The name of the machine image to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_machineImages_deleteAsync(string project, string machineImage, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/machineImages/"+ (machineImage==null? "" : System.Uri.EscapeDataString(machineImage))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified machine image.
		/// Compute_machineImages_get projects/{project}/global/machineImages/{machineImage}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="machineImage">The name of the machine image.</param>
		/// <returns>Successful response</returns>
		public async Task<MachineImage> Compute_machineImages_getAsync(string project, string machineImage, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/machineImages/"+ (machineImage==null? "" : System.Uri.EscapeDataString(machineImage));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MachineImage>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_machineImages_getIamPolicy projects/{project}/global/machineImages/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_machineImages_getIamPolicyAsync(string project, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/machineImages/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_machineImages_setIamPolicy projects/{project}/global/machineImages/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_machineImages_setIamPolicyAsync(string project, string resource, GlobalSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/machineImages/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_machineImages_testIamPermissions projects/{project}/global/machineImages/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_machineImages_testIamPermissionsAsync(string project, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/machineImages/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of network endpoint groups that are located in the specified project.
		/// Compute_globalNetworkEndpointGroups_list projects/{project}/global/networkEndpointGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEndpointGroupList> Compute_globalNetworkEndpointGroups_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networkEndpointGroups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEndpointGroupList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a network endpoint group in the specified project using the parameters that are included in the request.
		/// Compute_globalNetworkEndpointGroups_insert projects/{project}/global/networkEndpointGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalNetworkEndpointGroups_insertAsync(string project, string requestId, NetworkEndpointGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networkEndpointGroups&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified network endpoint group.Note that the NEG cannot be deleted if there are backend services referencing it.
		/// Compute_globalNetworkEndpointGroups_delete projects/{project}/global/networkEndpointGroups/{networkEndpointGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group to delete. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalNetworkEndpointGroups_deleteAsync(string project, string networkEndpointGroup, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified network endpoint group.
		/// Compute_globalNetworkEndpointGroups_get projects/{project}/global/networkEndpointGroups/{networkEndpointGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group. It should comply with RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEndpointGroup> Compute_globalNetworkEndpointGroups_getAsync(string project, string networkEndpointGroup, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEndpointGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Attach a network endpoint to the specified network endpoint group.
		/// Compute_globalNetworkEndpointGroups_attachNetworkEndpoints projects/{project}/global/networkEndpointGroups/{networkEndpointGroup}/attachNetworkEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group where you are attaching network endpoints to. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalNetworkEndpointGroups_attachNetworkEndpointsAsync(string project, string networkEndpointGroup, string requestId, GlobalNetworkEndpointGroupsAttachEndpointsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"/attachNetworkEndpoints&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Detach the network endpoint from the specified network endpoint group.
		/// Compute_globalNetworkEndpointGroups_detachNetworkEndpoints projects/{project}/global/networkEndpointGroups/{networkEndpointGroup}/detachNetworkEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group where you are removing network endpoints. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalNetworkEndpointGroups_detachNetworkEndpointsAsync(string project, string networkEndpointGroup, string requestId, GlobalNetworkEndpointGroupsDetachEndpointsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"/detachNetworkEndpoints&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the network endpoints in the specified network endpoint group.
		/// Compute_globalNetworkEndpointGroups_listNetworkEndpoints projects/{project}/global/networkEndpointGroups/{networkEndpointGroup}/listNetworkEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group from which you want to generate a list of included network endpoints. It should comply with RFC1035.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEndpointGroupsListNetworkEndpoints> Compute_globalNetworkEndpointGroups_listNetworkEndpointsAsync(string project, string networkEndpointGroup, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"/listNetworkEndpoints&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEndpointGroupsListNetworkEndpoints>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of networks available to the specified project.
		/// Compute_networks_list projects/{project}/global/networks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkList> Compute_networks_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a network in the specified project using the data included in the request.
		/// Compute_networks_insert projects/{project}/global/networks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networks_insertAsync(string project, string requestId, Network requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified network.
		/// Compute_networks_delete projects/{project}/global/networks/{network}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="network">Name of the network to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networks_deleteAsync(string project, string network, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks/"+ (network==null? "" : System.Uri.EscapeDataString(network))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified network.
		/// Compute_networks_get projects/{project}/global/networks/{network}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="network">Name of the network to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Network> Compute_networks_getAsync(string project, string network, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks/"+ (network==null? "" : System.Uri.EscapeDataString(network));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Network>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified network with the data included in the request. Only the following fields can be modified: routingConfig.routingMode.
		/// Compute_networks_patch projects/{project}/global/networks/{network}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="network">Name of the network to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networks_patchAsync(string project, string network, string requestId, Network requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks/"+ (network==null? "" : System.Uri.EscapeDataString(network))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds a peering to the specified network.
		/// Compute_networks_addPeering projects/{project}/global/networks/{network}/addPeering
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="network">Name of the network resource to add peering to.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networks_addPeeringAsync(string project, string network, string requestId, NetworksAddPeeringRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks/"+ (network==null? "" : System.Uri.EscapeDataString(network))+"/addPeering&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the effective firewalls on a given network.
		/// Compute_networks_getEffectiveFirewalls projects/{project}/global/networks/{network}/getEffectiveFirewalls
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="network">Name of the network for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworksGetEffectiveFirewallsResponse> Compute_networks_getEffectiveFirewallsAsync(string project, string network, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks/"+ (network==null? "" : System.Uri.EscapeDataString(network))+"/getEffectiveFirewalls";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworksGetEffectiveFirewallsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the peering routes exchanged over peering connection.
		/// Compute_networks_listPeeringRoutes projects/{project}/global/networks/{network}/listPeeringRoutes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="network">Name of the network for this request.</param>
		/// <param name="direction">The direction of the exchanged routes.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="peeringName">The response will show routes exchanged over the given peering connection.</param>
		/// <param name="region">The region of the request. The response will include all subnet routes, static routes and dynamic routes in the region.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ExchangedPeeringRoutesList> Compute_networks_listPeeringRoutesAsync(string project, string network, Compute_networks_listPeeringRoutesDirection direction, string filter, int maxResults, string orderBy, string pageToken, string peeringName, string region, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks/"+ (network==null? "" : System.Uri.EscapeDataString(network))+"/listPeeringRoutes&direction=" + direction+"&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&peeringName=" + (peeringName==null? "" : System.Uri.EscapeDataString(peeringName))+"&region=" + (region==null? "" : System.Uri.EscapeDataString(region))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExchangedPeeringRoutesList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes a peering from the specified network.
		/// Compute_networks_removePeering projects/{project}/global/networks/{network}/removePeering
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="network">Name of the network resource to remove peering from.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networks_removePeeringAsync(string project, string network, string requestId, NetworksRemovePeeringRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks/"+ (network==null? "" : System.Uri.EscapeDataString(network))+"/removePeering&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Switches the network mode from auto subnet mode to custom subnet mode.
		/// Compute_networks_switchToCustomMode projects/{project}/global/networks/{network}/switchToCustomMode
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="network">Name of the network to be updated.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networks_switchToCustomModeAsync(string project, string network, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks/"+ (network==null? "" : System.Uri.EscapeDataString(network))+"/switchToCustomMode&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified network peering with the data included in the request. You can only modify the NetworkPeering.export_custom_routes field and the NetworkPeering.import_custom_routes field.
		/// Compute_networks_updatePeering projects/{project}/global/networks/{network}/updatePeering
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="network">Name of the network resource which the updated peering is belonging to.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networks_updatePeeringAsync(string project, string network, string requestId, NetworksUpdatePeeringRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/networks/"+ (network==null? "" : System.Uri.EscapeDataString(network))+"/updatePeering&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of Operation resources contained within the specified project.
		/// Compute_globalOperations_list projects/{project}/global/operations
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<OperationList> Compute_globalOperations_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/operations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OperationList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified Operations resource.
		/// Compute_globalOperations_delete projects/{project}/global/operations/{operation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="operation">Name of the Operations resource to delete.</param>
		/// <returns>Successful response</returns>
		public async Task Compute_globalOperations_deleteAsync(string project, string operation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the specified Operations resource.
		/// Compute_globalOperations_get projects/{project}/global/operations/{operation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="operation">Name of the Operations resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalOperations_getAsync(string project, string operation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method differs from the `GET` method in that it waits for no more than the default deadline (2 minutes) and then returns the current state of the operation, which might be `DONE` or still in progress. This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.
		/// Compute_globalOperations_wait projects/{project}/global/operations/{operation}/wait
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="operation">Name of the Operations resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalOperations_waitAsync(string project, string operation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation))+"/wait";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the PublicAdvertisedPrefixes for a project.
		/// Compute_publicAdvertisedPrefixes_list projects/{project}/global/publicAdvertisedPrefixes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<PublicAdvertisedPrefixList> Compute_publicAdvertisedPrefixes_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicAdvertisedPrefixes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PublicAdvertisedPrefixList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a PublicAdvertisedPrefix in the specified project using the parameters that are included in the request.
		/// Compute_publicAdvertisedPrefixes_insert projects/{project}/global/publicAdvertisedPrefixes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_publicAdvertisedPrefixes_insertAsync(string project, string requestId, PublicAdvertisedPrefix requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicAdvertisedPrefixes&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified PublicAdvertisedPrefix
		/// Compute_publicAdvertisedPrefixes_delete projects/{project}/global/publicAdvertisedPrefixes/{publicAdvertisedPrefix}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="publicAdvertisedPrefix">Name of the PublicAdvertisedPrefix resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_publicAdvertisedPrefixes_deleteAsync(string project, string publicAdvertisedPrefix, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicAdvertisedPrefixes/"+ (publicAdvertisedPrefix==null? "" : System.Uri.EscapeDataString(publicAdvertisedPrefix))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified PublicAdvertisedPrefix resource.
		/// Compute_publicAdvertisedPrefixes_get projects/{project}/global/publicAdvertisedPrefixes/{publicAdvertisedPrefix}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="publicAdvertisedPrefix">Name of the PublicAdvertisedPrefix resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<PublicAdvertisedPrefix> Compute_publicAdvertisedPrefixes_getAsync(string project, string publicAdvertisedPrefix, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicAdvertisedPrefixes/"+ (publicAdvertisedPrefix==null? "" : System.Uri.EscapeDataString(publicAdvertisedPrefix));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PublicAdvertisedPrefix>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified Router resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_publicAdvertisedPrefixes_patch projects/{project}/global/publicAdvertisedPrefixes/{publicAdvertisedPrefix}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="publicAdvertisedPrefix">Name of the PublicAdvertisedPrefix resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_publicAdvertisedPrefixes_patchAsync(string project, string publicAdvertisedPrefix, string requestId, PublicAdvertisedPrefix requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicAdvertisedPrefixes/"+ (publicAdvertisedPrefix==null? "" : System.Uri.EscapeDataString(publicAdvertisedPrefix))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Announces the specified PublicAdvertisedPrefix
		/// Compute_publicAdvertisedPrefixes_announce projects/{project}/global/publicAdvertisedPrefixes/{publicAdvertisedPrefix}/announce
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="publicAdvertisedPrefix">The name of the public advertised prefix. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_publicAdvertisedPrefixes_announceAsync(string project, string publicAdvertisedPrefix, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicAdvertisedPrefixes/"+ (publicAdvertisedPrefix==null? "" : System.Uri.EscapeDataString(publicAdvertisedPrefix))+"/announce&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Withdraws the specified PublicAdvertisedPrefix
		/// Compute_publicAdvertisedPrefixes_withdraw projects/{project}/global/publicAdvertisedPrefixes/{publicAdvertisedPrefix}/withdraw
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="publicAdvertisedPrefix">The name of the public advertised prefix. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_publicAdvertisedPrefixes_withdrawAsync(string project, string publicAdvertisedPrefix, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicAdvertisedPrefixes/"+ (publicAdvertisedPrefix==null? "" : System.Uri.EscapeDataString(publicAdvertisedPrefix))+"/withdraw&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the global PublicDelegatedPrefixes for a project.
		/// Compute_globalPublicDelegatedPrefixes_list projects/{project}/global/publicDelegatedPrefixes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<PublicDelegatedPrefixList> Compute_globalPublicDelegatedPrefixes_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicDelegatedPrefixes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PublicDelegatedPrefixList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a global PublicDelegatedPrefix in the specified project using the parameters that are included in the request.
		/// Compute_globalPublicDelegatedPrefixes_insert projects/{project}/global/publicDelegatedPrefixes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalPublicDelegatedPrefixes_insertAsync(string project, string requestId, PublicDelegatedPrefix requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicDelegatedPrefixes&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified global PublicDelegatedPrefix.
		/// Compute_globalPublicDelegatedPrefixes_delete projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="publicDelegatedPrefix">Name of the PublicDelegatedPrefix resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalPublicDelegatedPrefixes_deleteAsync(string project, string publicDelegatedPrefix, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicDelegatedPrefixes/"+ (publicDelegatedPrefix==null? "" : System.Uri.EscapeDataString(publicDelegatedPrefix))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified global PublicDelegatedPrefix resource.
		/// Compute_globalPublicDelegatedPrefixes_get projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="publicDelegatedPrefix">Name of the PublicDelegatedPrefix resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<PublicDelegatedPrefix> Compute_globalPublicDelegatedPrefixes_getAsync(string project, string publicDelegatedPrefix, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicDelegatedPrefixes/"+ (publicDelegatedPrefix==null? "" : System.Uri.EscapeDataString(publicDelegatedPrefix));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PublicDelegatedPrefix>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified global PublicDelegatedPrefix resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_globalPublicDelegatedPrefixes_patch projects/{project}/global/publicDelegatedPrefixes/{publicDelegatedPrefix}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="publicDelegatedPrefix">Name of the PublicDelegatedPrefix resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_globalPublicDelegatedPrefixes_patchAsync(string project, string publicDelegatedPrefix, string requestId, PublicDelegatedPrefix requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/publicDelegatedPrefixes/"+ (publicDelegatedPrefix==null? "" : System.Uri.EscapeDataString(publicDelegatedPrefix))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of Route resources available to the specified project.
		/// Compute_routes_list projects/{project}/global/routes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RouteList> Compute_routes_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/routes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RouteList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a Route resource in the specified project using the data included in the request.
		/// Compute_routes_insert projects/{project}/global/routes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_routes_insertAsync(string project, string requestId, Route requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/routes&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified Route resource.
		/// Compute_routes_delete projects/{project}/global/routes/{route}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="route">Name of the Route resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_routes_deleteAsync(string project, string route, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/routes/"+ (route==null? "" : System.Uri.EscapeDataString(route))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified Route resource.
		/// Compute_routes_get projects/{project}/global/routes/{route}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="route">Name of the Route resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Route> Compute_routes_getAsync(string project, string route, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/routes/"+ (route==null? "" : System.Uri.EscapeDataString(route));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Route>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all the policies that have been configured for the specified project.
		/// Compute_securityPolicies_list projects/{project}/global/securityPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SecurityPolicyList> Compute_securityPolicies_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SecurityPolicyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new policy in the specified project using the data included in the request.
		/// Compute_securityPolicies_insert projects/{project}/global/securityPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="validateOnly">If true, the request will not be committed.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_securityPolicies_insertAsync(string project, string requestId, bool validateOnly, SecurityPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the current list of preconfigured Web Application Firewall (WAF) expressions.
		/// Compute_securityPolicies_listPreconfiguredExpressionSets projects/{project}/global/securityPolicies/listPreconfiguredExpressionSets
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SecurityPoliciesListPreconfiguredExpressionSetsResponse> Compute_securityPolicies_listPreconfiguredExpressionSetsAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies/listPreconfiguredExpressionSets&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SecurityPoliciesListPreconfiguredExpressionSetsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on a security policy. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_securityPolicies_setLabels projects/{project}/global/securityPolicies/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_securityPolicies_setLabelsAsync(string project, string resource, GlobalSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified policy.
		/// Compute_securityPolicies_delete projects/{project}/global/securityPolicies/{securityPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="securityPolicy">Name of the security policy to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_securityPolicies_deleteAsync(string project, string securityPolicy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all of the ordered rules present in a single specified policy.
		/// Compute_securityPolicies_get projects/{project}/global/securityPolicies/{securityPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="securityPolicy">Name of the security policy to get.</param>
		/// <returns>Successful response</returns>
		public async Task<SecurityPolicy> Compute_securityPolicies_getAsync(string project, string securityPolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SecurityPolicy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified policy with the data included in the request. To clear fields in the policy, leave the fields empty and specify them in the updateMask. This cannot be used to be update the rules in the policy. Please use the per rule methods like addRule, patchRule, and removeRule instead.
		/// Compute_securityPolicies_patch projects/{project}/global/securityPolicies/{securityPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="securityPolicy">Name of the security policy to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">Indicates fields to be cleared as part of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_securityPolicies_patchAsync(string project, string securityPolicy, string requestId, string updateMask, SecurityPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts a rule into a security policy.
		/// Compute_securityPolicies_addRule projects/{project}/global/securityPolicies/{securityPolicy}/addRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="securityPolicy">Name of the security policy to update.</param>
		/// <param name="validateOnly">If true, the request will not be committed.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_securityPolicies_addRuleAsync(string project, string securityPolicy, bool validateOnly, SecurityPolicyRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"/addRule&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a rule at the specified priority.
		/// Compute_securityPolicies_getRule projects/{project}/global/securityPolicies/{securityPolicy}/getRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="securityPolicy">Name of the security policy to which the queried rule belongs.</param>
		/// <param name="priority">The priority of the rule to get from the security policy.</param>
		/// <returns>Successful response</returns>
		public async Task<SecurityPolicyRule> Compute_securityPolicies_getRuleAsync(string project, string securityPolicy, int priority, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"/getRule&priority="+priority;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SecurityPolicyRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches a rule at the specified priority. To clear fields in the rule, leave the fields empty and specify them in the updateMask.
		/// Compute_securityPolicies_patchRule projects/{project}/global/securityPolicies/{securityPolicy}/patchRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="securityPolicy">Name of the security policy to update.</param>
		/// <param name="priority">The priority of the rule to patch.</param>
		/// <param name="updateMask">Indicates fields to be cleared as part of this request.</param>
		/// <param name="validateOnly">If true, the request will not be committed.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_securityPolicies_patchRuleAsync(string project, string securityPolicy, int priority, string updateMask, bool validateOnly, SecurityPolicyRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"/patchRule&priority="+priority+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask))+"&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a rule at the specified priority.
		/// Compute_securityPolicies_removeRule projects/{project}/global/securityPolicies/{securityPolicy}/removeRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="securityPolicy">Name of the security policy to update.</param>
		/// <param name="priority">The priority of the rule to remove from the security policy.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_securityPolicies_removeRuleAsync(string project, string securityPolicy, int priority, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"/removeRule&priority="+priority;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get snapshot settings.
		/// Compute_snapshotSettings_get projects/{project}/global/snapshotSettings
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<SnapshotSettings> Compute_snapshotSettings_getAsync(string project, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/snapshotSettings";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SnapshotSettings>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patch snapshot settings.
		/// Compute_snapshotSettings_patch projects/{project}/global/snapshotSettings
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">update_mask indicates fields to be updated as part of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_snapshotSettings_patchAsync(string project, string requestId, string updateMask, SnapshotSettings requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/snapshotSettings&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of Snapshot resources contained within the specified project.
		/// Compute_snapshots_list projects/{project}/global/snapshots
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SnapshotList> Compute_snapshots_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/snapshots&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SnapshotList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a snapshot in the specified project using the data included in the request. For regular snapshot creation, consider using this method instead of disks.createSnapshot, as this method supports more features, such as creating snapshots in a project different from the source disk project.
		/// Compute_snapshots_insert projects/{project}/global/snapshots
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_snapshots_insertAsync(string project, string requestId, Snapshot requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/snapshots&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_snapshots_getIamPolicy projects/{project}/global/snapshots/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_snapshots_getIamPolicyAsync(string project, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/snapshots/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_snapshots_setIamPolicy projects/{project}/global/snapshots/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_snapshots_setIamPolicyAsync(string project, string resource, GlobalSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/snapshots/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on a snapshot. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_snapshots_setLabels projects/{project}/global/snapshots/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_snapshots_setLabelsAsync(string project, string resource, GlobalSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/snapshots/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_snapshots_testIamPermissions projects/{project}/global/snapshots/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_snapshots_testIamPermissionsAsync(string project, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/snapshots/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified Snapshot resource. Keep in mind that deleting a single snapshot might not necessarily delete all the data on that snapshot. If any data on the snapshot that is marked for deletion is needed for subsequent snapshots, the data will be moved to the next corresponding snapshot. For more information, see Deleting snapshots.
		/// Compute_snapshots_delete projects/{project}/global/snapshots/{snapshot}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="snapshot">Name of the Snapshot resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_snapshots_deleteAsync(string project, string snapshot, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/snapshots/"+ (snapshot==null? "" : System.Uri.EscapeDataString(snapshot))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified Snapshot resource.
		/// Compute_snapshots_get projects/{project}/global/snapshots/{snapshot}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="snapshot">Name of the Snapshot resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Snapshot> Compute_snapshots_getAsync(string project, string snapshot, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/snapshots/"+ (snapshot==null? "" : System.Uri.EscapeDataString(snapshot));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Snapshot>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of SslCertificate resources available to the specified project.
		/// Compute_sslCertificates_list projects/{project}/global/sslCertificates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SslCertificateList> Compute_sslCertificates_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/sslCertificates&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslCertificateList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a SslCertificate resource in the specified project using the data included in the request.
		/// Compute_sslCertificates_insert projects/{project}/global/sslCertificates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_sslCertificates_insertAsync(string project, string requestId, SslCertificate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/sslCertificates&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified SslCertificate resource.
		/// Compute_sslCertificates_delete projects/{project}/global/sslCertificates/{sslCertificate}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="sslCertificate">Name of the SslCertificate resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_sslCertificates_deleteAsync(string project, string sslCertificate, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/sslCertificates/"+ (sslCertificate==null? "" : System.Uri.EscapeDataString(sslCertificate))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified SslCertificate resource.
		/// Compute_sslCertificates_get projects/{project}/global/sslCertificates/{sslCertificate}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="sslCertificate">Name of the SslCertificate resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<SslCertificate> Compute_sslCertificates_getAsync(string project, string sslCertificate, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/sslCertificates/"+ (sslCertificate==null? "" : System.Uri.EscapeDataString(sslCertificate));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslCertificate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all the SSL policies that have been configured for the specified project.
		/// Compute_sslPolicies_list projects/{project}/global/sslPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SslPoliciesList> Compute_sslPolicies_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/sslPolicies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslPoliciesList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified SSL policy resource.
		/// Compute_sslPolicies_insert projects/{project}/global/sslPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_sslPolicies_insertAsync(string project, string requestId, SslPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/sslPolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all features that can be specified in the SSL policy when using custom profile.
		/// Compute_sslPolicies_listAvailableFeatures projects/{project}/global/sslPolicies/listAvailableFeatures
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SslPoliciesListAvailableFeaturesResponse> Compute_sslPolicies_listAvailableFeaturesAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/sslPolicies/listAvailableFeatures&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslPoliciesListAvailableFeaturesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified SSL policy. The SSL policy resource can be deleted only if it is not in use by any TargetHttpsProxy or TargetSslProxy resources.
		/// Compute_sslPolicies_delete projects/{project}/global/sslPolicies/{sslPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="sslPolicy">Name of the SSL policy to delete. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_sslPolicies_deleteAsync(string project, string sslPolicy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/sslPolicies/"+ (sslPolicy==null? "" : System.Uri.EscapeDataString(sslPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all of the ordered rules present in a single specified policy.
		/// Compute_sslPolicies_get projects/{project}/global/sslPolicies/{sslPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="sslPolicy">Name of the SSL policy to update. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<SslPolicy> Compute_sslPolicies_getAsync(string project, string sslPolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/sslPolicies/"+ (sslPolicy==null? "" : System.Uri.EscapeDataString(sslPolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslPolicy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified SSL policy with the data included in the request.
		/// Compute_sslPolicies_patch projects/{project}/global/sslPolicies/{sslPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="sslPolicy">Name of the SSL policy to update. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_sslPolicies_patchAsync(string project, string sslPolicy, string requestId, SslPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/sslPolicies/"+ (sslPolicy==null? "" : System.Uri.EscapeDataString(sslPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the TargetGrpcProxies for a project in the given scope.
		/// Compute_targetGrpcProxies_list projects/{project}/global/targetGrpcProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetGrpcProxyList> Compute_targetGrpcProxies_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetGrpcProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetGrpcProxyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a TargetGrpcProxy in the specified project in the given scope using the parameters that are included in the request.
		/// Compute_targetGrpcProxies_insert projects/{project}/global/targetGrpcProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetGrpcProxies_insertAsync(string project, string requestId, TargetGrpcProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetGrpcProxies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified TargetGrpcProxy in the given scope
		/// Compute_targetGrpcProxies_delete projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetGrpcProxy">Name of the TargetGrpcProxy resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetGrpcProxies_deleteAsync(string project, string targetGrpcProxy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetGrpcProxies/"+ (targetGrpcProxy==null? "" : System.Uri.EscapeDataString(targetGrpcProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified TargetGrpcProxy resource in the given scope.
		/// Compute_targetGrpcProxies_get projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetGrpcProxy">Name of the TargetGrpcProxy resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetGrpcProxy> Compute_targetGrpcProxies_getAsync(string project, string targetGrpcProxy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetGrpcProxies/"+ (targetGrpcProxy==null? "" : System.Uri.EscapeDataString(targetGrpcProxy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetGrpcProxy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified TargetGrpcProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_targetGrpcProxies_patch projects/{project}/global/targetGrpcProxies/{targetGrpcProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetGrpcProxy">Name of the TargetGrpcProxy resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetGrpcProxies_patchAsync(string project, string targetGrpcProxy, string requestId, TargetGrpcProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetGrpcProxies/"+ (targetGrpcProxy==null? "" : System.Uri.EscapeDataString(targetGrpcProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of TargetHttpProxy resources available to the specified project.
		/// Compute_targetHttpProxies_list projects/{project}/global/targetHttpProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetHttpProxyList> Compute_targetHttpProxies_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetHttpProxyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a TargetHttpProxy resource in the specified project using the data included in the request.
		/// Compute_targetHttpProxies_insert projects/{project}/global/targetHttpProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpProxies_insertAsync(string project, string requestId, TargetHttpProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpProxies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified TargetHttpProxy resource.
		/// Compute_targetHttpProxies_delete projects/{project}/global/targetHttpProxies/{targetHttpProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpProxy">Name of the TargetHttpProxy resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpProxies_deleteAsync(string project, string targetHttpProxy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpProxies/"+ (targetHttpProxy==null? "" : System.Uri.EscapeDataString(targetHttpProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified TargetHttpProxy resource.
		/// Compute_targetHttpProxies_get projects/{project}/global/targetHttpProxies/{targetHttpProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpProxy">Name of the TargetHttpProxy resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetHttpProxy> Compute_targetHttpProxies_getAsync(string project, string targetHttpProxy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpProxies/"+ (targetHttpProxy==null? "" : System.Uri.EscapeDataString(targetHttpProxy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetHttpProxy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified TargetHttpProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_targetHttpProxies_patch projects/{project}/global/targetHttpProxies/{targetHttpProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpProxy">Name of the TargetHttpProxy resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpProxies_patchAsync(string project, string targetHttpProxy, string requestId, TargetHttpProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpProxies/"+ (targetHttpProxy==null? "" : System.Uri.EscapeDataString(targetHttpProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of TargetHttpsProxy resources available to the specified project.
		/// Compute_targetHttpsProxies_list projects/{project}/global/targetHttpsProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetHttpsProxyList> Compute_targetHttpsProxies_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpsProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetHttpsProxyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a TargetHttpsProxy resource in the specified project using the data included in the request.
		/// Compute_targetHttpsProxies_insert projects/{project}/global/targetHttpsProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpsProxies_insertAsync(string project, string requestId, TargetHttpsProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpsProxies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified TargetHttpsProxy resource.
		/// Compute_targetHttpsProxies_delete projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpsProxies_deleteAsync(string project, string targetHttpsProxy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified TargetHttpsProxy resource.
		/// Compute_targetHttpsProxies_get projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetHttpsProxy> Compute_targetHttpsProxies_getAsync(string project, string targetHttpsProxy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetHttpsProxy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified TargetHttpsProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_targetHttpsProxies_patch projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpsProxies_patchAsync(string project, string targetHttpsProxy, string requestId, TargetHttpsProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the Certificate Map for TargetHttpsProxy.
		/// Compute_targetHttpsProxies_setCertificateMap projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}/setCertificateMap
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource whose CertificateMap is to be set. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpsProxies_setCertificateMapAsync(string project, string targetHttpsProxy, string requestId, TargetHttpsProxiesSetCertificateMapRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"/setCertificateMap&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the QUIC override policy for TargetHttpsProxy.
		/// Compute_targetHttpsProxies_setQuicOverride projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}/setQuicOverride
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource to set the QUIC override policy for. The name should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpsProxies_setQuicOverrideAsync(string project, string targetHttpsProxy, string requestId, TargetHttpsProxiesSetQuicOverrideRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"/setQuicOverride&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the server-side support for SSL features. This affects connections between clients and the HTTPS proxy load balancer. They do not affect the connection between the load balancer and the backends.
		/// Compute_targetHttpsProxies_setSslPolicy projects/{project}/global/targetHttpsProxies/{targetHttpsProxy}/setSslPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource whose SSL policy is to be set. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpsProxies_setSslPolicyAsync(string project, string targetHttpsProxy, string requestId, SslPolicyReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"/setSslPolicy&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of TargetSslProxy resources available to the specified project.
		/// Compute_targetSslProxies_list projects/{project}/global/targetSslProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetSslProxyList> Compute_targetSslProxies_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetSslProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetSslProxyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a TargetSslProxy resource in the specified project using the data included in the request.
		/// Compute_targetSslProxies_insert projects/{project}/global/targetSslProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetSslProxies_insertAsync(string project, string requestId, TargetSslProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetSslProxies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified TargetSslProxy resource.
		/// Compute_targetSslProxies_delete projects/{project}/global/targetSslProxies/{targetSslProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetSslProxy">Name of the TargetSslProxy resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetSslProxies_deleteAsync(string project, string targetSslProxy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetSslProxies/"+ (targetSslProxy==null? "" : System.Uri.EscapeDataString(targetSslProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified TargetSslProxy resource.
		/// Compute_targetSslProxies_get projects/{project}/global/targetSslProxies/{targetSslProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetSslProxy">Name of the TargetSslProxy resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetSslProxy> Compute_targetSslProxies_getAsync(string project, string targetSslProxy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetSslProxies/"+ (targetSslProxy==null? "" : System.Uri.EscapeDataString(targetSslProxy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetSslProxy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes the BackendService for TargetSslProxy.
		/// Compute_targetSslProxies_setBackendService projects/{project}/global/targetSslProxies/{targetSslProxy}/setBackendService
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetSslProxy">Name of the TargetSslProxy resource whose BackendService resource is to be set.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetSslProxies_setBackendServiceAsync(string project, string targetSslProxy, string requestId, TargetSslProxiesSetBackendServiceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetSslProxies/"+ (targetSslProxy==null? "" : System.Uri.EscapeDataString(targetSslProxy))+"/setBackendService&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the Certificate Map for TargetSslProxy.
		/// Compute_targetSslProxies_setCertificateMap projects/{project}/global/targetSslProxies/{targetSslProxy}/setCertificateMap
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetSslProxy">Name of the TargetSslProxy resource whose CertificateMap is to be set. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetSslProxies_setCertificateMapAsync(string project, string targetSslProxy, string requestId, TargetSslProxiesSetCertificateMapRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetSslProxies/"+ (targetSslProxy==null? "" : System.Uri.EscapeDataString(targetSslProxy))+"/setCertificateMap&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the ProxyHeaderType for TargetSslProxy.
		/// Compute_targetSslProxies_setProxyHeader projects/{project}/global/targetSslProxies/{targetSslProxy}/setProxyHeader
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetSslProxy">Name of the TargetSslProxy resource whose ProxyHeader is to be set.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetSslProxies_setProxyHeaderAsync(string project, string targetSslProxy, string requestId, TargetSslProxiesSetProxyHeaderRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetSslProxies/"+ (targetSslProxy==null? "" : System.Uri.EscapeDataString(targetSslProxy))+"/setProxyHeader&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes SslCertificates for TargetSslProxy.
		/// Compute_targetSslProxies_setSslCertificates projects/{project}/global/targetSslProxies/{targetSslProxy}/setSslCertificates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetSslProxy">Name of the TargetSslProxy resource whose SslCertificate resource is to be set.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetSslProxies_setSslCertificatesAsync(string project, string targetSslProxy, string requestId, TargetSslProxiesSetSslCertificatesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetSslProxies/"+ (targetSslProxy==null? "" : System.Uri.EscapeDataString(targetSslProxy))+"/setSslCertificates&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the SSL policy for TargetSslProxy. The SSL policy specifies the server-side support for SSL features. This affects connections between clients and the load balancer. They do not affect the connection between the load balancer and the backends.
		/// Compute_targetSslProxies_setSslPolicy projects/{project}/global/targetSslProxies/{targetSslProxy}/setSslPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetSslProxy">Name of the TargetSslProxy resource whose SSL policy is to be set. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetSslProxies_setSslPolicyAsync(string project, string targetSslProxy, string requestId, SslPolicyReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetSslProxies/"+ (targetSslProxy==null? "" : System.Uri.EscapeDataString(targetSslProxy))+"/setSslPolicy&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of TargetTcpProxy resources available to the specified project.
		/// Compute_targetTcpProxies_list projects/{project}/global/targetTcpProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetTcpProxyList> Compute_targetTcpProxies_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetTcpProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetTcpProxyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a TargetTcpProxy resource in the specified project using the data included in the request.
		/// Compute_targetTcpProxies_insert projects/{project}/global/targetTcpProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetTcpProxies_insertAsync(string project, string requestId, TargetTcpProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetTcpProxies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified TargetTcpProxy resource.
		/// Compute_targetTcpProxies_delete projects/{project}/global/targetTcpProxies/{targetTcpProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetTcpProxy">Name of the TargetTcpProxy resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetTcpProxies_deleteAsync(string project, string targetTcpProxy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetTcpProxies/"+ (targetTcpProxy==null? "" : System.Uri.EscapeDataString(targetTcpProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified TargetTcpProxy resource.
		/// Compute_targetTcpProxies_get projects/{project}/global/targetTcpProxies/{targetTcpProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetTcpProxy">Name of the TargetTcpProxy resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetTcpProxy> Compute_targetTcpProxies_getAsync(string project, string targetTcpProxy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetTcpProxies/"+ (targetTcpProxy==null? "" : System.Uri.EscapeDataString(targetTcpProxy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetTcpProxy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes the BackendService for TargetTcpProxy.
		/// Compute_targetTcpProxies_setBackendService projects/{project}/global/targetTcpProxies/{targetTcpProxy}/setBackendService
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetTcpProxy">Name of the TargetTcpProxy resource whose BackendService resource is to be set.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetTcpProxies_setBackendServiceAsync(string project, string targetTcpProxy, string requestId, TargetTcpProxiesSetBackendServiceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetTcpProxies/"+ (targetTcpProxy==null? "" : System.Uri.EscapeDataString(targetTcpProxy))+"/setBackendService&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the ProxyHeaderType for TargetTcpProxy.
		/// Compute_targetTcpProxies_setProxyHeader projects/{project}/global/targetTcpProxies/{targetTcpProxy}/setProxyHeader
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetTcpProxy">Name of the TargetTcpProxy resource whose ProxyHeader is to be set.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetTcpProxies_setProxyHeaderAsync(string project, string targetTcpProxy, string requestId, TargetTcpProxiesSetProxyHeaderRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/targetTcpProxies/"+ (targetTcpProxy==null? "" : System.Uri.EscapeDataString(targetTcpProxy))+"/setProxyHeader&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of UrlMap resources available to the specified project.
		/// Compute_urlMaps_list projects/{project}/global/urlMaps
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<UrlMapList> Compute_urlMaps_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/urlMaps&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UrlMapList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a UrlMap resource in the specified project using the data included in the request.
		/// Compute_urlMaps_insert projects/{project}/global/urlMaps
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_urlMaps_insertAsync(string project, string requestId, UrlMap requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/urlMaps&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified UrlMap resource.
		/// Compute_urlMaps_delete projects/{project}/global/urlMaps/{urlMap}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="urlMap">Name of the UrlMap resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_urlMaps_deleteAsync(string project, string urlMap, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified UrlMap resource.
		/// Compute_urlMaps_get projects/{project}/global/urlMaps/{urlMap}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="urlMap">Name of the UrlMap resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<UrlMap> Compute_urlMaps_getAsync(string project, string urlMap, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UrlMap>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified UrlMap resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_urlMaps_patch projects/{project}/global/urlMaps/{urlMap}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="urlMap">Name of the UrlMap resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_urlMaps_patchAsync(string project, string urlMap, string requestId, UrlMap requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the specified UrlMap resource with the data included in the request.
		/// Compute_urlMaps_update projects/{project}/global/urlMaps/{urlMap}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="urlMap">Name of the UrlMap resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_urlMaps_updateAsync(string project, string urlMap, string requestId, UrlMap requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Initiates a cache invalidation operation, invalidating the specified path, scoped to the specified UrlMap. For more information, see [Invalidating cached content](/cdn/docs/invalidating-cached-content).
		/// Compute_urlMaps_invalidateCache projects/{project}/global/urlMaps/{urlMap}/invalidateCache
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="urlMap">Name of the UrlMap scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_urlMaps_invalidateCacheAsync(string project, string urlMap, string requestId, CacheInvalidationRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap))+"/invalidateCache&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Runs static validation for the UrlMap. In particular, the tests of the provided UrlMap will be run. Calling this method does NOT create the UrlMap.
		/// Compute_urlMaps_validate projects/{project}/global/urlMaps/{urlMap}/validate
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="urlMap">Name of the UrlMap resource to be validated as.</param>
		/// <returns>Successful response</returns>
		public async Task<UrlMapsValidateResponse> Compute_urlMaps_validateAsync(string project, string urlMap, UrlMapsValidateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/global/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap))+"/validate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UrlMapsValidateResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all shared VPC host projects visible to the user in an organization.
		/// Compute_projects_listXpnHosts projects/{project}/listXpnHosts
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<XpnHostList> Compute_projects_listXpnHostsAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, ProjectsListXpnHostsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/listXpnHosts&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<XpnHostList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Moves a persistent disk from one zone to another.
		/// Compute_projects_moveDisk projects/{project}/moveDisk
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_projects_moveDiskAsync(string project, string requestId, DiskMoveRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/moveDisk&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Moves an instance and its attached persistent disks from one zone to another. *Note*: Moving VMs or disks by using this method might cause unexpected behavior. For more information, see the [known issue](/compute/docs/troubleshooting/known-issues#moving_vms_or_disks_using_the_moveinstance_api_or_the_causes_unexpected_behavior). [Deprecated] This method is deprecated. See [moving instance across zones](/compute/docs/instances/moving-instance-across-zones) instead.
		/// Compute_projects_moveInstance projects/{project}/moveInstance
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_projects_moveInstanceAsync(string project, string requestId, InstanceMoveRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/moveInstance&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of region resources available to the specified project. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is especially recommended for unused quota information (the `items.quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need. For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request.
		/// Compute_regions_list projects/{project}/regions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RegionList> Compute_regions_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegionList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified Region resource. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is especially recommended for unused quota information (the `quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need. For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request.
		/// Compute_regions_get projects/{project}/regions/{region}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Region> Compute_regions_getAsync(string project, string region, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Region>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of addresses contained within the specified region.
		/// Compute_addresses_list projects/{project}/regions/{region}/addresses
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<AddressList> Compute_addresses_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/addresses&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AddressList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an address resource in the specified project by using the data included in the request.
		/// Compute_addresses_insert projects/{project}/regions/{region}/addresses
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_addresses_insertAsync(string project, string region, string requestId, Address requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/addresses&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified address resource.
		/// Compute_addresses_delete projects/{project}/regions/{region}/addresses/{address}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="address">Name of the address resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_addresses_deleteAsync(string project, string region, string address, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/addresses/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified address resource.
		/// Compute_addresses_get projects/{project}/regions/{region}/addresses/{address}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="address">Name of the address resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Address> Compute_addresses_getAsync(string project, string region, string address, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/addresses/"+ (address==null? "" : System.Uri.EscapeDataString(address));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Address>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Moves the specified address resource.
		/// Compute_addresses_move projects/{project}/regions/{region}/addresses/{address}/move
		/// </summary>
		/// <param name="project">Source project ID which the Address is moved from.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="address">Name of the address resource to move.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_addresses_moveAsync(string project, string region, string address, string requestId, RegionAddressesMoveRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/addresses/"+ (address==null? "" : System.Uri.EscapeDataString(address))+"/move&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on an Address. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_addresses_setLabels projects/{project}/regions/{region}/addresses/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_addresses_setLabelsAsync(string project, string region, string resource, string requestId, RegionSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/addresses/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of autoscalers contained within the specified region.
		/// Compute_regionAutoscalers_list projects/{project}/regions/{region}/autoscalers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RegionAutoscalerList> Compute_regionAutoscalers_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/autoscalers&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegionAutoscalerList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an autoscaler in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_regionAutoscalers_patch projects/{project}/regions/{region}/autoscalers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="autoscaler">Name of the autoscaler to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionAutoscalers_patchAsync(string project, string region, string autoscaler, string requestId, Autoscaler requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/autoscalers&autoscaler=" + (autoscaler==null? "" : System.Uri.EscapeDataString(autoscaler))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates an autoscaler in the specified project using the data included in the request.
		/// Compute_regionAutoscalers_insert projects/{project}/regions/{region}/autoscalers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionAutoscalers_insertAsync(string project, string region, string requestId, Autoscaler requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/autoscalers&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an autoscaler in the specified project using the data included in the request.
		/// Compute_regionAutoscalers_update projects/{project}/regions/{region}/autoscalers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="autoscaler">Name of the autoscaler to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionAutoscalers_updateAsync(string project, string region, string autoscaler, string requestId, Autoscaler requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/autoscalers&autoscaler=" + (autoscaler==null? "" : System.Uri.EscapeDataString(autoscaler))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified autoscaler.
		/// Compute_regionAutoscalers_delete projects/{project}/regions/{region}/autoscalers/{autoscaler}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="autoscaler">Name of the autoscaler to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionAutoscalers_deleteAsync(string project, string region, string autoscaler, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/autoscalers/"+ (autoscaler==null? "" : System.Uri.EscapeDataString(autoscaler))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified autoscaler.
		/// Compute_regionAutoscalers_get projects/{project}/regions/{region}/autoscalers/{autoscaler}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="autoscaler">Name of the autoscaler to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Autoscaler> Compute_regionAutoscalers_getAsync(string project, string region, string autoscaler, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/autoscalers/"+ (autoscaler==null? "" : System.Uri.EscapeDataString(autoscaler));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Autoscaler>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of regional BackendService resources available to the specified project in the given region.
		/// Compute_regionBackendServices_list projects/{project}/regions/{region}/backendServices
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendServiceList> Compute_regionBackendServices_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendServiceList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a regional BackendService resource in the specified project using the data included in the request. For more information, see Backend services overview.
		/// Compute_regionBackendServices_insert projects/{project}/regions/{region}/backendServices
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionBackendServices_insertAsync(string project, string region, string requestId, BackendService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves an aggregated list of all usable backend services in the specified project in the given region.
		/// Compute_regionBackendServices_listUsable projects/{project}/regions/{region}/backendServices/listUsable
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request. It must be a string that meets the requirements in RFC1035.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendServiceListUsable> Compute_regionBackendServices_listUsableAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices/listUsable&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendServiceListUsable>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified regional BackendService resource.
		/// Compute_regionBackendServices_delete projects/{project}/regions/{region}/backendServices/{backendService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="backendService">Name of the BackendService resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionBackendServices_deleteAsync(string project, string region, string backendService, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified regional BackendService resource.
		/// Compute_regionBackendServices_get projects/{project}/regions/{region}/backendServices/{backendService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="backendService">Name of the BackendService resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendService> Compute_regionBackendServices_getAsync(string project, string region, string backendService, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendService>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified regional BackendService resource with the data included in the request. For more information, see Understanding backend services This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_regionBackendServices_patch projects/{project}/regions/{region}/backendServices/{backendService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="backendService">Name of the BackendService resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionBackendServices_patchAsync(string project, string region, string backendService, string requestId, BackendService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the specified regional BackendService resource with the data included in the request. For more information, see Backend services overview .
		/// Compute_regionBackendServices_update projects/{project}/regions/{region}/backendServices/{backendService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="backendService">Name of the BackendService resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionBackendServices_updateAsync(string project, string region, string backendService, string requestId, BackendService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the most recent health check results for this regional BackendService.
		/// Compute_regionBackendServices_getHealth projects/{project}/regions/{region}/backendServices/{backendService}/getHealth
		/// </summary>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="backendService">Name of the BackendService resource for which to get health.</param>
		/// <returns>Successful response</returns>
		public async Task<BackendServiceGroupHealth> Compute_regionBackendServices_getHealthAsync(string project, string region, string backendService, ResourceGroupReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"/getHealth";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BackendServiceGroupHealth>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the Google Cloud Armor security policy for the specified backend service. For more information, see Google Cloud Armor Overview
		/// Compute_regionBackendServices_setSecurityPolicy projects/{project}/regions/{region}/backendServices/{backendService}/setSecurityPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="backendService">Name of the BackendService resource to which the security policy should be set. The name should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionBackendServices_setSecurityPolicyAsync(string project, string region, string backendService, string requestId, SecurityPolicyReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices/"+ (backendService==null? "" : System.Uri.EscapeDataString(backendService))+"/setSecurityPolicy&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_regionBackendServices_getIamPolicy projects/{project}/regions/{region}/backendServices/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_regionBackendServices_getIamPolicyAsync(string project, string region, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_regionBackendServices_setIamPolicy projects/{project}/regions/{region}/backendServices/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_regionBackendServices_setIamPolicyAsync(string project, string region, string resource, RegionSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_regionBackendServices_testIamPermissions projects/{project}/regions/{region}/backendServices/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_regionBackendServices_testIamPermissionsAsync(string project, string region, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/backendServices/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of commitments contained within the specified region.
		/// Compute_regionCommitments_list projects/{project}/regions/{region}/commitments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<CommitmentList> Compute_regionCommitments_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/commitments&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CommitmentList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a commitment in the specified project using the data included in the request.
		/// Compute_regionCommitments_insert projects/{project}/regions/{region}/commitments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionCommitments_insertAsync(string project, string region, string requestId, Commitment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/commitments&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the specified commitment resource.
		/// Compute_regionCommitments_get projects/{project}/regions/{region}/commitments/{commitment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="commitment">Name of the commitment to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Commitment> Compute_regionCommitments_getAsync(string project, string region, string commitment, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/commitments/"+ (commitment==null? "" : System.Uri.EscapeDataString(commitment));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Commitment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified commitment with the data included in the request. Update is performed only on selected fields included as part of update-mask. Only the following fields can be modified: auto_renew.
		/// Compute_regionCommitments_update projects/{project}/regions/{region}/commitments/{commitment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="commitment">Name of the commitment for which auto renew is being updated.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">update_mask indicates fields to be updated as part of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionCommitments_updateAsync(string project, string region, string commitment, string[] paths, string requestId, string updateMask, Commitment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/commitments/"+ (commitment==null? "" : System.Uri.EscapeDataString(commitment))+"&"+string.Join("&", paths.Select(z => $"paths={System.Uri.EscapeDataString(z.ToString())}"))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of regional disk types available to the specified project.
		/// Compute_regionDiskTypes_list projects/{project}/regions/{region}/diskTypes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RegionDiskTypeList> Compute_regionDiskTypes_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/diskTypes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegionDiskTypeList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified regional disk type.
		/// Compute_regionDiskTypes_get projects/{project}/regions/{region}/diskTypes/{diskType}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="diskType">Name of the disk type to return.</param>
		/// <returns>Successful response</returns>
		public async Task<DiskType> Compute_regionDiskTypes_getAsync(string project, string region, string diskType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/diskTypes/"+ (diskType==null? "" : System.Uri.EscapeDataString(diskType));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DiskType>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of persistent disks contained within the specified region.
		/// Compute_regionDisks_list projects/{project}/regions/{region}/disks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<DiskList> Compute_regionDisks_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DiskList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a persistent regional disk in the specified project using the data included in the request.
		/// Compute_regionDisks_insert projects/{project}/regions/{region}/disks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="sourceImage">Source image to restore onto a disk. This field is optional.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_insertAsync(string project, string region, string requestId, string sourceImage, Disk requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&sourceImage=" + (sourceImage==null? "" : System.Uri.EscapeDataString(sourceImage));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Bulk create a set of disks.
		/// Compute_regionDisks_bulkInsert projects/{project}/regions/{region}/disks/bulkInsert
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_bulkInsertAsync(string project, string region, string requestId, BulkInsertDiskResource requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/bulkInsert&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stops asynchronous replication for a consistency group of disks. Can be invoked either in the primary or secondary scope.
		/// Compute_regionDisks_stopGroupAsyncReplication projects/{project}/regions/{region}/disks/stopGroupAsyncReplication
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request. This must be the region of the primary or secondary disks in the consistency group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_stopGroupAsyncReplicationAsync(string project, string region, string requestId, DisksStopGroupAsyncReplicationResource requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/stopGroupAsyncReplication&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified regional persistent disk. Deleting a regional disk removes all the replicas of its data permanently and is irreversible. However, deleting a disk does not delete any snapshots previously made from the disk. You must separately delete snapshots.
		/// Compute_regionDisks_delete projects/{project}/regions/{region}/disks/{disk}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="disk">Name of the regional persistent disk to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_deleteAsync(string project, string region, string disk, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a specified regional persistent disk.
		/// Compute_regionDisks_get projects/{project}/regions/{region}/disks/{disk}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="disk">Name of the regional persistent disk to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Disk> Compute_regionDisks_getAsync(string project, string region, string disk, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Disk>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update the specified disk with the data included in the request. Update is performed only on selected fields included as part of update-mask. Only the following fields can be modified: user_license.
		/// Compute_regionDisks_update projects/{project}/regions/{region}/disks/{disk}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="disk">The disk name for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">update_mask indicates fields to be updated as part of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_updateAsync(string project, string region, string disk, string[] paths, string requestId, string updateMask, Disk requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"&"+string.Join("&", paths.Select(z => $"paths={System.Uri.EscapeDataString(z.ToString())}"))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds existing resource policies to a regional disk. You can only add one policy which will be applied to this disk for scheduling snapshot creation.
		/// Compute_regionDisks_addResourcePolicies projects/{project}/regions/{region}/disks/{disk}/addResourcePolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="disk">The disk name for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_addResourcePoliciesAsync(string project, string region, string disk, string requestId, RegionDisksAddResourcePoliciesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/addResourcePolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a snapshot of a specified persistent disk. For regular snapshot creation, consider using snapshots.insert instead, as that method supports more features, such as creating snapshots in a project different from the source disk project.
		/// Compute_regionDisks_createSnapshot projects/{project}/regions/{region}/disks/{disk}/createSnapshot
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="disk">Name of the regional persistent disk to snapshot.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_createSnapshotAsync(string project, string region, string disk, string requestId, Snapshot requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/createSnapshot&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes resource policies from a regional disk.
		/// Compute_regionDisks_removeResourcePolicies projects/{project}/regions/{region}/disks/{disk}/removeResourcePolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="disk">The disk name for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_removeResourcePoliciesAsync(string project, string region, string disk, string requestId, RegionDisksRemoveResourcePoliciesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/removeResourcePolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Resizes the specified regional persistent disk.
		/// Compute_regionDisks_resize projects/{project}/regions/{region}/disks/{disk}/resize
		/// </summary>
		/// <param name="project">The project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="disk">Name of the regional persistent disk.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_resizeAsync(string project, string region, string disk, string requestId, RegionDisksResizeRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/resize&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Starts asynchronous replication. Must be invoked on the primary disk.
		/// Compute_regionDisks_startAsyncReplication projects/{project}/regions/{region}/disks/{disk}/startAsyncReplication
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="disk">The name of the persistent disk.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_startAsyncReplicationAsync(string project, string region, string disk, string requestId, RegionDisksStartAsyncReplicationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/startAsyncReplication&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stops asynchronous replication. Can be invoked either on the primary or on the secondary disk.
		/// Compute_regionDisks_stopAsyncReplication projects/{project}/regions/{region}/disks/{disk}/stopAsyncReplication
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="disk">The name of the persistent disk.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_stopAsyncReplicationAsync(string project, string region, string disk, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/stopAsyncReplication&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_regionDisks_getIamPolicy projects/{project}/regions/{region}/disks/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_regionDisks_getIamPolicyAsync(string project, string region, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_regionDisks_setIamPolicy projects/{project}/regions/{region}/disks/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_regionDisks_setIamPolicyAsync(string project, string region, string resource, RegionSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on the target regional disk.
		/// Compute_regionDisks_setLabels projects/{project}/regions/{region}/disks/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionDisks_setLabelsAsync(string project, string region, string resource, string requestId, RegionSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_regionDisks_testIamPermissions projects/{project}/regions/{region}/disks/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_regionDisks_testIamPermissionsAsync(string project, string region, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/disks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all the network firewall policies that have been configured for the specified project in the given region.
		/// Compute_regionNetworkFirewallPolicies_list projects/{project}/regions/{region}/firewallPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicyList> Compute_regionNetworkFirewallPolicies_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new network firewall policy in the specified project and region.
		/// Compute_regionNetworkFirewallPolicies_insert projects/{project}/regions/{region}/firewallPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkFirewallPolicies_insertAsync(string project, string region, string requestId, FirewallPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the effective firewalls on a given network.
		/// Compute_regionNetworkFirewallPolicies_getEffectiveFirewalls projects/{project}/regions/{region}/firewallPolicies/getEffectiveFirewalls
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="network">Network reference</param>
		/// <returns>Successful response</returns>
		public async Task<RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse> Compute_regionNetworkFirewallPolicies_getEffectiveFirewallsAsync(string project, string region, string network, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/getEffectiveFirewalls&network=" + (network==null? "" : System.Uri.EscapeDataString(network));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified network firewall policy.
		/// Compute_regionNetworkFirewallPolicies_delete projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkFirewallPolicies_deleteAsync(string project, string region, string firewallPolicy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified network firewall policy.
		/// Compute_regionNetworkFirewallPolicies_get projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to get.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicy> Compute_regionNetworkFirewallPolicies_getAsync(string project, string region, string firewallPolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified network firewall policy.
		/// Compute_regionNetworkFirewallPolicies_patch projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkFirewallPolicies_patchAsync(string project, string region, string firewallPolicy, string requestId, FirewallPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts an association for the specified network firewall policy.
		/// Compute_regionNetworkFirewallPolicies_addAssociation projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/addAssociation
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="replaceExistingAssociation">Indicates whether or not to replace it if an association already exists. This is false by default, in which case an error will be returned if an association already exists.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkFirewallPolicies_addAssociationAsync(string project, string region, string firewallPolicy, bool replaceExistingAssociation, string requestId, FirewallPolicyAssociation requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/addAssociation&replaceExistingAssociation="+replaceExistingAssociation+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts a rule into a network firewall policy.
		/// Compute_regionNetworkFirewallPolicies_addRule projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/addRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="maxPriority">When rule.priority is not specified, auto choose a unused priority between minPriority and maxPriority>. This field is exclusive with rule.priority.</param>
		/// <param name="minPriority">When rule.priority is not specified, auto choose a unused priority between minPriority and maxPriority>. This field is exclusive with rule.priority.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkFirewallPolicies_addRuleAsync(string project, string region, string firewallPolicy, int maxPriority, int minPriority, string requestId, FirewallPolicyRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/addRule&maxPriority="+maxPriority+"&minPriority="+minPriority+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Copies rules to the specified network firewall policy.
		/// Compute_regionNetworkFirewallPolicies_cloneRules projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/cloneRules
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="sourceFirewallPolicy">The firewall policy from which to copy rules.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkFirewallPolicies_cloneRulesAsync(string project, string region, string firewallPolicy, string requestId, string sourceFirewallPolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/cloneRules&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&sourceFirewallPolicy=" + (sourceFirewallPolicy==null? "" : System.Uri.EscapeDataString(sourceFirewallPolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets an association with the specified name.
		/// Compute_regionNetworkFirewallPolicies_getAssociation projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/getAssociation
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to which the queried association belongs.</param>
		/// <param name="name">The name of the association to get from the firewall policy.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicyAssociation> Compute_regionNetworkFirewallPolicies_getAssociationAsync(string project, string region, string firewallPolicy, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/getAssociation&name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicyAssociation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a rule of the specified priority.
		/// Compute_regionNetworkFirewallPolicies_getRule projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/getRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to which the queried rule belongs.</param>
		/// <param name="priority">The priority of the rule to get from the firewall policy.</param>
		/// <returns>Successful response</returns>
		public async Task<FirewallPolicyRule> Compute_regionNetworkFirewallPolicies_getRuleAsync(string project, string region, string firewallPolicy, int priority, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/getRule&priority="+priority;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FirewallPolicyRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches a rule of the specified priority.
		/// Compute_regionNetworkFirewallPolicies_patchRule projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/patchRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="priority">The priority of the rule to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkFirewallPolicies_patchRuleAsync(string project, string region, string firewallPolicy, int priority, string requestId, FirewallPolicyRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/patchRule&priority="+priority+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes an association for the specified network firewall policy.
		/// Compute_regionNetworkFirewallPolicies_removeAssociation projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/removeAssociation
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="name">Name for the association that will be removed.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkFirewallPolicies_removeAssociationAsync(string project, string region, string firewallPolicy, string name, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/removeAssociation&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a rule of the specified priority.
		/// Compute_regionNetworkFirewallPolicies_removeRule projects/{project}/regions/{region}/firewallPolicies/{firewallPolicy}/removeRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="firewallPolicy">Name of the firewall policy to update.</param>
		/// <param name="priority">The priority of the rule to remove from the firewall policy.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkFirewallPolicies_removeRuleAsync(string project, string region, string firewallPolicy, int priority, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (firewallPolicy==null? "" : System.Uri.EscapeDataString(firewallPolicy))+"/removeRule&priority="+priority+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_regionNetworkFirewallPolicies_getIamPolicy projects/{project}/regions/{region}/firewallPolicies/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_regionNetworkFirewallPolicies_getIamPolicyAsync(string project, string region, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_regionNetworkFirewallPolicies_setIamPolicy projects/{project}/regions/{region}/firewallPolicies/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_regionNetworkFirewallPolicies_setIamPolicyAsync(string project, string region, string resource, RegionSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_regionNetworkFirewallPolicies_testIamPermissions projects/{project}/regions/{region}/firewallPolicies/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_regionNetworkFirewallPolicies_testIamPermissionsAsync(string project, string region, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/firewallPolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of ForwardingRule resources available to the specified project and region.
		/// Compute_forwardingRules_list projects/{project}/regions/{region}/forwardingRules
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ForwardingRuleList> Compute_forwardingRules_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/forwardingRules&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ForwardingRuleList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a ForwardingRule resource in the specified project and region using the data included in the request.
		/// Compute_forwardingRules_insert projects/{project}/regions/{region}/forwardingRules
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_forwardingRules_insertAsync(string project, string region, string requestId, ForwardingRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/forwardingRules&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified ForwardingRule resource.
		/// Compute_forwardingRules_delete projects/{project}/regions/{region}/forwardingRules/{forwardingRule}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="forwardingRule">Name of the ForwardingRule resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_forwardingRules_deleteAsync(string project, string region, string forwardingRule, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/forwardingRules/"+ (forwardingRule==null? "" : System.Uri.EscapeDataString(forwardingRule))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified ForwardingRule resource.
		/// Compute_forwardingRules_get projects/{project}/regions/{region}/forwardingRules/{forwardingRule}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="forwardingRule">Name of the ForwardingRule resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<ForwardingRule> Compute_forwardingRules_getAsync(string project, string region, string forwardingRule, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/forwardingRules/"+ (forwardingRule==null? "" : System.Uri.EscapeDataString(forwardingRule));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ForwardingRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified forwarding rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. Currently, you can only patch the network_tier field.
		/// Compute_forwardingRules_patch projects/{project}/regions/{region}/forwardingRules/{forwardingRule}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="forwardingRule">Name of the ForwardingRule resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_forwardingRules_patchAsync(string project, string region, string forwardingRule, string requestId, ForwardingRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/forwardingRules/"+ (forwardingRule==null? "" : System.Uri.EscapeDataString(forwardingRule))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes target URL for forwarding rule. The new target should be of the same type as the old target.
		/// Compute_forwardingRules_setTarget projects/{project}/regions/{region}/forwardingRules/{forwardingRule}/setTarget
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="forwardingRule">Name of the ForwardingRule resource in which target is to be set.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_forwardingRules_setTargetAsync(string project, string region, string forwardingRule, string requestId, TargetReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/forwardingRules/"+ (forwardingRule==null? "" : System.Uri.EscapeDataString(forwardingRule))+"/setTarget&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on the specified resource. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_forwardingRules_setLabels projects/{project}/regions/{region}/forwardingRules/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_forwardingRules_setLabelsAsync(string project, string region, string resource, string requestId, RegionSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/forwardingRules/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all the HealthCheckService resources that have been configured for the specified project in the given region.
		/// Compute_regionHealthCheckServices_list projects/{project}/regions/{region}/healthCheckServices
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<HealthCheckServicesList> Compute_regionHealthCheckServices_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthCheckServices&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HealthCheckServicesList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a regional HealthCheckService resource in the specified project and region using the data included in the request.
		/// Compute_regionHealthCheckServices_insert projects/{project}/regions/{region}/healthCheckServices
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionHealthCheckServices_insertAsync(string project, string region, string requestId, HealthCheckService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthCheckServices&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified regional HealthCheckService.
		/// Compute_regionHealthCheckServices_delete projects/{project}/regions/{region}/healthCheckServices/{healthCheckService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="healthCheckService">Name of the HealthCheckService to delete. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionHealthCheckServices_deleteAsync(string project, string region, string healthCheckService, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthCheckServices/"+ (healthCheckService==null? "" : System.Uri.EscapeDataString(healthCheckService))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified regional HealthCheckService resource.
		/// Compute_regionHealthCheckServices_get projects/{project}/regions/{region}/healthCheckServices/{healthCheckService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="healthCheckService">Name of the HealthCheckService to update. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<HealthCheckService> Compute_regionHealthCheckServices_getAsync(string project, string region, string healthCheckService, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthCheckServices/"+ (healthCheckService==null? "" : System.Uri.EscapeDataString(healthCheckService));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HealthCheckService>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified regional HealthCheckService resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_regionHealthCheckServices_patch projects/{project}/regions/{region}/healthCheckServices/{healthCheckService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="healthCheckService">Name of the HealthCheckService to update. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionHealthCheckServices_patchAsync(string project, string region, string healthCheckService, string requestId, HealthCheckService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthCheckServices/"+ (healthCheckService==null? "" : System.Uri.EscapeDataString(healthCheckService))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of HealthCheck resources available to the specified project.
		/// Compute_regionHealthChecks_list projects/{project}/regions/{region}/healthChecks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<HealthCheckList> Compute_regionHealthChecks_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthChecks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HealthCheckList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a HealthCheck resource in the specified project using the data included in the request.
		/// Compute_regionHealthChecks_insert projects/{project}/regions/{region}/healthChecks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionHealthChecks_insertAsync(string project, string region, string requestId, HealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthChecks&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified HealthCheck resource.
		/// Compute_regionHealthChecks_delete projects/{project}/regions/{region}/healthChecks/{healthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="healthCheck">Name of the HealthCheck resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionHealthChecks_deleteAsync(string project, string region, string healthCheck, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthChecks/"+ (healthCheck==null? "" : System.Uri.EscapeDataString(healthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified HealthCheck resource.
		/// Compute_regionHealthChecks_get projects/{project}/regions/{region}/healthChecks/{healthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="healthCheck">Name of the HealthCheck resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<HealthCheck> Compute_regionHealthChecks_getAsync(string project, string region, string healthCheck, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthChecks/"+ (healthCheck==null? "" : System.Uri.EscapeDataString(healthCheck));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<HealthCheck>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a HealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_regionHealthChecks_patch projects/{project}/regions/{region}/healthChecks/{healthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="healthCheck">Name of the HealthCheck resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionHealthChecks_patchAsync(string project, string region, string healthCheck, string requestId, HealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthChecks/"+ (healthCheck==null? "" : System.Uri.EscapeDataString(healthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates a HealthCheck resource in the specified project using the data included in the request.
		/// Compute_regionHealthChecks_update projects/{project}/regions/{region}/healthChecks/{healthCheck}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="healthCheck">Name of the HealthCheck resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionHealthChecks_updateAsync(string project, string region, string healthCheck, string requestId, HealthCheck requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/healthChecks/"+ (healthCheck==null? "" : System.Uri.EscapeDataString(healthCheck))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of managed instance groups that are contained within the specified region.
		/// Compute_regionInstanceGroupManagers_list projects/{project}/regions/{region}/instanceGroupManagers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RegionInstanceGroupManagerList> Compute_regionInstanceGroupManagers_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegionInstanceGroupManagerList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a managed instance group using the information that you specify in the request. After the group is created, instances in the group are created using the specified instance template. This operation is marked as DONE when the group is created even if the instances in the group have not yet been created. You must separately verify the status of the individual instances with the listmanagedinstances method. A regional managed instance group can contain up to 2000 instances.
		/// Compute_regionInstanceGroupManagers_insert projects/{project}/regions/{region}/instanceGroupManagers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_insertAsync(string project, string region, string requestId, InstanceGroupManager requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified managed instance group and all of the instances in that group.
		/// Compute_regionInstanceGroupManagers_delete projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroupManager">Name of the managed instance group to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_deleteAsync(string project, string region, string instanceGroupManager, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all of the details about the specified managed instance group.
		/// Compute_regionInstanceGroupManagers_get projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroupManager">Name of the managed instance group to return.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroupManager> Compute_regionInstanceGroupManagers_getAsync(string project, string region, string instanceGroupManager, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroupManager>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a managed instance group using the information that you specify in the request. This operation is marked as DONE when the group is patched even if the instances in the group are still in the process of being patched. You must separately verify the status of the individual instances with the listmanagedinstances method. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. If you update your group to specify a new template or instance configuration, it's possible that your intended specification for each VM in the group is different from the current state of that VM. To learn how to apply an updated configuration to the VMs in a MIG, see Updating instances in a MIG.
		/// Compute_regionInstanceGroupManagers_patch projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroupManager">The name of the instance group manager.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_patchAsync(string project, string region, string instanceGroupManager, string requestId, InstanceGroupManager requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Flags the specified instances to be immediately removed from the managed instance group. Abandoning an instance does not delete the instance, but it does remove the instance from any target pools that are applied by the managed instance group. This method reduces the targetSize of the managed instance group by the number of instances that you abandon. This operation is marked as DONE when the action is scheduled even if the instances have not yet been removed from the group. You must separately verify the status of the abandoning action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
		/// Compute_regionInstanceGroupManagers_abandonInstances projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/abandonInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroupManager">Name of the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_abandonInstancesAsync(string project, string region, string instanceGroupManager, string requestId, RegionInstanceGroupManagersAbandonInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/abandonInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Apply updates to selected instances the managed instance group.
		/// Compute_regionInstanceGroupManagers_applyUpdatesToInstances projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request, should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group, should conform to RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_applyUpdatesToInstancesAsync(string project, string region, string instanceGroupManager, RegionInstanceGroupManagersApplyUpdatesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/applyUpdatesToInstances";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates instances with per-instance configurations in this regional managed instance group. Instances are created using the current instance template. The create instances operation is marked DONE if the createInstances request is successful. The underlying actions take additional time. You must separately verify the status of the creating or actions with the listmanagedinstances method.
		/// Compute_regionInstanceGroupManagers_createInstances projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/createInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region where the managed instance group is located. It should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_createInstancesAsync(string project, string region, string instanceGroupManager, string requestId, RegionInstanceGroupManagersCreateInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/createInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Flags the specified instances in the managed instance group to be immediately deleted. The instances are also removed from any target pools of which they were a member. This method reduces the targetSize of the managed instance group by the number of instances that you delete. The deleteInstances operation is marked DONE if the deleteInstances request is successful. The underlying actions take additional time. You must separately verify the status of the deleting action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
		/// Compute_regionInstanceGroupManagers_deleteInstances projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/deleteInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroupManager">Name of the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_deleteInstancesAsync(string project, string region, string instanceGroupManager, string requestId, RegionInstanceGroupManagersDeleteInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/deleteInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes selected per-instance configurations for the managed instance group.
		/// Compute_regionInstanceGroupManagers_deletePerInstanceConfigs projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/deletePerInstanceConfigs
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request, should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It should conform to RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_deletePerInstanceConfigsAsync(string project, string region, string instanceGroupManager, RegionInstanceGroupManagerDeleteInstanceConfigReq requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/deletePerInstanceConfigs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all errors thrown by actions on instances for a given regional managed instance group. The filter and orderBy query parameters are not supported.
		/// Compute_regionInstanceGroupManagers_listErrors projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/listErrors
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request. This should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It must be a string that meets the requirements in RFC1035, or an unsigned long integer: must match regexp pattern: (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|1-9{0,19}.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RegionInstanceGroupManagersListErrorsResponse> Compute_regionInstanceGroupManagers_listErrorsAsync(string project, string region, string instanceGroupManager, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/listErrors&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegionInstanceGroupManagersListErrorsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the instances in the managed instance group and instances that are scheduled to be created. The list includes any current actions that the group has scheduled for its instances. The orderBy query parameter is not supported. The `pageToken` query parameter is supported only if the group's `listManagedInstancesResults` field is set to `PAGINATED`.
		/// Compute_regionInstanceGroupManagers_listManagedInstances projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/listManagedInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RegionInstanceGroupManagersListInstancesResponse> Compute_regionInstanceGroupManagers_listManagedInstancesAsync(string project, string region, string instanceGroupManager, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/listManagedInstances&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegionInstanceGroupManagersListInstancesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all of the per-instance configurations defined for the managed instance group. The orderBy query parameter is not supported.
		/// Compute_regionInstanceGroupManagers_listPerInstanceConfigs projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/listPerInstanceConfigs
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request, should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It should conform to RFC1035.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RegionInstanceGroupManagersListInstanceConfigsResp> Compute_regionInstanceGroupManagers_listPerInstanceConfigsAsync(string project, string region, string instanceGroupManager, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/listPerInstanceConfigs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegionInstanceGroupManagersListInstanceConfigsResp>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Inserts or patches per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch.
		/// Compute_regionInstanceGroupManagers_patchPerInstanceConfigs projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/patchPerInstanceConfigs
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request, should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_patchPerInstanceConfigsAsync(string project, string region, string instanceGroupManager, string requestId, RegionInstanceGroupManagerPatchInstanceConfigReq requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/patchPerInstanceConfigs&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Flags the specified VM instances in the managed instance group to be immediately recreated. Each instance is recreated using the group's current configuration. This operation is marked as DONE when the flag is set even if the instances have not yet been recreated. You must separately verify the status of each instance by checking its currentAction field; for more information, see Checking the status of managed instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
		/// Compute_regionInstanceGroupManagers_recreateInstances projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/recreateInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroupManager">Name of the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_recreateInstancesAsync(string project, string region, string instanceGroupManager, string requestId, RegionInstanceGroupManagersRecreateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/recreateInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the intended size of the managed instance group. If you increase the size, the group creates new instances using the current instance template. If you decrease the size, the group deletes one or more instances. The resize operation is marked DONE if the resize request is successful. The underlying actions take additional time. You must separately verify the status of the creating or deleting actions with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted.
		/// Compute_regionInstanceGroupManagers_resize projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/resize
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroupManager">Name of the managed instance group.</param>
		/// <param name="size">Number of instances that should exist in this instance group manager.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_resizeAsync(string project, string region, string instanceGroupManager, int size, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/resize&size="+size+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the instance template to use when creating new instances or recreating instances in this group. Existing instances are not affected.
		/// Compute_regionInstanceGroupManagers_setInstanceTemplate projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/setInstanceTemplate
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_setInstanceTemplateAsync(string project, string region, string instanceGroupManager, string requestId, RegionInstanceGroupManagersSetTemplateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/setInstanceTemplate&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Modifies the target pools to which all new instances in this group are assigned. Existing instances in the group are not affected.
		/// Compute_regionInstanceGroupManagers_setTargetPools projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/setTargetPools
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroupManager">Name of the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_setTargetPoolsAsync(string project, string region, string instanceGroupManager, string requestId, RegionInstanceGroupManagersSetTargetPoolsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/setTargetPools&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts or updates per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch.
		/// Compute_regionInstanceGroupManagers_updatePerInstanceConfigs projects/{project}/regions/{region}/instanceGroupManagers/{instanceGroupManager}/updatePerInstanceConfigs
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request, should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroupManagers_updatePerInstanceConfigsAsync(string project, string region, string instanceGroupManager, string requestId, RegionInstanceGroupManagerUpdateInstanceConfigReq requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/updatePerInstanceConfigs&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of instance group resources contained within the specified region.
		/// Compute_regionInstanceGroups_list projects/{project}/regions/{region}/instanceGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RegionInstanceGroupList> Compute_regionInstanceGroups_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegionInstanceGroupList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified instance group resource.
		/// Compute_regionInstanceGroups_get projects/{project}/regions/{region}/instanceGroups/{instanceGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroup">Name of the instance group resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroup> Compute_regionInstanceGroups_getAsync(string project, string region, string instanceGroup, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroups/"+ (instanceGroup==null? "" : System.Uri.EscapeDataString(instanceGroup));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the instances in the specified instance group and displays information about the named ports. Depending on the specified options, this method can list all instances or only the instances that are running. The orderBy query parameter is not supported.
		/// Compute_regionInstanceGroups_listInstances projects/{project}/regions/{region}/instanceGroups/{instanceGroup}/listInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroup">Name of the regional instance group for which we want to list the instances.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RegionInstanceGroupsListInstances> Compute_regionInstanceGroups_listInstancesAsync(string project, string region, string instanceGroup, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, RegionInstanceGroupsListInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroups/"+ (instanceGroup==null? "" : System.Uri.EscapeDataString(instanceGroup))+"/listInstances&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RegionInstanceGroupsListInstances>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the named ports for the specified regional instance group.
		/// Compute_regionInstanceGroups_setNamedPorts projects/{project}/regions/{region}/instanceGroups/{instanceGroup}/setNamedPorts
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="instanceGroup">The name of the regional instance group where the named ports are updated.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceGroups_setNamedPortsAsync(string project, string region, string instanceGroup, string requestId, RegionInstanceGroupsSetNamedPortsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceGroups/"+ (instanceGroup==null? "" : System.Uri.EscapeDataString(instanceGroup))+"/setNamedPorts&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of instance templates that are contained within the specified project and region.
		/// Compute_regionInstanceTemplates_list projects/{project}/regions/{region}/instanceTemplates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the regions for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceTemplateList> Compute_regionInstanceTemplates_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceTemplates&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceTemplateList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an instance template in the specified project and region using the global instance template whose URL is included in the request.
		/// Compute_regionInstanceTemplates_insert projects/{project}/regions/{region}/instanceTemplates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceTemplates_insertAsync(string project, string region, string requestId, InstanceTemplate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceTemplates&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified instance template. Deleting an instance template is permanent and cannot be undone.
		/// Compute_regionInstanceTemplates_delete projects/{project}/regions/{region}/instanceTemplates/{instanceTemplate}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="instanceTemplate">The name of the instance template to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstanceTemplates_deleteAsync(string project, string region, string instanceTemplate, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceTemplates/"+ (instanceTemplate==null? "" : System.Uri.EscapeDataString(instanceTemplate))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified instance template.
		/// Compute_regionInstanceTemplates_get projects/{project}/regions/{region}/instanceTemplates/{instanceTemplate}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="instanceTemplate">The name of the instance template.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceTemplate> Compute_regionInstanceTemplates_getAsync(string project, string region, string instanceTemplate, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instanceTemplates/"+ (instanceTemplate==null? "" : System.Uri.EscapeDataString(instanceTemplate));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceTemplate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates multiple instances in a given region. Count specifies the number of instances to create.
		/// Compute_regionInstances_bulkInsert projects/{project}/regions/{region}/instances/bulkInsert
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionInstances_bulkInsertAsync(string project, string region, string requestId, BulkInsertInstanceResource requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/instances/bulkInsert&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of interconnect attachments contained within the specified region.
		/// Compute_interconnectAttachments_list projects/{project}/regions/{region}/interconnectAttachments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InterconnectAttachmentList> Compute_interconnectAttachments_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/interconnectAttachments&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InterconnectAttachmentList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an InterconnectAttachment in the specified project using the data included in the request.
		/// Compute_interconnectAttachments_insert projects/{project}/regions/{region}/interconnectAttachments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="validateOnly">If true, the request will not be committed.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_interconnectAttachments_insertAsync(string project, string region, string requestId, bool validateOnly, InterconnectAttachment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/interconnectAttachments&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified interconnect attachment.
		/// Compute_interconnectAttachments_delete projects/{project}/regions/{region}/interconnectAttachments/{interconnectAttachment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="interconnectAttachment">Name of the interconnect attachment to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_interconnectAttachments_deleteAsync(string project, string region, string interconnectAttachment, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/interconnectAttachments/"+ (interconnectAttachment==null? "" : System.Uri.EscapeDataString(interconnectAttachment))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified interconnect attachment.
		/// Compute_interconnectAttachments_get projects/{project}/regions/{region}/interconnectAttachments/{interconnectAttachment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="interconnectAttachment">Name of the interconnect attachment to return.</param>
		/// <returns>Successful response</returns>
		public async Task<InterconnectAttachment> Compute_interconnectAttachments_getAsync(string project, string region, string interconnectAttachment, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/interconnectAttachments/"+ (interconnectAttachment==null? "" : System.Uri.EscapeDataString(interconnectAttachment));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InterconnectAttachment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified interconnect attachment with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_interconnectAttachments_patch projects/{project}/regions/{region}/interconnectAttachments/{interconnectAttachment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="interconnectAttachment">Name of the interconnect attachment to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_interconnectAttachments_patchAsync(string project, string region, string interconnectAttachment, string requestId, InterconnectAttachment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/interconnectAttachments/"+ (interconnectAttachment==null? "" : System.Uri.EscapeDataString(interconnectAttachment))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on an InterconnectAttachment. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_interconnectAttachments_setLabels projects/{project}/regions/{region}/interconnectAttachments/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_interconnectAttachments_setLabelsAsync(string project, string region, string resource, string requestId, RegionSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/interconnectAttachments/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the NetworkAttachments for a project in the given scope.
		/// Compute_networkAttachments_list projects/{project}/regions/{region}/networkAttachments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkAttachmentList> Compute_networkAttachments_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkAttachments&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkAttachmentList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a NetworkAttachment in the specified project in the given scope using the parameters that are included in the request.
		/// Compute_networkAttachments_insert projects/{project}/regions/{region}/networkAttachments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000). end_interface: MixerMutationRequestBuilder</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkAttachments_insertAsync(string project, string region, string requestId, NetworkAttachment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkAttachments&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified NetworkAttachment in the given scope
		/// Compute_networkAttachments_delete projects/{project}/regions/{region}/networkAttachments/{networkAttachment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="networkAttachment">Name of the NetworkAttachment resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000). end_interface: MixerMutationRequestBuilder</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkAttachments_deleteAsync(string project, string region, string networkAttachment, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkAttachments/"+ (networkAttachment==null? "" : System.Uri.EscapeDataString(networkAttachment))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified NetworkAttachment resource in the given scope.
		/// Compute_networkAttachments_get projects/{project}/regions/{region}/networkAttachments/{networkAttachment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="networkAttachment">Name of the NetworkAttachment resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkAttachment> Compute_networkAttachments_getAsync(string project, string region, string networkAttachment, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkAttachments/"+ (networkAttachment==null? "" : System.Uri.EscapeDataString(networkAttachment));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkAttachment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified NetworkAttachment resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_networkAttachments_patch projects/{project}/regions/{region}/networkAttachments/{networkAttachment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="networkAttachment">Name of the NetworkAttachment resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000). end_interface: MixerMutationRequestBuilder</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkAttachments_patchAsync(string project, string region, string networkAttachment, string requestId, NetworkAttachment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkAttachments/"+ (networkAttachment==null? "" : System.Uri.EscapeDataString(networkAttachment))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_networkAttachments_getIamPolicy projects/{project}/regions/{region}/networkAttachments/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_networkAttachments_getIamPolicyAsync(string project, string region, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkAttachments/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_networkAttachments_setIamPolicy projects/{project}/regions/{region}/networkAttachments/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_networkAttachments_setIamPolicyAsync(string project, string region, string resource, RegionSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkAttachments/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_networkAttachments_testIamPermissions projects/{project}/regions/{region}/networkAttachments/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_networkAttachments_testIamPermissionsAsync(string project, string region, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkAttachments/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a new service in the specified project using the data included in the request.
		/// Compute_networkEdgeSecurityServices_insert projects/{project}/regions/{region}/networkEdgeSecurityServices
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="validateOnly">If true, the request will not be committed.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkEdgeSecurityServices_insertAsync(string project, string region, string requestId, bool validateOnly, NetworkEdgeSecurityService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEdgeSecurityServices&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified service.
		/// Compute_networkEdgeSecurityServices_delete projects/{project}/regions/{region}/networkEdgeSecurityServices/{networkEdgeSecurityService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="networkEdgeSecurityService">Name of the network edge security service to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkEdgeSecurityServices_deleteAsync(string project, string region, string networkEdgeSecurityService, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEdgeSecurityServices/"+ (networkEdgeSecurityService==null? "" : System.Uri.EscapeDataString(networkEdgeSecurityService))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets a specified NetworkEdgeSecurityService.
		/// Compute_networkEdgeSecurityServices_get projects/{project}/regions/{region}/networkEdgeSecurityServices/{networkEdgeSecurityService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="networkEdgeSecurityService">Name of the network edge security service to get.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEdgeSecurityService> Compute_networkEdgeSecurityServices_getAsync(string project, string region, string networkEdgeSecurityService, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEdgeSecurityServices/"+ (networkEdgeSecurityService==null? "" : System.Uri.EscapeDataString(networkEdgeSecurityService));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEdgeSecurityService>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified policy with the data included in the request.
		/// Compute_networkEdgeSecurityServices_patch projects/{project}/regions/{region}/networkEdgeSecurityServices/{networkEdgeSecurityService}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="networkEdgeSecurityService">Name of the network edge security service to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">Indicates fields to be updated as part of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkEdgeSecurityServices_patchAsync(string project, string region, string networkEdgeSecurityService, string[] paths, string requestId, string updateMask, NetworkEdgeSecurityService requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEdgeSecurityServices/"+ (networkEdgeSecurityService==null? "" : System.Uri.EscapeDataString(networkEdgeSecurityService))+"&"+string.Join("&", paths.Select(z => $"paths={System.Uri.EscapeDataString(z.ToString())}"))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of regional network endpoint groups available to the specified project in the given region.
		/// Compute_regionNetworkEndpointGroups_list projects/{project}/regions/{region}/networkEndpointGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEndpointGroupList> Compute_regionNetworkEndpointGroups_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEndpointGroups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEndpointGroupList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a network endpoint group in the specified project using the parameters that are included in the request.
		/// Compute_regionNetworkEndpointGroups_insert projects/{project}/regions/{region}/networkEndpointGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region where you want to create the network endpoint group. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkEndpointGroups_insertAsync(string project, string region, string requestId, NetworkEndpointGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEndpointGroups&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified network endpoint group. Note that the NEG cannot be deleted if it is configured as a backend of a backend service.
		/// Compute_regionNetworkEndpointGroups_delete projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group to delete. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkEndpointGroups_deleteAsync(string project, string region, string networkEndpointGroup, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified network endpoint group.
		/// Compute_regionNetworkEndpointGroups_get projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group. It should comply with RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEndpointGroup> Compute_regionNetworkEndpointGroups_getAsync(string project, string region, string networkEndpointGroup, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEndpointGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Attach a list of network endpoints to the specified network endpoint group.
		/// Compute_regionNetworkEndpointGroups_attachNetworkEndpoints projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}/attachNetworkEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region where you want to create the network endpoint group. It should comply with RFC1035.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group where you are attaching network endpoints to. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkEndpointGroups_attachNetworkEndpointsAsync(string project, string region, string networkEndpointGroup, string requestId, RegionNetworkEndpointGroupsAttachEndpointsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"/attachNetworkEndpoints&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Detach the network endpoint from the specified network endpoint group.
		/// Compute_regionNetworkEndpointGroups_detachNetworkEndpoints projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}/detachNetworkEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group you are detaching network endpoints from. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000). end_interface: MixerMutationRequestBuilder</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNetworkEndpointGroups_detachNetworkEndpointsAsync(string project, string region, string networkEndpointGroup, string requestId, RegionNetworkEndpointGroupsDetachEndpointsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"/detachNetworkEndpoints&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the network endpoints in the specified network endpoint group.
		/// Compute_regionNetworkEndpointGroups_listNetworkEndpoints projects/{project}/regions/{region}/networkEndpointGroups/{networkEndpointGroup}/listNetworkEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group from which you want to generate a list of included network endpoints. It should comply with RFC1035.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEndpointGroupsListNetworkEndpoints> Compute_regionNetworkEndpointGroups_listNetworkEndpointsAsync(string project, string region, string networkEndpointGroup, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"/listNetworkEndpoints&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEndpointGroupsListNetworkEndpoints>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of node templates available to the specified project.
		/// Compute_nodeTemplates_list projects/{project}/regions/{region}/nodeTemplates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NodeTemplateList> Compute_nodeTemplates_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/nodeTemplates&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeTemplateList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a NodeTemplate resource in the specified project using the data included in the request.
		/// Compute_nodeTemplates_insert projects/{project}/regions/{region}/nodeTemplates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_nodeTemplates_insertAsync(string project, string region, string requestId, NodeTemplate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/nodeTemplates&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified NodeTemplate resource.
		/// Compute_nodeTemplates_delete projects/{project}/regions/{region}/nodeTemplates/{nodeTemplate}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="nodeTemplate">Name of the NodeTemplate resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_nodeTemplates_deleteAsync(string project, string region, string nodeTemplate, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/nodeTemplates/"+ (nodeTemplate==null? "" : System.Uri.EscapeDataString(nodeTemplate))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified node template.
		/// Compute_nodeTemplates_get projects/{project}/regions/{region}/nodeTemplates/{nodeTemplate}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="nodeTemplate">Name of the node template to return.</param>
		/// <returns>Successful response</returns>
		public async Task<NodeTemplate> Compute_nodeTemplates_getAsync(string project, string region, string nodeTemplate, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/nodeTemplates/"+ (nodeTemplate==null? "" : System.Uri.EscapeDataString(nodeTemplate));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeTemplate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_nodeTemplates_getIamPolicy projects/{project}/regions/{region}/nodeTemplates/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_nodeTemplates_getIamPolicyAsync(string project, string region, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/nodeTemplates/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_nodeTemplates_setIamPolicy projects/{project}/regions/{region}/nodeTemplates/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_nodeTemplates_setIamPolicyAsync(string project, string region, string resource, RegionSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/nodeTemplates/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_nodeTemplates_testIamPermissions projects/{project}/regions/{region}/nodeTemplates/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_nodeTemplates_testIamPermissionsAsync(string project, string region, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/nodeTemplates/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the NotificationEndpoints for a project in the given region.
		/// Compute_regionNotificationEndpoints_list projects/{project}/regions/{region}/notificationEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NotificationEndpointList> Compute_regionNotificationEndpoints_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/notificationEndpoints&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NotificationEndpointList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a NotificationEndpoint in the specified project in the given region using the parameters that are included in the request.
		/// Compute_regionNotificationEndpoints_insert projects/{project}/regions/{region}/notificationEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNotificationEndpoints_insertAsync(string project, string region, string requestId, NotificationEndpoint requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/notificationEndpoints&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified NotificationEndpoint in the given region
		/// Compute_regionNotificationEndpoints_delete projects/{project}/regions/{region}/notificationEndpoints/{notificationEndpoint}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="notificationEndpoint">Name of the NotificationEndpoint resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionNotificationEndpoints_deleteAsync(string project, string region, string notificationEndpoint, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/notificationEndpoints/"+ (notificationEndpoint==null? "" : System.Uri.EscapeDataString(notificationEndpoint))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified NotificationEndpoint resource in the given region.
		/// Compute_regionNotificationEndpoints_get projects/{project}/regions/{region}/notificationEndpoints/{notificationEndpoint}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="notificationEndpoint">Name of the NotificationEndpoint resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<NotificationEndpoint> Compute_regionNotificationEndpoints_getAsync(string project, string region, string notificationEndpoint, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/notificationEndpoints/"+ (notificationEndpoint==null? "" : System.Uri.EscapeDataString(notificationEndpoint));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NotificationEndpoint>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of Operation resources contained within the specified region.
		/// Compute_regionOperations_list projects/{project}/regions/{region}/operations
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<OperationList> Compute_regionOperations_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/operations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OperationList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified region-specific Operations resource.
		/// Compute_regionOperations_delete projects/{project}/regions/{region}/operations/{operation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="operation">Name of the Operations resource to delete.</param>
		/// <returns>Successful response</returns>
		public async Task Compute_regionOperations_deleteAsync(string project, string region, string operation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the specified region-specific Operations resource.
		/// Compute_regionOperations_get projects/{project}/regions/{region}/operations/{operation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="operation">Name of the Operations resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionOperations_getAsync(string project, string region, string operation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method differs from the `GET` method in that it waits for no more than the default deadline (2 minutes) and then returns the current state of the operation, which might be `DONE` or still in progress. This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.
		/// Compute_regionOperations_wait projects/{project}/regions/{region}/operations/{operation}/wait
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="operation">Name of the Operations resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionOperations_waitAsync(string project, string region, string operation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation))+"/wait";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of PacketMirroring resources available to the specified project and region.
		/// Compute_packetMirrorings_list projects/{project}/regions/{region}/packetMirrorings
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<PacketMirroringList> Compute_packetMirrorings_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/packetMirrorings&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PacketMirroringList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a PacketMirroring resource in the specified project and region using the data included in the request.
		/// Compute_packetMirrorings_insert projects/{project}/regions/{region}/packetMirrorings
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_packetMirrorings_insertAsync(string project, string region, string requestId, PacketMirroring requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/packetMirrorings&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified PacketMirroring resource.
		/// Compute_packetMirrorings_delete projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="packetMirroring">Name of the PacketMirroring resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_packetMirrorings_deleteAsync(string project, string region, string packetMirroring, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/packetMirrorings/"+ (packetMirroring==null? "" : System.Uri.EscapeDataString(packetMirroring))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified PacketMirroring resource.
		/// Compute_packetMirrorings_get projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="packetMirroring">Name of the PacketMirroring resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<PacketMirroring> Compute_packetMirrorings_getAsync(string project, string region, string packetMirroring, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/packetMirrorings/"+ (packetMirroring==null? "" : System.Uri.EscapeDataString(packetMirroring));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PacketMirroring>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified PacketMirroring resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_packetMirrorings_patch projects/{project}/regions/{region}/packetMirrorings/{packetMirroring}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="packetMirroring">Name of the PacketMirroring resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_packetMirrorings_patchAsync(string project, string region, string packetMirroring, string requestId, PacketMirroring requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/packetMirrorings/"+ (packetMirroring==null? "" : System.Uri.EscapeDataString(packetMirroring))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_packetMirrorings_testIamPermissions projects/{project}/regions/{region}/packetMirrorings/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_packetMirrorings_testIamPermissionsAsync(string project, string region, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/packetMirrorings/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the PublicDelegatedPrefixes for a project in the given region.
		/// Compute_publicDelegatedPrefixes_list projects/{project}/regions/{region}/publicDelegatedPrefixes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<PublicDelegatedPrefixList> Compute_publicDelegatedPrefixes_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/publicDelegatedPrefixes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PublicDelegatedPrefixList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a PublicDelegatedPrefix in the specified project in the given region using the parameters that are included in the request.
		/// Compute_publicDelegatedPrefixes_insert projects/{project}/regions/{region}/publicDelegatedPrefixes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_publicDelegatedPrefixes_insertAsync(string project, string region, string requestId, PublicDelegatedPrefix requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/publicDelegatedPrefixes&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified PublicDelegatedPrefix in the given region.
		/// Compute_publicDelegatedPrefixes_delete projects/{project}/regions/{region}/publicDelegatedPrefixes/{publicDelegatedPrefix}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="publicDelegatedPrefix">Name of the PublicDelegatedPrefix resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_publicDelegatedPrefixes_deleteAsync(string project, string region, string publicDelegatedPrefix, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/publicDelegatedPrefixes/"+ (publicDelegatedPrefix==null? "" : System.Uri.EscapeDataString(publicDelegatedPrefix))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified PublicDelegatedPrefix resource in the given region.
		/// Compute_publicDelegatedPrefixes_get projects/{project}/regions/{region}/publicDelegatedPrefixes/{publicDelegatedPrefix}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="publicDelegatedPrefix">Name of the PublicDelegatedPrefix resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<PublicDelegatedPrefix> Compute_publicDelegatedPrefixes_getAsync(string project, string region, string publicDelegatedPrefix, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/publicDelegatedPrefixes/"+ (publicDelegatedPrefix==null? "" : System.Uri.EscapeDataString(publicDelegatedPrefix));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PublicDelegatedPrefix>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified PublicDelegatedPrefix resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_publicDelegatedPrefixes_patch projects/{project}/regions/{region}/publicDelegatedPrefixes/{publicDelegatedPrefix}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="publicDelegatedPrefix">Name of the PublicDelegatedPrefix resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_publicDelegatedPrefixes_patchAsync(string project, string region, string publicDelegatedPrefix, string requestId, PublicDelegatedPrefix requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/publicDelegatedPrefixes/"+ (publicDelegatedPrefix==null? "" : System.Uri.EscapeDataString(publicDelegatedPrefix))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Announces the specified PublicDelegatedPrefix in the given region.
		/// Compute_publicDelegatedPrefixes_announce projects/{project}/regions/{region}/publicDelegatedPrefixes/{publicDelegatedPrefix}/announce
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region where the public delegated prefix is located. It should comply with RFC1035.</param>
		/// <param name="publicDelegatedPrefix">The name of the public delegated prefix. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_publicDelegatedPrefixes_announceAsync(string project, string region, string publicDelegatedPrefix, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/publicDelegatedPrefixes/"+ (publicDelegatedPrefix==null? "" : System.Uri.EscapeDataString(publicDelegatedPrefix))+"/announce&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Withdraws the specified PublicDelegatedPrefix in the given region.
		/// Compute_publicDelegatedPrefixes_withdraw projects/{project}/regions/{region}/publicDelegatedPrefixes/{publicDelegatedPrefix}/withdraw
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region where the public delegated prefix is located. It should comply with RFC1035.</param>
		/// <param name="publicDelegatedPrefix">The name of the public delegated prefix. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_publicDelegatedPrefixes_withdrawAsync(string project, string region, string publicDelegatedPrefix, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/publicDelegatedPrefixes/"+ (publicDelegatedPrefix==null? "" : System.Uri.EscapeDataString(publicDelegatedPrefix))+"/withdraw&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// A list all the resource policies that have been configured for the specified project in specified region.
		/// Compute_resourcePolicies_list projects/{project}/regions/{region}/resourcePolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ResourcePolicyList> Compute_resourcePolicies_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/resourcePolicies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourcePolicyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new resource policy.
		/// Compute_resourcePolicies_insert projects/{project}/regions/{region}/resourcePolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_resourcePolicies_insertAsync(string project, string region, string requestId, ResourcePolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/resourcePolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified resource policy.
		/// Compute_resourcePolicies_delete projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="resourcePolicy">Name of the resource policy to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_resourcePolicies_deleteAsync(string project, string region, string resourcePolicy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/resourcePolicies/"+ (resourcePolicy==null? "" : System.Uri.EscapeDataString(resourcePolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves all information of the specified resource policy.
		/// Compute_resourcePolicies_get projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="resourcePolicy">Name of the resource policy to retrieve.</param>
		/// <returns>Successful response</returns>
		public async Task<ResourcePolicy> Compute_resourcePolicies_getAsync(string project, string region, string resourcePolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/resourcePolicies/"+ (resourcePolicy==null? "" : System.Uri.EscapeDataString(resourcePolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ResourcePolicy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modify the specified resource policy.
		/// Compute_resourcePolicies_patch projects/{project}/regions/{region}/resourcePolicies/{resourcePolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="resourcePolicy">Id of the resource policy to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">update_mask indicates fields to be updated as part of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_resourcePolicies_patchAsync(string project, string region, string resourcePolicy, string requestId, string updateMask, ResourcePolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/resourcePolicies/"+ (resourcePolicy==null? "" : System.Uri.EscapeDataString(resourcePolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_resourcePolicies_getIamPolicy projects/{project}/regions/{region}/resourcePolicies/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_resourcePolicies_getIamPolicyAsync(string project, string region, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/resourcePolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_resourcePolicies_setIamPolicy projects/{project}/regions/{region}/resourcePolicies/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_resourcePolicies_setIamPolicyAsync(string project, string region, string resource, RegionSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/resourcePolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_resourcePolicies_testIamPermissions projects/{project}/regions/{region}/resourcePolicies/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_resourcePolicies_testIamPermissionsAsync(string project, string region, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/resourcePolicies/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of Router resources available to the specified project.
		/// Compute_routers_list projects/{project}/regions/{region}/routers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<RouterList> Compute_routers_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/routers&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RouterList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a Router resource in the specified project and region using the data included in the request.
		/// Compute_routers_insert projects/{project}/regions/{region}/routers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_routers_insertAsync(string project, string region, string requestId, Router requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/routers&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified Router resource.
		/// Compute_routers_delete projects/{project}/regions/{region}/routers/{router}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="router">Name of the Router resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_routers_deleteAsync(string project, string region, string router, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/routers/"+ (router==null? "" : System.Uri.EscapeDataString(router))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified Router resource.
		/// Compute_routers_get projects/{project}/regions/{region}/routers/{router}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="router">Name of the Router resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Router> Compute_routers_getAsync(string project, string region, string router, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/routers/"+ (router==null? "" : System.Uri.EscapeDataString(router));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Router>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified Router resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_routers_patch projects/{project}/regions/{region}/routers/{router}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="router">Name of the Router resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_routers_patchAsync(string project, string region, string router, string requestId, Router requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/routers/"+ (router==null? "" : System.Uri.EscapeDataString(router))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the specified Router resource with the data included in the request. This method conforms to PUT semantics, which requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload.
		/// Compute_routers_update projects/{project}/regions/{region}/routers/{router}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="router">Name of the Router resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_routers_updateAsync(string project, string region, string router, string requestId, Router requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/routers/"+ (router==null? "" : System.Uri.EscapeDataString(router))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves runtime NAT IP information.
		/// Compute_routers_getNatIpInfo projects/{project}/regions/{region}/routers/{router}/getNatIpInfo
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="router">Name of the Router resource to query for Nat IP information. The name should conform to RFC1035.</param>
		/// <param name="natName">Name of the nat service to filter the NAT IP information. If it is omitted, all nats for this router will be returned. Name should conform to RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<NatIpInfoResponse> Compute_routers_getNatIpInfoAsync(string project, string region, string router, string natName, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/routers/"+ (router==null? "" : System.Uri.EscapeDataString(router))+"/getNatIpInfo&natName=" + (natName==null? "" : System.Uri.EscapeDataString(natName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NatIpInfoResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves runtime Nat mapping information of VM endpoints.
		/// Compute_routers_getNatMappingInfo projects/{project}/regions/{region}/routers/{router}/getNatMappingInfo
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="router">Name of the Router resource to query for Nat Mapping information of VM endpoints.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="natName">Name of the nat service to filter the Nat Mapping information. If it is omitted, all nats for this router will be returned. Name should conform to RFC1035.</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<VmEndpointNatMappingsList> Compute_routers_getNatMappingInfoAsync(string project, string region, string router, string filter, int maxResults, string natName, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/routers/"+ (router==null? "" : System.Uri.EscapeDataString(router))+"/getNatMappingInfo&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&natName=" + (natName==null? "" : System.Uri.EscapeDataString(natName))+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VmEndpointNatMappingsList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves runtime information of the specified router.
		/// Compute_routers_getRouterStatus projects/{project}/regions/{region}/routers/{router}/getRouterStatus
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="router">Name of the Router resource to query.</param>
		/// <returns>Successful response</returns>
		public async Task<RouterStatusResponse> Compute_routers_getRouterStatusAsync(string project, string region, string router, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/routers/"+ (router==null? "" : System.Uri.EscapeDataString(router))+"/getRouterStatus";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RouterStatusResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Preview fields auto-generated during router create and update operations. Calling this method does NOT create or update the router.
		/// Compute_routers_preview projects/{project}/regions/{region}/routers/{router}/preview
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="router">Name of the Router resource to query.</param>
		/// <returns>Successful response</returns>
		public async Task<RoutersPreviewResponse> Compute_routers_previewAsync(string project, string region, string router, Router requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/routers/"+ (router==null? "" : System.Uri.EscapeDataString(router))+"/preview";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RoutersPreviewResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List all the policies that have been configured for the specified project and region.
		/// Compute_regionSecurityPolicies_list projects/{project}/regions/{region}/securityPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SecurityPolicyList> Compute_regionSecurityPolicies_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/securityPolicies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SecurityPolicyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new policy in the specified project using the data included in the request.
		/// Compute_regionSecurityPolicies_insert projects/{project}/regions/{region}/securityPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="validateOnly">If true, the request will not be committed.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSecurityPolicies_insertAsync(string project, string region, string requestId, bool validateOnly, SecurityPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/securityPolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified policy.
		/// Compute_regionSecurityPolicies_delete projects/{project}/regions/{region}/securityPolicies/{securityPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="securityPolicy">Name of the security policy to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSecurityPolicies_deleteAsync(string project, string region, string securityPolicy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all of the ordered rules present in a single specified policy.
		/// Compute_regionSecurityPolicies_get projects/{project}/regions/{region}/securityPolicies/{securityPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="securityPolicy">Name of the security policy to get.</param>
		/// <returns>Successful response</returns>
		public async Task<SecurityPolicy> Compute_regionSecurityPolicies_getAsync(string project, string region, string securityPolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SecurityPolicy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified policy with the data included in the request. To clear fields in the policy, leave the fields empty and specify them in the updateMask. This cannot be used to be update the rules in the policy. Please use the per rule methods like addRule, patchRule, and removeRule instead.
		/// Compute_regionSecurityPolicies_patch projects/{project}/regions/{region}/securityPolicies/{securityPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="securityPolicy">Name of the security policy to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">Indicates fields to be cleared as part of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSecurityPolicies_patchAsync(string project, string region, string securityPolicy, string requestId, string updateMask, SecurityPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts a rule into a security policy.
		/// Compute_regionSecurityPolicies_addRule projects/{project}/regions/{region}/securityPolicies/{securityPolicy}/addRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="securityPolicy">Name of the security policy to update.</param>
		/// <param name="validateOnly">If true, the request will not be committed.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSecurityPolicies_addRuleAsync(string project, string region, string securityPolicy, bool validateOnly, SecurityPolicyRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"/addRule&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets a rule at the specified priority.
		/// Compute_regionSecurityPolicies_getRule projects/{project}/regions/{region}/securityPolicies/{securityPolicy}/getRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="securityPolicy">Name of the security policy to which the queried rule belongs.</param>
		/// <param name="priority">The priority of the rule to get from the security policy.</param>
		/// <returns>Successful response</returns>
		public async Task<SecurityPolicyRule> Compute_regionSecurityPolicies_getRuleAsync(string project, string region, string securityPolicy, int priority, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"/getRule&priority="+priority;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SecurityPolicyRule>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches a rule at the specified priority. To clear fields in the rule, leave the fields empty and specify them in the updateMask.
		/// Compute_regionSecurityPolicies_patchRule projects/{project}/regions/{region}/securityPolicies/{securityPolicy}/patchRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="securityPolicy">Name of the security policy to update.</param>
		/// <param name="priority">The priority of the rule to patch.</param>
		/// <param name="updateMask">Indicates fields to be cleared as part of this request.</param>
		/// <param name="validateOnly">If true, the request will not be committed.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSecurityPolicies_patchRuleAsync(string project, string region, string securityPolicy, int priority, string updateMask, bool validateOnly, SecurityPolicyRule requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"/patchRule&priority="+priority+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask))+"&validateOnly="+validateOnly;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes a rule at the specified priority.
		/// Compute_regionSecurityPolicies_removeRule projects/{project}/regions/{region}/securityPolicies/{securityPolicy}/removeRule
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="securityPolicy">Name of the security policy to update.</param>
		/// <param name="priority">The priority of the rule to remove from the security policy.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSecurityPolicies_removeRuleAsync(string project, string region, string securityPolicy, int priority, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/securityPolicies/"+ (securityPolicy==null? "" : System.Uri.EscapeDataString(securityPolicy))+"/removeRule&priority="+priority;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists the ServiceAttachments for a project in the given scope.
		/// Compute_serviceAttachments_list projects/{project}/regions/{region}/serviceAttachments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ServiceAttachmentList> Compute_serviceAttachments_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/serviceAttachments&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ServiceAttachmentList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a ServiceAttachment in the specified project in the given scope using the parameters that are included in the request.
		/// Compute_serviceAttachments_insert projects/{project}/regions/{region}/serviceAttachments
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_serviceAttachments_insertAsync(string project, string region, string requestId, ServiceAttachment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/serviceAttachments&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_serviceAttachments_getIamPolicy projects/{project}/regions/{region}/serviceAttachments/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_serviceAttachments_getIamPolicyAsync(string project, string region, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/serviceAttachments/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_serviceAttachments_setIamPolicy projects/{project}/regions/{region}/serviceAttachments/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_serviceAttachments_setIamPolicyAsync(string project, string region, string resource, RegionSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/serviceAttachments/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_serviceAttachments_testIamPermissions projects/{project}/regions/{region}/serviceAttachments/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_serviceAttachments_testIamPermissionsAsync(string project, string region, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/serviceAttachments/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified ServiceAttachment in the given scope
		/// Compute_serviceAttachments_delete projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="serviceAttachment">Name of the ServiceAttachment resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_serviceAttachments_deleteAsync(string project, string region, string serviceAttachment, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/serviceAttachments/"+ (serviceAttachment==null? "" : System.Uri.EscapeDataString(serviceAttachment))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified ServiceAttachment resource in the given scope.
		/// Compute_serviceAttachments_get projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region of this request.</param>
		/// <param name="serviceAttachment">Name of the ServiceAttachment resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<ServiceAttachment> Compute_serviceAttachments_getAsync(string project, string region, string serviceAttachment, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/serviceAttachments/"+ (serviceAttachment==null? "" : System.Uri.EscapeDataString(serviceAttachment));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ServiceAttachment>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified ServiceAttachment resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_serviceAttachments_patch projects/{project}/regions/{region}/serviceAttachments/{serviceAttachment}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The region scoping this request and should conform to RFC1035.</param>
		/// <param name="serviceAttachment">The resource id of the ServiceAttachment to patch. It should conform to RFC1035 resource name or be a string form on an unsigned long number.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_serviceAttachments_patchAsync(string project, string region, string serviceAttachment, string requestId, ServiceAttachment requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/serviceAttachments/"+ (serviceAttachment==null? "" : System.Uri.EscapeDataString(serviceAttachment))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of SslCertificate resources available to the specified project in the specified region.
		/// Compute_regionSslCertificates_list projects/{project}/regions/{region}/sslCertificates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SslCertificateList> Compute_regionSslCertificates_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/sslCertificates&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslCertificateList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a SslCertificate resource in the specified project and region using the data included in the request
		/// Compute_regionSslCertificates_insert projects/{project}/regions/{region}/sslCertificates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSslCertificates_insertAsync(string project, string region, string requestId, SslCertificate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/sslCertificates&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified SslCertificate resource in the region.
		/// Compute_regionSslCertificates_delete projects/{project}/regions/{region}/sslCertificates/{sslCertificate}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="sslCertificate">Name of the SslCertificate resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSslCertificates_deleteAsync(string project, string region, string sslCertificate, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/sslCertificates/"+ (sslCertificate==null? "" : System.Uri.EscapeDataString(sslCertificate))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified SslCertificate resource in the specified region. Get a list of available SSL certificates by making a list() request.
		/// Compute_regionSslCertificates_get projects/{project}/regions/{region}/sslCertificates/{sslCertificate}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="sslCertificate">Name of the SslCertificate resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<SslCertificate> Compute_regionSslCertificates_getAsync(string project, string region, string sslCertificate, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/sslCertificates/"+ (sslCertificate==null? "" : System.Uri.EscapeDataString(sslCertificate));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslCertificate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all the SSL policies that have been configured for the specified project and region.
		/// Compute_regionSslPolicies_list projects/{project}/regions/{region}/sslPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SslPoliciesList> Compute_regionSslPolicies_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/sslPolicies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslPoliciesList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new policy in the specified project and region using the data included in the request.
		/// Compute_regionSslPolicies_insert projects/{project}/regions/{region}/sslPolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSslPolicies_insertAsync(string project, string region, string requestId, SslPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/sslPolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all features that can be specified in the SSL policy when using custom profile.
		/// Compute_regionSslPolicies_listAvailableFeatures projects/{project}/regions/{region}/sslPolicies/listAvailableFeatures
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SslPoliciesListAvailableFeaturesResponse> Compute_regionSslPolicies_listAvailableFeaturesAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/sslPolicies/listAvailableFeatures&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslPoliciesListAvailableFeaturesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified SSL policy. The SSL policy resource can be deleted only if it is not in use by any TargetHttpsProxy or TargetSslProxy resources.
		/// Compute_regionSslPolicies_delete projects/{project}/regions/{region}/sslPolicies/{sslPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="sslPolicy">Name of the SSL policy to delete. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSslPolicies_deleteAsync(string project, string region, string sslPolicy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/sslPolicies/"+ (sslPolicy==null? "" : System.Uri.EscapeDataString(sslPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all of the ordered rules present in a single specified policy.
		/// Compute_regionSslPolicies_get projects/{project}/regions/{region}/sslPolicies/{sslPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="sslPolicy">Name of the SSL policy to update. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<SslPolicy> Compute_regionSslPolicies_getAsync(string project, string region, string sslPolicy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/sslPolicies/"+ (sslPolicy==null? "" : System.Uri.EscapeDataString(sslPolicy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SslPolicy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified SSL policy with the data included in the request.
		/// Compute_regionSslPolicies_patch projects/{project}/regions/{region}/sslPolicies/{sslPolicy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="sslPolicy">Name of the SSL policy to update. The name must be 1-63 characters long, and comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionSslPolicies_patchAsync(string project, string region, string sslPolicy, string requestId, SslPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/sslPolicies/"+ (sslPolicy==null? "" : System.Uri.EscapeDataString(sslPolicy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of subnetworks available to the specified project.
		/// Compute_subnetworks_list projects/{project}/regions/{region}/subnetworks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<SubnetworkList> Compute_subnetworks_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/subnetworks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SubnetworkList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a subnetwork in the specified project using the data included in the request.
		/// Compute_subnetworks_insert projects/{project}/regions/{region}/subnetworks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_subnetworks_insertAsync(string project, string region, string requestId, Subnetwork requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/subnetworks&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_subnetworks_getIamPolicy projects/{project}/regions/{region}/subnetworks/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_subnetworks_getIamPolicyAsync(string project, string region, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/subnetworks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_subnetworks_setIamPolicy projects/{project}/regions/{region}/subnetworks/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_subnetworks_setIamPolicyAsync(string project, string region, string resource, RegionSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/subnetworks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_subnetworks_testIamPermissions projects/{project}/regions/{region}/subnetworks/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_subnetworks_testIamPermissionsAsync(string project, string region, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/subnetworks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified subnetwork.
		/// Compute_subnetworks_delete projects/{project}/regions/{region}/subnetworks/{subnetwork}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="subnetwork">Name of the Subnetwork resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_subnetworks_deleteAsync(string project, string region, string subnetwork, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/subnetworks/"+ (subnetwork==null? "" : System.Uri.EscapeDataString(subnetwork))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified subnetwork.
		/// Compute_subnetworks_get projects/{project}/regions/{region}/subnetworks/{subnetwork}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="subnetwork">Name of the Subnetwork resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Subnetwork> Compute_subnetworks_getAsync(string project, string region, string subnetwork, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/subnetworks/"+ (subnetwork==null? "" : System.Uri.EscapeDataString(subnetwork));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Subnetwork>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified subnetwork with the data included in the request. Only certain fields can be updated with a patch request as indicated in the field descriptions. You must specify the current fingerprint of the subnetwork resource being patched.
		/// Compute_subnetworks_patch projects/{project}/regions/{region}/subnetworks/{subnetwork}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="subnetwork">Name of the Subnetwork resource to patch.</param>
		/// <param name="drainTimeoutSeconds">The drain timeout specifies the upper bound in seconds on the amount of time allowed to drain connections from the current ACTIVE subnetwork to the current BACKUP subnetwork. The drain timeout is only applicable when the following conditions are true: - the subnetwork being patched has purpose = INTERNAL_HTTPS_LOAD_BALANCER - the subnetwork being patched has role = BACKUP - the patch request is setting the role to ACTIVE. Note that after this patch operation the roles of the ACTIVE and BACKUP subnetworks will be swapped.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_subnetworks_patchAsync(string project, string region, string subnetwork, int drainTimeoutSeconds, string requestId, Subnetwork requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/subnetworks/"+ (subnetwork==null? "" : System.Uri.EscapeDataString(subnetwork))+"&drainTimeoutSeconds="+drainTimeoutSeconds+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Expands the IP CIDR range of the subnetwork to a specified value.
		/// Compute_subnetworks_expandIpCidrRange projects/{project}/regions/{region}/subnetworks/{subnetwork}/expandIpCidrRange
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="subnetwork">Name of the Subnetwork resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_subnetworks_expandIpCidrRangeAsync(string project, string region, string subnetwork, string requestId, SubnetworksExpandIpCidrRangeRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/subnetworks/"+ (subnetwork==null? "" : System.Uri.EscapeDataString(subnetwork))+"/expandIpCidrRange&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Set whether VMs in this subnet can access Google services without assigning external IP addresses through Private Google Access.
		/// Compute_subnetworks_setPrivateIpGoogleAccess projects/{project}/regions/{region}/subnetworks/{subnetwork}/setPrivateIpGoogleAccess
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="subnetwork">Name of the Subnetwork resource.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_subnetworks_setPrivateIpGoogleAccessAsync(string project, string region, string subnetwork, string requestId, SubnetworksSetPrivateIpGoogleAccessRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/subnetworks/"+ (subnetwork==null? "" : System.Uri.EscapeDataString(subnetwork))+"/setPrivateIpGoogleAccess&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of TargetHttpProxy resources available to the specified project in the specified region.
		/// Compute_regionTargetHttpProxies_list projects/{project}/regions/{region}/targetHttpProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetHttpProxyList> Compute_regionTargetHttpProxies_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetHttpProxyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a TargetHttpProxy resource in the specified project and region using the data included in the request.
		/// Compute_regionTargetHttpProxies_insert projects/{project}/regions/{region}/targetHttpProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionTargetHttpProxies_insertAsync(string project, string region, string requestId, TargetHttpProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpProxies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified TargetHttpProxy resource.
		/// Compute_regionTargetHttpProxies_delete projects/{project}/regions/{region}/targetHttpProxies/{targetHttpProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetHttpProxy">Name of the TargetHttpProxy resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionTargetHttpProxies_deleteAsync(string project, string region, string targetHttpProxy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpProxies/"+ (targetHttpProxy==null? "" : System.Uri.EscapeDataString(targetHttpProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified TargetHttpProxy resource in the specified region.
		/// Compute_regionTargetHttpProxies_get projects/{project}/regions/{region}/targetHttpProxies/{targetHttpProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetHttpProxy">Name of the TargetHttpProxy resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetHttpProxy> Compute_regionTargetHttpProxies_getAsync(string project, string region, string targetHttpProxy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpProxies/"+ (targetHttpProxy==null? "" : System.Uri.EscapeDataString(targetHttpProxy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetHttpProxy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Changes the URL map for TargetHttpProxy.
		/// Compute_regionTargetHttpProxies_setUrlMap projects/{project}/regions/{region}/targetHttpProxies/{targetHttpProxy}/setUrlMap
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetHttpProxy">Name of the TargetHttpProxy to set a URL map for.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionTargetHttpProxies_setUrlMapAsync(string project, string region, string targetHttpProxy, string requestId, UrlMapReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpProxies/"+ (targetHttpProxy==null? "" : System.Uri.EscapeDataString(targetHttpProxy))+"/setUrlMap&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of TargetHttpsProxy resources available to the specified project in the specified region.
		/// Compute_regionTargetHttpsProxies_list projects/{project}/regions/{region}/targetHttpsProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetHttpsProxyList> Compute_regionTargetHttpsProxies_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpsProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetHttpsProxyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a TargetHttpsProxy resource in the specified project and region using the data included in the request.
		/// Compute_regionTargetHttpsProxies_insert projects/{project}/regions/{region}/targetHttpsProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionTargetHttpsProxies_insertAsync(string project, string region, string requestId, TargetHttpsProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpsProxies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified TargetHttpsProxy resource.
		/// Compute_regionTargetHttpsProxies_delete projects/{project}/regions/{region}/targetHttpsProxies/{targetHttpsProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionTargetHttpsProxies_deleteAsync(string project, string region, string targetHttpsProxy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified TargetHttpsProxy resource in the specified region.
		/// Compute_regionTargetHttpsProxies_get projects/{project}/regions/{region}/targetHttpsProxies/{targetHttpsProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetHttpsProxy> Compute_regionTargetHttpsProxies_getAsync(string project, string region, string targetHttpsProxy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetHttpsProxy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified regional TargetHttpsProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_regionTargetHttpsProxies_patch projects/{project}/regions/{region}/targetHttpsProxies/{targetHttpsProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionTargetHttpsProxies_patchAsync(string project, string region, string targetHttpsProxy, string requestId, TargetHttpsProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Replaces SslCertificates for TargetHttpsProxy.
		/// Compute_regionTargetHttpsProxies_setSslCertificates projects/{project}/regions/{region}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource to set an SslCertificates resource for.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionTargetHttpsProxies_setSslCertificatesAsync(string project, string region, string targetHttpsProxy, string requestId, RegionTargetHttpsProxiesSetSslCertificatesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"/setSslCertificates&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the URL map for TargetHttpsProxy.
		/// Compute_regionTargetHttpsProxies_setUrlMap projects/{project}/regions/{region}/targetHttpsProxies/{targetHttpsProxy}/setUrlMap
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy to set a URL map for.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionTargetHttpsProxies_setUrlMapAsync(string project, string region, string targetHttpsProxy, string requestId, UrlMapReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"/setUrlMap&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of target pools available to the specified project and region.
		/// Compute_targetPools_list projects/{project}/regions/{region}/targetPools
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetPoolList> Compute_targetPools_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetPoolList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a target pool in the specified project and region using the data included in the request.
		/// Compute_targetPools_insert projects/{project}/regions/{region}/targetPools
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetPools_insertAsync(string project, string region, string requestId, TargetPool requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified target pool.
		/// Compute_targetPools_delete projects/{project}/regions/{region}/targetPools/{targetPool}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetPool">Name of the TargetPool resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetPools_deleteAsync(string project, string region, string targetPool, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools/"+ (targetPool==null? "" : System.Uri.EscapeDataString(targetPool))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified target pool.
		/// Compute_targetPools_get projects/{project}/regions/{region}/targetPools/{targetPool}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetPool">Name of the TargetPool resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetPool> Compute_targetPools_getAsync(string project, string region, string targetPool, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools/"+ (targetPool==null? "" : System.Uri.EscapeDataString(targetPool));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetPool>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds health check URLs to a target pool.
		/// Compute_targetPools_addHealthCheck projects/{project}/regions/{region}/targetPools/{targetPool}/addHealthCheck
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetPool">Name of the target pool to add a health check to.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetPools_addHealthCheckAsync(string project, string region, string targetPool, string requestId, TargetPoolsAddHealthCheckRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools/"+ (targetPool==null? "" : System.Uri.EscapeDataString(targetPool))+"/addHealthCheck&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds an instance to a target pool.
		/// Compute_targetPools_addInstance projects/{project}/regions/{region}/targetPools/{targetPool}/addInstance
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetPool">Name of the TargetPool resource to add instances to.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetPools_addInstanceAsync(string project, string region, string targetPool, string requestId, TargetPoolsAddInstanceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools/"+ (targetPool==null? "" : System.Uri.EscapeDataString(targetPool))+"/addInstance&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the most recent health check results for each IP for the instance that is referenced by the given target pool.
		/// Compute_targetPools_getHealth projects/{project}/regions/{region}/targetPools/{targetPool}/getHealth
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetPool">Name of the TargetPool resource to which the queried instance belongs.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetPoolInstanceHealth> Compute_targetPools_getHealthAsync(string project, string region, string targetPool, InstanceReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools/"+ (targetPool==null? "" : System.Uri.EscapeDataString(targetPool))+"/getHealth";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetPoolInstanceHealth>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes health check URL from a target pool.
		/// Compute_targetPools_removeHealthCheck projects/{project}/regions/{region}/targetPools/{targetPool}/removeHealthCheck
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="targetPool">Name of the target pool to remove health checks from.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetPools_removeHealthCheckAsync(string project, string region, string targetPool, string requestId, TargetPoolsRemoveHealthCheckRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools/"+ (targetPool==null? "" : System.Uri.EscapeDataString(targetPool))+"/removeHealthCheck&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes instance URL from a target pool.
		/// Compute_targetPools_removeInstance projects/{project}/regions/{region}/targetPools/{targetPool}/removeInstance
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetPool">Name of the TargetPool resource to remove instances from.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetPools_removeInstanceAsync(string project, string region, string targetPool, string requestId, TargetPoolsRemoveInstanceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools/"+ (targetPool==null? "" : System.Uri.EscapeDataString(targetPool))+"/removeInstance&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes a backup target pool's configurations.
		/// Compute_targetPools_setBackup projects/{project}/regions/{region}/targetPools/{targetPool}/setBackup
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetPool">Name of the TargetPool resource to set a backup pool for.</param>
		/// <param name="failoverRatio">New failoverRatio value for the target pool.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetPools_setBackupAsync(string project, string region, string targetPool, double failoverRatio, string requestId, TargetReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools/"+ (targetPool==null? "" : System.Uri.EscapeDataString(targetPool))+"/setBackup&failoverRatio="+failoverRatio+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the Google Cloud Armor security policy for the specified target pool. For more information, see Google Cloud Armor Overview
		/// Compute_targetPools_setSecurityPolicy projects/{project}/regions/{region}/targetPools/{targetPool}/setSecurityPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetPool">Name of the TargetPool resource to which the security policy should be set. The name should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetPools_setSecurityPolicyAsync(string project, string region, string targetPool, string requestId, SecurityPolicyReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetPools/"+ (targetPool==null? "" : System.Uri.EscapeDataString(targetPool))+"/setSecurityPolicy&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of TargetTcpProxy resources available to the specified project in a given region.
		/// Compute_regionTargetTcpProxies_list projects/{project}/regions/{region}/targetTcpProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetTcpProxyList> Compute_regionTargetTcpProxies_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetTcpProxies&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetTcpProxyList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a TargetTcpProxy resource in the specified project and region using the data included in the request.
		/// Compute_regionTargetTcpProxies_insert projects/{project}/regions/{region}/targetTcpProxies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionTargetTcpProxies_insertAsync(string project, string region, string requestId, TargetTcpProxy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetTcpProxies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified TargetTcpProxy resource.
		/// Compute_regionTargetTcpProxies_delete projects/{project}/regions/{region}/targetTcpProxies/{targetTcpProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetTcpProxy">Name of the TargetTcpProxy resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionTargetTcpProxies_deleteAsync(string project, string region, string targetTcpProxy, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetTcpProxies/"+ (targetTcpProxy==null? "" : System.Uri.EscapeDataString(targetTcpProxy))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified TargetTcpProxy resource.
		/// Compute_regionTargetTcpProxies_get projects/{project}/regions/{region}/targetTcpProxies/{targetTcpProxy}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="targetTcpProxy">Name of the TargetTcpProxy resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetTcpProxy> Compute_regionTargetTcpProxies_getAsync(string project, string region, string targetTcpProxy, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetTcpProxies/"+ (targetTcpProxy==null? "" : System.Uri.EscapeDataString(targetTcpProxy));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetTcpProxy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of target VPN gateways available to the specified project and region.
		/// Compute_targetVpnGateways_list projects/{project}/regions/{region}/targetVpnGateways
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetVpnGatewayList> Compute_targetVpnGateways_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetVpnGateways&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetVpnGatewayList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a target VPN gateway in the specified project and region using the data included in the request.
		/// Compute_targetVpnGateways_insert projects/{project}/regions/{region}/targetVpnGateways
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetVpnGateways_insertAsync(string project, string region, string requestId, TargetVpnGateway requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetVpnGateways&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on a TargetVpnGateway. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_targetVpnGateways_setLabels projects/{project}/regions/{region}/targetVpnGateways/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetVpnGateways_setLabelsAsync(string project, string region, string resource, string requestId, RegionSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetVpnGateways/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified target VPN gateway.
		/// Compute_targetVpnGateways_delete projects/{project}/regions/{region}/targetVpnGateways/{targetVpnGateway}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="targetVpnGateway">Name of the target VPN gateway to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetVpnGateways_deleteAsync(string project, string region, string targetVpnGateway, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetVpnGateways/"+ (targetVpnGateway==null? "" : System.Uri.EscapeDataString(targetVpnGateway))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified target VPN gateway.
		/// Compute_targetVpnGateways_get projects/{project}/regions/{region}/targetVpnGateways/{targetVpnGateway}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="targetVpnGateway">Name of the target VPN gateway to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetVpnGateway> Compute_targetVpnGateways_getAsync(string project, string region, string targetVpnGateway, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/targetVpnGateways/"+ (targetVpnGateway==null? "" : System.Uri.EscapeDataString(targetVpnGateway));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetVpnGateway>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of UrlMap resources available to the specified project in the specified region.
		/// Compute_regionUrlMaps_list projects/{project}/regions/{region}/urlMaps
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<UrlMapList> Compute_regionUrlMaps_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/urlMaps&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UrlMapList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a UrlMap resource in the specified project using the data included in the request.
		/// Compute_regionUrlMaps_insert projects/{project}/regions/{region}/urlMaps
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="requestId">begin_interface: MixerMutationRequestBuilder Request ID to support idempotency.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionUrlMaps_insertAsync(string project, string region, string requestId, UrlMap requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/urlMaps&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified UrlMap resource.
		/// Compute_regionUrlMaps_delete projects/{project}/regions/{region}/urlMaps/{urlMap}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="urlMap">Name of the UrlMap resource to delete.</param>
		/// <param name="requestId">begin_interface: MixerMutationRequestBuilder Request ID to support idempotency.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionUrlMaps_deleteAsync(string project, string region, string urlMap, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified UrlMap resource.
		/// Compute_regionUrlMaps_get projects/{project}/regions/{region}/urlMaps/{urlMap}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="urlMap">Name of the UrlMap resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<UrlMap> Compute_regionUrlMaps_getAsync(string project, string region, string urlMap, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UrlMap>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Patches the specified UrlMap resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
		/// Compute_regionUrlMaps_patch projects/{project}/regions/{region}/urlMaps/{urlMap}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="urlMap">Name of the UrlMap resource to patch.</param>
		/// <param name="requestId">begin_interface: MixerMutationRequestBuilder Request ID to support idempotency.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionUrlMaps_patchAsync(string project, string region, string urlMap, string requestId, UrlMap requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the specified UrlMap resource with the data included in the request.
		/// Compute_regionUrlMaps_update projects/{project}/regions/{region}/urlMaps/{urlMap}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="urlMap">Name of the UrlMap resource to update.</param>
		/// <param name="requestId">begin_interface: MixerMutationRequestBuilder Request ID to support idempotency.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_regionUrlMaps_updateAsync(string project, string region, string urlMap, string requestId, UrlMap requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Runs static validation for the UrlMap. In particular, the tests of the provided UrlMap will be run. Calling this method does NOT create the UrlMap.
		/// Compute_regionUrlMaps_validate projects/{project}/regions/{region}/urlMaps/{urlMap}/validate
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region scoping this request.</param>
		/// <param name="urlMap">Name of the UrlMap resource to be validated as.</param>
		/// <returns>Successful response</returns>
		public async Task<UrlMapsValidateResponse> Compute_regionUrlMaps_validateAsync(string project, string region, string urlMap, RegionUrlMapsValidateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/urlMaps/"+ (urlMap==null? "" : System.Uri.EscapeDataString(urlMap))+"/validate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UrlMapsValidateResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of VPN gateways available to the specified project and region.
		/// Compute_vpnGateways_list projects/{project}/regions/{region}/vpnGateways
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<VpnGatewayList> Compute_vpnGateways_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnGateways&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VpnGatewayList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a VPN gateway in the specified project and region using the data included in the request.
		/// Compute_vpnGateways_insert projects/{project}/regions/{region}/vpnGateways
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_vpnGateways_insertAsync(string project, string region, string requestId, VpnGateway requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnGateways&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on a VpnGateway. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_vpnGateways_setLabels projects/{project}/regions/{region}/vpnGateways/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_vpnGateways_setLabelsAsync(string project, string region, string resource, string requestId, RegionSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnGateways/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_vpnGateways_testIamPermissions projects/{project}/regions/{region}/vpnGateways/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The name of the region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_vpnGateways_testIamPermissionsAsync(string project, string region, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnGateways/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified VPN gateway.
		/// Compute_vpnGateways_delete projects/{project}/regions/{region}/vpnGateways/{vpnGateway}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="vpnGateway">Name of the VPN gateway to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_vpnGateways_deleteAsync(string project, string region, string vpnGateway, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnGateways/"+ (vpnGateway==null? "" : System.Uri.EscapeDataString(vpnGateway))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified VPN gateway.
		/// Compute_vpnGateways_get projects/{project}/regions/{region}/vpnGateways/{vpnGateway}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="vpnGateway">Name of the VPN gateway to return.</param>
		/// <returns>Successful response</returns>
		public async Task<VpnGateway> Compute_vpnGateways_getAsync(string project, string region, string vpnGateway, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnGateways/"+ (vpnGateway==null? "" : System.Uri.EscapeDataString(vpnGateway));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VpnGateway>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the status for the specified VPN gateway.
		/// Compute_vpnGateways_getStatus projects/{project}/regions/{region}/vpnGateways/{vpnGateway}/getStatus
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="vpnGateway">Name of the VPN gateway to return.</param>
		/// <returns>Successful response</returns>
		public async Task<VpnGatewaysGetStatusResponse> Compute_vpnGateways_getStatusAsync(string project, string region, string vpnGateway, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnGateways/"+ (vpnGateway==null? "" : System.Uri.EscapeDataString(vpnGateway))+"/getStatus";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VpnGatewaysGetStatusResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of VpnTunnel resources contained in the specified project and region.
		/// Compute_vpnTunnels_list projects/{project}/regions/{region}/vpnTunnels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<VpnTunnelList> Compute_vpnTunnels_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnTunnels&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VpnTunnelList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a VpnTunnel resource in the specified project and region using the data included in the request.
		/// Compute_vpnTunnels_insert projects/{project}/regions/{region}/vpnTunnels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_vpnTunnels_insertAsync(string project, string region, string requestId, VpnTunnel requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnTunnels&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on a VpnTunnel. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_vpnTunnels_setLabels projects/{project}/regions/{region}/vpnTunnels/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">The region for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_vpnTunnels_setLabelsAsync(string project, string region, string resource, string requestId, RegionSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnTunnels/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified VpnTunnel resource.
		/// Compute_vpnTunnels_delete projects/{project}/regions/{region}/vpnTunnels/{vpnTunnel}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="vpnTunnel">Name of the VpnTunnel resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_vpnTunnels_deleteAsync(string project, string region, string vpnTunnel, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnTunnels/"+ (vpnTunnel==null? "" : System.Uri.EscapeDataString(vpnTunnel))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified VpnTunnel resource.
		/// Compute_vpnTunnels_get projects/{project}/regions/{region}/vpnTunnels/{vpnTunnel}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Name of the region for this request.</param>
		/// <param name="vpnTunnel">Name of the VpnTunnel resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<VpnTunnel> Compute_vpnTunnels_getAsync(string project, string region, string vpnTunnel, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/vpnTunnels/"+ (vpnTunnel==null? "" : System.Uri.EscapeDataString(vpnTunnel));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<VpnTunnel>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of Zone resources under the specific region available to the specified project.
		/// Compute_regionZones_list projects/{project}/regions/{region}/zones
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="region">Region for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ZoneList> Compute_regionZones_listAsync(string project, string region, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/regions/"+ (region==null? "" : System.Uri.EscapeDataString(region))+"/zones&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ZoneList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets metadata common to all instances within the specified project using the data included in the request.
		/// Compute_projects_setCommonInstanceMetadata projects/{project}/setCommonInstanceMetadata
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_projects_setCommonInstanceMetadataAsync(string project, string requestId, Metadata requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/setCommonInstanceMetadata&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the default network tier of the project. The default network tier is used when an address/forwardingRule/instance is created without specifying the network tier field.
		/// Compute_projects_setDefaultNetworkTier projects/{project}/setDefaultNetworkTier
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_projects_setDefaultNetworkTierAsync(string project, string requestId, ProjectsSetDefaultNetworkTierRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/setDefaultNetworkTier&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Enables the usage export feature and sets the usage export bucket where reports are stored. If you provide an empty request body using this method, the usage export feature will be disabled.
		/// Compute_projects_setUsageExportBucket projects/{project}/setUsageExportBucket
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_projects_setUsageExportBucketAsync(string project, string requestId, UsageExportLocation requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/setUsageExportBucket&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the URL map for TargetHttpProxy.
		/// Compute_targetHttpProxies_setUrlMap projects/{project}/targetHttpProxies/{targetHttpProxy}/setUrlMap
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpProxy">Name of the TargetHttpProxy to set a URL map for.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpProxies_setUrlMapAsync(string project, string targetHttpProxy, string requestId, UrlMapReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/targetHttpProxies/"+ (targetHttpProxy==null? "" : System.Uri.EscapeDataString(targetHttpProxy))+"/setUrlMap&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Replaces SslCertificates for TargetHttpsProxy.
		/// Compute_targetHttpsProxies_setSslCertificates projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setSslCertificates
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource to set an SslCertificates resource for.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpsProxies_setSslCertificatesAsync(string project, string targetHttpsProxy, string requestId, TargetHttpsProxiesSetSslCertificatesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"/setSslCertificates&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the URL map for TargetHttpsProxy.
		/// Compute_targetHttpsProxies_setUrlMap projects/{project}/targetHttpsProxies/{targetHttpsProxy}/setUrlMap
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="targetHttpsProxy">Name of the TargetHttpsProxy resource whose URL map is to be set.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetHttpsProxies_setUrlMapAsync(string project, string targetHttpsProxy, string requestId, UrlMapReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/targetHttpsProxies/"+ (targetHttpsProxy==null? "" : System.Uri.EscapeDataString(targetHttpsProxy))+"/setUrlMap&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of Zone resources available to the specified project.
		/// Compute_zones_list projects/{project}/zones
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ZoneList> Compute_zones_listAsync(string project, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ZoneList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified Zone resource.
		/// Compute_zones_get projects/{project}/zones/{zone}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Zone> Compute_zones_getAsync(string project, string zone, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Zone>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of accelerator types that are available to the specified project.
		/// Compute_acceleratorTypes_list projects/{project}/zones/{zone}/acceleratorTypes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<AcceleratorTypeList> Compute_acceleratorTypes_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/acceleratorTypes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AcceleratorTypeList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified accelerator type.
		/// Compute_acceleratorTypes_get projects/{project}/zones/{zone}/acceleratorTypes/{acceleratorType}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="acceleratorType">Name of the accelerator type to return.</param>
		/// <returns>Successful response</returns>
		public async Task<AcceleratorType> Compute_acceleratorTypes_getAsync(string project, string zone, string acceleratorType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/acceleratorTypes/"+ (acceleratorType==null? "" : System.Uri.EscapeDataString(acceleratorType));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AcceleratorType>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of autoscalers contained within the specified zone.
		/// Compute_autoscalers_list projects/{project}/zones/{zone}/autoscalers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<AutoscalerList> Compute_autoscalers_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/autoscalers&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<AutoscalerList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an autoscaler in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_autoscalers_patch projects/{project}/zones/{zone}/autoscalers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="autoscaler">Name of the autoscaler to patch.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_autoscalers_patchAsync(string project, string zone, string autoscaler, string requestId, Autoscaler requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/autoscalers&autoscaler=" + (autoscaler==null? "" : System.Uri.EscapeDataString(autoscaler))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates an autoscaler in the specified project using the data included in the request.
		/// Compute_autoscalers_insert projects/{project}/zones/{zone}/autoscalers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_autoscalers_insertAsync(string project, string zone, string requestId, Autoscaler requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/autoscalers&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an autoscaler in the specified project using the data included in the request.
		/// Compute_autoscalers_update projects/{project}/zones/{zone}/autoscalers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="autoscaler">Name of the autoscaler to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_autoscalers_updateAsync(string project, string zone, string autoscaler, string requestId, Autoscaler requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/autoscalers&autoscaler=" + (autoscaler==null? "" : System.Uri.EscapeDataString(autoscaler))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified autoscaler.
		/// Compute_autoscalers_delete projects/{project}/zones/{zone}/autoscalers/{autoscaler}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="autoscaler">Name of the autoscaler to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_autoscalers_deleteAsync(string project, string zone, string autoscaler, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/autoscalers/"+ (autoscaler==null? "" : System.Uri.EscapeDataString(autoscaler))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified autoscaler resource.
		/// Compute_autoscalers_get projects/{project}/zones/{zone}/autoscalers/{autoscaler}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="autoscaler">Name of the autoscaler to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Autoscaler> Compute_autoscalers_getAsync(string project, string zone, string autoscaler, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/autoscalers/"+ (autoscaler==null? "" : System.Uri.EscapeDataString(autoscaler));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Autoscaler>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of disk types available to the specified project.
		/// Compute_diskTypes_list projects/{project}/zones/{zone}/diskTypes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<DiskTypeList> Compute_diskTypes_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/diskTypes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DiskTypeList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified disk type.
		/// Compute_diskTypes_get projects/{project}/zones/{zone}/diskTypes/{diskType}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="diskType">Name of the disk type to return.</param>
		/// <returns>Successful response</returns>
		public async Task<DiskType> Compute_diskTypes_getAsync(string project, string zone, string diskType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/diskTypes/"+ (diskType==null? "" : System.Uri.EscapeDataString(diskType));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DiskType>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of persistent disks contained within the specified zone.
		/// Compute_disks_list projects/{project}/zones/{zone}/disks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<DiskList> Compute_disks_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DiskList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a persistent disk in the specified project using the data in the request. You can create a disk from a source (sourceImage, sourceSnapshot, or sourceDisk) or create an empty 500 GB data disk by omitting all properties. You can also create a disk that is larger than the default size by specifying the sizeGb property.
		/// Compute_disks_insert projects/{project}/zones/{zone}/disks
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="sourceImage">Source image to restore onto a disk. This field is optional.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_insertAsync(string project, string zone, string requestId, string sourceImage, Disk requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&sourceImage=" + (sourceImage==null? "" : System.Uri.EscapeDataString(sourceImage));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Bulk create a set of disks.
		/// Compute_disks_bulkInsert projects/{project}/zones/{zone}/disks/bulkInsert
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_bulkInsertAsync(string project, string zone, string requestId, BulkInsertDiskResource requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/bulkInsert&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stops asynchronous replication for a consistency group of disks. Can be invoked either in the primary or secondary scope.
		/// Compute_disks_stopGroupAsyncReplication projects/{project}/zones/{zone}/disks/stopGroupAsyncReplication
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request. This must be the zone of the primary or secondary disks in the consistency group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_stopGroupAsyncReplicationAsync(string project, string zone, string requestId, DisksStopGroupAsyncReplicationResource requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/stopGroupAsyncReplication&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified persistent disk. Deleting a disk removes its data permanently and is irreversible. However, deleting a disk does not delete any snapshots previously made from the disk. You must separately delete snapshots.
		/// Compute_disks_delete projects/{project}/zones/{zone}/disks/{disk}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="disk">Name of the persistent disk to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_deleteAsync(string project, string zone, string disk, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified persistent disk.
		/// Compute_disks_get projects/{project}/zones/{zone}/disks/{disk}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="disk">Name of the persistent disk to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Disk> Compute_disks_getAsync(string project, string zone, string disk, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Disk>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified disk with the data included in the request. The update is performed only on selected fields included as part of update-mask. Only the following fields can be modified: user_license.
		/// Compute_disks_update projects/{project}/zones/{zone}/disks/{disk}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="disk">The disk name for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">update_mask indicates fields to be updated as part of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_updateAsync(string project, string zone, string disk, string[] paths, string requestId, string updateMask, Disk requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"&"+string.Join("&", paths.Select(z => $"paths={System.Uri.EscapeDataString(z.ToString())}"))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds existing resource policies to a disk. You can only add one policy which will be applied to this disk for scheduling snapshot creation.
		/// Compute_disks_addResourcePolicies projects/{project}/zones/{zone}/disks/{disk}/addResourcePolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="disk">The disk name for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_addResourcePoliciesAsync(string project, string zone, string disk, string requestId, DisksAddResourcePoliciesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/addResourcePolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates a snapshot of a specified persistent disk. For regular snapshot creation, consider using snapshots.insert instead, as that method supports more features, such as creating snapshots in a project different from the source disk project.
		/// Compute_disks_createSnapshot projects/{project}/zones/{zone}/disks/{disk}/createSnapshot
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="disk">Name of the persistent disk to snapshot.</param>
		/// <param name="guestFlush">[Input Only] Whether to attempt an application consistent snapshot by informing the OS to prepare for the snapshot process.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_createSnapshotAsync(string project, string zone, string disk, bool guestFlush, string requestId, Snapshot requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/createSnapshot&guestFlush="+guestFlush+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes resource policies from a disk.
		/// Compute_disks_removeResourcePolicies projects/{project}/zones/{zone}/disks/{disk}/removeResourcePolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="disk">The disk name for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_removeResourcePoliciesAsync(string project, string zone, string disk, string requestId, DisksRemoveResourcePoliciesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/removeResourcePolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Resizes the specified persistent disk. You can only increase the size of the disk.
		/// Compute_disks_resize projects/{project}/zones/{zone}/disks/{disk}/resize
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="disk">The name of the persistent disk.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_resizeAsync(string project, string zone, string disk, string requestId, DisksResizeRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/resize&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Starts asynchronous replication. Must be invoked on the primary disk.
		/// Compute_disks_startAsyncReplication projects/{project}/zones/{zone}/disks/{disk}/startAsyncReplication
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="disk">The name of the persistent disk.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_startAsyncReplicationAsync(string project, string zone, string disk, string requestId, DisksStartAsyncReplicationRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/startAsyncReplication&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stops asynchronous replication. Can be invoked either on the primary or on the secondary disk.
		/// Compute_disks_stopAsyncReplication projects/{project}/zones/{zone}/disks/{disk}/stopAsyncReplication
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="disk">The name of the persistent disk.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_stopAsyncReplicationAsync(string project, string zone, string disk, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (disk==null? "" : System.Uri.EscapeDataString(disk))+"/stopAsyncReplication&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_disks_getIamPolicy projects/{project}/zones/{zone}/disks/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_disks_getIamPolicyAsync(string project, string zone, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_disks_setIamPolicy projects/{project}/zones/{zone}/disks/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_disks_setIamPolicyAsync(string project, string zone, string resource, ZoneSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the labels on a disk. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_disks_setLabels projects/{project}/zones/{zone}/disks/{resource}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_disks_setLabelsAsync(string project, string zone, string resource, string requestId, ZoneSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setLabels&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_disks_testIamPermissions projects/{project}/zones/{zone}/disks/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_disks_testIamPermissionsAsync(string project, string zone, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/disks/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns the latest image that is part of an image family, is not deprecated and is rolled out in the specified zone.
		/// Compute_imageFamilyViews_get projects/{project}/zones/{zone}/imageFamilyViews/{family}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="family">Name of the image family to search for.</param>
		/// <returns>Successful response</returns>
		public async Task<ImageFamilyView> Compute_imageFamilyViews_getAsync(string project, string zone, string family, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/imageFamilyViews/"+ (family==null? "" : System.Uri.EscapeDataString(family));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ImageFamilyView>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of managed instance groups that are contained within the specified project and zone.
		/// Compute_instanceGroupManagers_list projects/{project}/zones/{zone}/instanceGroupManagers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroupManagerList> Compute_instanceGroupManagers_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroupManagerList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a managed instance group using the information that you specify in the request. After the group is created, instances in the group are created using the specified instance template. This operation is marked as DONE when the group is created even if the instances in the group have not yet been created. You must separately verify the status of the individual instances with the listmanagedinstances method. A managed instance group can have up to 1000 VM instances per group. Please contact Cloud Support if you need an increase in this limit.
		/// Compute_instanceGroupManagers_insert projects/{project}/zones/{zone}/instanceGroupManagers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where you want to create the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_insertAsync(string project, string zone, string requestId, InstanceGroupManager requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified managed instance group and all of the instances in that group. Note that the instance group must not belong to a backend service. Read Deleting an instance group for more information.
		/// Compute_instanceGroupManagers_delete projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_deleteAsync(string project, string zone, string instanceGroupManager, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all of the details about the specified managed instance group.
		/// Compute_instanceGroupManagers_get projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroupManager> Compute_instanceGroupManagers_getAsync(string project, string zone, string instanceGroupManager, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroupManager>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates a managed instance group using the information that you specify in the request. This operation is marked as DONE when the group is patched even if the instances in the group are still in the process of being patched. You must separately verify the status of the individual instances with the listManagedInstances method. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. If you update your group to specify a new template or instance configuration, it's possible that your intended specification for each VM in the group is different from the current state of that VM. To learn how to apply an updated configuration to the VMs in a MIG, see Updating instances in a MIG.
		/// Compute_instanceGroupManagers_patch projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where you want to create the managed instance group.</param>
		/// <param name="instanceGroupManager">The name of the instance group manager.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_patchAsync(string project, string zone, string instanceGroupManager, string requestId, InstanceGroupManager requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Flags the specified instances to be removed from the managed instance group. Abandoning an instance does not delete the instance, but it does remove the instance from any target pools that are applied by the managed instance group. This method reduces the targetSize of the managed instance group by the number of instances that you abandon. This operation is marked as DONE when the action is scheduled even if the instances have not yet been removed from the group. You must separately verify the status of the abandoning action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
		/// Compute_instanceGroupManagers_abandonInstances projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/abandonInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_abandonInstancesAsync(string project, string zone, string instanceGroupManager, string requestId, InstanceGroupManagersAbandonInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/abandonInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Applies changes to selected instances on the managed instance group. This method can be used to apply new overrides and/or new versions.
		/// Compute_instanceGroupManagers_applyUpdatesToInstances projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/applyUpdatesToInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located. Should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group, should conform to RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_applyUpdatesToInstancesAsync(string project, string zone, string instanceGroupManager, InstanceGroupManagersApplyUpdatesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/applyUpdatesToInstances";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates instances with per-instance configurations in this managed instance group. Instances are created using the current instance template. The create instances operation is marked DONE if the createInstances request is successful. The underlying actions take additional time. You must separately verify the status of the creating or actions with the listmanagedinstances method.
		/// Compute_instanceGroupManagers_createInstances projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/createInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located. It should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_createInstancesAsync(string project, string zone, string instanceGroupManager, string requestId, InstanceGroupManagersCreateInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/createInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Flags the specified instances in the managed instance group for immediate deletion. The instances are also removed from any target pools of which they were a member. This method reduces the targetSize of the managed instance group by the number of instances that you delete. This operation is marked as DONE when the action is scheduled even if the instances are still being deleted. You must separately verify the status of the deleting action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
		/// Compute_instanceGroupManagers_deleteInstances projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/deleteInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_deleteInstancesAsync(string project, string zone, string instanceGroupManager, string requestId, InstanceGroupManagersDeleteInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/deleteInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes selected per-instance configurations for the managed instance group.
		/// Compute_instanceGroupManagers_deletePerInstanceConfigs projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/deletePerInstanceConfigs
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located. It should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It should conform to RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_deletePerInstanceConfigsAsync(string project, string zone, string instanceGroupManager, InstanceGroupManagersDeletePerInstanceConfigsReq requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/deletePerInstanceConfigs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists all errors thrown by actions on instances for a given managed instance group. The filter and orderBy query parameters are not supported.
		/// Compute_instanceGroupManagers_listErrors projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/listErrors
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located. It should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It must be a string that meets the requirements in RFC1035, or an unsigned long integer: must match regexp pattern: (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|1-9{0,19}.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroupManagersListErrorsResponse> Compute_instanceGroupManagers_listErrorsAsync(string project, string zone, string instanceGroupManager, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/listErrors&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroupManagersListErrorsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all of the instances in the managed instance group. Each instance in the list has a currentAction, which indicates the action that the managed instance group is performing on the instance. For example, if the group is still creating an instance, the currentAction is CREATING. If a previous action failed, the list displays the errors for that failed action. The orderBy query parameter is not supported. The `pageToken` query parameter is supported only if the group's `listManagedInstancesResults` field is set to `PAGINATED`.
		/// Compute_instanceGroupManagers_listManagedInstances projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/listManagedInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroupManagersListManagedInstancesResponse> Compute_instanceGroupManagers_listManagedInstancesAsync(string project, string zone, string instanceGroupManager, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/listManagedInstances&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroupManagersListManagedInstancesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists all of the per-instance configurations defined for the managed instance group. The orderBy query parameter is not supported.
		/// Compute_instanceGroupManagers_listPerInstanceConfigs projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/listPerInstanceConfigs
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located. It should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It should conform to RFC1035.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroupManagersListPerInstanceConfigsResp> Compute_instanceGroupManagers_listPerInstanceConfigsAsync(string project, string zone, string instanceGroupManager, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/listPerInstanceConfigs&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroupManagersListPerInstanceConfigsResp>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Inserts or patches per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch.
		/// Compute_instanceGroupManagers_patchPerInstanceConfigs projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/patchPerInstanceConfigs
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located. It should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_patchPerInstanceConfigsAsync(string project, string zone, string instanceGroupManager, string requestId, InstanceGroupManagersPatchPerInstanceConfigsReq requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/patchPerInstanceConfigs&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Flags the specified VM instances in the managed instance group to be immediately recreated. Each instance is recreated using the group's current configuration. This operation is marked as DONE when the flag is set even if the instances have not yet been recreated. You must separately verify the status of each instance by checking its currentAction field; for more information, see Checking the status of managed instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
		/// Compute_instanceGroupManagers_recreateInstances projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/recreateInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_recreateInstancesAsync(string project, string zone, string instanceGroupManager, string requestId, InstanceGroupManagersRecreateInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/recreateInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Resizes the managed instance group. If you increase the size, the group creates new instances using the current instance template. If you decrease the size, the group deletes instances. The resize operation is marked DONE when the resize actions are scheduled even if the group has not yet added or deleted any instances. You must separately verify the status of the creating or deleting actions with the listmanagedinstances method. When resizing down, the instance group arbitrarily chooses the order in which VMs are deleted. The group takes into account some VM attributes when making the selection including: + The status of the VM instance. + The health of the VM instance. + The instance template version the VM is based on. + For regional managed instance groups, the location of the VM instance. This list is subject to change. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted.
		/// Compute_instanceGroupManagers_resize projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/resize
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group.</param>
		/// <param name="size">The number of running instances that the managed instance group should maintain at any given time. The group automatically adds or removes instances to maintain the number of instances specified by this parameter.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_resizeAsync(string project, string zone, string instanceGroupManager, int size, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/resize&size="+size+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Specifies the instance template to use when creating new instances in this group. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group's updatePolicy.type to PROACTIVE.
		/// Compute_instanceGroupManagers_setInstanceTemplate projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setInstanceTemplate
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_setInstanceTemplateAsync(string project, string zone, string instanceGroupManager, string requestId, InstanceGroupManagersSetInstanceTemplateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/setInstanceTemplate&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Modifies the target pools to which all instances in this managed instance group are assigned. The target pools automatically apply to all of the instances in the managed instance group. This operation is marked DONE when you make the request even if the instances have not yet been added to their target pools. The change might take some time to apply to all of the instances in the group depending on the size of the group.
		/// Compute_instanceGroupManagers_setTargetPools projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/setTargetPools
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_setTargetPoolsAsync(string project, string zone, string instanceGroupManager, string requestId, InstanceGroupManagersSetTargetPoolsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/setTargetPools&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Inserts or updates per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch.
		/// Compute_instanceGroupManagers_updatePerInstanceConfigs projects/{project}/zones/{zone}/instanceGroupManagers/{instanceGroupManager}/updatePerInstanceConfigs
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the managed instance group is located. It should conform to RFC1035.</param>
		/// <param name="instanceGroupManager">The name of the managed instance group. It should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroupManagers_updatePerInstanceConfigsAsync(string project, string zone, string instanceGroupManager, string requestId, InstanceGroupManagersUpdatePerInstanceConfigsReq requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroupManagers/"+ (instanceGroupManager==null? "" : System.Uri.EscapeDataString(instanceGroupManager))+"/updatePerInstanceConfigs&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of zonal instance group resources contained within the specified zone. For managed instance groups, use the instanceGroupManagers or regionInstanceGroupManagers methods instead.
		/// Compute_instanceGroups_list projects/{project}/zones/{zone}/instanceGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the instance group is located.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroupList> Compute_instanceGroups_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroupList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an instance group in the specified project using the parameters that are included in the request.
		/// Compute_instanceGroups_insert projects/{project}/zones/{zone}/instanceGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where you want to create the instance group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroups_insertAsync(string project, string zone, string requestId, InstanceGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroups&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified instance group. The instances in the group are not deleted. Note that instance group must not belong to a backend service. Read Deleting an instance group for more information.
		/// Compute_instanceGroups_delete projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the instance group is located.</param>
		/// <param name="instanceGroup">The name of the instance group to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroups_deleteAsync(string project, string zone, string instanceGroup, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroups/"+ (instanceGroup==null? "" : System.Uri.EscapeDataString(instanceGroup))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified zonal instance group. Get a list of available zonal instance groups by making a list() request. For managed instance groups, use the instanceGroupManagers or regionInstanceGroupManagers methods instead.
		/// Compute_instanceGroups_get projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the instance group is located.</param>
		/// <param name="instanceGroup">The name of the instance group.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroup> Compute_instanceGroups_getAsync(string project, string zone, string instanceGroup, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroups/"+ (instanceGroup==null? "" : System.Uri.EscapeDataString(instanceGroup));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a list of instances to the specified instance group. All of the instances in the instance group must be in the same network/subnetwork. Read Adding instances for more information.
		/// Compute_instanceGroups_addInstances projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}/addInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the instance group is located.</param>
		/// <param name="instanceGroup">The name of the instance group where you are adding instances.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroups_addInstancesAsync(string project, string zone, string instanceGroup, string requestId, InstanceGroupsAddInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroups/"+ (instanceGroup==null? "" : System.Uri.EscapeDataString(instanceGroup))+"/addInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the instances in the specified instance group. The orderBy query parameter is not supported. The filter query parameter is supported, but only for expressions that use `eq` (equal) or `ne` (not equal) operators.
		/// Compute_instanceGroups_listInstances projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}/listInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the instance group is located.</param>
		/// <param name="instanceGroup">The name of the instance group from which you want to generate a list of included instances.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceGroupsListInstances> Compute_instanceGroups_listInstancesAsync(string project, string zone, string instanceGroup, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, InstanceGroupsListInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroups/"+ (instanceGroup==null? "" : System.Uri.EscapeDataString(instanceGroup))+"/listInstances&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceGroupsListInstances>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Removes one or more instances from the specified instance group, but does not delete those instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration before the VM instance is removed or deleted.
		/// Compute_instanceGroups_removeInstances projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}/removeInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the instance group is located.</param>
		/// <param name="instanceGroup">The name of the instance group where the specified instances will be removed.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroups_removeInstancesAsync(string project, string zone, string instanceGroup, string requestId, InstanceGroupsRemoveInstancesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroups/"+ (instanceGroup==null? "" : System.Uri.EscapeDataString(instanceGroup))+"/removeInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the named ports for the specified instance group.
		/// Compute_instanceGroups_setNamedPorts projects/{project}/zones/{zone}/instanceGroups/{instanceGroup}/setNamedPorts
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the instance group is located.</param>
		/// <param name="instanceGroup">The name of the instance group where the named ports are updated.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instanceGroups_setNamedPortsAsync(string project, string zone, string instanceGroup, string requestId, InstanceGroupsSetNamedPortsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instanceGroups/"+ (instanceGroup==null? "" : System.Uri.EscapeDataString(instanceGroup))+"/setNamedPorts&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of instances contained within the specified zone.
		/// Compute_instances_list projects/{project}/zones/{zone}/instances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceList> Compute_instances_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates an instance resource in the specified project using the data included in the request.
		/// Compute_instances_insert projects/{project}/zones/{zone}/instances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="sourceInstanceTemplate">Specifies instance template to create the instance. This field is optional. It can be a full or partial URL. For example, the following are all valid URLs to an instance template: - https://www.googleapis.com/compute/v1/projects/project /global/instanceTemplates/instanceTemplate - projects/project/global/instanceTemplates/instanceTemplate - global/instanceTemplates/instanceTemplate </param>
		/// <param name="sourceMachineImage">Specifies the machine image to use to create the instance. This field is optional. It can be a full or partial URL. For example, the following are all valid URLs to a machine image: - https://www.googleapis.com/compute/v1/projects/project/global/global /machineImages/machineImage - projects/project/global/global/machineImages/machineImage - global/machineImages/machineImage </param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_insertAsync(string project, string zone, string requestId, string sourceInstanceTemplate, string sourceMachineImage, Instance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&sourceInstanceTemplate=" + (sourceInstanceTemplate==null? "" : System.Uri.EscapeDataString(sourceInstanceTemplate))+"&sourceMachineImage=" + (sourceMachineImage==null? "" : System.Uri.EscapeDataString(sourceMachineImage));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Creates multiple instances. Count specifies the number of instances to create. For more information, see About bulk creation of VMs.
		/// Compute_instances_bulkInsert projects/{project}/zones/{zone}/instances/bulkInsert
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_bulkInsertAsync(string project, string zone, string requestId, BulkInsertInstanceResource requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/bulkInsert&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified Instance resource. For more information, see Deleting an instance.
		/// Compute_instances_delete projects/{project}/zones/{zone}/instances/{instance}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_deleteAsync(string project, string zone, string instance, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified Instance resource.
		/// Compute_instances_get projects/{project}/zones/{zone}/instances/{instance}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Instance> Compute_instances_getAsync(string project, string zone, string instance, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Instance>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an instance only if the necessary resources are available. This method can update only a specific set of instance properties. See Updating a running instance for a list of updatable instance properties.
		/// Compute_instances_update projects/{project}/zones/{zone}/instances/{instance}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance resource to update.</param>
		/// <param name="minimalAction">Specifies the action to take when updating an instance even if the updated properties do not require it. If not specified, then Compute Engine acts based on the minimum action that the updated properties require.</param>
		/// <param name="mostDisruptiveAllowedAction">Specifies the most disruptive action that can be taken on the instance as part of the update. Compute Engine returns an error if the instance properties require a more disruptive action as part of the instance update. Valid options from lowest to highest are NO_EFFECT, REFRESH, and RESTART.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_updateAsync(string project, string zone, string instance, Compute_instances_updateMinimalAction minimalAction, Compute_instances_updateMinimalAction mostDisruptiveAllowedAction, string requestId, Instance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"&minimalAction=" + minimalAction+"&mostDisruptiveAllowedAction=" + mostDisruptiveAllowedAction+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds an access config to an instance's network interface.
		/// Compute_instances_addAccessConfig projects/{project}/zones/{zone}/instances/{instance}/addAccessConfig
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">The instance name for this request.</param>
		/// <param name="networkInterface">The name of the network interface to add to this instance.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_addAccessConfigAsync(string project, string zone, string instance, string networkInterface, string requestId, AccessConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/addAccessConfig&networkInterface=" + (networkInterface==null? "" : System.Uri.EscapeDataString(networkInterface))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds existing resource policies to an instance. You can only add one policy right now which will be applied to this instance for scheduling live migrations.
		/// Compute_instances_addResourcePolicies projects/{project}/zones/{zone}/instances/{instance}/addResourcePolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">The instance name for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_addResourcePoliciesAsync(string project, string zone, string instance, string requestId, InstancesAddResourcePoliciesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/addResourcePolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Attaches an existing Disk resource to an instance. You must first create the disk before you can attach it. It is not possible to create and attach a disk at the same time. For more information, read Adding a persistent disk to your instance.
		/// Compute_instances_attachDisk projects/{project}/zones/{zone}/instances/{instance}/attachDisk
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">The instance name for this request.</param>
		/// <param name="forceAttach">Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_attachDiskAsync(string project, string zone, string instance, bool forceAttach, string requestId, AttachedDisk requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/attachDisk&forceAttach="+forceAttach+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes an access config from an instance's network interface.
		/// Compute_instances_deleteAccessConfig projects/{project}/zones/{zone}/instances/{instance}/deleteAccessConfig
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">The instance name for this request.</param>
		/// <param name="accessConfig">The name of the access config to delete.</param>
		/// <param name="networkInterface">The name of the network interface.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_deleteAccessConfigAsync(string project, string zone, string instance, string accessConfig, string networkInterface, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/deleteAccessConfig&accessConfig=" + (accessConfig==null? "" : System.Uri.EscapeDataString(accessConfig))+"&networkInterface=" + (networkInterface==null? "" : System.Uri.EscapeDataString(networkInterface))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Detaches a disk from an instance.
		/// Compute_instances_detachDisk projects/{project}/zones/{zone}/instances/{instance}/detachDisk
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Instance name for this request.</param>
		/// <param name="deviceName">The device name of the disk to detach. Make a get() request on the instance to view currently attached disks and device names.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_detachDiskAsync(string project, string zone, string instance, string deviceName, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/detachDisk&deviceName=" + (deviceName==null? "" : System.Uri.EscapeDataString(deviceName))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns effective firewalls applied to an interface of the instance.
		/// Compute_instances_getEffectiveFirewalls projects/{project}/zones/{zone}/instances/{instance}/getEffectiveFirewalls
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="networkInterface">The name of the network interface to get the effective firewalls.</param>
		/// <returns>Successful response</returns>
		public async Task<InstancesGetEffectiveFirewallsResponse> Compute_instances_getEffectiveFirewallsAsync(string project, string zone, string instance, string networkInterface, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/getEffectiveFirewalls&networkInterface=" + (networkInterface==null? "" : System.Uri.EscapeDataString(networkInterface));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstancesGetEffectiveFirewallsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified guest attributes entry.
		/// Compute_instances_getGuestAttributes projects/{project}/zones/{zone}/instances/{instance}/getGuestAttributes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="queryPath">Specifies the guest attributes path to be queried.</param>
		/// <param name="variableKey">Specifies the key for the guest attributes entry.</param>
		/// <returns>Successful response</returns>
		public async Task<GuestAttributes> Compute_instances_getGuestAttributesAsync(string project, string zone, string instance, string queryPath, string variableKey, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/getGuestAttributes&queryPath=" + (queryPath==null? "" : System.Uri.EscapeDataString(queryPath))+"&variableKey=" + (variableKey==null? "" : System.Uri.EscapeDataString(variableKey));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GuestAttributes>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the Shielded Instance Identity of an instance
		/// Compute_instances_getShieldedInstanceIdentity projects/{project}/zones/{zone}/instances/{instance}/getShieldedInstanceIdentity
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name or id of the instance scoping this request.</param>
		/// <returns>Successful response</returns>
		public async Task<ShieldedInstanceIdentity> Compute_instances_getShieldedInstanceIdentityAsync(string project, string zone, string instance, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/getShieldedInstanceIdentity";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ShieldedInstanceIdentity>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Perform a manual maintenance on the instance.
		/// Compute_instances_performMaintenance projects/{project}/zones/{zone}/instances/{instance}/performMaintenance
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_performMaintenanceAsync(string project, string zone, string instance, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/performMaintenance&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of resources that refer to the VM instance specified in the request. For example, if the VM instance is part of a managed or unmanaged instance group, the referrers list includes the instance group. For more information, read Viewing referrers to VM instances.
		/// Compute_instances_listReferrers projects/{project}/zones/{zone}/instances/{instance}/referrers
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the target instance scoping this request, or '-' if the request should span over all instances in the container.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<InstanceListReferrers> Compute_instances_listReferrersAsync(string project, string zone, string instance, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/referrers&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<InstanceListReferrers>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Removes resource policies from an instance.
		/// Compute_instances_removeResourcePolicies projects/{project}/zones/{zone}/instances/{instance}/removeResourcePolicies
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">The instance name for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_removeResourcePoliciesAsync(string project, string zone, string instance, string requestId, InstancesRemoveResourcePoliciesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/removeResourcePolicies&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Performs a reset on the instance. This is a hard reset. The VM does not do a graceful shutdown. For more information, see Resetting an instance.
		/// Compute_instances_reset projects/{project}/zones/{zone}/instances/{instance}/reset
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_resetAsync(string project, string zone, string instance, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/reset&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resumes an instance that was suspended using the instances().suspend method.
		/// Compute_instances_resume projects/{project}/zones/{zone}/instances/{instance}/resume
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance resource to resume.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_resumeAsync(string project, string zone, string instance, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/resume&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the screenshot from the specified instance.
		/// Compute_instances_getScreenshot projects/{project}/zones/{zone}/instances/{instance}/screenshot
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Screenshot> Compute_instances_getScreenshotAsync(string project, string zone, string instance, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/screenshot";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Screenshot>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sends diagnostic interrupt to the instance.
		/// Compute_instances_sendDiagnosticInterrupt projects/{project}/zones/{zone}/instances/{instance}/sendDiagnosticInterrupt
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <returns>Successful response</returns>
		public async Task Compute_instances_sendDiagnosticInterruptAsync(string project, string zone, string instance, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/sendDiagnosticInterrupt";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the last 1 MB of serial port output from the specified instance.
		/// Compute_instances_getSerialPortOutput projects/{project}/zones/{zone}/instances/{instance}/serialPort
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance for this request.</param>
		/// <param name="port">Specifies which COM or serial port to retrieve data from.</param>
		/// <param name="start">Specifies the starting byte position of the output to return. To start with the first byte of output to the specified port, omit this field or set it to `0`. If the output for that byte position is available, this field matches the `start` parameter sent with the request. If the amount of serial console output exceeds the size of the buffer (1 MB), the oldest output is discarded and is no longer available. If the requested start position refers to discarded output, the start position is adjusted to the oldest output still available, and the adjusted start position is returned as the `start` property value. You can also provide a negative start position, which translates to the most recent number of bytes written to the serial port. For example, -3 is interpreted as the most recent 3 bytes written to the serial console.</param>
		/// <returns>Successful response</returns>
		public async Task<SerialPortOutput> Compute_instances_getSerialPortOutputAsync(string project, string zone, string instance, int port, string start, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/serialPort&port="+port+"&start=" + (start==null? "" : System.Uri.EscapeDataString(start));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SerialPortOutput>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the auto-delete flag for a disk attached to an instance.
		/// Compute_instances_setDiskAutoDelete projects/{project}/zones/{zone}/instances/{instance}/setDiskAutoDelete
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">The instance name for this request.</param>
		/// <param name="autoDelete">Whether to auto-delete the disk when the instance is deleted.</param>
		/// <param name="deviceName">The device name of the disk to modify. Make a get() request on the instance to view currently attached disks and device names.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setDiskAutoDeleteAsync(string project, string zone, string instance, bool autoDelete, string deviceName, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setDiskAutoDelete&autoDelete="+autoDelete+"&deviceName=" + (deviceName==null? "" : System.Uri.EscapeDataString(deviceName))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets labels on an instance. To learn more about labels, read the Labeling Resources documentation.
		/// Compute_instances_setLabels projects/{project}/zones/{zone}/instances/{instance}/setLabels
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setLabelsAsync(string project, string zone, string instance, string requestId, InstancesSetLabelsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setLabels&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the number and/or type of accelerator for a stopped instance to the values specified in the request.
		/// Compute_instances_setMachineResources projects/{project}/zones/{zone}/instances/{instance}/setMachineResources
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setMachineResourcesAsync(string project, string zone, string instance, string requestId, InstancesSetMachineResourcesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setMachineResources&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the machine type for a stopped instance to the machine type specified in the request.
		/// Compute_instances_setMachineType projects/{project}/zones/{zone}/instances/{instance}/setMachineType
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setMachineTypeAsync(string project, string zone, string instance, string requestId, InstancesSetMachineTypeRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setMachineType&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets metadata for the specified instance to the data included in the request.
		/// Compute_instances_setMetadata projects/{project}/zones/{zone}/instances/{instance}/setMetadata
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setMetadataAsync(string project, string zone, string instance, string requestId, Metadata requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setMetadata&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Changes the minimum CPU platform that this instance should use. This method can only be called on a stopped instance. For more information, read Specifying a Minimum CPU Platform.
		/// Compute_instances_setMinCpuPlatform projects/{project}/zones/{zone}/instances/{instance}/setMinCpuPlatform
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setMinCpuPlatformAsync(string project, string zone, string instance, string requestId, InstancesSetMinCpuPlatformRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setMinCpuPlatform&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets name of an instance.
		/// Compute_instances_setName projects/{project}/zones/{zone}/instances/{instance}/setName
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">The instance name for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setNameAsync(string project, string zone, string instance, string requestId, InstancesSetNameRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setName&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets an instance's scheduling options. You can only call this method on a stopped instance, that is, a VM instance that is in a `TERMINATED` state. See Instance Life Cycle for more information on the possible instance states. For more information about setting scheduling options for a VM, see Set VM host maintenance policy.
		/// Compute_instances_setScheduling projects/{project}/zones/{zone}/instances/{instance}/setScheduling
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Instance name for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setSchedulingAsync(string project, string zone, string instance, string requestId, Scheduling requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setScheduling&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the Google Cloud Armor security policy for the specified instance. For more information, see Google Cloud Armor Overview
		/// Compute_instances_setSecurityPolicy projects/{project}/zones/{zone}/instances/{instance}/setSecurityPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone scoping this request.</param>
		/// <param name="instance">Name of the Instance resource to which the security policy should be set. The name should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setSecurityPolicyAsync(string project, string zone, string instance, string requestId, InstancesSetSecurityPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setSecurityPolicy&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the service account on the instance. For more information, read Changing the service account and access scopes for an instance.
		/// Compute_instances_setServiceAccount projects/{project}/zones/{zone}/instances/{instance}/setServiceAccount
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance resource to start.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setServiceAccountAsync(string project, string zone, string instance, string requestId, InstancesSetServiceAccountRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setServiceAccount&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets the Shielded Instance integrity policy for an instance. You can only use this method on a running instance. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_instances_setShieldedInstanceIntegrityPolicy projects/{project}/zones/{zone}/instances/{instance}/setShieldedInstanceIntegrityPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name or id of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setShieldedInstanceIntegrityPolicyAsync(string project, string zone, string instance, string requestId, ShieldedInstanceIntegrityPolicy requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setShieldedInstanceIntegrityPolicy&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sets network tags for the specified instance to the data included in the request.
		/// Compute_instances_setTags projects/{project}/zones/{zone}/instances/{instance}/setTags
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setTagsAsync(string project, string zone, string instance, string requestId, Tags requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/setTags&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Simulates a host maintenance event on a VM. For more information, see Simulate a host maintenance event.
		/// Compute_instances_simulateMaintenanceEvent projects/{project}/zones/{zone}/instances/{instance}/simulateMaintenanceEvent
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="withExtendedNotifications">Determines whether the customers receive notifications before migration. Only applicable to SF vms.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_simulateMaintenanceEventAsync(string project, string zone, string instance, string requestId, bool withExtendedNotifications, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/simulateMaintenanceEvent&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&withExtendedNotifications="+withExtendedNotifications;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts an instance that was stopped using the instances().stop method. For more information, see Restart an instance.
		/// Compute_instances_start projects/{project}/zones/{zone}/instances/{instance}/start
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance resource to start.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_startAsync(string project, string zone, string instance, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/start&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Starts an instance that was stopped using the instances().stop method. For more information, see Restart an instance.
		/// Compute_instances_startWithEncryptionKey projects/{project}/zones/{zone}/instances/{instance}/startWithEncryptionKey
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance resource to start.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_startWithEncryptionKeyAsync(string project, string zone, string instance, string requestId, InstancesStartWithEncryptionKeyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/startWithEncryptionKey&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Stops a running instance, shutting it down cleanly, and allows you to restart the instance at a later time. Stopped instances do not incur VM usage charges while they are stopped. However, resources that the VM is using, such as persistent disks and static IP addresses, will continue to be charged until they are deleted. For more information, see Stopping an instance.
		/// Compute_instances_stop projects/{project}/zones/{zone}/instances/{instance}/stop
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance resource to stop.</param>
		/// <param name="discardLocalSsd">This property is required if the instance has any attached Local SSD disks. If false, Local SSD data will be preserved when the instance is suspended. If true, the contents of any attached Local SSD disks will be discarded.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_stopAsync(string project, string zone, string instance, bool discardLocalSsd, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/stop&discardLocalSsd="+discardLocalSsd+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// This method suspends a running instance, saving its state to persistent storage, and allows you to resume the instance at a later time. Suspended instances have no compute costs (cores or RAM), and incur only storage charges for the saved VM memory and localSSD data. Any charged resources the virtual machine was using, such as persistent disks and static IP addresses, will continue to be charged while the instance is suspended. For more information, see Suspending and resuming an instance.
		/// Compute_instances_suspend projects/{project}/zones/{zone}/instances/{instance}/suspend
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance resource to suspend.</param>
		/// <param name="discardLocalSsd">This property is required if the instance has any attached Local SSD disks. If false, Local SSD data will be preserved when the instance is suspended. If true, the contents of any attached Local SSD disks will be discarded.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_suspendAsync(string project, string zone, string instance, bool discardLocalSsd, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/suspend&discardLocalSsd="+discardLocalSsd+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified access config from an instance's network interface with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_instances_updateAccessConfig projects/{project}/zones/{zone}/instances/{instance}/updateAccessConfig
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">The instance name for this request.</param>
		/// <param name="networkInterface">The name of the network interface where the access config is attached.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_updateAccessConfigAsync(string project, string zone, string instance, string networkInterface, string requestId, AccessConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/updateAccessConfig&networkInterface=" + (networkInterface==null? "" : System.Uri.EscapeDataString(networkInterface))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the Display config for a VM instance. You can only use this method on a stopped VM instance. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_instances_updateDisplayDevice projects/{project}/zones/{zone}/instances/{instance}/updateDisplayDevice
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_updateDisplayDeviceAsync(string project, string zone, string instance, string requestId, DisplayDevice requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/updateDisplayDevice&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates an instance's network interface. This method can only update an interface's alias IP range and attached network. See Modifying alias IP ranges for an existing instance for instructions on changing alias IP ranges. See Migrating a VM between networks for instructions on migrating an interface. This method follows PATCH semantics.
		/// Compute_instances_updateNetworkInterface projects/{project}/zones/{zone}/instances/{instance}/updateNetworkInterface
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">The instance name for this request.</param>
		/// <param name="networkInterface">The name of the network interface to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_updateNetworkInterfaceAsync(string project, string zone, string instance, string networkInterface, string requestId, NetworkInterface requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/updateNetworkInterface&networkInterface=" + (networkInterface==null? "" : System.Uri.EscapeDataString(networkInterface))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates the Shielded Instance config for an instance. You can only use this method on a stopped instance. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
		/// Compute_instances_updateShieldedInstanceConfig projects/{project}/zones/{zone}/instances/{instance}/updateShieldedInstanceConfig
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="instance">Name or id of the instance scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_updateShieldedInstanceConfigAsync(string project, string zone, string instance, string requestId, ShieldedInstanceConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (instance==null? "" : System.Uri.EscapeDataString(instance))+"/updateShieldedInstanceConfig&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_instances_getIamPolicy projects/{project}/zones/{zone}/instances/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_instances_getIamPolicyAsync(string project, string zone, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets deletion protection on the instance.
		/// Compute_instances_setDeletionProtection projects/{project}/zones/{zone}/instances/{resource}/setDeletionProtection
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="deletionProtection">Whether the resource should be protected against deletion.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_instances_setDeletionProtectionAsync(string project, string zone, string resource, bool deletionProtection, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setDeletionProtection&deletionProtection="+deletionProtection+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_instances_setIamPolicy projects/{project}/zones/{zone}/instances/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_instances_setIamPolicyAsync(string project, string zone, string resource, ZoneSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_instances_testIamPermissions projects/{project}/zones/{zone}/instances/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_instances_testIamPermissionsAsync(string project, string zone, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/instances/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of machine types available to the specified project.
		/// Compute_machineTypes_list projects/{project}/zones/{zone}/machineTypes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<MachineTypeList> Compute_machineTypes_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/machineTypes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MachineTypeList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified machine type.
		/// Compute_machineTypes_get projects/{project}/zones/{zone}/machineTypes/{machineType}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="machineType">Name of the machine type to return.</param>
		/// <returns>Successful response</returns>
		public async Task<MachineType> Compute_machineTypes_getAsync(string project, string zone, string machineType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/machineTypes/"+ (machineType==null? "" : System.Uri.EscapeDataString(machineType));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<MachineType>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the list of network endpoint groups that are located in the specified project and zone.
		/// Compute_networkEndpointGroups_list projects/{project}/zones/{zone}/networkEndpointGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEndpointGroupList> Compute_networkEndpointGroups_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/networkEndpointGroups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEndpointGroupList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a network endpoint group in the specified project using the parameters that are included in the request.
		/// Compute_networkEndpointGroups_insert projects/{project}/zones/{zone}/networkEndpointGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where you want to create the network endpoint group. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkEndpointGroups_insertAsync(string project, string zone, string requestId, NetworkEndpointGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/networkEndpointGroups&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified network endpoint group. The network endpoints in the NEG and the VM instances they belong to are not terminated when the NEG is deleted. Note that the NEG cannot be deleted if there are backend services referencing it.
		/// Compute_networkEndpointGroups_delete projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group to delete. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkEndpointGroups_deleteAsync(string project, string zone, string networkEndpointGroup, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified network endpoint group.
		/// Compute_networkEndpointGroups_get projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group. It should comply with RFC1035.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEndpointGroup> Compute_networkEndpointGroups_getAsync(string project, string zone, string networkEndpointGroup, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEndpointGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Attach a list of network endpoints to the specified network endpoint group.
		/// Compute_networkEndpointGroups_attachNetworkEndpoints projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}/attachNetworkEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group where you are attaching network endpoints to. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkEndpointGroups_attachNetworkEndpointsAsync(string project, string zone, string networkEndpointGroup, string requestId, NetworkEndpointGroupsAttachEndpointsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"/attachNetworkEndpoints&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Detach a list of network endpoints from the specified network endpoint group.
		/// Compute_networkEndpointGroups_detachNetworkEndpoints projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}/detachNetworkEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group where you are removing network endpoints. It should comply with RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_networkEndpointGroups_detachNetworkEndpointsAsync(string project, string zone, string networkEndpointGroup, string requestId, NetworkEndpointGroupsDetachEndpointsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"/detachNetworkEndpoints&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists the network endpoints in the specified network endpoint group.
		/// Compute_networkEndpointGroups_listNetworkEndpoints projects/{project}/zones/{zone}/networkEndpointGroups/{networkEndpointGroup}/listNetworkEndpoints
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone where the network endpoint group is located. It should comply with RFC1035.</param>
		/// <param name="networkEndpointGroup">The name of the network endpoint group from which you want to generate a list of included network endpoints. It should comply with RFC1035.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NetworkEndpointGroupsListNetworkEndpoints> Compute_networkEndpointGroups_listNetworkEndpointsAsync(string project, string zone, string networkEndpointGroup, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, NetworkEndpointGroupsListEndpointsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/networkEndpointGroups/"+ (networkEndpointGroup==null? "" : System.Uri.EscapeDataString(networkEndpointGroup))+"/listNetworkEndpoints&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NetworkEndpointGroupsListNetworkEndpoints>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_networkEndpointGroups_testIamPermissions projects/{project}/zones/{zone}/networkEndpointGroups/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_networkEndpointGroups_testIamPermissionsAsync(string project, string zone, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/networkEndpointGroups/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of node groups available to the specified project. Note: use nodeGroups.listNodes for more details about each group.
		/// Compute_nodeGroups_list projects/{project}/zones/{zone}/nodeGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NodeGroupList> Compute_nodeGroups_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeGroupList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a NodeGroup resource in the specified project using the data included in the request.
		/// Compute_nodeGroups_insert projects/{project}/zones/{zone}/nodeGroups
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="initialNodeCount">Initial count of nodes in the node group.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_nodeGroups_insertAsync(string project, string zone, int initialNodeCount, string requestId, NodeGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups&initialNodeCount="+initialNodeCount+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified NodeGroup resource.
		/// Compute_nodeGroups_delete projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="nodeGroup">Name of the NodeGroup resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_nodeGroups_deleteAsync(string project, string zone, string nodeGroup, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (nodeGroup==null? "" : System.Uri.EscapeDataString(nodeGroup))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified NodeGroup. Get a list of available NodeGroups by making a list() request. Note: the "nodes" field should not be used. Use nodeGroups.listNodes instead.
		/// Compute_nodeGroups_get projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="nodeGroup">Name of the node group to return.</param>
		/// <returns>Successful response</returns>
		public async Task<NodeGroup> Compute_nodeGroups_getAsync(string project, string zone, string nodeGroup, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (nodeGroup==null? "" : System.Uri.EscapeDataString(nodeGroup));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeGroup>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the specified node group.
		/// Compute_nodeGroups_patch projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="nodeGroup">Name of the NodeGroup resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_nodeGroups_patchAsync(string project, string zone, string nodeGroup, string requestId, NodeGroup requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (nodeGroup==null? "" : System.Uri.EscapeDataString(nodeGroup))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Adds specified number of nodes to the node group.
		/// Compute_nodeGroups_addNodes projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}/addNodes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="nodeGroup">Name of the NodeGroup resource.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_nodeGroups_addNodesAsync(string project, string zone, string nodeGroup, string requestId, NodeGroupsAddNodesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (nodeGroup==null? "" : System.Uri.EscapeDataString(nodeGroup))+"/addNodes&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes specified nodes from the node group.
		/// Compute_nodeGroups_deleteNodes projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}/deleteNodes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="nodeGroup">Name of the NodeGroup resource whose nodes will be deleted.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_nodeGroups_deleteNodesAsync(string project, string zone, string nodeGroup, string requestId, NodeGroupsDeleteNodesRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (nodeGroup==null? "" : System.Uri.EscapeDataString(nodeGroup))+"/deleteNodes&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists nodes in the node group.
		/// Compute_nodeGroups_listNodes projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}/listNodes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="nodeGroup">Name of the NodeGroup resource whose nodes you want to list.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NodeGroupsListNodes> Compute_nodeGroups_listNodesAsync(string project, string zone, string nodeGroup, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (nodeGroup==null? "" : System.Uri.EscapeDataString(nodeGroup))+"/listNodes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeGroupsListNodes>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates the node template of the node group.
		/// Compute_nodeGroups_setNodeTemplate projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}/setNodeTemplate
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="nodeGroup">Name of the NodeGroup resource to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_nodeGroups_setNodeTemplateAsync(string project, string zone, string nodeGroup, string requestId, NodeGroupsSetNodeTemplateRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (nodeGroup==null? "" : System.Uri.EscapeDataString(nodeGroup))+"/setNodeTemplate&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Simulates maintenance event on specified nodes from the node group.
		/// Compute_nodeGroups_simulateMaintenanceEvent projects/{project}/zones/{zone}/nodeGroups/{nodeGroup}/simulateMaintenanceEvent
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="nodeGroup">Name of the NodeGroup resource whose nodes will go under maintenance simulation.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_nodeGroups_simulateMaintenanceEventAsync(string project, string zone, string nodeGroup, string requestId, NodeGroupsSimulateMaintenanceEventRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (nodeGroup==null? "" : System.Uri.EscapeDataString(nodeGroup))+"/simulateMaintenanceEvent&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_nodeGroups_getIamPolicy projects/{project}/zones/{zone}/nodeGroups/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_nodeGroups_getIamPolicyAsync(string project, string zone, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_nodeGroups_setIamPolicy projects/{project}/zones/{zone}/nodeGroups/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_nodeGroups_setIamPolicyAsync(string project, string zone, string resource, ZoneSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_nodeGroups_testIamPermissions projects/{project}/zones/{zone}/nodeGroups/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_nodeGroups_testIamPermissionsAsync(string project, string zone, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeGroups/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of node types available to the specified project.
		/// Compute_nodeTypes_list projects/{project}/zones/{zone}/nodeTypes
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<NodeTypeList> Compute_nodeTypes_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeTypes&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeTypeList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified node type.
		/// Compute_nodeTypes_get projects/{project}/zones/{zone}/nodeTypes/{nodeType}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="nodeType">Name of the node type to return.</param>
		/// <returns>Successful response</returns>
		public async Task<NodeType> Compute_nodeTypes_getAsync(string project, string zone, string nodeType, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/nodeTypes/"+ (nodeType==null? "" : System.Uri.EscapeDataString(nodeType));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NodeType>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of Operation resources contained within the specified zone.
		/// Compute_zoneOperations_list projects/{project}/zones/{zone}/operations
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<OperationList> Compute_zoneOperations_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/operations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<OperationList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified zone-specific Operations resource.
		/// Compute_zoneOperations_delete projects/{project}/zones/{zone}/operations/{operation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="operation">Name of the Operations resource to delete.</param>
		/// <returns>Successful response</returns>
		public async Task Compute_zoneOperations_deleteAsync(string project, string zone, string operation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the specified zone-specific Operations resource.
		/// Compute_zoneOperations_get projects/{project}/zones/{zone}/operations/{operation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="operation">Name of the Operations resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_zoneOperations_getAsync(string project, string zone, string operation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method waits for no more than the 2 minutes and then returns the current state of the operation, which might be `DONE` or still in progress. This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.
		/// Compute_zoneOperations_wait projects/{project}/zones/{zone}/operations/{operation}/wait
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="operation">Name of the Operations resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_zoneOperations_waitAsync(string project, string zone, string operation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/operations/"+ (operation==null? "" : System.Uri.EscapeDataString(operation))+"/wait";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// A list of all the reservations that have been configured for the specified project in specified zone.
		/// Compute_reservations_list projects/{project}/zones/{zone}/reservations
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<ReservationList> Compute_reservations_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/reservations&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ReservationList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new reservation. For more information, read Reserving zonal resources.
		/// Compute_reservations_insert projects/{project}/zones/{zone}/reservations
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_reservations_insertAsync(string project, string zone, string requestId, Reservation requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/reservations&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified reservation.
		/// Compute_reservations_delete projects/{project}/zones/{zone}/reservations/{reservation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="reservation">Name of the reservation to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_reservations_deleteAsync(string project, string zone, string reservation, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/reservations/"+ (reservation==null? "" : System.Uri.EscapeDataString(reservation))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves information about the specified reservation.
		/// Compute_reservations_get projects/{project}/zones/{zone}/reservations/{reservation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="reservation">Name of the reservation to retrieve.</param>
		/// <returns>Successful response</returns>
		public async Task<Reservation> Compute_reservations_getAsync(string project, string zone, string reservation, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/reservations/"+ (reservation==null? "" : System.Uri.EscapeDataString(reservation));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Reservation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update share settings of the reservation.
		/// Compute_reservations_update projects/{project}/zones/{zone}/reservations/{reservation}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="reservation">Name of the reservation to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <param name="updateMask">Update_mask indicates fields to be updated as part of this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_reservations_updateAsync(string project, string zone, string reservation, string[] paths, string requestId, string updateMask, Reservation requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/reservations/"+ (reservation==null? "" : System.Uri.EscapeDataString(reservation))+"&"+string.Join("&", paths.Select(z => $"paths={System.Uri.EscapeDataString(z.ToString())}"))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Resizes the reservation (applicable to standalone reservations only). For more information, read Modifying reservations.
		/// Compute_reservations_resize projects/{project}/zones/{zone}/reservations/{reservation}/resize
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone for this request.</param>
		/// <param name="reservation">Name of the reservation to update.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_reservations_resizeAsync(string project, string zone, string reservation, string requestId, ReservationsResizeRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/reservations/"+ (reservation==null? "" : System.Uri.EscapeDataString(reservation))+"/resize&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
		/// Compute_reservations_getIamPolicy projects/{project}/zones/{zone}/reservations/{resource}/getIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <param name="optionsRequestedPolicyVersion">Requested IAM Policy version.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_reservations_getIamPolicyAsync(string project, string zone, string resource, int optionsRequestedPolicyVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/reservations/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/getIamPolicy&optionsRequestedPolicyVersion="+optionsRequestedPolicyVersion;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the access control policy on the specified resource. Replaces any existing policy.
		/// Compute_reservations_setIamPolicy projects/{project}/zones/{zone}/reservations/{resource}/setIamPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<Policy> Compute_reservations_setIamPolicyAsync(string project, string zone, string resource, ZoneSetPolicyRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/reservations/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/setIamPolicy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Policy>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Returns permissions that a caller has on the specified resource.
		/// Compute_reservations_testIamPermissions projects/{project}/zones/{zone}/reservations/{resource}/testIamPermissions
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">The name of the zone for this request.</param>
		/// <param name="resource">Name or id of the resource for this request.</param>
		/// <returns>Successful response</returns>
		public async Task<TestPermissionsResponse> Compute_reservations_testIamPermissionsAsync(string project, string zone, string resource, TestPermissionsRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/reservations/"+ (resource==null? "" : System.Uri.EscapeDataString(resource))+"/testIamPermissions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TestPermissionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieves a list of TargetInstance resources available to the specified project and zone.
		/// Compute_targetInstances_list projects/{project}/zones/{zone}/targetInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone scoping this request.</param>
		/// <param name="filter">A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.</param>
		/// <param name="maxResults">The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)</param>
		/// <param name="orderBy">Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.</param>
		/// <param name="pageToken">Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.</param>
		/// <param name="returnPartialSuccess">Opt-in for partial success behavior which provides partial results in case of failure. The default value is false.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetInstanceList> Compute_targetInstances_listAsync(string project, string zone, string filter, int maxResults, string orderBy, string pageToken, bool returnPartialSuccess, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/targetInstances&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter))+"&maxResults="+maxResults+"&orderBy=" + (orderBy==null? "" : System.Uri.EscapeDataString(orderBy))+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&returnPartialSuccess="+returnPartialSuccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetInstanceList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a TargetInstance resource in the specified project and zone using the data included in the request.
		/// Compute_targetInstances_insert projects/{project}/zones/{zone}/targetInstances
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone scoping this request.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetInstances_insertAsync(string project, string zone, string requestId, TargetInstance requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/targetInstances&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Deletes the specified TargetInstance resource.
		/// Compute_targetInstances_delete projects/{project}/zones/{zone}/targetInstances/{targetInstance}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone scoping this request.</param>
		/// <param name="targetInstance">Name of the TargetInstance resource to delete.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetInstances_deleteAsync(string project, string zone, string targetInstance, string requestId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/targetInstances/"+ (targetInstance==null? "" : System.Uri.EscapeDataString(targetInstance))+"&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the specified TargetInstance resource.
		/// Compute_targetInstances_get projects/{project}/zones/{zone}/targetInstances/{targetInstance}
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone scoping this request.</param>
		/// <param name="targetInstance">Name of the TargetInstance resource to return.</param>
		/// <returns>Successful response</returns>
		public async Task<TargetInstance> Compute_targetInstances_getAsync(string project, string zone, string targetInstance, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/targetInstances/"+ (targetInstance==null? "" : System.Uri.EscapeDataString(targetInstance));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TargetInstance>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets the Google Cloud Armor security policy for the specified target instance. For more information, see Google Cloud Armor Overview
		/// Compute_targetInstances_setSecurityPolicy projects/{project}/zones/{zone}/targetInstances/{targetInstance}/setSecurityPolicy
		/// </summary>
		/// <param name="project">Project ID for this request.</param>
		/// <param name="zone">Name of the zone scoping this request.</param>
		/// <param name="targetInstance">Name of the TargetInstance resource to which the security policy should be set. The name should conform to RFC1035.</param>
		/// <param name="requestId">An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).</param>
		/// <returns>Successful response</returns>
		public async Task<Operation> Compute_targetInstances_setSecurityPolicyAsync(string project, string zone, string targetInstance, string requestId, SecurityPolicyReference requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "projects/"+ (project==null? "" : System.Uri.EscapeDataString(project))+"/zones/"+ (zone==null? "" : System.Uri.EscapeDataString(zone))+"/targetInstances/"+ (targetInstance==null? "" : System.Uri.EscapeDataString(targetInstance))+"/setSecurityPolicy&requestId=" + (requestId==null? "" : System.Uri.EscapeDataString(requestId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Operation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public enum Compute_networks_listPeeringRoutesDirection
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCOMING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OUTGOING = 1,
	}
	
	public enum Compute_instances_updateMinimalAction
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_EFFECT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REFRESH = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTART = 3,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
