//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Request for the Acknowledge method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AcknowledgeRequest
	{
		
		/// <summary>
		/// The acknowledgment ID for the message being acknowledged. This was returned by the Pub/Sub system in the Pull response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ackId")]
		public string[] AckId { get; set; }
		
		/// <summary>
		/// The subscription whose message is being acknowledged.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription")]
		public string Subscription { get; set; }
	}
	
	/// <summary>
	/// An empty message that you can re-use to avoid defining duplicated empty messages in your project. A typical example is to use it as argument or the return value of a service API. For instance: service Foo { rpc Bar (proto2.Empty) returns (proto2.Empty) { }; }; BEGIN GOOGLE-INTERNAL The difference between this one and net/rpc/empty-message.proto is that 1) The generated message here is in proto2 C++ API. 2) The proto2.Empty has minimum dependencies (no message_set or net/rpc dependencies) END GOOGLE-INTERNAL
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Empty
	{
	}
	
	/// <summary>
	/// A key-value pair applied to a given object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Label
	{
		
		/// <summary>
		/// The key of a label is a syntactically valid URL (as per RFC 1738) with the "scheme" and initial slashes omitted and with the additional restrictions noted below. Each key should be globally unique. The "host" portion is called the "namespace" and is not necessarily resolvable to a network endpoint. Instead, the namespace indicates what system or entity defines the semantics of the label. Namespaces do not restrict the set of objects to which a label may be associated. Keys are defined by the following grammar: key = hostname "/" kpath kpath = ksegment *[ "/" ksegment ] ksegment = alphadigit | *[ alphadigit | "-" | "_" | "." ] where "hostname" and "alphadigit" are defined as in RFC 1738. Example key: spanner.google.com/universe
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="key")]
		public string Key { get; set; }
		
		/// <summary>
		/// An integer value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numValue")]
		public string NumValue { get; set; }
		
		/// <summary>
		/// A string value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="strValue")]
		public string StrValue { get; set; }
	}
	
	/// <summary>
	/// Response for the ListSubscriptions method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListSubscriptionsResponse
	{
		
		/// <summary>
		/// If not empty, indicates that there are more subscriptions that match the request and this value should be passed to the next ListSubscriptionsRequest to continue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The subscriptions that match the request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription")]
		public Subscription[] Subscription { get; set; }
	}
	
	/// <summary>
	/// A subscription resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Subscription
	{
		
		/// <summary>
		/// For either push or pull delivery, the value is the maximum time after a subscriber receives a message before the subscriber should acknowledge or Nack the message. If the Ack deadline for a message passes without an Ack or a Nack, the Pub/Sub system will eventually redeliver the message. If a subscriber acknowledges after the deadline, the Pub/Sub system may accept the Ack, but it is possible that the message has been already delivered again. Multiple Acks to the message are allowed and will succeed. For push delivery, this value is used to set the request timeout for the call to the push endpoint. For pull delivery, this value is used as the initial value for the Ack deadline. It may be overridden for each message using its corresponding ack_id with ModifyAckDeadline. While a message is outstanding (i.e. it has been delivered to a pull subscriber and the subscriber has not yet Acked or Nacked), the Pub/Sub system will not deliver that message to another pull subscriber (on a best-effort basis).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ackDeadlineSeconds")]
		public System.Nullable<System.Int32> AckDeadlineSeconds { get; set; }
		
		/// <summary>
		/// Name of the subscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Configuration for a push delivery endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pushConfig")]
		public PushConfig PushConfig { get; set; }
		
		/// <summary>
		/// The name of the topic from which this subscription is receiving messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topic")]
		public string Topic { get; set; }
	}
	
	/// <summary>
	/// Configuration for a push delivery endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PushConfig
	{
		
		/// <summary>
		/// A URL locating the endpoint to which messages should be pushed. For example, a Webhook endpoint might use "https://example.com/push".
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pushEndpoint")]
		public string PushEndpoint { get; set; }
	}
	
	/// <summary>
	/// Response for the ListTopics method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ListTopicsResponse
	{
		
		/// <summary>
		/// If not empty, indicates that there are more topics that match the request, and this value should be passed to the next ListTopicsRequest to continue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The resulting topics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topic")]
		public Topic[] Topic { get; set; }
	}
	
	/// <summary>
	/// A topic resource.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Topic
	{
		
		/// <summary>
		/// Name of the topic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// Request for the ModifyAckDeadline method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ModifyAckDeadlineRequest
	{
		
		/// <summary>
		/// The new ack deadline with respect to the time this request was sent to the Pub/Sub system. Must be >= 0. For example, if the value is 10, the new ack deadline will expire 10 seconds after the ModifyAckDeadline call was made. Specifying zero may immediately make the message available for another pull request.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ackDeadlineSeconds")]
		public System.Nullable<System.Int32> AckDeadlineSeconds { get; set; }
		
		/// <summary>
		/// The acknowledgment ID. Either this or ack_ids must be populated, not both.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ackId")]
		public string AckId { get; set; }
		
		/// <summary>
		/// List of acknowledgment IDs. Either this field or ack_id should be populated, not both.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ackIds")]
		public string[] AckIds { get; set; }
		
		/// <summary>
		/// Next Index: 5 The name of the subscription from which messages are being pulled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription")]
		public string Subscription { get; set; }
	}
	
	/// <summary>
	/// Request for the ModifyPushConfig method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ModifyPushConfigRequest
	{
		
		/// <summary>
		/// Configuration for a push delivery endpoint.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pushConfig")]
		public PushConfig PushConfig { get; set; }
		
		/// <summary>
		/// The name of the subscription.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription")]
		public string Subscription { get; set; }
	}
	
	/// <summary>
	/// Request for the PublishBatch method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PublishBatchRequest
	{
		
		/// <summary>
		/// The messages to publish.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messages")]
		public PubsubMessage[] Messages { get; set; }
		
		/// <summary>
		/// The messages in the request will be published on this topic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topic")]
		public string Topic { get; set; }
	}
	
	/// <summary>
	/// A message data and its labels.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PubsubMessage
	{
		
		/// <summary>
		/// The message payload.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="data")]
		public string Data { get; set; }
		
		/// <summary>
		/// Optional list of labels for this message. Keys in this collection must be unique.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="label")]
		public Label[] Label { get; set; }
		
		/// <summary>
		/// ID of this message assigned by the server at publication time. Guaranteed to be unique within the topic. This value may be read by a subscriber that receives a PubsubMessage via a Pull call or a push delivery. It must not be populated by a publisher in a Publish call.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageId")]
		public string MessageId { get; set; }
		
		/// <summary>
		/// The time at which the message was published. The time is milliseconds since the UNIX epoch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="publishTime")]
		public string PublishTime { get; set; }
	}
	
	/// <summary>
	/// Response for the PublishBatch method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PublishBatchResponse
	{
		
		/// <summary>
		/// The server-assigned ID of each published message, in the same order as the messages in the request. IDs are guaranteed to be unique within the topic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="messageIds")]
		public string[] MessageIds { get; set; }
	}
	
	/// <summary>
	/// Request for the Publish method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PublishRequest
	{
		
		/// <summary>
		/// A message data and its labels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public PubsubMessage Message { get; set; }
		
		/// <summary>
		/// The message in the request will be published on this topic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topic")]
		public string Topic { get; set; }
	}
	
	/// <summary>
	/// An event indicating a received message or truncation event.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PubsubEvent
	{
		
		/// <summary>
		/// Indicates that this subscription has been deleted. (Note that pull subscribers will always receive NOT_FOUND in response in their pull request on the subscription, rather than seeing this boolean.)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deleted")]
		public System.Nullable<System.Boolean> Deleted { get; set; }
		
		/// <summary>
		/// A message data and its labels.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public PubsubMessage Message { get; set; }
		
		/// <summary>
		/// The subscription that received the event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription")]
		public string Subscription { get; set; }
		
		/// <summary>
		/// Indicates that this subscription has been truncated.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="truncated")]
		public System.Nullable<System.Boolean> Truncated { get; set; }
	}
	
	/// <summary>
	/// Request for the PullBatch method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PullBatchRequest
	{
		
		/// <summary>
		/// The maximum number of PubsubEvents returned for this request. The Pub/Sub system may return fewer than the number of events specified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxEvents")]
		public System.Nullable<System.Int32> MaxEvents { get; set; }
		
		/// <summary>
		/// If this is specified as true the system will respond immediately even if it is not able to return a message in the Pull response. Otherwise the system is allowed to wait until at least one message is available rather than returning no messages. The client may cancel the request if it does not wish to wait any longer for the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="returnImmediately")]
		public System.Nullable<System.Boolean> ReturnImmediately { get; set; }
		
		/// <summary>
		/// The subscription from which messages should be pulled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription")]
		public string Subscription { get; set; }
	}
	
	/// <summary>
	/// Response for the PullBatch method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PullBatchResponse
	{
		
		/// <summary>
		/// Received Pub/Sub messages or status events. The Pub/Sub system will return zero messages if there are no more messages available in the backlog. The Pub/Sub system may return fewer than the max_events requested even if there are more messages available in the backlog.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pullResponses")]
		public PullResponse[] PullResponses { get; set; }
	}
	
	/// <summary>
	/// Either a PubsubMessage or a truncation event. One of these two must be populated.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PullResponse
	{
		
		/// <summary>
		/// This ID must be used to acknowledge the received event or message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ackId")]
		public string AckId { get; set; }
		
		/// <summary>
		/// An event indicating a received message or truncation event.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pubsubEvent")]
		public PubsubEvent PubsubEvent { get; set; }
	}
	
	/// <summary>
	/// Request for the Pull method.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PullRequest
	{
		
		/// <summary>
		/// If this is specified as true the system will respond immediately even if it is not able to return a message in the Pull response. Otherwise the system is allowed to wait until at least one message is available rather than returning FAILED_PRECONDITION. The client may cancel the request if it does not wish to wait any longer for the response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="returnImmediately")]
		public System.Nullable<System.Boolean> ReturnImmediately { get; set; }
		
		/// <summary>
		/// The subscription from which a message should be pulled.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subscription")]
		public string Subscription { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists matching subscriptions.
		/// Pubsub_subscriptions_list v1beta1a/subscriptions
		/// </summary>
		/// <param name="maxResults">Maximum number of subscriptions to return.</param>
		/// <param name="pageToken">The value obtained in the last ListSubscriptionsResponse for continuation.</param>
		/// <param name="query">A valid label query expression.</param>
		/// <returns>Successful response</returns>
		public async Task<ListSubscriptionsResponse> Pubsub_subscriptions_listAsync(int maxResults, string pageToken, string query, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/subscriptions?maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&query=" + (query==null? "" : System.Uri.EscapeDataString(query));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListSubscriptionsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a subscription on a given topic for a given subscriber. If the subscription already exists, returns ALREADY_EXISTS. If the corresponding topic doesn't exist, returns NOT_FOUND. If the name is not provided in the request, the server will assign a random name for this subscription on the same project as the topic.
		/// Pubsub_subscriptions_create v1beta1a/subscriptions
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<Subscription> Pubsub_subscriptions_createAsync(Subscription requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/subscriptions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Subscription>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Acknowledges a particular received message: the Pub/Sub system can remove the given message from the subscription. Acknowledging a message whose Ack deadline has expired may succeed, but the message could have been already redelivered. Acknowledging a message more than once will not result in an error. This is only used for messages received via pull.
		/// Pubsub_subscriptions_acknowledge v1beta1a/subscriptions/acknowledge
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<Empty> Pubsub_subscriptions_acknowledgeAsync(AcknowledgeRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/subscriptions/acknowledge";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modifies the Ack deadline for a message received from a pull request.
		/// Pubsub_subscriptions_modifyAckDeadline v1beta1a/subscriptions/modifyAckDeadline
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<Empty> Pubsub_subscriptions_modifyAckDeadlineAsync(ModifyAckDeadlineRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/subscriptions/modifyAckDeadline";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Modifies the PushConfig for a specified subscription. This method can be used to suspend the flow of messages to an endpoint by clearing the PushConfig field in the request. Messages will be accumulated for delivery even if no push configuration is defined or while the configuration is modified.
		/// Pubsub_subscriptions_modifyPushConfig v1beta1a/subscriptions/modifyPushConfig
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<Empty> Pubsub_subscriptions_modifyPushConfigAsync(ModifyPushConfigRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/subscriptions/modifyPushConfig";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Pulls a single message from the server. If return_immediately is true, and no messages are available in the subscription, this method returns FAILED_PRECONDITION. The system is free to return an UNAVAILABLE error if no messages are available in a reasonable amount of time (to reduce system load).
		/// Pubsub_subscriptions_pull v1beta1a/subscriptions/pull
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<PullResponse> Pubsub_subscriptions_pullAsync(PullRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/subscriptions/pull";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PullResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Pulls messages from the server. Returns an empty list if there are no messages available in the backlog. The system is free to return UNAVAILABLE if there are too many pull requests outstanding for the given subscription.
		/// Pubsub_subscriptions_pullBatch v1beta1a/subscriptions/pullBatch
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<PullBatchResponse> Pubsub_subscriptions_pullBatchAsync(PullBatchRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/subscriptions/pullBatch";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PullBatchResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes an existing subscription. All pending messages in the subscription are immediately dropped. Calls to Pull after deletion will return NOT_FOUND.
		/// Pubsub_subscriptions_delete v1beta1a/subscriptions/{subscription}
		/// </summary>
		/// <param name="subscription">The subscription to delete.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Pubsub_subscriptions_deleteAsync(string subscription, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/subscriptions/"+ (subscription==null? "" : System.Uri.EscapeDataString(subscription));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the configuration details of a subscription.
		/// Pubsub_subscriptions_get v1beta1a/subscriptions/{subscription}
		/// </summary>
		/// <param name="subscription">The name of the subscription to get.</param>
		/// <returns>Successful response</returns>
		public async Task<Subscription> Pubsub_subscriptions_getAsync(string subscription, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/subscriptions/"+ (subscription==null? "" : System.Uri.EscapeDataString(subscription));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Subscription>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists matching topics.
		/// Pubsub_topics_list v1beta1a/topics
		/// </summary>
		/// <param name="maxResults">Maximum number of topics to return.</param>
		/// <param name="pageToken">The value obtained in the last ListTopicsResponse for continuation.</param>
		/// <param name="query">A valid label query expression.</param>
		/// <returns>Successful response</returns>
		public async Task<ListTopicsResponse> Pubsub_topics_listAsync(int maxResults, string pageToken, string query, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/topics?maxResults="+maxResults+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&query=" + (query==null? "" : System.Uri.EscapeDataString(query));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ListTopicsResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates the given topic with the given name.
		/// Pubsub_topics_create v1beta1a/topics
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<Topic> Pubsub_topics_createAsync(Topic requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/topics";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Topic>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds a message to the topic. Returns NOT_FOUND if the topic does not exist.
		/// Pubsub_topics_publish v1beta1a/topics/publish
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<Empty> Pubsub_topics_publishAsync(PublishRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/topics/publish";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Adds one or more messages to the topic. Returns NOT_FOUND if the topic does not exist.
		/// Pubsub_topics_publishBatch v1beta1a/topics/publishBatch
		/// </summary>
		/// <returns>Successful response</returns>
		public async Task<PublishBatchResponse> Pubsub_topics_publishBatchAsync(PublishBatchRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/topics/publishBatch";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PublishBatchResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes the topic with the given name. Returns NOT_FOUND if the topic does not exist. After a topic is deleted, a new topic may be created with the same name.
		/// Pubsub_topics_delete v1beta1a/topics/{topic}
		/// </summary>
		/// <param name="topic">Name of the topic to delete.</param>
		/// <returns>Successful response</returns>
		public async Task<Empty> Pubsub_topics_deleteAsync(string topic, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/topics/"+ (topic==null? "" : System.Uri.EscapeDataString(topic));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Empty>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the configuration of a topic. Since the topic only has the name attribute, this method is only useful to check the existence of a topic. If other attributes are added in the future, they will be returned here.
		/// Pubsub_topics_get v1beta1a/topics/{topic}
		/// </summary>
		/// <param name="topic">The name of the topic to get.</param>
		/// <returns>Successful response</returns>
		public async Task<Topic> Pubsub_topics_getAsync(string topic, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1beta1a/topics/"+ (topic==null? "" : System.Uri.EscapeDataString(topic));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Topic>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
