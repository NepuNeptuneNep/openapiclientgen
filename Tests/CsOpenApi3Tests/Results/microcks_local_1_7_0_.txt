//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Abstract bean representing a Service or API Exchange.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AbstractExchange
	{
		
		/// <summary>
		/// Discriminant type for identifying kind of exchange
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public AbstractExchangeType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AbstractExchangeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reqRespPair = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unidirEvent = 1,
	}
	
	/// <summary>
	/// Artifact to be imported by Microcks.
	///This structure represents a mime-multipart file upload (as specified here: https://swagger.io/docs/specification/describing-request-body/file-upload/)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ArtifactUpload
	{
		
		/// <summary>
		/// The artifact to upload
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="file")]
		public string File { get; set; }
	}
	
	/// <summary>
	/// Protocol binding details for asynchronous operations
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Binding
	{
		
		/// <summary>
		/// Name of destination for asynchronous messages of this operation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationName")]
		public string DestinationName { get; set; }
		
		/// <summary>
		/// Type of destination for asynchronous messages of this operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="destinationType")]
		public string DestinationType { get; set; }
		
		/// <summary>
		/// Type of key for Kafka messages
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="keyType")]
		public string KeyType { get; set; }
		
		/// <summary>
		/// HTTP method for WebSocket binding
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		/// <summary>
		/// Persistent attribute for MQTT binding
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="persistent")]
		public System.Nullable<System.Boolean> Persistent { get; set; }
		
		/// <summary>
		/// Quality of Service attribute for MQTT binding
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="qoS")]
		public string QoS { get; set; }
		
		/// <summary>
		/// Protocol binding identifier
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public BindingType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum BindingType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KAFKA = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MQTT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WS = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AMQP = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NATS = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GOOGLEPUBSUB = 5,
	}
	
	/// <summary>
	/// A simple Counter type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Counter
	{
		
		/// <summary>
		/// Number of items in a resource collection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="counter")]
		public System.Nullable<System.Int32> Counter1 { get; set; }
	}
	
	/// <summary>
	/// A generic map of counter
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CounterMap
	{
	}
	
	/// <summary>
	/// The daily statistic of a service mock invocations
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DailyInvocationStatistic
	{
		
		/// <summary>
		/// The number of service mock invocations on this day
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dailyCount")]
		public double DailyCount { get; set; }
		
		/// <summary>
		/// The day (formatted as yyyyMMdd string) represented by this statistic
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="day")]
		public string Day { get; set; }
		
		/// <summary>
		/// The number of service mock invocations per hour of the day (keys range from 0 to 23)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hourlyCount")]
		public string HourlyCount { get; set; }
		
		/// <summary>
		/// Unique identifier of this statistic object
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The number of service mock invocations per minute of the day (keys range from 0 to 1439)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minuteCount")]
		public string MinuteCount { get; set; }
		
		/// <summary>
		/// The name of the service this statistic is related to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceName")]
		public string ServiceName { get; set; }
		
		/// <summary>
		/// The version of the service this statistic is related to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceVersion")]
		public string ServiceVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class EventMessage
	{
		
		/// <summary>
		/// Body content for this message
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Headers for this message
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Header[] Headers { get; set; }
		
		/// <summary>
		/// Unique identifier of this message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Content type of message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="mediaType")]
		public string MediaType { get; set; }
		
		/// <summary>
		/// Unique distinct name of this message
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Identifier of Operation this message is associated to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationId")]
		public string OperationId { get; set; }
		
		/// <summary>
		/// Unique identifier of TestCase this message is attached (in case of a test)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="testCaseId")]
		public string TestCaseId { get; set; }
	}
	
	/// <summary>
	/// Transport headers for both Requests and Responses
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Header
	{
		
		/// <summary>
		/// Unique distinct name of this Header
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Values for this Header
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string[] Values { get; set; }
	}
	
	/// <summary>
	/// Abstract representation of a Service or API exchange type (request/response, event based, ...)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Exchange
	{
	}
	
	/// <summary>
	/// Representation of optional features configuration used by Microcks server
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FeaturesConfig
	{
		
		/// <summary>
		/// Asynchronous feature properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="async-api")]
		public FeaturesConfigAsync_api Async_api { get; set; }
		
		/// <summary>
		/// Microcks Hub feature properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="microcks-hub")]
		public FeaturesConfigMicrocks_hub Microcks_hub { get; set; }
		
		/// <summary>
		/// Repository filtering feature properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository-filter")]
		public FeaturesConfigRepository_filter Repository_filter { get; set; }
		
		/// <summary>
		/// Repository tenancy feature properties
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repository-tenancy")]
		public FeaturesConfigRepository_tenancy Repository_tenancy { get; set; }
	}
	
	public class FeaturesConfigAsync_api
	{
		
		[System.Runtime.Serialization.DataMember(Name="default-binding")]
		public string Default_binding { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public string Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpoint-AMQP")]
		public string Endpoint_AMQP { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpoint-GOOGLEPUBSUB")]
		public string Endpoint_GOOGLEPUBSUB { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpoint-KAFKA")]
		public string Endpoint_KAFKA { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpoint-MQTT")]
		public string Endpoint_MQTT { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpoint-NATS")]
		public string Endpoint_NATS { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpoint-WS")]
		public string Endpoint_WS { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="frequencies")]
		public string Frequencies { get; set; }
	}
	
	public class FeaturesConfigMicrocks_hub
	{
		
		[System.Runtime.Serialization.DataMember(Name="allowed-roles")]
		public string Allowed_roles { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public string Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endpoint")]
		public string Endpoint { get; set; }
	}
	
	public class FeaturesConfigRepository_filter
	{
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public string Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label-key")]
		public string Label_key { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label-label")]
		public string Label_label { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="label-list")]
		public string Label_list { get; set; }
	}
	
	public class FeaturesConfigRepository_tenancy
	{
		
		[System.Runtime.Serialization.DataMember(Name="artifact-import-allowed-roles")]
		public string Artifact_import_allowed_roles { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public string Enabled { get; set; }
	}
	
	/// <summary>
	/// Data Transfert Object for headers of both Requests and Responses
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HeaderDTO
	{
		
		/// <summary>
		/// Unique distinct name of this Header
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Values for this header (comma separated strings)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="values")]
		public string Values { get; set; }
	}
	
	/// <summary>
	/// An ImportJob allow defining a repository artifact to poll for discovering Services and APIs mocks and tests
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportJob
	{
		
		/// <summary>
		/// Whether this ImportJob is active (ie. scheduled for execution)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="active")]
		public System.Nullable<System.Boolean> Active { get; set; }
		
		/// <summary>
		/// Creation date for this ImportJob
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createdDate")]
		public System.Nullable<System.DateTimeOffset> CreatedDate { get; set; }
		
		/// <summary>
		/// Etag of repository URL during previous import. Is used for not re-importing if no recent changes
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="etag")]
		public string Etag { get; set; }
		
		/// <summary>
		/// Reserved for future usage
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public string Frequency { get; set; }
		
		/// <summary>
		/// Unique identifier of ImportJob
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Date last import was done
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastImportDate")]
		public System.Nullable<System.DateTimeOffset> LastImportDate { get; set; }
		
		/// <summary>
		/// Error message of last import (if any)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastImportError")]
		public string LastImportError { get; set; }
		
		/// <summary>
		/// Flag telling if considered as primary or secondary artifact. Default to `true`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mainArtifact")]
		public System.Nullable<System.Boolean> MainArtifact { get; set; }
		
		/// <summary>
		/// Commodity object for holding metadata on any entity. This object is inspired by Kubernetes metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public Metadata Metadata { get; set; }
		
		/// <summary>
		/// Unique distinct name of this ImportJob
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Whether to disable SSL certificate verification when checking repository
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="repositoryDisableSSLValidation")]
		public System.Nullable<System.Boolean> RepositoryDisableSSLValidation { get; set; }
		
		/// <summary>
		/// URL of mocks and tests repository artifact
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="repositoryUrl")]
		public string RepositoryUrl { get; set; }
		
		/// <summary>
		/// Lightweight reference for an existing Secret
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secretRef")]
		public SecretRef SecretRef { get; set; }
		
		/// <summary>
		/// References of Services discovered when checking repository
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serviceRefs")]
		public ServiceRef[] ServiceRefs { get; set; }
	}
	
	/// <summary>
	/// Commodity object for holding metadata on any entity. This object is inspired by Kubernetes metadata.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Metadata
	{
		
		/// <summary>
		/// Annotations of attached object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="annotations")]
		public System.Collections.Generic.Dictionary<string, string> Annotations { get; set; }
		
		/// <summary>
		/// Creation date of attached object
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdOn")]
		public int CreatedOn { get; set; }
		
		/// <summary>
		/// Labels put on attached object
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Last update of attached object
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lastUpdate")]
		public int LastUpdate { get; set; }
	}
	
	/// <summary>
	/// Lightweight reference of an existing Service
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceRef
	{
		
		/// <summary>
		/// The Service name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Unique reference of a Service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceId")]
		public string ServiceId { get; set; }
		
		/// <summary>
		/// The Service version
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
	}
	
	/// <summary>
	/// Representation of Keycloak / SSO configuration used by Microcks server
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class KeycloakConfig
	{
		
		/// <summary>
		/// SSO Server authentication url
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="auth-server-url")]
		public string Auth_server_url { get; set; }
		
		/// <summary>
		/// Whether Keycloak authentification and usage is enabled
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="enabled")]
		public bool Enabled { get; set; }
		
		/// <summary>
		/// Name of public-client that can be used for requesting OAuth token
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="public-client")]
		public string Public_client { get; set; }
		
		/// <summary>
		/// Authentication realm name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="realm")]
		public string Realm { get; set; }
		
		/// <summary>
		/// Name of Keycloak resource/application used on client side
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resource")]
		public string Resource { get; set; }
		
		/// <summary>
		/// SSL certificates requirements
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="ssl-required")]
		public KeycloakConfigSsl_required Ssl_required { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum KeycloakConfigSsl_required
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		none = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		external = 1,
	}
	
	/// <summary>
	/// A map which keys are already used labels keys and values are already used values for this key
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LabelsMap
	{
	}
	
	/// <summary>
	/// An Operation of a Service or API
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Operation
	{
		
		/// <summary>
		/// Map of protocol binding details for this operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="bindings")]
		public System.Collections.Generic.Dictionary<string, Binding> Bindings { get; set; }
		
		/// <summary>
		/// Default response time delay for mocks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultDelay")]
		public System.Nullable<System.Double> DefaultDelay { get; set; }
		
		/// <summary>
		/// Dispatcher strategy used for mocks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dispatcher")]
		public string Dispatcher { get; set; }
		
		/// <summary>
		/// DispatcherRules used for mocks
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dispatcherRules")]
		public string DispatcherRules { get; set; }
		
		/// <summary>
		/// Name of input parameters in case of Xml based Service
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputName")]
		public string InputName { get; set; }
		
		/// <summary>
		/// Represents transport method
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="method")]
		public string Method { get; set; }
		
		/// <summary>
		/// Unique name of this Operation within Service scope
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Name of output parameters in case of Xml based Service
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputName")]
		public string OutputName { get; set; }
		
		/// <summary>
		/// Contraints that may apply to mock invocatino on this operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameterContraints")]
		public ParameterConstraint[] ParameterContraints { get; set; }
		
		/// <summary>
		/// Paths the mocks endpoints are mapped on
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourcePaths")]
		public string[] ResourcePaths { get; set; }
	}
	
	/// <summary>
	/// Companion object for Operation that may be used to express constraints on request parameters
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ParameterConstraint
	{
		
		/// <summary>
		/// Parameter location
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in")]
		public System.Nullable<ParameterConstraintIn> In { get; set; }
		
		/// <summary>
		/// Whether it's a regular expression matching constraint
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mustMatchRegexp")]
		public string MustMatchRegexp { get; set; }
		
		/// <summary>
		/// Parameter name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Whether it's a recopy constraint
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recopy")]
		public System.Nullable<System.Boolean> Recopy { get; set; }
		
		/// <summary>
		/// Whether it's a required constraint
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="required")]
		public System.Nullable<System.Boolean> Required { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ParameterConstraintIn
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		path = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		query = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		header = 2,
	}
	
	/// <summary>
	/// Specification of additional headers for a Service/API operations. Keys are operation name or "globals" (if header applies to all), values are Header objects DTO.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationHeaders
	{
	}
	
	/// <summary>
	/// Data Transfer object for grouping the mutable properties of an Operation
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationOverrideDTO
	{
		
		/// <summary>
		/// Default delay in milliseconds to apply to mock responses on this operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultDelay")]
		public System.Nullable<System.Int32> DefaultDelay { get; set; }
		
		/// <summary>
		/// Type of dispatcher to apply for this operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dispatcher")]
		public string Dispatcher { get; set; }
		
		/// <summary>
		/// Rules of dispatcher for this operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dispatcherRules")]
		public string DispatcherRules { get; set; }
		
		/// <summary>
		/// Constraints that may apply to incoming parameters on this operation
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parameterConstraints")]
		public ParameterConstraint[] ParameterConstraints { get; set; }
	}
	
	/// <summary>
	/// A mock invocation or test request
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Request
	{
		
		/// <summary>
		/// Body content for this request
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Headers for this Request
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Header[] Headers { get; set; }
		
		/// <summary>
		/// Unique identifier of Request
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unique distinct name of this Request
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Identifier of Operation this Request is associated to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operationId")]
		public string OperationId { get; set; }
		
		/// <summary>
		/// Unique identifier of TestCase this Request is attached (in case of a test)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="testCaseId")]
		public string TestCaseId { get; set; }
	}
	
	/// <summary>
	/// Request associated with corresponding Response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class RequestResponsePair
	{
	}
	
	/// <summary>
	/// Resource represents a Service or API artifacts such as specification, contract
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Resource
	{
		
		/// <summary>
		/// String content of this resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Uniquer identifier of this Service or API Resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unique name/business identifier for this Service or API resource
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Relatvie path of this resource regarding main resource
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Unique identifier of the Servoce or API this resource is attached to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceId")]
		public string ServiceId { get; set; }
		
		/// <summary>
		/// Short name of the artifact this resource was extracted from
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceArtifact")]
		public string SourceArtifact { get; set; }
		
		/// <summary>
		/// Types of managed resources for Services or APIs
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ResourceType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ResourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WSDL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		XSD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JSON_SCHEMA = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN_API_SPEC = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN_API_SCHEMA = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASYNC_API_SPEC = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASYNC_API_SCHEMA = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AVRO_SCHEMA = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROTOBUF_SCHEMA = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROTOBUF_DESCRIPTION = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRAPHQL_SCHEMA = 10,
	}
	
	/// <summary>
	/// A mock invocation or test response
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Response
	{
		
		/// <summary>
		/// Body content of this Response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="content")]
		public string Content { get; set; }
		
		/// <summary>
		/// Headers for this Response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="headers")]
		public Header[] Headers { get; set; }
		
		/// <summary>
		/// Unique identifier of Response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unique distinct name of this Response
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Identifier of Operation this Response is associated to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operationId")]
		public string OperationId { get; set; }
		
		/// <summary>
		/// Unique identifier of TestCase this Response is attached (in case of a test)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="testCaseId")]
		public string TestCaseId { get; set; }
	}
	
	/// <summary>
	/// A Secret allows grouping informations on how to access a restricted resource such as a repsoitory URL. Secrets are typically used by ImpoortJobs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Secret
	{
		
		[System.Runtime.Serialization.DataMember(Name="caCertPem")]
		public string CaCertPem { get; set; }
		
		/// <summary>
		/// Description of this Secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// Unique identifier of Secret
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unique distinct name of Secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="password")]
		public string Password { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="token")]
		public string Token { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="tokenHeader")]
		public string TokenHeader { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="username")]
		public string Username { get; set; }
	}
	
	/// <summary>
	/// Lightweight reference for an existing Secret
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SecretRef
	{
		
		/// <summary>
		/// Distinct name of the referenced Secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Unique identifier or referenced Secret
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secretId")]
		public string SecretId { get; set; }
	}
	
	/// <summary>
	/// Represents a Service or API definition as registred into Microcks repository
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Service
	{
		
		/// <summary>
		/// Unique identifier for this Service or API
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Commodity object for holding metadata on any entity. This object is inspired by Kubernetes metadata.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public Metadata Metadata { get; set; }
		
		/// <summary>
		/// Distinct name for this Service or API (maybe shared among many versions)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Set of Operations for Service or API
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public Operation[] Operations { get; set; }
		
		/// <summary>
		/// Service or API Type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public ServiceType Type { get; set; }
		
		/// <summary>
		/// Distinct version for a named Service or API
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public string Version { get; set; }
		
		/// <summary>
		/// Associated Xml Namespace in case of Xml based Service
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="xmlNS")]
		public string XmlNS { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ServiceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REST = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOAP_HTTP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GENERIC_REST = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GENERIC_EVENT = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EVENT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRPC = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRAPHQL = 6,
	}
	
	/// <summary>
	/// Aggregate bean for grouping a Service an its messages pairs
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ServiceView
	{
		
		/// <summary>
		/// Map of messages for this Service. Keys are operation name, values are array of messages for this operation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="messagesMap")]
		public System.Collections.Generic.Dictionary<string, Exchange[]> MessagesMap { get; set; }
		
		/// <summary>
		/// Represents a Service or API definition as registred into Microcks repository
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="service")]
		public Service Service { get; set; }
	}
	
	/// <summary>
	/// Upload of a repository snapshot file
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SnapshotUpload
	{
		
		/// <summary>
		/// The repository snapshot file
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="file")]
		public string File { get; set; }
	}
	
	/// <summary>
	/// Companion objects for TestResult. Each TestCaseResult correspond to a particuliar service operation / action reference by the operationName field. TestCaseResults owns a collection of TestStepResults (one for every request associated to service operation / action).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestCaseResult
	{
		
		/// <summary>
		/// Elapsed time in milliseconds since the test case beginning
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="elapsedTime")]
		public double ElapsedTime { get; set; }
		
		/// <summary>
		/// Name of operation this test case is bound to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operationName")]
		public string OperationName { get; set; }
		
		/// <summary>
		/// Flag telling if test case is a success
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="success")]
		public bool Success { get; set; }
		
		/// <summary>
		/// Test steps associated to this test case
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="testStepResults")]
		public TestStepResult[] TestStepResults { get; set; }
	}
	
	/// <summary>
	/// TestStepResult is an entity embedded within TestCaseResult. They are created for each request associated with an operation / action of a microservice.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestStepResult
	{
		
		/// <summary>
		/// Elapsed time in milliseconds since the test step beginning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="elapsedTime")]
		public System.Nullable<System.Double> ElapsedTime { get; set; }
		
		/// <summary>
		/// Name of event this test step is bound to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="eventMessageName")]
		public string EventMessageName { get; set; }
		
		/// <summary>
		/// Error message that may be associated to this test step
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Name of request this test step is bound to
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestName")]
		public string RequestName { get; set; }
		
		/// <summary>
		/// Flag telling if test case is a success
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="success")]
		public bool Success { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestCaseReturnDTO
	{
		
		/// <summary>
		/// Name of related operation for this TestCase
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operationName")]
		public string OperationName { get; set; }
	}
	
	/// <summary>
	/// Represents the test conformance metrics (current score, history and evolution trend) of a Service
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestConformanceMetric
	{
		
		/// <summary>
		/// Value of the label used for metrics aggregation (if any)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aggregationLabelValue")]
		public string AggregationLabelValue { get; set; }
		
		/// <summary>
		/// Current test conformance score for the related Service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentScore")]
		public double CurrentScore { get; set; }
		
		/// <summary>
		/// Unique identifier of coverage metric
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The day of latest score update (in yyyyMMdd format)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lastUpdateDay")]
		public string LastUpdateDay { get; set; }
		
		/// <summary>
		/// History of latest scores (key is date with format yyyyMMdd, value is score as double)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latestScores")]
		public System.Collections.Generic.Dictionary<string, double> LatestScores { get; set; }
		
		/// <summary>
		/// Evolution trend qualifier
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latestTrend")]
		public System.Nullable<TestConformanceMetricLatestTrend> LatestTrend { get; set; }
		
		/// <summary>
		/// Maximum conformance score that can be reached (depends on samples expresiveness)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="maxPossibleScore")]
		public double MaxPossibleScore { get; set; }
		
		/// <summary>
		/// Unique identifier of the Service this metric is related to
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceId")]
		public string ServiceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TestConformanceMetricLatestTrend
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOW_DOWN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STABLE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOW_UP = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UP = 4,
	}
	
	/// <summary>
	/// Test request is a minimalist wrapper for requesting the launch of a new test
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestRequest
	{
		
		/// <summary>
		/// A restriction on service operations to test
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filteredOperations")]
		public string[] FilteredOperations { get; set; }
		
		/// <summary>
		/// Specification of additional headers for a Service/API operations. Keys are operation name or "globals" (if header applies to all), values are Header objects DTO.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationHeaders")]
		public OperationHeaders OperationHeaders { get; set; }
		
		/// <summary>
		/// Type of test strategy (different strategies are implemented by different runners)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runnerType")]
		public TestRequestRunnerType RunnerType { get; set; }
		
		/// <summary>
		/// The name of Secret to use for connecting the test endpoint
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secretName")]
		public string SecretName { get; set; }
		
		/// <summary>
		/// Unique identifier of service to test
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceId")]
		public string ServiceId { get; set; }
		
		/// <summary>
		/// Endpoint to test for this service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="testEndpoint")]
		public string TestEndpoint { get; set; }
		
		/// <summary>
		/// The maximum time (in milliseconds) to wait for this test ends
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public int Timeout { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TestRequestRunnerType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOAP_HTTP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOAP_UI = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POSTMAN = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN_API_SCHEMA = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASYNC_API_SCHEMA = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRPC_PROTOBUF = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRAPHQL_SCHEMA = 7,
	}
	
	/// <summary>
	/// Represents the result of a Service or API test run by Microcks. Tests are related to a service and made of multiple test cases corresponding to each operations / actions composing service. Tests are run against a specific endpoint named testedEndpoint. It holds global markers telling if test still ran, is a success, how many times is has taken and so on ...
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestResult
	{
		
		/// <summary>
		/// Elapsed time in milliseconds since test beginning
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="elapsedTime")]
		public System.Nullable<System.Double> ElapsedTime { get; set; }
		
		/// <summary>
		/// Unique identifier of TestResult
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Flag telling is test is still in progress
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="inProgress")]
		public bool InProgress { get; set; }
		
		/// <summary>
		/// Specification of additional headers for a Service/API operations. Keys are operation name or "globals" (if header applies to all), values are Header objects DTO.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="operationHeaders")]
		public OperationHeaders OperationHeaders { get; set; }
		
		/// <summary>
		/// Type of test strategy (different strategies are implemented by different runners)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="runnerType")]
		public TestRequestRunnerType RunnerType { get; set; }
		
		/// <summary>
		/// Lightweight reference for an existing Secret
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="secretRef")]
		public SecretRef SecretRef { get; set; }
		
		/// <summary>
		/// Unique identifier of service tested
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceId")]
		public string ServiceId { get; set; }
		
		/// <summary>
		/// Flag telling if test is a success
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="success")]
		public bool Success { get; set; }
		
		/// <summary>
		/// TestCase results associated to this test
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="testCaseResults")]
		public TestCaseResult[] TestCaseResults { get; set; }
		
		/// <summary>
		/// Timestamp of creation date of this service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="testDate")]
		public long TestDate { get; set; }
		
		/// <summary>
		/// Incremental number for tracking number of tests of a service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="testNumber")]
		public double TestNumber { get; set; }
		
		/// <summary>
		/// Endpoint used during test
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="testedEndpoint")]
		public string TestedEndpoint { get; set; }
		
		/// <summary>
		/// The maximum time (in milliseconds) to wait for this test ends
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public System.Nullable<System.Int32> Timeout { get; set; }
		
		/// <summary>
		/// Revision number of this test
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="version")]
		public double Version { get; set; }
	}
	
	/// <summary>
	/// Represents the summary result of a Service or API test run by Microcks. 
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestResultSummary
	{
		
		/// <summary>
		/// Unique identifier of TestResult
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Unique identifier of service tested
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serviceId")]
		public string ServiceId { get; set; }
		
		/// <summary>
		/// Flag telling if test is a success
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="success")]
		public bool Success { get; set; }
		
		/// <summary>
		/// Timestamp of creation date of this service
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="testDate")]
		public long TestDate { get; set; }
	}
	
	/// <summary>
	/// TestReturn is used for wrapping the return code of a test step execution
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class TestReturn
	{
		
		/// <summary>
		/// Return code for test (0 means Success, 1 means Failure)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public int Code { get; set; }
		
		/// <summary>
		/// Elapsed time in milliseconds
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="elapsedTime")]
		public long ElapsedTime { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="eventMessage")]
		public EventMessage EventMessage { get; set; }
		
		/// <summary>
		/// Error message if any
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// A mock invocation or test request
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="request")]
		public Request Request { get; set; }
		
		/// <summary>
		/// A mock invocation or test response
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public Response Response { get; set; }
	}
	
	/// <summary>
	/// Type of test strategy (different strategies are implemented by different runners)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum TestRunnerType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HTTP = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOAP_HTTP = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SOAP_UI = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POSTMAN = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OPEN_API_SCHEMA = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ASYNC_API_SCHEMA = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRPC_PROTOBUF = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GRAPHQL_SCHEMA = 7,
	}
	
	/// <summary>
	/// Evolution trend qualifier
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Trend
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOW_DOWN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STABLE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOW_UP = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UP = 4,
	}
	
	/// <summary>
	/// Representation of an unidirectional exchange as an event message
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UnidirectionalEvent
	{
	}
	
	/// <summary>
	/// Value of a metric with an associated weight
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WeightedMetricValue
	{
		
		/// <summary>
		/// Metric name or serie name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The value of this metric
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public int Value { get; set; }
		
		/// <summary>
		/// Weight of this metric value (typically a percentage)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="weight")]
		public int Weight { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Export a snapshot
		/// Export a repostiory snapshot with requested services
		/// ExportSnapshot export
		/// </summary>
		/// <param name="serviceIds">List of service identifiers to export</param>
		/// <returns>Snapshot file representing the export of requested services</returns>
		public async Task<string> ExportSnapshotAsync(string[] serviceIds, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "export?"+string.Join("&", serviceIds.Select(z => $"serviceIds={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<string>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get features configuration
		/// GetFeaturesConfiguration features/config
		/// </summary>
		/// <returns>Get features configuration</returns>
		public async Task GetFeaturesConfigurationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "features/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get ImportJobs
		/// Retrieve a list of ImportJobs
		/// GetImportJobs jobs
		/// </summary>
		/// <param name="page">Page of ImportJobs to retrieve (starts at and defaults to 0)</param>
		/// <param name="size">Size of a page. Maximum number of ImportJobs to include in a response (defaults to 20)</param>
		/// <param name="name">Name like criterion for query</param>
		/// <returns>List of found ImportJobs</returns>
		public async Task<ImportJob[]> GetImportJobsAsync(int page, int size, string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs?page="+page+"&size="+size+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImportJob[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create ImportJob
		/// Create a new ImportJob
		/// CreateImportJob jobs
		/// </summary>
		public async Task CreateImportJobAsync(ImportJob requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the ImportJobs counter
		/// GetImportJobCounter jobs/count
		/// </summary>
		/// <returns>Number of ImportJobs in datastore</returns>
		public async Task<Counter> GetImportJobCounterAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/count";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Counter>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete ImportJob
		/// Delete an ImportJob
		/// DeleteImportJob jobs/{id}
		/// </summary>
		/// <returns>ImportJob deleted</returns>
		public async Task DeleteImportJobAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get ImportJob
		/// Retrieve an ImportJob using its identifier
		/// JobGet jobs/{id}
		/// </summary>
		/// <returns>Found ImportJob</returns>
		public async Task<ImportJob> JobGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImportJob>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update ImportJob
		/// Update an ImportJob
		/// JobPost jobs/{id}
		/// </summary>
		/// <returns>Updated ImportJob</returns>
		public async Task<ImportJob> JobPostAsync(ImportJob requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImportJob>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Activate an ImportJob
		/// Make an ImportJob active, so that it is executed
		/// ActivateImportJob jobs/{id}/activate
		/// </summary>
		/// <returns>ImportJob is activated</returns>
		public async Task<ImportJob> ActivateImportJobAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/{id}/activate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImportJob>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Start an ImportJob
		/// Starting an ImportJob forces it to immediatly import mock definitions
		/// StartImportJob jobs/{id}/start
		/// </summary>
		/// <returns>Started ImportJob</returns>
		public async Task<ImportJob> StartImportJobAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/{id}/start";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImportJob>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Stop an ImportJob
		/// Stopping an ImportJob desactivate it, so that it won't execute at next schedule
		/// StopImportJob jobs/{id}/stop
		/// </summary>
		/// <returns>Stopped ImportJob</returns>
		public async Task<ImportJob> StopImportJobAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "jobs/{id}/stop";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ImportJob>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get authentification configuration
		/// GetKeycloakConfig keycloak/config
		/// </summary>
		/// <returns>Get current configuration</returns>
		public async Task<KeycloakConfig> GetKeycloakConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "keycloak/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<KeycloakConfig>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get aggregation of conformance metrics
		/// GetConformanceMetricsAggregation metrics/conformance/aggregate
		/// </summary>
		/// <returns>Get aggregated coverage metric value</returns>
		public async Task<WeightedMetricValue[]> GetConformanceMetricsAggregationAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metrics/conformance/aggregate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WeightedMetricValue[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get conformance metrics for a Service
		/// GetServiceTestConformanceMetric metrics/conformance/service/{serviceId}
		/// </summary>
		/// <returns>Test coverage metric for Service</returns>
		public async Task<TestConformanceMetric> GetServiceTestConformanceMetricAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metrics/conformance/service/{serviceId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TestConformanceMetric>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get aggregated invocation statistics for a day
		/// GetAggregatedInvocationsStats metrics/invocations/global
		/// </summary>
		/// <param name="day">The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.</param>
		/// <returns>Aggregated invocation statistics for specified day</returns>
		public async Task<DailyInvocationStatistic> GetAggregatedInvocationsStatsAsync(string day, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metrics/invocations/global?day=" + (day==null? "" : System.Uri.EscapeDataString(day));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DailyInvocationStatistic>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get aggregated invocations statistics for latest days
		/// GetLatestAggregatedInvocationsStats metrics/invocations/global/latest
		/// </summary>
		/// <param name="limit">Number of days to get back in time. Default is 20.</param>
		/// <returns>A map where keys are day (formatted using yyyyMMdd pattern) and values are counter of invocations on this day</returns>
		public async Task<CounterMap> GetLatestAggregatedInvocationsStatsAsync(int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metrics/invocations/global/latest?limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CounterMap>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get top invocation statistics for a day
		/// GetTopIvnocationsStatsByDay metrics/invocations/top
		/// </summary>
		/// <param name="day">The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.</param>
		/// <param name="limit">The number of top invoked mocks to return</param>
		/// <returns>Top invocations for a defined day</returns>
		public async Task<DailyInvocationStatistic[]> GetTopIvnocationsStatsByDayAsync(string day, int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metrics/invocations/top?day=" + (day==null? "" : System.Uri.EscapeDataString(day))+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DailyInvocationStatistic[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get invocation statistics for Service
		/// GetInvocationStatsByService metrics/invocations/{serviceName}/{serviceVersion}
		/// </summary>
		/// <param name="day">The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.</param>
		/// <returns>Invocation statistics for service for specified day</returns>
		public async Task<DailyInvocationStatistic> GetInvocationStatsByServiceAsync(string day, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metrics/invocations/{serviceName}/{serviceVersion}?day=" + (day==null? "" : System.Uri.EscapeDataString(day));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DailyInvocationStatistic>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get latest tests results
		/// GetLatestTestResults metrics/tests/latest
		/// </summary>
		/// <param name="limit">Number of days to consider for test results to return. Default is 7 (one week)</param>
		/// <returns>Test results summary for specified <limit> last days.</returns>
		public async Task<TestResultSummary[]> GetLatestTestResultsAsync(int limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "metrics/tests/latest?limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TestResultSummary[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Resources by Service
		/// GetResourcesByService resources/service/{serviceId}
		/// </summary>
		/// <returns>List the resources attached to a Service or API</returns>
		public async Task<Resource[]> GetResourcesByServiceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "resources/service/{serviceId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Resource[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Resource
		/// GetResource resources/{name}
		/// </summary>
		/// <returns>Retrieve the resource having this name</returns>
		public async Task<Resource> GetResourceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "resources/{name}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Resource>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Secrets
		/// GetSecrets secrets
		/// </summary>
		/// <param name="page">Page of Secrets to retrieve (starts at and defaults to 0)</param>
		/// <param name="size">Size of a page. Maximum number of Secrets to include in a response (defaults to 20)</param>
		/// <returns>List of found Secrets</returns>
		public async Task<Secret[]> GetSecretsAsync(int page, int size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "secrets?page="+page+"&size="+size;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Secret[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new Secret
		/// CreateSecret secrets
		/// </summary>
		public async Task CreateSecretAsync(Secret requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "secrets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the Secrets counter
		/// GetSecretsCounter secrets/count
		/// </summary>
		/// <returns>Number of Secrets in datastore</returns>
		public async Task<Counter> GetSecretsCounterAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "secrets/count";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Counter>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete Secret
		/// Delete a Secret
		/// DeleteSecret secrets/{id}
		/// </summary>
		/// <returns>Secret has been deleted</returns>
		public async Task DeleteSecretAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "secrets/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Secret
		/// Retrieve a Secret
		/// GetSecret secrets/{id}
		/// </summary>
		/// <returns>Found Secret</returns>
		public async Task<Secret> GetSecretAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "secrets/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Secret>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update Secret
		/// Update a Secret
		/// UpdateSecret secrets/{id}
		/// </summary>
		/// <returns>Updated Secret</returns>
		public async Task UpdateSecretAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "secrets/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Services and APIs
		/// GetServices services
		/// </summary>
		/// <param name="page">Page of Services to retrieve (starts at and defaults to 0)</param>
		/// <param name="size">Size of a page. Maximum number of Services to include in a response (defaults to 20)</param>
		/// <returns>List of found Services</returns>
		public async Task<Service> GetServicesAsync(int page, int size, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "services?page="+page+"&size="+size;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Service>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the Services counter
		/// GetServicesCounter services/count
		/// </summary>
		/// <returns>Number of Services in datastore</returns>
		public async Task<Counter> GetServicesCounterAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "services/count";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Counter>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the already used labels for Services
		/// GetServicesLabels services/labels
		/// </summary>
		/// <returns>Already used labels: keys are label Keys, values are array of label Values</returns>
		public async Task<LabelsMap> GetServicesLabelsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "services/labels";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<LabelsMap>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search for Services and APIs
		/// SearchServices services/search
		/// </summary>
		/// <param name="queryMap">Map of criterion. Key can be simply 'name' with value as the searched string. You can also search by label using keys like 'labels.x' where 'x' is the label and value the label value</param>
		/// <returns>List of found Services (filtered according search criteria)</returns>
		public async Task<Service[]> SearchServicesAsync(System.Collections.Generic.Dictionary<string, string> queryMap, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "services/search?queryMap=" + queryMap;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Service[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete Service
		/// Delete a Service
		/// DeleteService services/{id}
		/// </summary>
		/// <returns>Service has been deleted</returns>
		public async Task DeleteServiceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "services/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Service
		/// GetService services/{id}
		/// </summary>
		/// <param name="messages">Whether to include details on services messages into result. Default is false</param>
		public async Task<Service> GetServiceAsync(bool messages, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "services/{id}?messages="+messages;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Service>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update Service Metadata
		/// UpdateServiceMetadata services/{id}/metadata
		/// </summary>
		/// <returns>Service metadata has been updated</returns>
		public async Task UpdateServiceMetadataAsync(Metadata requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "services/{id}/metadata";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Override Service Operation
		/// OverrideServiceOperation services/{id}/operation
		/// </summary>
		/// <param name="operationName">Name of operation to update</param>
		/// <returns>Operation has been updated</returns>
		public async Task OverrideServiceOperationAsync(string operationName, OperationOverrideDTO requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "services/{id}/operation?operationName=" + (operationName==null? "" : System.Uri.EscapeDataString(operationName));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a new Test
		/// CreateTest tests
		/// </summary>
		public async Task CreateTestAsync(TestRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tests";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get TestResults by Service
		/// GetTestResultsByService tests/service/{serviceId}
		/// </summary>
		/// <returns>List of TestResults for the Service having the requested id</returns>
		public async Task<TestResult[]> GetTestResultsByServiceAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tests/service/{serviceId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TestResult[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get the TestResults for Service counter
		/// GetTestResultsByServiceCounter tests/service/{serviceId}/count
		/// </summary>
		/// <returns>Number of TestResults for this Service in datastore</returns>
		public async Task<Counter> GetTestResultsByServiceCounterAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tests/service/{serviceId}/count";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<Counter>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get TestResult
		/// GetTestResult tests/{id}
		/// </summary>
		/// <returns>Requested TestResult</returns>
		public async Task<TestResult> GetTestResultAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tests/{id}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TestResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get events for TestCase
		/// GetEventsByTestCase tests/{id}/events/{testCaseId}
		/// </summary>
		/// <returns>List of event messages for this TestCase</returns>
		public async Task<UnidirectionalEvent[]> GetEventsByTestCaseAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tests/{id}/events/{testCaseId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<UnidirectionalEvent[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get messages for TestCase
		/// GetMessagesByTestCase tests/{id}/messages/{testCaseId}
		/// </summary>
		/// <returns>List of request and response messages for this TestCase</returns>
		public async Task<RequestResponsePair[]> GetMessagesByTestCaseAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tests/{id}/messages/{testCaseId}";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<RequestResponsePair[]>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Report and create a new TestCaseResult
		/// Report a TestCaseResult (typically used by a Test runner)
		/// ReportTestCaseResult tests/{id}/testCaseResult
		/// </summary>
		/// <param name="requestBody">TestCase return wrapper object</param>
		/// <returns>TestCaseResult is reported</returns>
		public async Task<TestCaseResult> ReportTestCaseResultAsync(TestCaseReturnDTO requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "tests/{id}/testCaseResult";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<TestCaseResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
