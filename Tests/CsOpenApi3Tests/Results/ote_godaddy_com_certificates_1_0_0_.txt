//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateAction
	{
		
		/// <summary>
		/// Date action created
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public string CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CertificateActionType Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateActionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CERTIFICATE_ISSUED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CERTIFICATE_ORDER_CANCELED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CERTIFICATE_ORDER_CREATED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CERTIFICATE_REVOKED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOMAIN_VALIDATION_COMPLETE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FRAUD_DETECTED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORG_NAME_CHANGE = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ORG_VALIDATION_COMPLETE = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SAN_DROP = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Certificate
	{
		
		/// <summary>
		/// The unique identifier of the certificate request. Only present if no errors returned
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
		
		/// <summary>
		/// Common name of certificate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commonName")]
		public string CommonName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contact")]
		public CertificateContact Contact { get; set; }
		
		/// <summary>
		/// The date the certificate was ordered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public string CreatedAt { get; set; }
		
		/// <summary>
		/// Only present if certificate order has been denied
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deniedReason")]
		public string DeniedReason { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public CertificateOrganization Organization { get; set; }
		
		/// <summary>
		/// Validity period of order. Specified in years
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="period")]
		public int Period { get; set; }
		
		/// <summary>
		/// Certificate product type
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public CertificateProductType ProductType { get; set; }
		
		/// <summary>
		/// Percentage of completion for certificate vetting
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public System.Nullable<System.Int32> Progress { get; set; }
		
		/// <summary>
		/// The revocation date of certificate (if revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="revokedAt")]
		public string RevokedAt { get; set; }
		
		/// <summary>
		/// Root Type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rootType")]
		public System.Nullable<CertificateRootType> RootType { get; set; }
		
		/// <summary>
		/// Serial number of certificate (if issued or revoked)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serialNumber")]
		public string SerialNumber { get; set; }
		
		/// <summary>
		/// Hexadecmial format for Serial number of certificate(if issued or revoked)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serialNumberHex")]
		public string SerialNumberHex { get; set; }
		
		/// <summary>
		/// Number of subject alternative names(SAN) to be included in certificate 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slotSize")]
		public System.Nullable<CertificateSlotSize> SlotSize { get; set; }
		
		/// <summary>
		/// Status of certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public CertificateStatus Status { get; set; }
		
		/// <summary>
		/// Contains subject alternative names set
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public SubjectAlternativeNameDetails[] SubjectAlternativeNames { get; set; }
		
		/// <summary>
		/// The end date of the certificate's validity (if issued or revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validEnd")]
		public string ValidEnd { get; set; }
		
		/// <summary>
		/// The start date of the certificate's validity (if issued or revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validStart")]
		public string ValidStart { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateProductType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DV_SSL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DV_WILDCARD_SSL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EV_SSL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OV_CS = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OV_DS = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OV_SSL = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OV_WILDCARD_SSL = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UCC_DV_SSL = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UCC_EV_SSL = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UCC_OV_SSL = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateRootType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GODADDY_SHA_1 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GODADDY_SHA_2 = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARFIELD_SHA_1 = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STARFIELD_SHA_2 = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateSlotSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TEN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIFTEEN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TWENTY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		THIRTY = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FOURTY = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FIFTY = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ONE_HUNDRED = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_ISSUANCE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ISSUED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVOKED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DENIED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_REVOCATION = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_REKEY = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNUSED = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SubjectAlternativeNameDetails
	{
		
		/// <summary>
		/// Total number of page results
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public SubjectAlternativeNameDetailsStatus Status { get; set; }
		
		/// <summary>
		/// Subject alternative name to be included in certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeName")]
		public string SubjectAlternativeName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SubjectAlternativeNameDetailsStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FRAUD = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateAddress
	{
		
		/// <summary>
		/// Address line 1 of organization address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="address1")]
		public string Address1 { get; set; }
		
		/// <summary>
		/// Address line 2 of organization address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="address2")]
		public string Address2 { get; set; }
		
		/// <summary>
		/// City/Locality of organization address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// Two character country code of organization
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public CertificateAddressCountry Country { get; set; }
		
		/// <summary>
		/// Postal code of organization address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="postalCode")]
		public string PostalCode { get; set; }
		
		/// <summary>
		/// Full name of State/Province/Territory of organization address
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateAddressCountry
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AC = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AD = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AF = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AG = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AI = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AL = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AM = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AN = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AO = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AQ = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AR = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AS = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AT = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AU = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AW = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AZ = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BA = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BB = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BD = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BE = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BF = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BG = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BH = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BI = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BJ = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BM = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BN = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BO = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BR = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BS = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BT = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BV = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BW = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BY = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BZ = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CA = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CC = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CD = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CF = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CG = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CH = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CI = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CK = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CL = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CM = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CN = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CO = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CR = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CV = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CX = 50,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CY = 51,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CZ = 52,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DE = 53,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DJ = 54,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DK = 55,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DM = 56,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DO = 57,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DZ = 58,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EC = 59,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EE = 60,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EG = 61,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EH = 62,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ER = 63,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ES = 64,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ET = 65,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FI = 66,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FJ = 67,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FK = 68,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FM = 69,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FO = 70,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FR = 71,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GA = 72,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GB = 73,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GD = 74,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GE = 75,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GF = 76,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GG = 77,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GH = 78,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GI = 79,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GL = 80,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GM = 81,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GN = 82,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GP = 83,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GQ = 84,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GR = 85,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GS = 86,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GT = 87,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GU = 88,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GW = 89,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GY = 90,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HK = 91,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HM = 92,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HN = 93,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HR = 94,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HT = 95,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HU = 96,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ID = 97,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IE = 98,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IL = 99,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IM = 100,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IN = 101,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IO = 102,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IQ = 103,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IS = 104,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IT = 105,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JE = 106,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JM = 107,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JO = 108,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		JP = 109,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KE = 110,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KG = 111,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KH = 112,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KI = 113,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KM = 114,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KN = 115,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KR = 116,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KW = 117,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KY = 118,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KZ = 119,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LA = 120,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LB = 121,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LC = 122,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LI = 123,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LK = 124,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LR = 125,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LS = 126,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LT = 127,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LU = 128,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LV = 129,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LY = 130,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MA = 131,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MC = 132,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MD = 133,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ME = 134,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MG = 135,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MH = 136,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ML = 137,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MM = 138,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MN = 139,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MO = 140,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MP = 141,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MQ = 142,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MR = 143,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MS = 144,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MT = 145,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MU = 146,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MV = 147,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MW = 148,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MX = 149,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MY = 150,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MZ = 151,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NA = 152,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NC = 153,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NE = 154,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NF = 155,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NG = 156,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NI = 157,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NL = 158,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO = 159,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NP = 160,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NR = 161,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NU = 162,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NZ = 163,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OM = 164,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PA = 165,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PE = 166,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PF = 167,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PG = 168,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PH = 169,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PK = 170,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PL = 171,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PM = 172,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PN = 173,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PR = 174,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PS = 175,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PT = 176,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PW = 177,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PY = 178,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QA = 179,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RE = 180,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RO = 181,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RS = 182,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RU = 183,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RW = 184,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SA = 185,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SB = 186,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SC = 187,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SE = 188,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SG = 189,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SH = 190,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SI = 191,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SJ = 192,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SK = 193,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SL = 194,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SM = 195,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SN = 196,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SO = 197,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SR = 198,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ST = 199,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SV = 200,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SZ = 201,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TC = 202,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TD = 203,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TF = 204,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TG = 205,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TH = 206,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TJ = 207,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TK = 208,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TL = 209,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TM = 210,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TN = 211,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TO = 212,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TP = 213,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TR = 214,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TT = 215,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TV = 216,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TW = 217,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		TZ = 218,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UA = 219,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UG = 220,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UM = 221,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		US = 222,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UY = 223,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UZ = 224,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VA = 225,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VC = 226,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VE = 227,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VG = 228,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VI = 229,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VN = 230,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VU = 231,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WF = 232,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WS = 233,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		YE = 234,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		YT = 235,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		YU = 236,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZA = 237,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZM = 238,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ZW = 239,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateBundle
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pems")]
		public PEMCertificates Pems { get; set; }
		
		/// <summary>
		/// Serial number of certificate requested
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serialNumber")]
		public string SerialNumber { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateCallback
	{
		
		/// <summary>
		/// Callback url registered to receive stateful actions
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="callbackUrl")]
		public string CallbackUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateContact
	{
		
		/// <summary>
		/// Email address of requestor contact
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Only used for EVSSL. Job title of requestor contact
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jobTitle")]
		public string JobTitle { get; set; }
		
		/// <summary>
		/// First name of requestor contact
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nameFirst")]
		public string NameFirst { get; set; }
		
		/// <summary>
		/// Last name of requestor contact
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nameLast")]
		public string NameLast { get; set; }
		
		/// <summary>
		/// Middle initial of requestor contact
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nameMiddle")]
		public string NameMiddle { get; set; }
		
		/// <summary>
		/// Phone number for requestor contact
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="phone")]
		public string Phone { get; set; }
		
		/// <summary>
		/// Suffix of requestor contact
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suffix")]
		public string Suffix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateCreate
	{
		
		/// <summary>
		/// Required if client would like to receive stateful actions via callback during certificate lifecyle
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="callbackUrl")]
		public string CallbackUrl { get; set; }
		
		/// <summary>
		/// Name to be secured in certificate. If provided, CN field in CSR will be ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commonName")]
		public string CommonName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contact")]
		public CertificateContact Contact { get; set; }
		
		/// <summary>
		/// Certificate Signing Request
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="csr")]
		public string Csr { get; set; }
		
		/// <summary>
		/// Only used for OV
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="intelVPro")]
		public System.Nullable<System.Boolean> IntelVPro { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public CertificateOrganizationCreate Organization { get; set; }
		
		/// <summary>
		/// Number of years for certificate validity period
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="period")]
		public int Period { get; set; }
		
		/// <summary>
		/// Type of product requesting a certificate. Only required non-renewal
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="productType")]
		public CertificateProductType ProductType { get; set; }
		
		/// <summary>
		/// Root Type. Depending on certificate expiration date, SHA_1 not be allowed. Will default to SHA_2 if expiration date exceeds sha1 allowed date
		/// </summary>
		[System.ComponentModel.DefaultValue(CertificateRootType.STARFIELD_SHA_2)]
		[System.Runtime.Serialization.DataMember(Name="rootType")]
		public CertificateRootType RootType { get; set; } = CertificateRootType.STARFIELD_SHA_2;
		
		/// <summary>
		/// Number of subject alternative names(SAN) to be included in certificate 
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slotSize")]
		public CertificateSlotSize SlotSize { get; set; }
		
		/// <summary>
		/// Subject Alternative names. Collection of subjectAlternativeNames to be included in certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public string[] SubjectAlternativeNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateDetailV2
	{
		
		/// <summary>
		/// The unique identifier of the certificate request. Only present if no errors returned
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
		
		/// <summary>
		/// Common name of certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commonName")]
		public string CommonName { get; set; }
		
		/// <summary>
		/// The date the certificate request completed processing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public string CompletedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="contact")]
		public CertificateContact Contact { get; set; }
		
		/// <summary>
		/// The date the certificate was ordered.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public string CreatedAt { get; set; }
		
		/// <summary>
		/// Certificate signing request (if present) in PEM format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="csr")]
		public string Csr { get; set; }
		
		/// <summary>
		/// Only present if certificate order has been denied
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deniedReason")]
		public string DeniedReason { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="organization")]
		public CertificateOrganization Organization { get; set; }
		
		/// <summary>
		/// Validity period of order. Specified in years
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="period")]
		public int Period { get; set; }
		
		/// <summary>
		/// Percentage of completion for certificate vetting
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="progress")]
		public System.Nullable<System.Int32> Progress { get; set; }
		
		/// <summary>
		/// Only returned when a renewal is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="renewalAvailable")]
		public System.Nullable<System.Boolean> RenewalAvailable { get; set; }
		
		/// <summary>
		/// The revocation date of certificate (if revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="revokedAt")]
		public string RevokedAt { get; set; }
		
		/// <summary>
		/// Root type: 
		///  * `GODADDY_SHA_1` - GoDaddy (Secure Hash Algorithm 1) SHA-1 root type
		///  * `GODADDY_SHA_2` - GoDaddy (Secure Hash Algorithm 2) SHA-2 root type
		///  * `STARFIELD_SHA_1` - Starfield SHA-1 root type
		///  * `STARFIELD_SHA_2` - Starfield SHA-2 root type
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rootType")]
		public CertificateRootType RootType { get; set; }
		
		/// <summary>
		/// Serial number of certificate (if issued or revoked)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serialNumber")]
		public string SerialNumber { get; set; }
		
		/// <summary>
		/// Hexadecmial format for Serial number of certificate(if issued or revoked)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serialNumberHex")]
		public string SerialNumberHex { get; set; }
		
		/// <summary>
		/// Number of subject alternative names (SAN) to be included in certificate (if UCC): 
		///  * `FIVE` - Five slot UCC request
		///  * `TEN` - Ten slot UCC request
		///  * `FIFTEEN` - Fifteen slot UCC request
		///  * `TWENTY` - Twenty slot UCC request
		///  * `THIRTY` - Thirty slot UCC request
		///  * `FOURTY` - Fourty slot UCC request
		///  * `FIFTY` - Fifty slot UCC request
		///  * `ONE_HUNDRED` - One hundred slot UCC request
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slotSize")]
		public CertificateSlotSize SlotSize { get; set; }
		
		/// <summary>
		/// Certificate status (if issued or revoked): 
		///  * `CANCELED` - Certificate request was canceled by customer
		///  * `DENIED` - Certificate request was denied by customer\n  * `EXPIRED` - Issued certificate has exceeded the valid end date
		///  * `ISSUED` - Certificate has been issued and is within validity period
		///  * `PENDING_ISSUANCE` - Certificate request has completed domain verification and is in the process of being issued
		///  * `PENDING_REKEY` - Previously issued certificate was rekeyed by customer and is in the process of being reissued
		///  * `PENDING_REVOCATION` - Previously issued certificate is in the process of being revoked
		///  * `REVOKED` - Issued certificate has been revoked\n  * `UNUSED` - Certificate in an error state
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public CertificateStatus Status { get; set; }
		
		/// <summary>
		/// Subject Alternative names. Collection of subjectAlternativeNames to be included in certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public string[] SubjectAlternativeNames { get; set; }
		
		/// <summary>
		/// Certificate type: 
		///  * `DV_SSL` - (Domain Validated Secure Sockets Layer) SSL certificate validated using domain name only
		///  * `DV_WILDCARD_SSL` - SSL certificate containing subdomains which is validated using domain name only
		///  * `EV_SSL` - (Extended Validation) SSL certificate validated using organization information, domain name, business legal status, and other factors
		///  * `OV_CODE_SIGNING` - Code signing SSL certificate used by software developers to digitally sign apps. Validated using organization information
		///  * `OV_DRIVER_SIGNING` - Driver signing SSL certificate request used by software developers to digitally sign secure code for Windows hardware drivers. Validated using organization information
		///  * `OV_SSL` - SSL certificate validated using organization information and domain name
		///  * `OV_WILDCARD_SSL` - SSL certificate containing subdomains which is validated using organization information and domain name
		///  * `UCC_DV_SSL` - (Unified Communication Certificate) Multi domain SSL certificate validated using domain name only
		///  * `UCC_EV_SSL` - Multi domain SSL certificate validated using organization information, domain name, business legal status, and other factors
		///  * `UCC_OV_SSL` - Multi domain SSL certificate validated using organization information and domain name
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CertificateDetailV2Type Type { get; set; }
		
		/// <summary>
		/// The end date of the certificate's validity (if issued or revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validEndAt")]
		public string ValidEndAt { get; set; }
		
		/// <summary>
		/// The start date of the certificate's validity (if issued or revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validStartAt")]
		public string ValidStartAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateDetailV2Type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DV_SSL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DV_WILDCARD_SSL = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EV_SSL = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OV_CODE_SIGNING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OV_DRIVER_SIGNING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OV_SSL = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OV_WILDCARD_SSL = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UCC_DV_SSL = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UCC_EV_SSL = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UCC_OV_SSL = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateEmailHistory
	{
		
		/// <summary>
		/// Shopper Id requested certificate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accountId")]
		public int AccountId { get; set; }
		
		/// <summary>
		/// Email message
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="body")]
		public string Body { get; set; }
		
		/// <summary>
		/// Date email sent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dateEntered")]
		public string DateEntered { get; set; }
		
		/// <summary>
		/// Email from address
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fromType")]
		public string FromType { get; set; }
		
		/// <summary>
		/// Email Id
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Email address email was sent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="recipients")]
		public string Recipients { get; set; }
		
		/// <summary>
		/// Email subject
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="subject")]
		public string Subject { get; set; }
		
		/// <summary>
		/// Email template type name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="templateType")]
		public string TemplateType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateIdentifier
	{
		
		/// <summary>
		/// The unique identifier of the certificate request. Only present if verified.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateOrganization
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="address")]
		public CertificateAddress Address { get; set; }
		
		/// <summary>
		/// Only for EVSSL. The DBA(does business as) name for the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assumedName")]
		public string AssumedName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="jurisdictionOfIncorporation")]
		public JurisdictionOfIncorporation JurisdictionOfIncorporation { get; set; }
		
		/// <summary>
		/// Name of organization that owns common name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Phone number for organization
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="phone")]
		public string Phone { get; set; }
		
		/// <summary>
		/// Only for EVSSL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registrationAgent")]
		public string RegistrationAgent { get; set; }
		
		/// <summary>
		/// Only for EVSSL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registrationNumber")]
		public string RegistrationNumber { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateOrganizationCreate
	{
		
		[System.Runtime.Serialization.DataMember(Name="address")]
		public CertificateAddress Address { get; set; }
		
		/// <summary>
		/// Only for EVSSL. The DBA(does business as) name for the organization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="assumedName")]
		public string AssumedName { get; set; }
		
		/// <summary>
		/// Name of organization that owns common name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Phone number for organization
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="phone")]
		public string Phone { get; set; }
		
		/// <summary>
		/// Only for EVSSL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registrationAgent")]
		public string RegistrationAgent { get; set; }
		
		/// <summary>
		/// Only for EVSSL.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="registrationNumber")]
		public string RegistrationNumber { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateReissue
	{
		
		/// <summary>
		/// Required if client would like to receive stateful action via callback during certificate lifecyle
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="callbackUrl")]
		public string CallbackUrl { get; set; }
		
		/// <summary>
		/// The common name of certificate to be secured
		/// </summary>
		[System.ComponentModel.DefaultValue("Existing common name")]
		[System.Runtime.Serialization.DataMember(Name="commonName")]
		public string CommonName { get; set; } = "Existing common name";
		
		/// <summary>
		/// Certificate Signing Request.
		/// </summary>
		[System.ComponentModel.DefaultValue("Existing CSR")]
		[System.Runtime.Serialization.DataMember(Name="csr")]
		public string Csr { get; set; } = "Existing CSR";
		
		/// <summary>
		/// In hours, time to delay revoking existing certificate after issuance of new certificate. If revokeExistingCertOnIssuance is enabled, this value will be ignored
		/// Maximum: 168
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="delayExistingRevoke")]
		[System.ComponentModel.DataAnnotations.Range(System.Int32.MinValue, 168)]
		public System.Nullable<System.Int32> DelayExistingRevoke { get; set; }
		
		/// <summary>
		/// Optional field. Domain verification will be required for each domain listed here. Specify a value of * to indicate that all domains associated with the request should have their domain information reverified.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="forceDomainRevetting")]
		public string[] ForceDomainRevetting { get; set; }
		
		/// <summary>
		/// Root Type. Depending on certificate expiration date, SHA_1 not be allowed. Will default to SHA_2 if expiration date exceeds sha1 allowed date
		/// </summary>
		[System.ComponentModel.DefaultValue(CertificateRootType.GODADDY_SHA_1)]
		[System.Runtime.Serialization.DataMember(Name="rootType")]
		public CertificateRootType RootType { get; set; } = CertificateRootType.GODADDY_SHA_1;
		
		/// <summary>
		/// Only used for UCC products. An array of subject alternative names to include in certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public string[] SubjectAlternativeNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateRenew
	{
		
		/// <summary>
		/// Required if client would like to receive stateful actions via callback during certificate lifecyle
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="callbackUrl")]
		public string CallbackUrl { get; set; }
		
		/// <summary>
		/// The common name of certificate to be secured
		/// </summary>
		[System.ComponentModel.DefaultValue("Existing common name")]
		[System.Runtime.Serialization.DataMember(Name="commonName")]
		public string CommonName { get; set; } = "Existing common name";
		
		/// <summary>
		/// Certificate Signing Request.
		/// </summary>
		[System.ComponentModel.DefaultValue("Existing CSR")]
		[System.Runtime.Serialization.DataMember(Name="csr")]
		public string Csr { get; set; } = "Existing CSR";
		
		/// <summary>
		/// Number of years for certificate validity period, if different from previous certificate
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="period")]
		public System.Nullable<System.Int32> Period { get; set; }
		
		/// <summary>
		/// Root Type. Depending on certificate expiration date, SHA_1 not be allowed. Will default to SHA_2 if expiration date exceeds sha1 allowed date
		/// </summary>
		[System.ComponentModel.DefaultValue(CertificateRootType.GODADDY_SHA_1)]
		[System.Runtime.Serialization.DataMember(Name="rootType")]
		public CertificateRootType RootType { get; set; } = CertificateRootType.GODADDY_SHA_1;
		
		/// <summary>
		/// Only used for UCC products. An array of subject alternative names to include in certificate. Not including a subject alternative name that was in the previous certificate will remove it from the renewed certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public string[] SubjectAlternativeNames { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateRevoke
	{
		
		/// <summary>
		/// Reason for revocation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public CertificateRevokeReason Reason { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateRevokeReason
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AFFILIATION_CHANGED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CESSATION_OF_OPERATION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		KEY_COMPROMISE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVILEGE_WITHDRAWN = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUPERSEDED = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateSiteSeal
	{
		
		/// <summary>
		/// Certificate Seal HTML
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="html")]
		public string Html { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateSummariesV2
	{
		
		/// <summary>
		/// List of certificates for a specified customer.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificates")]
		public CertificateSummaryV2[] Certificates { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Pagination Pagination { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CertificateSummaryV2
	{
		
		/// <summary>
		/// The unique identifier of the certificate request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificateId")]
		public string CertificateId { get; set; }
		
		/// <summary>
		/// Common name for the certificate request.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="commonName")]
		public string CommonName { get; set; }
		
		/// <summary>
		/// The date the certificate request completed processing (if issued or revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public string CompletedAt { get; set; }
		
		/// <summary>
		/// Date that the certificate request was received.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public string CreatedAt { get; set; }
		
		/// <summary>
		/// Validity period of order. Specified in years.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="period")]
		public int Period { get; set; }
		
		/// <summary>
		/// Only returned when a renewal is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="renewalAvailable")]
		public System.Nullable<System.Boolean> RenewalAvailable { get; set; }
		
		/// <summary>
		/// The revocation date of certificate (if revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="revokedAt")]
		public string RevokedAt { get; set; }
		
		/// <summary>
		/// Serial number of certificate (if issued or revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serialNumber")]
		public string SerialNumber { get; set; }
		
		/// <summary>
		/// Number of subject alternative names (SAN) to be included in certificate (if UCC): 
		///  * `FIVE` - Five slot UCC request
		///  * `TEN` - Ten slot UCC request
		///  * `FIFTEEN` - Fifteen slot UCC request
		///  * `TWENTY` - Twenty slot UCC request
		///  * `THIRTY` - Thirty slot UCC request
		///  * `FOURTY` - Fourty slot UCC request
		///  * `FIFTY` - Fifty slot UCC request
		///  * `ONE_HUNDRED` - One hundred slot UCC request
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="slotSize")]
		public CertificateSlotSize SlotSize { get; set; }
		
		/// <summary>
		/// Certificate status (if issued or revoked): 
		///  * `CANCELED` - Certificate request was canceled by customer
		///  * `DENIED` - Certificate request was denied by customer
		///  * `EXPIRED` - Issued certificate has exceeded the valid end date
		///  * `ISSUED` - Certificate has been issued and is within validity period
		///  * `PENDING_ISSUANCE` - Certificate request has completed domain verification and is in the process of being issued
		///  * `PENDING_REKEY` - Previously issued certificate was rekeyed by customer and is in the process of being reissued
		///  * `PENDING_REVOCATION` - Previously issued certificate is in the process of being revoked
		///  * `REVOKED` - Issued certificate has been revoked
		///  * `UNUSED` - Certificate in an error state
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public CertificateSummaryV2Status Status { get; set; }
		
		/// <summary>
		/// Subject Alternative names (if UCC). Collection of subjectAlternativeNames to be included in certificate.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subjectAlternativeNames")]
		public string[] SubjectAlternativeNames { get; set; }
		
		/// <summary>
		/// Certificate type: 
		///  * `DV_SSL` - (Domain Validated Secure Sockets Layer) SSL certificate validated using domain name only
		///  * `DV_WILDCARD_SSL` - SSL certificate containing subdomains which is validated using domain name only
		///  * `EV_SSL` - (Extended Validation) SSL certificate validated using organization information, domain name, business legal status, and other factors
		///  * `OV_CODE_SIGNING` - Code signing SSL certificate used by software developers to digitally sign apps. Validated using organization information
		///  * `OV_DRIVER_SIGNING` - Driver signing SSL certificate request used by software developers to digitally sign secure code for Windows hardware drivers. Validated using organization information
		///  * `OV_SSL` - SSL certificate validated using organization information and domain name
		///  * `OV_WILDCARD_SSL` - SSL certificate containing subdomains which is validated using organization information and domain name
		///  * `UCC_DV_SSL` - (Unified Communication Certificate) Multi domain SSL certificate validated using domain name only
		///  * `UCC_EV_SSL` - Multi domain SSL certificate validated using organization information, domain name, business legal status, and other factors
		///  * `UCC_OV_SSL` - Multi domain SSL certificate validated using organization information and domain name
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public CertificateDetailV2Type Type { get; set; }
		
		/// <summary>
		/// The end date of the certificate's validity (if issued or revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validEndAt")]
		public string ValidEndAt { get; set; }
		
		/// <summary>
		/// The start date of the certificate's validity (if issued or revoked).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validStartAt")]
		public string ValidStartAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CertificateSummaryV2Status
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ISSUED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DENIED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXPIRED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_ISSUANCE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_REKEY = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_REVOCATION = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVOKED = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNUSED = 8,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Pagination
	{
		
		/// <summary>
		/// URI to access the first page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="first")]
		public string First { get; set; }
		
		/// <summary>
		/// URI to access the last page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="last")]
		public string Last { get; set; }
		
		/// <summary>
		/// URI to access the next page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="next")]
		public string Next { get; set; }
		
		/// <summary>
		/// URI to access the previous page
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="previous")]
		public string Previous { get; set; }
		
		/// <summary>
		/// Number of records available
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="total")]
		public System.Nullable<System.Int32> Total { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DomainVerificationDetail : DomainVerificationSummary
	{
		
		/// <summary>
		/// Contains information about the last Certificate Authority Authorization (CAA) Lookup details for the specified domain.
		///
		///In order for a domain to be eligible to be included in the certificate, the entire domain hierarchy must be scanned for DNS CAA records, as outlined by RFC 6844.
		///
		///The absence of any CAA records found in the domain hierarchy indicates that the domain may be included in the certificate. Alternatively, if CAA records are found when scanning the domain hierarchy, the domain may be included in the certificate as long as `godaddy.com` or `starfieldtech.com` is found in the DNS record value. However, if CAA records are found, yet `godaddy.com` or `starfieldtech.com` is not found in any CAA record's value, then we must drop the domain from the certificate request.
		///
		///In the case where there are repeated DNS errors when scanning the domain hierarchy for CAA records, thus ending in an unsuccessful scan, then the domain can still be included in the certificate provided the primary domain is not setup with DNSSEC. Conversely, if DNSSEC is found to be setup on the primary domain when scanning following repeated CAA failures, the domain must be dropped from the certificate request. Finally, if DNS errors persist to the point where a successful DNSSEC query could not be obtained, then the domain must be dropped from the certificate request.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="certificateAuthorityAuthorization")]
		public DomainVerificationDetailCertificateAuthorityAuthorization CertificateAuthorityAuthorization { get; set; }
	}
	
	public class DomainVerificationDetailCertificateAuthorityAuthorization
	{
		
		/// <summary>
		/// The date the certificate request completed processing.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public string CompletedAt { get; set; }
		
		/// <summary>
		/// Details all the individual DNS paths that were scanned for CAA records for this domain, as detailed by RFC 6844. This element not only contains the parts determined from parsing the domain, but also any CNAME or DNAME targets specified by any of those individual parts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryPaths")]
		public string[] QueryPaths { get; set; }
		
		/// <summary>
		/// Returns a list of fix recommendations if the query was unsuccessful, or if the domain was dropped from the certificate request, so that a subsequent certificate request with the specified domain will successfully pass its CAA scan.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="recommendations")]
		public string[] Recommendations { get; set; }
		
		/// <summary>
		/// Returns the status of the CAA Lookup for the specified domain:
		///* `PENDING` - The CAA lookup has not yet been attempted for the specified domain.
		///* `REMOVED_DNS_ERROR` - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. DNS errors then prevented the system from determining if DNSSEC was enabled for the specified domain, and it had to be removed from the certificate request.
		///* `REMOVED_DNSSEC_ENABLED` - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. DNSSEC was determined to be enabled for the specified domain, and it had to be removed from the certificate request.
		///* `REMOVED_NOT_FOUND_CA` - CAA records were found during the CAA lookup for the speicified domain, but `godaddy.com` or `starfieldtech.com` was not listed as a value, thereby not allowing us to issue a certificate with this domain. The specified domain was removed from the certificate request.
		///* `REMOVED_UNKNOWN_CRITICAL_TAG` - A CAA record was found during the CAA lookup with its Critical bit set, as outlined by RFC 6844, yet the Tag of the CAA record was not understood (as outlined by RFC 6844). The specified domain was removed from the certificate request.
		///* `SUCCESS_CAA` - The CAA lookup was successful for the specified domain, and the domain can remain in the certificate request.
		///* `SUCCESS_DNSSEC` - Repeated errors occurred while scanning for CAA records, thereby resulting in a DNSSEC scan. The system detemined that DNSSEC was not enabled for the specified domain, so the domain is allowed to remain in the certificate request.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public System.Nullable<DomainVerificationDetailCertificateAuthorityAuthorizationStatus> Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DomainVerificationDetailCertificateAuthorityAuthorizationStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REMOVED_DNS_ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REMOVED_DNSSEC_ENABLED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REMOVED_NOT_FOUND_CA = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REMOVED_UNKNOWN_CRITICAL_TAG = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS_CAA = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUCCESS_DNSSEC = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DomainVerificationSummary
	{
		
		/// <summary>
		/// Timestamp indicating when the domain verification process was started
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public string CreatedAt { get; set; }
		
		/// <summary>
		/// DCE verification type token (if DCE verification type).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dceToken")]
		public string DceToken { get; set; }
		
		/// <summary>
		/// Domain name
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domain")]
		public string Domain { get; set; }
		
		/// <summary>
		/// A unique identifier that can be leveraged for retrieving domain verification related information. Primarily used when troubleshooting a request
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="domainEntityId")]
		public int DomainEntityId { get; set; }
		
		/// <summary>
		/// Timestamp indicating when the domain verification process was last updated
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="modifiedAt")]
		public string ModifiedAt { get; set; }
		
		/// <summary>
		/// Domain verification status: 
		///  * `AWAITING` - Verification pending customer input
		///  * `INVALID` - SAN connected to a cancelled request
		///  * `COMPLETED` - Verification completed
		///  * `FAILED_VERIFICATION` - Verification failed
		///  * `PENDING_POSSIBLE_FRAUD` - Flagged for a system level fraud review
		///  * `VERIFIED_POSSIBLE_FRAUD` - Fraud detection reviewed but verified
		///  * `DROPPED` - SAN dropped from request
		///  * `REVOKED_CERT` - Certificate revoked
		///  * `DROPPED_GOOGLE_SAFE_BROWSING` - SAN dropped from request due to Google Safe Browsing check
		///  * `DROPPED_CERTIFICATE_AUTHORITY_AUTHORIZATION` - SAN dropped from request due to Certificate Authorization Authority DNS record check
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public DomainVerificationSummaryStatus Status { get; set; }
		
		/// <summary>
		/// Domain verification type: 
		///  * `AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_ADMIN` - Domain verified using domain control verification email sent to admin@<your.domain.com>
		///  * `AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_ADMINSTRATOR` - Domain verified using domain control verification email sent to administrator@<your.domain.com>
		///  * `AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_HOST_MASTER` - Domain verified using domain control verification email sent to hostmaster@<your.domain.com>
		///  * `AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_POST_MASTER` - Domain verified using domain control verification email sent to postmaster@<your.domain.com>
		///  * `AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_WEB_MASTER` - Domain verified using domain control verification email sent to webmaster@<your.domain.com>
		///  * `DOMAIN_ACCESS_EMAIL` - Domain verified using a domain access email
		///  * `DOMAIN_ACCESS_LETTER` - Customer completed a domain access letter which was used for domain verification
		///  * `DOMAIN_CONTROL_EMAIL` - Domain verified using HTML file or DNS zone file text value
		///  * `DOMAIN_ZONE_CONTROL` - DNS zone file containing a pre-generated text value used for domain verification
		///  * `MANUAL_DOMAIN_ACCESS_EMAIL` - DAE sent to an email address manually entered by a rep
		///  * `PREVIOUS_DOMAIN_ACCESS_EMAIL` - Customers domain access email for a prior certificate request was used for domain verification
		///  * `REGISTRATION_AUTHORITY_DOMAIN_ACCESS_LETTER` - Representative reviewed a customer provided domain access letter and verified domain
		///  * `REGISTRATION_AUTHORITY_DOMAIN_ZONE_CONTROL` - Representative verified domain using a manual domain zone control check
		///  * `REGISTRATION_AUTHORITY_OVERRIDE` - Representative verified domain using alternative methods
		///  * `REGISTRATION_AUTHORITY_WEBSITE_CONTROL` - Representative verified domain using a manual website control check
		///  * `CUSTOMER_OWNED` - Validated customer account information used for domain control verification
		///  * `WEBSITE_CONTROL` - HTML file in root website directory containing pre-generated value used for domain control verification
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public DomainVerificationSummaryType Type { get; set; }
		
		/// <summary>
		/// Type of domain name used for domain verification
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="usage")]
		public DomainVerificationSummaryUsage Usage { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DomainVerificationSummaryStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED_VERIFICATION = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VERIFIED_POSSIBLE_FRAUD = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DROPPED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DROPPED_CERTIFICATE_AUTHORITY_AUTHORIZATION = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DROPPED_GOOGLE_SAFE_BROWSING = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AWAITING = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING_POSSIBLE_FRAUD = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REVOKED_CERTIFICATE = 9,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DomainVerificationSummaryType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOMAIN_CONTROL_EMAIL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_ADMIN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_ADMINSTRATOR = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_HOST_MASTER = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_POST_MASTER = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		AUTO_GENERATED_DOMAIN_ACCESS_EMAIL_WEB_MASTER = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOMAIN_ACCESS_EMAIL = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOMAIN_ACCESS_LETTER = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOMAIN_ZONE_CONTROL = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MANUAL_DOMAIN_ACCESS_EMAIL = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PREVIOUS_DOMAIN_ACCESS_EMAIL = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGISTRATION_AUTHORITY_DOMAIN_ACCESS_LETTER = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGISTRATION_AUTHORITY_DOMAIN_ZONE_CONTROL = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGISTRATION_AUTHORITY_OVERRIDE = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REGISTRATION_AUTHORITY_WEBSITE_CONTROL = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CUSTOMER_OWNED = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WEBSITE_CONTROL = 16,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DomainVerificationSummaryUsage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMMON_NAME = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		SUBJECT_ALTERNATIVE_NAME = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Error
	{
		
		/// <summary>
		/// Short identifier for the error, suitable for indicating the specific error within client code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// List of the specific fields, and the errors found with their contents
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fields")]
		public ErrorField[] Fields { get; set; }
		
		/// <summary>
		/// Description of the error
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ErrorField
	{
		
		/// <summary>
		/// Short identifier for the error, suitable for indicating the specific error within client code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Description of the problem with the contents of the field
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// JSONPath referring to the field within the submitted data containing an error
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	public class ErrorLimit
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ExternalAccountBinding
	{
		
		/// <summary>
		/// ACME directory resource URL.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="directoryUrl")]
		public string DirectoryUrl { get; set; }
		
		/// <summary>
		/// EAB HMAC key for the ACME account
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hmacKey")]
		public string HmacKey { get; set; }
		
		/// <summary>
		/// EAB key identifier for the ACME account.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="keyId")]
		public string KeyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JurisdictionOfIncorporation
	{
		
		[System.Runtime.Serialization.DataMember(Name="city")]
		public string City { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="country")]
		public string Country { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="county")]
		public string County { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public string State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PEMCertificates
	{
		
		/// <summary>
		/// End entity certificate in PEM format
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="certificate")]
		public string Certificate { get; set; }
		
		/// <summary>
		/// CA Cross Intermediate certificate in PEM format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cross")]
		public string Cross { get; set; }
		
		/// <summary>
		/// CA Signing Intermediate certificate in PEM format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="intermediate")]
		public string Intermediate { get; set; }
		
		/// <summary>
		/// CA Root certificate in PEM format
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="root")]
		public string Root { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Create a pending order for certificate
		/// <p>Creating a certificate order can be a long running asynchronous operation in the PKI workflow. The PKI API supports 2 options for getting the completion stateful actions for this asynchronous operations: 1) by polling operations -- see /v1/certificates/{certificateId}/actions 2) via WebHook style callback -- see '/v1/certificates/{certificateId}/callback'.</p>
		/// Certificate_create v1/certificates
		/// </summary>
		/// <param name="requestBody">The certificate order information</param>
		public async Task Certificate_createAsync(CertificateCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Validate a pending order for certificate
		/// Certificate_validate v1/certificates/validate
		/// </summary>
		/// <param name="requestBody">The certificate order info</param>
		public async Task Certificate_validateAsync(CertificateCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/validate";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Retrieve certificate details
		/// Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificate.
		/// Certificate_get v1/certificates/{certificateId}
		/// </summary>
		/// <param name="certificateId">Certificate id to lookup</param>
		/// <returns>Certificate details retrieved</returns>
		public async Task<Certificate> Certificate_getAsync(string certificateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Certificate>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve all certificate actions
		/// This method is used to retrieve all stateful actions relating to a certificate lifecycle.
		/// Certificate_action_retrieve v1/certificates/{certificateId}/actions
		/// </summary>
		/// <param name="certificateId">Certificate id to register for callback</param>
		/// <returns>Action retrieval successful</returns>
		public async Task<CertificateAction[]> Certificate_action_retrieveAsync(string certificateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/actions";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateAction[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Unregister system callback
		/// Unregister the callback for a particular certificate.
		/// Certificate_callback_delete v1/certificates/{certificateId}/callback
		/// </summary>
		/// <param name="certificateId">Certificate id to unregister callback</param>
		public async Task Certificate_callback_deleteAsync(string certificateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/callback";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve system stateful action callback url
		/// This method is used to retrieve the registered callback url for a certificate.
		/// Certificate_callback_get v1/certificates/{certificateId}/callback
		/// </summary>
		/// <param name="certificateId">Certificate id to register for stateful action callback</param>
		/// <returns>Callback registered</returns>
		public async Task<CertificateCallback> Certificate_callback_getAsync(string certificateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/callback";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateCallback>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Register of certificate action callback
		/// This method is used to register/replace url for callbacks for stateful actions relating to a certificate lifecycle. The callback url is a Webhook style pattern and will receive POST http requests with json body defined in the CertificateAction model definition for each certificate action.  Only one callback URL is allowed to be registered for each certificateId, so it will replace a previous registration.
		/// Certificate_callback_replace v1/certificates/{certificateId}/callback
		/// </summary>
		/// <param name="certificateId">Certificate id to register/replace for callback</param>
		/// <param name="callbackUrl">Callback url registered/replaced to receive stateful actions</param>
		public async Task Certificate_callback_replaceAsync(string certificateId, string callbackUrl, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/callback&callbackUrl=" + (callbackUrl==null? "" : System.Uri.EscapeDataString(callbackUrl));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Cancel a pending certificate
		/// Use the cancel call to cancel a pending certificate order.
		/// Certificate_cancel v1/certificates/{certificateId}/cancel
		/// </summary>
		/// <param name="certificateId">Certificate id to cancel</param>
		public async Task Certificate_cancelAsync(string certificateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download certificate
		/// Certificate_download v1/certificates/{certificateId}/download
		/// </summary>
		/// <param name="certificateId">Certificate id to download</param>
		/// <returns>Certificate retrieved</returns>
		public async Task<CertificateBundle> Certificate_downloadAsync(string certificateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/download";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateBundle>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve email history
		/// This method can be used to retrieve all emails sent for a certificate.
		/// Certificate_email_history v1/certificates/{certificateId}/email/history
		/// </summary>
		/// <param name="certificateId">Certificate id to retrieve email history</param>
		/// <returns>Email history retrieval successful</returns>
		public async Task<CertificateEmailHistory> Certificate_email_historyAsync(string certificateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/email/history";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateEmailHistory>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Add alternate email address
		/// This method adds an alternate email address to a certificate order and re-sends all existing request emails to that address.
		/// Certificate_alternate_email_address v1/certificates/{certificateId}/email/resend/{emailAddress}
		/// </summary>
		/// <param name="certificateId">Certificate id to resend emails</param>
		/// <param name="emailAddress">Specific email address to resend email</param>
		/// <returns>Alternate email address added and emails re-sent</returns>
		public async Task<CertificateEmailHistory> Certificate_alternate_email_addressAsync(string certificateId, string emailAddress, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/email/resend/"+ (emailAddress==null? "" : System.Uri.EscapeDataString(emailAddress));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateEmailHistory>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resend an email
		/// This method can be used to resend emails by providing the certificate id and the email id
		/// Certificate_resend_email v1/certificates/{certificateId}/email/{emailId}/resend
		/// </summary>
		/// <param name="certificateId">Certificate id to resend email</param>
		/// <param name="emailId">Email id for email to resend</param>
		public async Task Certificate_resend_emailAsync(string certificateId, string emailId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/email/"+ (emailId==null? "" : System.Uri.EscapeDataString(emailId))+"/resend";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Resend email to email address
		/// This method can be used to resend emails by providing the certificate id, the email id, and the recipient email address
		/// Certificate_resend_email_address v1/certificates/{certificateId}/email/{emailId}/resend/{emailAddress}
		/// </summary>
		/// <param name="certificateId">Certificate id to resend emails</param>
		/// <param name="emailId">Email id for email to resend</param>
		/// <param name="emailAddress">Specific email address to resend email</param>
		public async Task Certificate_resend_email_addressAsync(string certificateId, string emailId, string emailAddress, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/email/"+ (emailId==null? "" : System.Uri.EscapeDataString(emailId))+"/resend/"+ (emailAddress==null? "" : System.Uri.EscapeDataString(emailAddress));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reissue active certificate
		/// <p>Rekeying is the process by which the private and public key is changed for a certificate. It is a simplified reissue,where only the CSR is changed. Reissuing is the process by which domain names are added or removed from a certificate.Once a request is validated and approved, the certificate will be reissued with the new common name and sans specified. Unlimited reissues are available during the lifetime of the certificate.New names added to a certificate that do not share the base domain of the common name may take additional time to validate. If this API call is made before a previous pending reissue has been validated and issued, the previous reissue request is automatically rejected and replaced with the current request.</p>
		/// Certificate_reissue v1/certificates/{certificateId}/reissue
		/// </summary>
		/// <param name="certificateId">Certificate id to reissue</param>
		/// <param name="requestBody">The reissue request info</param>
		public async Task Certificate_reissueAsync(string certificateId, CertificateReissue requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/reissue";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Renew active certificate
		/// Renewal is the process by which the validity of a certificate is extended. Renewal is only available 60 days prior to expiration of the previous certificate and 30 days after the expiration of the previous certificate. The renewal supports modifying a set of the original certificate order information. Once a request is validated and approved, the certificate will be issued with extended validity. Since subject alternative names can be removed during a renewal, we require that you provide the subject alternative names you expect in the renewed certificate. New names added to a certificate that do not share the base domain of the common name may take additional time to validate. </p>
		/// Certificate_renew v1/certificates/{certificateId}/renew
		/// </summary>
		/// <param name="certificateId">Certificate id to renew</param>
		/// <param name="requestBody">The renew request info</param>
		public async Task Certificate_renewAsync(string certificateId, CertificateRenew requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/renew";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Revoke active certificate
		/// Use revoke call to revoke an active certificate, if the certificate has not been issued a 404 response will be returned.
		/// Certificate_revoke v1/certificates/{certificateId}/revoke
		/// </summary>
		/// <param name="certificateId">Certificate id to revoke</param>
		/// <param name="requestBody">The certificate revocation request</param>
		public async Task Certificate_revokeAsync(string certificateId, CertificateRevoke requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/revoke";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get Site seal
		/// <p>This method is used to obtain the site seal information for an issued certificate. A site seal is a graphic that the certificate purchaser can embed on their web site to show their visitors information about their SSL certificate. If a web site visitor clicks on the site seal image, a pop-up page is displayed that contains detailed information about the SSL certificate. The site seal token is used to link the site seal graphic image to the appropriate certificate details pop-up page display when a user clicks on the site seal. The site seal images are expected to be static images and hosted on the reseller's website, to minimize delays for customer page load times.</p>
		/// Certificate_siteseal_get v1/certificates/{certificateId}/siteSeal
		/// </summary>
		/// <param name="certificateId">Certificate id</param>
		/// <param name="theme">This value represents the visual theme of the seal. If seal doesn't exist, default values are used if params not present. If seal does exist, default values will not be used to update unless params present.</param>
		/// <param name="locale">Determine locale for text displayed in seal image and verification page. If seal doesn't exist, default values are used if params not present. If seal does exist, default values will not be used to update unless params present.</param>
		/// <returns>Site seal retrieved</returns>
		public async Task<CertificateSiteSeal> Certificate_siteseal_getAsync(string certificateId, Certificate_siteseal_getTheme theme, string locale, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/siteSeal&theme=" + theme+"&locale=" + (locale==null? "" : System.Uri.EscapeDataString(locale));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateSiteSeal>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check Domain Control
		/// Domain control is a means for verifying the domain included in the certificate order. This resource is useful for resellers that control the domains for their customers, and can expedite the verification process. See https://www.godaddy.com/help/verifying-your-domain-ownership-for-ssl-certificate-requests-html-or-dns-7452
		/// Certificate_verifydomaincontrol v1/certificates/{certificateId}/verifyDomainControl
		/// </summary>
		/// <param name="certificateId">Certificate id to lookup</param>
		public async Task Certificate_verifydomaincontrolAsync(string certificateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/verifyDomainControl";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search for certificate details by entitlement
		/// Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificates associated to an entitlement.
		/// Certificate_get_entitlement v2/certificates
		/// </summary>
		/// <param name="entitlementId">Entitlement id to lookup</param>
		/// <param name="latest">Fetch only the most recent certificate</param>
		/// <returns>Certificate details retrieved</returns>
		public async Task<Certificate[]> Certificate_get_entitlementAsync(string entitlementId, bool latest, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/certificates?entitlementId=" + (entitlementId==null? "" : System.Uri.EscapeDataString(entitlementId))+"&latest="+latest;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Certificate[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Download certificate by entitlement
		/// Certificate_download_entitlement v2/certificates/download
		/// </summary>
		/// <param name="entitlementId">Entitlement id to download</param>
		/// <returns>Certificate retrieved</returns>
		public async Task<CertificateBundle> Certificate_download_entitlementAsync(string entitlementId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/certificates/download?entitlementId=" + (entitlementId==null? "" : System.Uri.EscapeDataString(entitlementId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateBundle>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve customer's certificates
		/// This method can be used to retrieve a list of certificates for a specified customer. <ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
		/// GetCustomerCertificatesByCustomerId v2/customers/{customerId}/certificates
		/// </summary>
		/// <param name="customerId">An identifier for a customer</param>
		/// <param name="offset">Number of results to skip for pagination</param>
		/// <param name="limit">Maximum number of items to return</param>
		/// <returns>Customer certificate information retrieved.</returns>
		public async Task<CertificateSummariesV2> GetCustomerCertificatesByCustomerIdAsync(string customerId, string offset, string limit, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/customers/"+ (customerId==null? "" : System.Uri.EscapeDataString(customerId))+"/certificates&offset=" + (offset==null? "" : System.Uri.EscapeDataString(offset))+"&limit=" + (limit==null? "" : System.Uri.EscapeDataString(limit));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateSummariesV2>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieves the external account binding for the specified customer
		/// Use this endpoint to retrieve a key identifier and Hash-based Message Authentication Code (HMAC) key for Automated Certificate Management Environment (ACME) External Account Binding (EAB). These credentials can be used with an ACME client that supports EAB (ex. CertBot) to automate the issuance request and deployment of DV SSL certificates
		/// GetAcmeExternalAccountBinding v2/customers/{customerId}/certificates/acme/externalAccountBinding
		/// </summary>
		/// <param name="customerId">An identifier for a customer</param>
		/// <returns>Acme key identifier and HMAC key for the external account binding. Directory URI is also provided for making ACME requests.</returns>
		public async Task<ExternalAccountBinding> GetAcmeExternalAccountBindingAsync(string customerId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/customers/"+ (customerId==null? "" : System.Uri.EscapeDataString(customerId))+"/certificates/acme/externalAccountBinding";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ExternalAccountBinding>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve individual certificate details
		/// Once the certificate order has been created, this method can be used to check the status of the certificate. This method can also be used to retrieve details of the certificate. <ul><li>**shopperId** is **not the same** as **customerId**. **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
		/// GetCertificateDetailByCertIdentifier v2/customers/{customerId}/certificates/{certificateId}
		/// </summary>
		/// <param name="customerId">An identifier for a customer</param>
		/// <param name="certificateId">Certificate id to lookup</param>
		/// <returns>Certificate details retrieved</returns>
		public async Task<CertificateDetailV2> GetCertificateDetailByCertIdentifierAsync(string customerId, string certificateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/customers/"+ (customerId==null? "" : System.Uri.EscapeDataString(customerId))+"/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CertificateDetailV2>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve domain verification status
		/// This method can be used to retrieve the domain verification status for a certificate request.<ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>"
		/// GetDomainInformationByCertificateId v2/customers/{customerId}/certificates/{certificateId}/domainVerifications
		/// </summary>
		/// <param name="customerId">An identifier for a customer</param>
		/// <param name="certificateId">Certificate id to lookup</param>
		/// <returns>Domain verification status list for specified certificateId.</returns>
		public async Task<DomainVerificationSummary[]> GetDomainInformationByCertificateIdAsync(string customerId, string certificateId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/customers/"+ (customerId==null? "" : System.Uri.EscapeDataString(customerId))+"/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/domainVerifications";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DomainVerificationSummary[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve detailed information for supplied domain
		/// Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details. <ul><li>**shopperId** is **not the same** as **customerId**.  **shopperId** is a number of max length 10 digits (*ex:* 1234567890) whereas **customerId** is a UUIDv4 (*ex:* 295e3bc3-b3b9-4d95-aae5-ede41a994d13)</li></ul>
		/// GetDomainDetailsByDomain v2/customers/{customerId}/certificates/{certificateId}/domainVerifications/{domain}
		/// </summary>
		/// <param name="customerId">An identifier for a customer</param>
		/// <param name="certificateId">Certificate id to lookup</param>
		/// <param name="domain">A valid domain name in the certificate request</param>
		/// <returns>Retrieve detailed information for supplied domain, including domain verification details and Certificate Authority Authorization (CAA) verification details.</returns>
		public async Task<DomainVerificationDetail> GetDomainDetailsByDomainAsync(string customerId, string certificateId, string domain, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v2/customers/"+ (customerId==null? "" : System.Uri.EscapeDataString(customerId))+"/certificates/"+ (certificateId==null? "" : System.Uri.EscapeDataString(certificateId))+"/domainVerifications/"+ (domain==null? "" : System.Uri.EscapeDataString(domain));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DomainVerificationDetail>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Certificate_siteseal_getTheme
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DARK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LIGHT = 1,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
