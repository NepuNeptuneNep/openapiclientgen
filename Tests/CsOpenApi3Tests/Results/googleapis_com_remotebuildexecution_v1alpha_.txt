//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// An `Action` captures all the information about an execution which is required to reproduce it. `Action`s are the core component of the [Execution] service. A single `Action` represents a repeatable action that can be performed by the execution service. `Action`s can be succinctly identified by the digest of their wire format encoding and, once an `Action` has been executed, will be cached in the action cache. Future requests can then use the cached result rather than needing to run afresh. When a server completes execution of an Action, it MAY choose to cache the result in the ActionCache unless `do_not_cache` is `true`. Clients SHOULD expect the server to do so. By default, future calls to Execute the same `Action` will also serve their results from the cache. Clients must take care to understand the caching behaviour. Ideally, all `Action`s will be reproducible so that serving a result from cache is always desirable and correct.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2Action
	{
		
		/// <summary>
		/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="commandDigest")]
		public BuildBazelRemoteExecutionV2Digest CommandDigest { get; set; }
		
		/// <summary>
		/// If true, then the `Action`'s result cannot be cached, and in-flight requests for the same `Action` may not be merged.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="doNotCache")]
		public System.Nullable<System.Boolean> DoNotCache { get; set; }
		
		/// <summary>
		/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputRootDigest")]
		public BuildBazelRemoteExecutionV2Digest InputRootDigest { get; set; }
		
		/// <summary>
		/// A `Platform` is a set of requirements, such as hardware, operating system, or compiler toolchain, for an Action's execution environment. A `Platform` is represented as a series of key-value pairs representing the properties that are required of the platform.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platform")]
		public BuildBazelRemoteExecutionV2Platform Platform { get; set; }
		
		/// <summary>
		/// An optional additional salt value used to place this `Action` into a separate cache namespace from other instances having the same field contents. This salt typically comes from operational configuration specific to sources such as repo and service configuration, and allows disowning an entire set of ActionResults that might have been poisoned by buggy software or tool failures.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="salt")]
		public string Salt { get; set; }
		
		/// <summary>
		/// A timeout after which the execution should be killed. If the timeout is absent, then the client is specifying that the execution should continue as long as the server will let it. The server SHOULD impose a timeout if the client does not specify one, however, if the client does specify a timeout that is longer than the server's maximum timeout, the server MUST reject the request. The timeout is only intended to cover the "execution" of the specified action and not time in queue nor any overheads before or after execution such as marshalling inputs/outputs. The server SHOULD avoid including time spent the client doesn't have control over, and MAY extend or reduce the timeout to account for delays or speedups that occur during execution itself (e.g., lazily loading data from the Content Addressable Storage, live migration of virtual machines, emulation overhead). The timeout is a part of the Action message, and therefore two `Actions` with different timeouts are different, even if they are otherwise identical. This is because, if they were not, running an `Action` with a lower timeout than is required might result in a cache hit from an execution run with a longer timeout, hiding the fact that the timeout is too short. By encoding it directly in the `Action`, a lower timeout will result in a cache miss and the execution timeout will fail immediately, rather than whenever the cache entry gets evicted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeout")]
		public string Timeout { get; set; }
	}
	
	/// <summary>
	/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2Digest
	{
		
		/// <summary>
		/// The hash. In the case of SHA-256, it will always be a lowercase hex string exactly 64 characters long.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hash")]
		public string Hash { get; set; }
		
		/// <summary>
		/// The size of the blob, in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeBytes")]
		public string SizeBytes { get; set; }
	}
	
	/// <summary>
	/// A `Platform` is a set of requirements, such as hardware, operating system, or compiler toolchain, for an Action's execution environment. A `Platform` is represented as a series of key-value pairs representing the properties that are required of the platform.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2Platform
	{
		
		/// <summary>
		/// The properties that make up this platform. In order to ensure that equivalent `Platform`s always hash to the same value, the properties MUST be lexicographically sorted by name, and then by value. Sorting of strings is done by code point, equivalently, by the UTF-8 bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public BuildBazelRemoteExecutionV2PlatformProperty[] Properties { get; set; }
	}
	
	/// <summary>
	/// A single property for the environment. The server is responsible for specifying the property `name`s that it accepts. If an unknown `name` is provided in the requirements for an Action, the server SHOULD reject the execution request. If permitted by the server, the same `name` may occur multiple times. The server is also responsible for specifying the interpretation of property `value`s. For instance, a property describing how much RAM must be available may be interpreted as allowing a worker with 16GB to fulfill a request for 8GB, while a property describing the OS environment on which the action must be performed may require an exact match with the worker's OS. The server MAY use the `value` of one or more properties to determine how it sets up the execution environment, such as by making specific system files available to the worker. Both names and values are typically case-sensitive. Note that the platform is implicitly part of the action digest, so even tiny changes in the names or values (like changing case) may result in different action cache entries.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2PlatformProperty
	{
		
		/// <summary>
		/// The property name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The property value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// An ActionResult represents the result of an Action being run. It is advised that at least one field (for example `ActionResult.execution_metadata.Worker`) have a non-default value, to ensure that the serialized value is non-empty, which can then be used as a basic data sanity check.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2ActionResult
	{
		
		/// <summary>
		/// ExecutedActionMetadata contains details about a completed execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionMetadata")]
		public BuildBazelRemoteExecutionV2ExecutedActionMetadata ExecutionMetadata { get; set; }
		
		/// <summary>
		/// The exit code of the command.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exitCode")]
		public System.Nullable<System.Int32> ExitCode { get; set; }
		
		/// <summary>
		/// The output directories of the action. For each output directory requested in the `output_directories` or `output_paths` field of the Action, if the corresponding directory existed after the action completed, a single entry will be present in the output list, which will contain the digest of a Tree message containing the directory tree, and the path equal exactly to the corresponding Action output_directories member. As an example, suppose the Action had an output directory `a/b/dir` and the execution produced the following contents in `a/b/dir`: a file named `bar` and a directory named `foo` with an executable file named `baz`. Then, output_directory will contain (hashes shortened for readability): ```json // OutputDirectory proto: { path: "a/b/dir" tree_digest: { hash: "4a73bc9d03...", size: 55 } } // Tree proto with hash "4a73bc9d03..." and size 55: { root: { files: [ { name: "bar", digest: { hash: "4a73bc9d03...", size: 65534 } } ], directories: [ { name: "foo", digest: { hash: "4cf2eda940...", size: 43 } } ] } children : { // (Directory proto with hash "4cf2eda940..." and size 43) files: [ { name: "baz", digest: { hash: "b2c941073e...", size: 1294, }, is_executable: true } ] } } ``` If an output of the same name as listed in `output_files` of the Command was found in `output_directories`, but was not a directory, the server will return a FAILED_PRECONDITION.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputDirectories")]
		public BuildBazelRemoteExecutionV2OutputDirectory[] OutputDirectories { get; set; }
		
		/// <summary>
		/// The output directories of the action that are symbolic links to other directories. Those may be links to other output directories, or input directories, or even absolute paths outside of the working directory, if the server supports SymlinkAbsolutePathStrategy.ALLOWED. For each output directory requested in the `output_directories` field of the Action, if the directory existed after the action completed, a single entry will be present either in this field, or in the `output_directories` field, if the directory was not a symbolic link. If an output of the same name was found, but was a symbolic link to a file instead of a directory, the server will return a FAILED_PRECONDITION. If the action does not produce the requested output, then that output will be omitted from the list. The server is free to arrange the output list as desired; clients MUST NOT assume that the output list is sorted. DEPRECATED as of v2.1. Servers that wish to be compatible with v2.0 API should still populate this field in addition to `output_symlinks`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputDirectorySymlinks")]
		public BuildBazelRemoteExecutionV2OutputSymlink[] OutputDirectorySymlinks { get; set; }
		
		/// <summary>
		/// The output files of the action that are symbolic links to other files. Those may be links to other output files, or input files, or even absolute paths outside of the working directory, if the server supports SymlinkAbsolutePathStrategy.ALLOWED. For each output file requested in the `output_files` or `output_paths` field of the Action, if the corresponding file existed after the action completed, a single entry will be present either in this field, or in the `output_files` field, if the file was not a symbolic link. If an output symbolic link of the same name as listed in `output_files` of the Command was found, but its target type was not a regular file, the server will return a FAILED_PRECONDITION. If the action does not produce the requested output, then that output will be omitted from the list. The server is free to arrange the output list as desired; clients MUST NOT assume that the output list is sorted. DEPRECATED as of v2.1. Servers that wish to be compatible with v2.0 API should still populate this field in addition to `output_symlinks`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputFileSymlinks")]
		public BuildBazelRemoteExecutionV2OutputSymlink[] OutputFileSymlinks { get; set; }
		
		/// <summary>
		/// The output files of the action. For each output file requested in the `output_files` or `output_paths` field of the Action, if the corresponding file existed after the action completed, a single entry will be present either in this field, or the `output_file_symlinks` field if the file was a symbolic link to another file (`output_symlinks` field after v2.1). If an output listed in `output_files` was found, but was a directory rather than a regular file, the server will return a FAILED_PRECONDITION. If the action does not produce the requested output, then that output will be omitted from the list. The server is free to arrange the output list as desired; clients MUST NOT assume that the output list is sorted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputFiles")]
		public BuildBazelRemoteExecutionV2OutputFile[] OutputFiles { get; set; }
		
		/// <summary>
		/// New in v2.1: this field will only be populated if the command `output_paths` field was used, and not the pre v2.1 `output_files` or `output_directories` fields. The output paths of the action that are symbolic links to other paths. Those may be links to other outputs, or inputs, or even absolute paths outside of the working directory, if the server supports SymlinkAbsolutePathStrategy.ALLOWED. A single entry for each output requested in `output_paths` field of the Action, if the corresponding path existed after the action completed and was a symbolic link. If the action does not produce a requested output, then that output will be omitted from the list. The server is free to arrange the output list as desired; clients MUST NOT assume that the output list is sorted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputSymlinks")]
		public BuildBazelRemoteExecutionV2OutputSymlink[] OutputSymlinks { get; set; }
		
		/// <summary>
		/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stderrDigest")]
		public BuildBazelRemoteExecutionV2Digest StderrDigest { get; set; }
		
		/// <summary>
		/// The standard error buffer of the action. The server SHOULD NOT inline stderr unless requested by the client in the GetActionResultRequest message. The server MAY omit inlining, even if requested, and MUST do so if inlining would cause the response to exceed message size limits. Clients SHOULD NOT populate this field when uploading to the cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stderrRaw")]
		public string StderrRaw { get; set; }
		
		/// <summary>
		/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stdoutDigest")]
		public BuildBazelRemoteExecutionV2Digest StdoutDigest { get; set; }
		
		/// <summary>
		/// The standard output buffer of the action. The server SHOULD NOT inline stdout unless requested by the client in the GetActionResultRequest message. The server MAY omit inlining, even if requested, and MUST do so if inlining would cause the response to exceed message size limits. Clients SHOULD NOT populate this field when uploading to the cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stdoutRaw")]
		public string StdoutRaw { get; set; }
	}
	
	/// <summary>
	/// ExecutedActionMetadata contains details about a completed execution.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2ExecutedActionMetadata
	{
		
		/// <summary>
		/// Details that are specific to the kind of worker used. For example, on POSIX-like systems this could contain a message with getrusage(2) statistics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="auxiliaryMetadata")]
		public string[] AuxiliaryMetadata { get; set; }
		
		/// <summary>
		/// When the worker completed executing the action command.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionCompletedTimestamp")]
		public string ExecutionCompletedTimestamp { get; set; }
		
		/// <summary>
		/// When the worker started executing the action command.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionStartTimestamp")]
		public string ExecutionStartTimestamp { get; set; }
		
		/// <summary>
		/// When the worker finished fetching action inputs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputFetchCompletedTimestamp")]
		public string InputFetchCompletedTimestamp { get; set; }
		
		/// <summary>
		/// When the worker started fetching action inputs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputFetchStartTimestamp")]
		public string InputFetchStartTimestamp { get; set; }
		
		/// <summary>
		/// When the worker finished uploading action outputs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputUploadCompletedTimestamp")]
		public string OutputUploadCompletedTimestamp { get; set; }
		
		/// <summary>
		/// When the worker started uploading action outputs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputUploadStartTimestamp")]
		public string OutputUploadStartTimestamp { get; set; }
		
		/// <summary>
		/// When was the action added to the queue.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queuedTimestamp")]
		public string QueuedTimestamp { get; set; }
		
		/// <summary>
		/// New in v2.3: the amount of time the worker spent executing the action command, potentially computed using a worker-specific virtual clock. The virtual execution duration is only intended to cover the "execution" of the specified action and not time in queue nor any overheads before or after execution such as marshalling inputs/outputs. The server SHOULD avoid including time spent the client doesn't have control over, and MAY extend or reduce the execution duration to account for delays or speedups that occur during execution itself (e.g., lazily loading data from the Content Addressable Storage, live migration of virtual machines, emulation overhead). The method of timekeeping used to compute the virtual execution duration MUST be consistent with what is used to enforce the Action's `timeout`. There is no relationship between the virtual execution duration and the values of `execution_start_timestamp` and `execution_completed_timestamp`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="virtualExecutionDuration")]
		public string VirtualExecutionDuration { get; set; }
		
		/// <summary>
		/// The name of the worker which ran the execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="worker")]
		public string Worker { get; set; }
		
		/// <summary>
		/// When the worker completed the action, including all stages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workerCompletedTimestamp")]
		public string WorkerCompletedTimestamp { get; set; }
		
		/// <summary>
		/// When the worker received the action.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workerStartTimestamp")]
		public string WorkerStartTimestamp { get; set; }
	}
	
	/// <summary>
	/// An `OutputDirectory` is the output in an `ActionResult` corresponding to a directory's full contents rather than a single file.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2OutputDirectory
	{
		
		/// <summary>
		/// If set, consumers MAY make the following assumptions about the directories contained in the the Tree, so that it may be instantiated on a local file system by scanning through it sequentially: - All directories with the same binary representation are stored exactly once. - All directories, apart from the root directory, are referenced by at least one parent directory. - Directories are stored in topological order, with parents being stored before the child. The root directory is thus the first to be stored. Additionally, the Tree MUST be encoded as a stream of records, where each record has the following format: - A tag byte, having one of the following two values: - (1 << 3) | 2 == 0x0a: First record (the root directory). - (2 << 3) | 2 == 0x12: Any subsequent records (child directories). - The size of the directory, encoded as a base 128 varint. - The contents of the directory, encoded as a binary serialized Protobuf message. This encoding is a subset of the Protobuf wire format of the Tree message. As it is only permitted to store data associated with field numbers 1 and 2, the tag MUST be encoded as a single byte. More details on the Protobuf wire format can be found here: https://developers.google.com/protocol-buffers/docs/encoding It is recommended that implementations using this feature construct Tree objects manually using the specification given above, as opposed to using a Protobuf library to marshal a full Tree message. As individual Directory messages already need to be marshaled to compute their digests, constructing the Tree object manually avoids redundant marshaling.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isTopologicallySorted")]
		public System.Nullable<System.Boolean> IsTopologicallySorted { get; set; }
		
		/// <summary>
		/// The full path of the directory relative to the working directory. The path separator is a forward slash `/`. Since this is a relative path, it MUST NOT begin with a leading forward slash. The empty string value is allowed, and it denotes the entire working directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="treeDigest")]
		public BuildBazelRemoteExecutionV2Digest TreeDigest { get; set; }
	}
	
	/// <summary>
	/// An `OutputSymlink` is similar to a Symlink, but it is used as an output in an `ActionResult`. `OutputSymlink` is binary-compatible with `SymlinkNode`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2OutputSymlink
	{
		
		/// <summary>
		/// Node properties for FileNodes, DirectoryNodes, and SymlinkNodes. The server is responsible for specifying the properties that it accepts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeProperties")]
		public BuildBazelRemoteExecutionV2NodeProperties NodeProperties { get; set; }
		
		/// <summary>
		/// The full path of the symlink relative to the working directory, including the filename. The path separator is a forward slash `/`. Since this is a relative path, it MUST NOT begin with a leading forward slash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// The target path of the symlink. The path separator is a forward slash `/`. The target path can be relative to the parent directory of the symlink or it can be an absolute path starting with `/`. Support for absolute paths can be checked using the Capabilities API. `..` components are allowed anywhere in the target path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	/// <summary>
	/// Node properties for FileNodes, DirectoryNodes, and SymlinkNodes. The server is responsible for specifying the properties that it accepts.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2NodeProperties
	{
		
		/// <summary>
		/// The file's last modification timestamp.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="mtime")]
		public string Mtime { get; set; }
		
		/// <summary>
		/// A list of string-based NodeProperties.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="properties")]
		public BuildBazelRemoteExecutionV2NodeProperty[] Properties { get; set; }
		
		/// <summary>
		/// The UNIX file mode, e.g., 0755.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unixMode")]
		public System.Nullable<System.UInt32> UnixMode { get; set; }
	}
	
	/// <summary>
	/// A single property for FileNodes, DirectoryNodes, and SymlinkNodes. The server is responsible for specifying the property `name`s that it accepts. If permitted by the server, the same `name` may occur multiple times.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2NodeProperty
	{
		
		/// <summary>
		/// The property name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The property value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// An `OutputFile` is similar to a FileNode, but it is used as an output in an `ActionResult`. It allows a full file path rather than only a name.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2OutputFile
	{
		
		/// <summary>
		/// The contents of the file if inlining was requested. The server SHOULD NOT inline file contents unless requested by the client in the GetActionResultRequest message. The server MAY omit inlining, even if requested, and MUST do so if inlining would cause the response to exceed message size limits. Clients SHOULD NOT populate this field when uploading to the cache.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public BuildBazelRemoteExecutionV2Digest Digest { get; set; }
		
		/// <summary>
		/// True if file is executable, false otherwise.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isExecutable")]
		public System.Nullable<System.Boolean> IsExecutable { get; set; }
		
		/// <summary>
		/// Node properties for FileNodes, DirectoryNodes, and SymlinkNodes. The server is responsible for specifying the properties that it accepts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeProperties")]
		public BuildBazelRemoteExecutionV2NodeProperties NodeProperties { get; set; }
		
		/// <summary>
		/// The full path of the file relative to the working directory, including the filename. The path separator is a forward slash `/`. Since this is a relative path, it MUST NOT begin with a leading forward slash.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// A `Command` is the actual command executed by a worker running an Action and specifications of its environment. Except as otherwise required, the environment (such as which system libraries or binaries are available, and what filesystems are mounted where) is defined by and specific to the implementation of the remote execution API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2Command
	{
		
		/// <summary>
		/// The arguments to the command. The first argument specifies the command to run, which may be either an absolute path, a path relative to the working directory, or an unqualified path (without path separators) which will be resolved using the operating system's equivalent of the PATH environment variable. Path separators native to the operating system running on the worker SHOULD be used. If the `environment_variables` list contains an entry for the PATH environment variable, it SHOULD be respected. If not, the resolution process is implementation-defined. Changed in v2.3. v2.2 and older require that no PATH lookups are performed, and that relative paths are resolved relative to the input root. This behavior can, however, not be relied upon, as most implementations already followed the rules described above.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="arguments")]
		public string[] Arguments { get; set; }
		
		/// <summary>
		/// The environment variables to set when running the program. The worker may provide its own default environment variables; these defaults can be overridden using this field. Additional variables can also be specified. In order to ensure that equivalent Commands always hash to the same value, the environment variables MUST be lexicographically sorted by name. Sorting of strings is done by code point, equivalently, by the UTF-8 bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="environmentVariables")]
		public BuildBazelRemoteExecutionV2CommandEnvironmentVariable[] EnvironmentVariables { get; set; }
		
		/// <summary>
		/// A list of the output directories that the client expects to retrieve from the action. Only the listed directories will be returned (an entire directory structure will be returned as a Tree message digest, see OutputDirectory), as well as files listed in `output_files`. Other files or directories that may be created during command execution are discarded. The paths are relative to the working directory of the action execution. The paths are specified using a single forward slash (`/`) as a path separator, even if the execution platform natively uses a different separator. The path MUST NOT include a trailing slash, nor a leading slash, being a relative path. The special value of empty string is allowed, although not recommended, and can be used to capture the entire working directory tree, including inputs. In order to ensure consistent hashing of the same Action, the output paths MUST be sorted lexicographically by code point (or, equivalently, by UTF-8 bytes). An output directory cannot be duplicated or have the same path as any of the listed output files. An output directory is allowed to be a parent of another output directory. Directories leading up to the output directories (but not the output directories themselves) are created by the worker prior to execution, even if they are not explicitly part of the input root. DEPRECATED since 2.1: Use `output_paths` instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputDirectories")]
		public string[] OutputDirectories { get; set; }
		
		/// <summary>
		/// A list of the output files that the client expects to retrieve from the action. Only the listed files, as well as directories listed in `output_directories`, will be returned to the client as output. Other files or directories that may be created during command execution are discarded. The paths are relative to the working directory of the action execution. The paths are specified using a single forward slash (`/`) as a path separator, even if the execution platform natively uses a different separator. The path MUST NOT include a trailing slash, nor a leading slash, being a relative path. In order to ensure consistent hashing of the same Action, the output paths MUST be sorted lexicographically by code point (or, equivalently, by UTF-8 bytes). An output file cannot be duplicated, be a parent of another output file, or have the same path as any of the listed output directories. Directories leading up to the output files are created by the worker prior to execution, even if they are not explicitly part of the input root. DEPRECATED since v2.1: Use `output_paths` instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputFiles")]
		public string[] OutputFiles { get; set; }
		
		/// <summary>
		/// A list of keys for node properties the client expects to retrieve for output files and directories. Keys are either names of string-based NodeProperty or names of fields in NodeProperties. In order to ensure that equivalent `Action`s always hash to the same value, the node properties MUST be lexicographically sorted by name. Sorting of strings is done by code point, equivalently, by the UTF-8 bytes. The interpretation of string-based properties is server-dependent. If a property is not recognized by the server, the server will return an `INVALID_ARGUMENT`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputNodeProperties")]
		public string[] OutputNodeProperties { get; set; }
		
		/// <summary>
		/// A list of the output paths that the client expects to retrieve from the action. Only the listed paths will be returned to the client as output. The type of the output (file or directory) is not specified, and will be determined by the server after action execution. If the resulting path is a file, it will be returned in an OutputFile typed field. If the path is a directory, the entire directory structure will be returned as a Tree message digest, see OutputDirectory Other files or directories that may be created during command execution are discarded. The paths are relative to the working directory of the action execution. The paths are specified using a single forward slash (`/`) as a path separator, even if the execution platform natively uses a different separator. The path MUST NOT include a trailing slash, nor a leading slash, being a relative path. In order to ensure consistent hashing of the same Action, the output paths MUST be deduplicated and sorted lexicographically by code point (or, equivalently, by UTF-8 bytes). Directories leading up to the output paths are created by the worker prior to execution, even if they are not explicitly part of the input root. New in v2.1: this field supersedes the DEPRECATED `output_files` and `output_directories` fields. If `output_paths` is used, `output_files` and `output_directories` will be ignored!
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputPaths")]
		public string[] OutputPaths { get; set; }
		
		/// <summary>
		/// A `Platform` is a set of requirements, such as hardware, operating system, or compiler toolchain, for an Action's execution environment. A `Platform` is represented as a series of key-value pairs representing the properties that are required of the platform.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="platform")]
		public BuildBazelRemoteExecutionV2Platform Platform { get; set; }
		
		/// <summary>
		/// The working directory, relative to the input root, for the command to run in. It must be a directory which exists in the input tree. If it is left empty, then the action is run in the input root.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workingDirectory")]
		public string WorkingDirectory { get; set; }
	}
	
	/// <summary>
	/// An `EnvironmentVariable` is one variable to set in the running program's environment.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2CommandEnvironmentVariable
	{
		
		/// <summary>
		/// The variable name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The variable value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// A `Directory` represents a directory node in a file tree, containing zero or more children FileNodes, DirectoryNodes and SymlinkNodes. Each `Node` contains its name in the directory, either the digest of its content (either a file blob or a `Directory` proto) or a symlink target, as well as possibly some metadata about the file or directory. In order to ensure that two equivalent directory trees hash to the same value, the following restrictions MUST be obeyed when constructing a a `Directory`: * Every child in the directory must have a path of exactly one segment. Multiple levels of directory hierarchy may not be collapsed. * Each child in the directory must have a unique path segment (file name). Note that while the API itself is case-sensitive, the environment where the Action is executed may or may not be case-sensitive. That is, it is legal to call the API with a Directory that has both "Foo" and "foo" as children, but the Action may be rejected by the remote system upon execution. * The files, directories and symlinks in the directory must each be sorted in lexicographical order by path. The path strings must be sorted by code point, equivalently, by UTF-8 bytes. * The NodeProperties of files, directories, and symlinks must be sorted in lexicographical order by property name. A `Directory` that obeys the restrictions is said to be in canonical form. As an example, the following could be used for a file named `bar` and a directory named `foo` with an executable file named `baz` (hashes shortened for readability): ```json // (Directory proto) { files: [ { name: "bar", digest: { hash: "4a73bc9d03...", size: 65534 }, node_properties: [ { "name": "MTime", "value": "2017-01-15T01:30:15.01Z" } ] } ], directories: [ { name: "foo", digest: { hash: "4cf2eda940...", size: 43 } } ] } // (Directory proto with hash "4cf2eda940..." and size 43) { files: [ { name: "baz", digest: { hash: "b2c941073e...", size: 1294, }, is_executable: true } ] } ```
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2Directory
	{
		
		/// <summary>
		/// The subdirectories in the directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="directories")]
		public BuildBazelRemoteExecutionV2DirectoryNode[] Directories { get; set; }
		
		/// <summary>
		/// The files in the directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="files")]
		public BuildBazelRemoteExecutionV2FileNode[] Files { get; set; }
		
		/// <summary>
		/// Node properties for FileNodes, DirectoryNodes, and SymlinkNodes. The server is responsible for specifying the properties that it accepts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeProperties")]
		public BuildBazelRemoteExecutionV2NodeProperties NodeProperties { get; set; }
		
		/// <summary>
		/// The symlinks in the directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="symlinks")]
		public BuildBazelRemoteExecutionV2SymlinkNode[] Symlinks { get; set; }
	}
	
	/// <summary>
	/// A `DirectoryNode` represents a child of a Directory which is itself a `Directory` and its associated metadata.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2DirectoryNode
	{
		
		/// <summary>
		/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public BuildBazelRemoteExecutionV2Digest Digest { get; set; }
		
		/// <summary>
		/// The name of the directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// A `FileNode` represents a single file and associated metadata.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2FileNode
	{
		
		/// <summary>
		/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public BuildBazelRemoteExecutionV2Digest Digest { get; set; }
		
		/// <summary>
		/// True if file is executable, false otherwise.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isExecutable")]
		public System.Nullable<System.Boolean> IsExecutable { get; set; }
		
		/// <summary>
		/// The name of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Node properties for FileNodes, DirectoryNodes, and SymlinkNodes. The server is responsible for specifying the properties that it accepts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeProperties")]
		public BuildBazelRemoteExecutionV2NodeProperties NodeProperties { get; set; }
	}
	
	/// <summary>
	/// A `SymlinkNode` represents a symbolic link.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2SymlinkNode
	{
		
		/// <summary>
		/// The name of the symlink.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Node properties for FileNodes, DirectoryNodes, and SymlinkNodes. The server is responsible for specifying the properties that it accepts.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nodeProperties")]
		public BuildBazelRemoteExecutionV2NodeProperties NodeProperties { get; set; }
		
		/// <summary>
		/// The target path of the symlink. The path separator is a forward slash `/`. The target path can be relative to the parent directory of the symlink or it can be an absolute path starting with `/`. Support for absolute paths can be checked using the Capabilities API. `..` components are allowed anywhere in the target path as logical canonicalization may lead to different behavior in the presence of directory symlinks (e.g. `foo/../bar` may not be the same as `bar`). To reduce potential cache misses, canonicalization is still recommended where this is possible without impacting correctness.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="target")]
		public string Target { get; set; }
	}
	
	/// <summary>
	/// Metadata about an ongoing execution, which will be contained in the metadata field of the Operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2ExecuteOperationMetadata
	{
		
		/// <summary>
		/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionDigest")]
		public BuildBazelRemoteExecutionV2Digest ActionDigest { get; set; }
		
		/// <summary>
		/// ExecutedActionMetadata contains details about a completed execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partialExecutionMetadata")]
		public BuildBazelRemoteExecutionV2ExecutedActionMetadata PartialExecutionMetadata { get; set; }
		
		/// <summary>
		/// The current stage of execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stage")]
		public System.Nullable<BuildBazelRemoteExecutionV2ExecuteOperationMetadataStage> Stage { get; set; }
		
		/// <summary>
		/// If set, the client can use this resource name with ByteStream.Read to stream the standard error from the endpoint hosting streamed responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stderrStreamName")]
		public string StderrStreamName { get; set; }
		
		/// <summary>
		/// If set, the client can use this resource name with ByteStream.Read to stream the standard output from the endpoint hosting streamed responses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stdoutStreamName")]
		public string StdoutStreamName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum BuildBazelRemoteExecutionV2ExecuteOperationMetadataStage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CACHE_CHECK = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		QUEUED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXECUTING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETED = 4,
	}
	
	/// <summary>
	/// The response message for Execution.Execute, which will be contained in the response field of the Operation.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2ExecuteResponse
	{
		
		/// <summary>
		/// True if the result was served from cache, false if it was executed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cachedResult")]
		public System.Nullable<System.Boolean> CachedResult { get; set; }
		
		/// <summary>
		/// Freeform informational message with details on the execution of the action that may be displayed to the user upon failure or when requested explicitly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// An ActionResult represents the result of an Action being run. It is advised that at least one field (for example `ActionResult.execution_metadata.Worker`) have a non-default value, to ensure that the serialized value is non-empty, which can then be used as a basic data sanity check.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public BuildBazelRemoteExecutionV2ActionResult Result { get; set; }
		
		/// <summary>
		/// An optional list of additional log outputs the server wishes to provide. A server can use this to return execution-specific logs however it wishes. This is intended primarily to make it easier for users to debug issues that may be outside of the actual job execution, such as by identifying the worker executing the action or by providing logs from the worker's setup phase. The keys SHOULD be human readable so that a client can display them to a user.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverLogs")]
		public System.Collections.Generic.Dictionary<string, BuildBazelRemoteExecutionV2LogFile> ServerLogs { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GoogleRpcStatus Status { get; set; }
	}
	
	/// <summary>
	/// A `LogFile` is a log stored in the CAS.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2LogFile
	{
		
		/// <summary>
		/// A content digest. A digest for a given blob consists of the size of the blob and its hash. The hash algorithm to use is defined by the server. The size is considered to be an integral part of the digest and cannot be separated. That is, even if the `hash` field is correctly specified but `size_bytes` is not, the server MUST reject the request. The reason for including the size in the digest is as follows: in a great many cases, the server needs to know the size of the blob it is about to work with prior to starting an operation with it, such as flattening Merkle tree structures or streaming it to a worker. Technically, the server could implement a separate metadata store, but this results in a significantly more complicated implementation as opposed to having the client specify the size up-front (or storing the size along with the digest in every message where digests are embedded). This does mean that the API leaks some implementation details of (what we consider to be) a reasonable server implementation, but we consider this to be a worthwhile tradeoff. When a `Digest` is used to refer to a proto message, it always refers to the message in binary encoded form. To ensure consistent hashing, clients and servers MUST ensure that they serialize messages according to the following rules, even if there are alternate valid encodings for the same message: * Fields are serialized in tag order. * There are no unknown fields. * There are no duplicate fields. * Fields are serialized according to the default semantics for their type. Most protocol buffer implementations will always follow these rules when serializing, but care should be taken to avoid shortcuts. For instance, concatenating two messages to merge them may produce duplicate fields.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public BuildBazelRemoteExecutionV2Digest Digest { get; set; }
		
		/// <summary>
		/// This is a hint as to the purpose of the log, and is set to true if the log is human-readable text that can be usefully displayed to a user, and false otherwise. For instance, if a command-line client wishes to print the server logs to the terminal for a failed action, this allows it to avoid displaying a binary file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="humanReadable")]
		public System.Nullable<System.Boolean> HumanReadable { get; set; }
	}
	
	/// <summary>
	/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleRpcStatus
	{
		
		/// <summary>
		/// The status code, which should be an enum value of google.rpc.Code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<System.Int32> Code { get; set; }
		
		/// <summary>
		/// A list of messages that carry the error details. There is a common set of message types for APIs to use.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="details")]
		public string[] Details { get; set; }
		
		/// <summary>
		/// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	/// <summary>
	/// An optional Metadata to attach to any RPC request to tell the server about an external context of the request. The server may use this for logging or other purposes. To use it, the client attaches the header to the call using the canonical proto serialization: * name: `build.bazel.remote.execution.v2.requestmetadata-bin` * contents: the base64 encoded binary `RequestMetadata` message. Note: the gRPC library serializes binary headers encoded in base64 by default (https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#requests). Therefore, if the gRPC library is used to pass/retrieve this metadata, the user may ignore the base64 encoding and assume it is simply serialized as a binary message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2RequestMetadata
	{
		
		/// <summary>
		/// An identifier that ties multiple requests to the same action. For example, multiple requests to the CAS, Action Cache, and Execution API are used in order to compile foo.cc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionId")]
		public string ActionId { get; set; }
		
		/// <summary>
		/// A brief description of the kind of action, for example, CppCompile or GoLink. There is no standard agreed set of values for this, and they are expected to vary between different client tools.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionMnemonic")]
		public string ActionMnemonic { get; set; }
		
		/// <summary>
		/// An identifier for the configuration in which the target was built, e.g. for differentiating building host tools or different target platforms. There is no expectation that this value will have any particular structure, or equality across invocations, though some client tools may offer these guarantees.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configurationId")]
		public string ConfigurationId { get; set; }
		
		/// <summary>
		/// An identifier to tie multiple tool invocations together. For example, runs of foo_test, bar_test and baz_test on a post-submit of a given patch.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="correlatedInvocationsId")]
		public string CorrelatedInvocationsId { get; set; }
		
		/// <summary>
		/// An identifier for the target which produced this action. No guarantees are made around how many actions may relate to a single target.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetId")]
		public string TargetId { get; set; }
		
		/// <summary>
		/// Details for the tool used to call the API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toolDetails")]
		public BuildBazelRemoteExecutionV2ToolDetails ToolDetails { get; set; }
		
		/// <summary>
		/// An identifier that ties multiple actions together to a final result. For example, multiple actions are required to build and run foo_test.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toolInvocationId")]
		public string ToolInvocationId { get; set; }
	}
	
	/// <summary>
	/// Details for the tool used to call the API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2ToolDetails
	{
		
		/// <summary>
		/// Name of the tool, e.g. bazel.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toolName")]
		public string ToolName { get; set; }
		
		/// <summary>
		/// Version of the tool used for the request, e.g. 5.0.3.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="toolVersion")]
		public string ToolVersion { get; set; }
	}
	
	/// <summary>
	/// A `Tree` contains all the Directory protos in a single directory Merkle tree, compressed into one message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class BuildBazelRemoteExecutionV2Tree
	{
		
		/// <summary>
		/// All the child directories: the directories referred to by the root and, recursively, all its children. In order to reconstruct the directory tree, the client must take the digests of each of the child directories and then build up a tree starting from the `root`. Servers SHOULD ensure that these are ordered consistently such that two actions producing equivalent output directories on the same server implementation also produce Tree messages with matching digests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="children")]
		public BuildBazelRemoteExecutionV2Directory[] Children { get; set; }
		
		/// <summary>
		/// A `Directory` represents a directory node in a file tree, containing zero or more children FileNodes, DirectoryNodes and SymlinkNodes. Each `Node` contains its name in the directory, either the digest of its content (either a file blob or a `Directory` proto) or a symlink target, as well as possibly some metadata about the file or directory. In order to ensure that two equivalent directory trees hash to the same value, the following restrictions MUST be obeyed when constructing a a `Directory`: * Every child in the directory must have a path of exactly one segment. Multiple levels of directory hierarchy may not be collapsed. * Each child in the directory must have a unique path segment (file name). Note that while the API itself is case-sensitive, the environment where the Action is executed may or may not be case-sensitive. That is, it is legal to call the API with a Directory that has both "Foo" and "foo" as children, but the Action may be rejected by the remote system upon execution. * The files, directories and symlinks in the directory must each be sorted in lexicographical order by path. The path strings must be sorted by code point, equivalently, by UTF-8 bytes. * The NodeProperties of files, directories, and symlinks must be sorted in lexicographical order by property name. A `Directory` that obeys the restrictions is said to be in canonical form. As an example, the following could be used for a file named `bar` and a directory named `foo` with an executable file named `baz` (hashes shortened for readability): ```json // (Directory proto) { files: [ { name: "bar", digest: { hash: "4a73bc9d03...", size: 65534 }, node_properties: [ { "name": "MTime", "value": "2017-01-15T01:30:15.01Z" } ] } ], directories: [ { name: "foo", digest: { hash: "4cf2eda940...", size: 43 } } ] } // (Directory proto with hash "4cf2eda940..." and size 43) { files: [ { name: "baz", digest: { hash: "b2c941073e...", size: 1294, }, is_executable: true } ] } ```
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="root")]
		public BuildBazelRemoteExecutionV2Directory Root { get; set; }
	}
	
	/// <summary>
	/// CommandDuration contains the various duration metrics tracked when a bot performs a command.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildbotCommandDurations
	{
		
		/// <summary>
		/// The time spent to release the CAS blobs used by the task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="casRelease")]
		public string CasRelease { get; set; }
		
		/// <summary>
		/// The time spent waiting for Container Manager to assign an asynchronous container for execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cmWaitForAssignment")]
		public string CmWaitForAssignment { get; set; }
		
		/// <summary>
		/// The time spent preparing the command to be run in a Docker container (includes pulling the Docker image, if necessary).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerPrep")]
		public string DockerPrep { get; set; }
		
		/// <summary>
		/// The timestamp when docker preparation begins.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerPrepStartTime")]
		public string DockerPrepStartTime { get; set; }
		
		/// <summary>
		/// The time spent downloading the input files and constructing the working directory.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="download")]
		public string Download { get; set; }
		
		/// <summary>
		/// The timestamp when downloading the input files begins.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="downloadStartTime")]
		public string DownloadStartTime { get; set; }
		
		/// <summary>
		/// The timestamp when execution begins.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execStartTime")]
		public string ExecStartTime { get; set; }
		
		/// <summary>
		/// The time spent executing the command (i.e., doing useful work).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execution")]
		public string Execution { get; set; }
		
		/// <summary>
		/// The timestamp when preparation is done and bot starts downloading files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isoPrepDone")]
		public string IsoPrepDone { get; set; }
		
		/// <summary>
		/// The time spent completing the command, in total.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overall")]
		public string Overall { get; set; }
		
		/// <summary>
		/// The time spent uploading the stderr logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stderr")]
		public string Stderr { get; set; }
		
		/// <summary>
		/// The time spent uploading the stdout logs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stdout")]
		public string Stdout { get; set; }
		
		/// <summary>
		/// The time spent uploading the output files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upload")]
		public string Upload { get; set; }
		
		/// <summary>
		/// The timestamp when uploading the output files begins.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="uploadStartTime")]
		public string UploadStartTime { get; set; }
	}
	
	/// <summary>
	/// CommandEvents contains counters for the number of warnings and errors that occurred during the execution of a command.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildbotCommandEvents
	{
		
		/// <summary>
		/// Indicates if and how Container Manager is being used for task execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cmUsage")]
		public System.Nullable<GoogleDevtoolsRemotebuildbotCommandEventsCmUsage> CmUsage { get; set; }
		
		/// <summary>
		/// Indicates whether we are using a cached Docker image (true) or had to pull the Docker image (false) for this command.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerCacheHit")]
		public System.Nullable<System.Boolean> DockerCacheHit { get; set; }
		
		/// <summary>
		/// Docker Image name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerImageName")]
		public string DockerImageName { get; set; }
		
		/// <summary>
		/// The input cache miss rate as a fraction of the total size of input files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputCacheMissBytes")]
		public System.Nullable<System.Single> InputCacheMissBytes { get; set; }
		
		/// <summary>
		/// The input cache miss rate as a fraction of the number of input files.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputCacheMissFiles")]
		public System.Nullable<System.Single> InputCacheMissFiles { get; set; }
		
		/// <summary>
		/// The number of errors reported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numErrors")]
		public string NumErrors { get; set; }
		
		/// <summary>
		/// The number of warnings reported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numWarnings")]
		public string NumWarnings { get; set; }
		
		/// <summary>
		/// Indicates whether output files and/or output directories were found relative to the execution root or to the user provided work directory or both or none.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputLocation")]
		public System.Nullable<GoogleDevtoolsRemotebuildbotCommandEventsOutputLocation> OutputLocation { get; set; }
		
		/// <summary>
		/// Indicates whether an asynchronous container was used for execution.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="usedAsyncContainer")]
		public System.Nullable<System.Boolean> UsedAsyncContainer { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildbotCommandEventsCmUsage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONFIG_NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONFIG_MATCH = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CONFIG_MISMATCH = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildbotCommandEventsOutputLocation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCATION_UNDEFINED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCATION_NONE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCATION_EXEC_ROOT_RELATIVE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCATION_WORKING_DIR_RELATIVE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCATION_EXEC_ROOT_AND_WORKING_DIR_RELATIVE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCATION_EXEC_ROOT_RELATIVE_OUTPUT_OUTSIDE_WORKING_DIR = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCATION_EXEC_ROOT_AND_WORKING_DIR_RELATIVE_OUTPUT_OUTSIDE_WORKING_DIR = 6,
	}
	
	/// <summary>
	/// The internal status of the command result.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildbotCommandStatus
	{
		
		/// <summary>
		/// The status code.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public System.Nullable<GoogleDevtoolsRemotebuildbotCommandStatusCode> Code { get; set; }
		
		/// <summary>
		/// The error message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildbotCommandStatusCode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OK = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INVALID_ARGUMENT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DEADLINE_EXCEEDED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NOT_FOUND = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PERMISSION_DENIED = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INTERNAL = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ABORTED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FAILED_PRECONDITION = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CLEANUP_ERROR = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOWNLOAD_INPUTS_ERROR = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNKNOWN = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPLOAD_OUTPUTS_ERROR = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPLOAD_OUTPUTS_BYTES_LIMIT_EXCEEDED = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_LOGIN_ERROR = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_IMAGE_PULL_ERROR = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_IMAGE_EXIST_ERROR = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DUPLICATE_INPUTS = 16,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_IMAGE_PERMISSION_DENIED = 17,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_IMAGE_NOT_FOUND = 18,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WORKING_DIR_NOT_FOUND = 19,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WORKING_DIR_NOT_IN_BASE_DIR = 20,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_UNAVAILABLE = 21,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NO_CUDA_CAPABLE_DEVICE = 22,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REMOTE_CAS_DOWNLOAD_ERROR = 23,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REMOTE_CAS_UPLOAD_ERROR = 24,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL_CASPROXY_NOT_RUNNING = 25,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_CREATE_CONTAINER_ERROR = 26,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_INVALID_ULIMIT = 27,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_UNKNOWN_RUNTIME = 28,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_UNKNOWN_CAPABILITY = 29,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_UNKNOWN_ERROR = 30,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_CREATE_COMPUTE_SYSTEM_ERROR = 31,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_PREPARELAYER_ERROR = 32,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_INCOMPATIBLE_OS_ERROR = 33,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_CREATE_RUNTIME_FILE_NOT_FOUND = 34,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_CREATE_RUNTIME_PERMISSION_DENIED = 35,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_CREATE_PROCESS_FILE_NOT_FOUND = 36,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_CREATE_COMPUTE_SYSTEM_INCORRECT_PARAMETER_ERROR = 37,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_TOO_MANY_SYMBOLIC_LINK_LEVELS = 38,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL_CONTAINER_MANAGER_NOT_RUNNING = 39,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_IMAGE_VPCSC_PERMISSION_DENIED = 40,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WORKING_DIR_NOT_RELATIVE = 41,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_MISSING_CONTAINER = 42,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_MISSING_BLOB_IN_IMAGE = 43,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_INVALID_VOLUME = 44,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_CREATE_RUNTIME_CANNOT_MOUNT_TO_PROC = 45,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_START_RUNTIME_FILE_NOT_FOUND = 46,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_CREATE_INVALID_LAYERCHAIN_JSON = 47,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INCOMPATIBLE_CUDA_VERSION = 48,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LOCAL_WORKER_MANAGER_NOT_RUNNING = 49,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DOCKER_START_RUNTIME_FILE_FORMAT_ERROR = 50,
	}
	
	/// <summary>
	/// ResourceUsage is the system resource usage of the host machine.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildbotResourceUsage
	{
		
		[System.Runtime.Serialization.DataMember(Name="botState")]
		public System.Nullable<GoogleDevtoolsRemotebuildbotResourceUsageBotState> BotState { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cpuUsedPercent")]
		public System.Nullable<System.Double> CpuUsedPercent { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="diskUsage")]
		public GoogleDevtoolsRemotebuildbotResourceUsageStat DiskUsage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="memoryUsage")]
		public GoogleDevtoolsRemotebuildbotResourceUsageStat MemoryUsage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalDiskIoStats")]
		public GoogleDevtoolsRemotebuildbotResourceUsageIOStats TotalDiskIoStats { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildbotResourceUsageBotState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		IDLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BUSY = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildbotResourceUsageStat
	{
		
		[System.Runtime.Serialization.DataMember(Name="total")]
		public string Total { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="used")]
		public string Used { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildbotResourceUsageIOStats
	{
		
		[System.Runtime.Serialization.DataMember(Name="readBytesCount")]
		public string ReadBytesCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="readCount")]
		public string ReadCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="readTimeMs")]
		public string ReadTimeMs { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="writeBytesCount")]
		public string WriteBytesCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="writeCount")]
		public string WriteCount { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="writeTimeMs")]
		public string WriteTimeMs { get; set; }
	}
	
	/// <summary>
	/// AcceleratorConfig defines the accelerator cards to attach to the VM.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaAcceleratorConfig
	{
		
		/// <summary>
		/// The number of guest accelerator cards exposed to each VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceleratorCount")]
		public string AcceleratorCount { get; set; }
		
		/// <summary>
		/// The type of accelerator to attach to each VM, e.g. "nvidia-tesla-k80" for nVidia Tesla K80.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="acceleratorType")]
		public string AcceleratorType { get; set; }
	}
	
	/// <summary>
	/// Autoscale defines the autoscaling policy of a worker pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaAutoscale
	{
		
		/// <summary>
		/// Optional. The maximal number of workers. Must be equal to or greater than min_size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxSize")]
		public string MaxSize { get; set; }
		
		/// <summary>
		/// Optional. The minimum number of idle workers the autoscaler will aim to have in the pool at all times that are immediately available to accept a surge in build traffic. The pool size will still be constrained by min_size and max_size.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minIdleWorkers")]
		public string MinIdleWorkers { get; set; }
		
		/// <summary>
		/// Optional. The minimal number of workers. Must be greater than 0.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minSize")]
		public string MinSize { get; set; }
	}
	
	/// <summary>
	/// The request used for `CreateInstance`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaCreateInstanceRequest
	{
		
		/// <summary>
		/// Instance conceptually encapsulates all Remote Build Execution resources for remote builds. An instance consists of storage and compute resources (for example, `ContentAddressableStorage`, `ActionCache`, `WorkerPools`) used for running remote builds. All Remote Build Execution API calls are scoped to an instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaInstance Instance { get; set; }
		
		/// <summary>
		/// Required. ID of the created instance. A valid `instance_id` must: be 6-50 characters long, contain only lowercase letters, digits, hyphens and underscores, start with a lowercase letter, and end with a lowercase letter or a digit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instanceId")]
		public string InstanceId { get; set; }
		
		/// <summary>
		/// Required. Resource name of the project containing the instance. Format: `projects/[PROJECT_ID]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public string Parent { get; set; }
	}
	
	/// <summary>
	/// Instance conceptually encapsulates all Remote Build Execution resources for remote builds. An instance consists of storage and compute resources (for example, `ContentAddressableStorage`, `ActionCache`, `WorkerPools`) used for running remote builds. All Remote Build Execution API calls are scoped to an instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaInstance
	{
		
		/// <summary>
		/// FeaturePolicy defines features allowed to be used on RBE instances, as well as instance-wide behavior changes that take effect without opt-in or opt-out at usage time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="featurePolicy")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicy FeaturePolicy { get; set; }
		
		/// <summary>
		/// The location is a GCP region. Currently only `us-central1` is supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="location")]
		public string Location { get; set; }
		
		/// <summary>
		/// Output only. Whether stack driver logging is enabled for the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loggingEnabled")]
		public System.Nullable<System.Boolean> LoggingEnabled { get; set; }
		
		/// <summary>
		/// Output only. Instance resource name formatted as: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]`. Name should not be populated when creating an instance since it is provided in the `instance_id` field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Defines configurations for an instance's scheduler notifications, where a target Pub/Sub topic will be notified whenever a task (e.g. an action or reservation) completes on this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedulerNotificationConfig")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaSchedulerNotificationConfig SchedulerNotificationConfig { get; set; }
		
		/// <summary>
		/// Output only. State of the instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<GoogleDevtoolsRemotebuildexecutionAdminV1alphaInstanceState> State { get; set; }
	}
	
	/// <summary>
	/// FeaturePolicy defines features allowed to be used on RBE instances, as well as instance-wide behavior changes that take effect without opt-in or opt-out at usage time.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicy
	{
		
		/// <summary>
		/// Defines the hermeticity policy for actions on this instance. DO NOT USE: Experimental / unlaunched feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionHermeticity")]
		public System.Nullable<GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyActionHermeticity> ActionHermeticity { get; set; }
		
		/// <summary>
		/// Defines the isolation policy for actions on this instance. DO NOT USE: Experimental / unlaunched feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="actionIsolation")]
		public System.Nullable<GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyActionIsolation> ActionIsolation { get; set; }
		
		/// <summary>
		/// Defines whether a feature can be used or what values are accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="containerImageSources")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature ContainerImageSources { get; set; }
		
		/// <summary>
		/// Defines whether a feature can be used or what values are accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerAddCapabilities")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature DockerAddCapabilities { get; set; }
		
		/// <summary>
		/// Defines whether a feature can be used or what values are accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerChrootPath")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature DockerChrootPath { get; set; }
		
		/// <summary>
		/// Defines whether a feature can be used or what values are accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerNetwork")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature DockerNetwork { get; set; }
		
		/// <summary>
		/// Defines whether a feature can be used or what values are accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerPrivileged")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature DockerPrivileged { get; set; }
		
		/// <summary>
		/// Defines whether a feature can be used or what values are accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerRunAsContainerProvidedUser")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature DockerRunAsContainerProvidedUser { get; set; }
		
		/// <summary>
		/// Defines whether a feature can be used or what values are accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerRunAsRoot")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature DockerRunAsRoot { get; set; }
		
		/// <summary>
		/// Defines whether a feature can be used or what values are accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerRuntime")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature DockerRuntime { get; set; }
		
		/// <summary>
		/// Defines whether a feature can be used or what values are accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerSiblingContainers")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature DockerSiblingContainers { get; set; }
		
		/// <summary>
		/// Defines whether a feature can be used or what values are accepted.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerUlimits")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature DockerUlimits { get; set; }
		
		/// <summary>
		/// Defines how Linux actions are allowed to execute. DO NOT USE: Experimental / unlaunched feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linuxExecution")]
		public System.Nullable<GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyLinuxExecution> LinuxExecution { get; set; }
		
		/// <summary>
		/// linux_isolation allows overriding the docker runtime used for containers started on Linux.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="linuxIsolation")]
		public System.Nullable<GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyLinuxIsolation> LinuxIsolation { get; set; }
		
		/// <summary>
		/// Defines how Windows actions are allowed to execute. DO NOT USE: Experimental / unlaunched feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="macExecution")]
		public System.Nullable<GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyMacExecution> MacExecution { get; set; }
		
		/// <summary>
		/// Whether to verify CreateBotSession and UpdateBotSession from the bot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmVerification")]
		public System.Nullable<GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyVmVerification> VmVerification { get; set; }
		
		/// <summary>
		/// Defines how Windows actions are allowed to execute. DO NOT USE: Experimental / unlaunched feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="windowsExecution")]
		public System.Nullable<GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyWindowsExecution> WindowsExecution { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyActionHermeticity
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTION_HERMETICITY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTION_HERMETICITY_OFF = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTION_HERMETICITY_ENFORCED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTION_HERMETICITY_BEST_EFFORT = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyActionIsolation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTION_ISOLATION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTION_ISOLATION_OFF = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ACTION_ISOLATION_ENFORCED = 2,
	}
	
	/// <summary>
	/// Defines whether a feature can be used or what values are accepted.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeature
	{
		
		/// <summary>
		/// A list of acceptable values. Only effective when the policy is `RESTRICTED`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="allowedValues")]
		public string[] AllowedValues { get; set; }
		
		/// <summary>
		/// The policy of the feature.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public System.Nullable<GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeaturePolicy> Policy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyFeaturePolicy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		POLICY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ALLOWED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		FORBIDDEN = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RESTRICTED = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyLinuxExecution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINUX_EXECUTION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINUX_EXECUTION_FORBIDDEN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINUX_EXECUTION_UNRESTRICTED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINUX_EXECUTION_HARDENED_GVISOR = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINUX_EXECUTION_HARDENED_GVISOR_OR_TERMINAL = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyLinuxIsolation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		LINUX_ISOLATION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		GVISOR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		OFF = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyMacExecution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAC_EXECUTION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		MAC_EXECUTION_FORBIDDEN = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyVmVerification
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VM_VERIFICATION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VM_VERIFICATION_GCP_TOKEN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		VM_VERIFICATION_OFF = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildexecutionAdminV1alphaFeaturePolicyWindowsExecution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WINDOWS_EXECUTION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WINDOWS_EXECUTION_FORBIDDEN = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WINDOWS_EXECUTION_UNRESTRICTED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		WINDOWS_EXECUTION_TERMINAL = 3,
	}
	
	/// <summary>
	/// Defines configurations for an instance's scheduler notifications, where a target Pub/Sub topic will be notified whenever a task (e.g. an action or reservation) completes on this instance.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaSchedulerNotificationConfig
	{
		
		/// <summary>
		/// The Pub/Sub topic resource name to issue notifications to. Note that the topic does not need to be owned by the same project as this instance. Format: `projects//topics/`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="topic")]
		public string Topic { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildexecutionAdminV1alphaInstanceState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 3,
	}
	
	/// <summary>
	/// The request used for `CreateWorkerPool`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaCreateWorkerPoolRequest
	{
		
		/// <summary>
		/// Resource name of the instance in which to create the new worker pool. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public string Parent { get; set; }
		
		/// <summary>
		/// ID of the created worker pool. A valid pool ID must: be 6-50 characters long, contain only lowercase letters, digits, hyphens and underscores, start with a lowercase letter, and end with a lowercase letter or a digit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="poolId")]
		public string PoolId { get; set; }
		
		/// <summary>
		/// A worker pool resource in the Remote Build Execution API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workerPool")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerPool WorkerPool { get; set; }
	}
	
	/// <summary>
	/// A worker pool resource in the Remote Build Execution API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerPool
	{
		
		/// <summary>
		/// Autoscale defines the autoscaling policy of a worker pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="autoscale")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaAutoscale Autoscale { get; set; }
		
		/// <summary>
		/// Channel specifies the release channel of the pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="channel")]
		public string Channel { get; set; }
		
		/// <summary>
		/// HostOS specifies the OS version of the image for the worker VMs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hostOs")]
		public string HostOs { get; set; }
		
		/// <summary>
		/// WorkerPool resource name formatted as: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]/workerpools/[POOL_ID]`. name should not be populated when creating a worker pool since it is provided in the `poolId` field.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Output only. State of the worker pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public System.Nullable<GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerPoolState> State { get; set; }
		
		/// <summary>
		/// Defines the configuration to be used for creating workers in the worker pool.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workerConfig")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig WorkerConfig { get; set; }
		
		/// <summary>
		/// The desired number of workers in the worker pool. Must be a value between 0 and 15000.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workerCount")]
		public string WorkerCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerPoolState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		STATE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RUNNING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UPDATING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		DELETING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		INACTIVE = 5,
	}
	
	/// <summary>
	/// Defines the configuration to be used for creating workers in the worker pool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerConfig
	{
		
		/// <summary>
		/// AcceleratorConfig defines the accelerator cards to attach to the VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="accelerator")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaAcceleratorConfig Accelerator { get; set; }
		
		/// <summary>
		/// Disks defines the disks that would be attached to the workers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="attachedDisks")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisks AttachedDisks { get; set; }
		
		/// <summary>
		/// Required. Size of the disk attached to the worker, in GB. See https://cloud.google.com/compute/docs/disks/
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGb")]
		public string DiskSizeGb { get; set; }
		
		/// <summary>
		/// Required. Disk Type to use for the worker. See [Storage options](https://cloud.google.com/compute/docs/disks/#introduction). Currently only `pd-standard` and `pd-ssd` are supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskType")]
		public string DiskType { get; set; }
		
		/// <summary>
		/// Labels associated with the workers. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International letters are permitted. Label keys must start with a letter. Label values are optional. There can not be more than 64 labels per resource.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="labels")]
		public System.Collections.Generic.Dictionary<string, string> Labels { get; set; }
		
		/// <summary>
		/// Required. Machine type of the worker, such as `e2-standard-2`. See https://cloud.google.com/compute/docs/machine-types for a list of supported machine types. Note that `f1-micro` and `g1-small` are not yet supported.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="machineType")]
		public string MachineType { get; set; }
		
		/// <summary>
		/// The maximum number of actions a worker can execute concurrently.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="maxConcurrentActions")]
		public string MaxConcurrentActions { get; set; }
		
		/// <summary>
		/// Minimum CPU platform to use when creating the worker. See [CPU Platforms](https://cloud.google.com/compute/docs/cpu-platforms).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minCpuPlatform")]
		public string MinCpuPlatform { get; set; }
		
		/// <summary>
		/// Determines the type of network access granted to workers. Possible values: - "public": Workers can connect to the public internet. - "private": Workers can only connect to Google APIs and services. - "restricted-private": Workers can only connect to Google APIs that are reachable through `restricted.googleapis.com` (`199.36.153.4/30`).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="networkAccess")]
		public string NetworkAccess { get; set; }
		
		/// <summary>
		/// Determines whether the worker is reserved (equivalent to a Compute Engine on-demand VM and therefore won't be preempted). See [Preemptible VMs](https://cloud.google.com/preemptible-vms/) for more details.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reserved")]
		public System.Nullable<System.Boolean> Reserved { get; set; }
		
		/// <summary>
		/// The node type name to be used for sole-tenant nodes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="soleTenantNodeType")]
		public string SoleTenantNodeType { get; set; }
		
		/// <summary>
		/// The name of the image used by each VM.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="vmImage")]
		public string VmImage { get; set; }
		
		/// <summary>
		/// Optional. Zones in the region where the pool VMs should be. Leave empty for no restrictions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="zones")]
		public string[] Zones { get; set; }
	}
	
	/// <summary>
	/// Disks defines the disks that would be attached to the workers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisks
	{
		
		/// <summary>
		/// PersistentDisk specifies how to attach a persistent disk to the workers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dockerRootDisk")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisksPersistentDisk DockerRootDisk { get; set; }
		
		/// <summary>
		/// LocalSSD specifies how to attach local SSD to the workers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="localSsd")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisksLocalSSD LocalSsd { get; set; }
	}
	
	/// <summary>
	/// PersistentDisk specifies how to attach a persistent disk to the workers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisksPersistentDisk
	{
		
		/// <summary>
		/// Required. Size of the disk in GB.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskSizeGb")]
		public string DiskSizeGb { get; set; }
		
		/// <summary>
		/// Required. Type of disk attached (supported types are pd-standard and pd-ssd).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="diskType")]
		public string DiskType { get; set; }
		
		/// <summary>
		/// Required. VM image to use for the disk.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceImage")]
		public string SourceImage { get; set; }
	}
	
	/// <summary>
	/// LocalSSD specifies how to attach local SSD to the workers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaDisksLocalSSD
	{
		
		/// <summary>
		/// Optional. The number of Local SSDs to be attached.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="count")]
		public string Count { get; set; }
		
		/// <summary>
		/// Output only. The size of the local SSD in gb. Intended for informational purposes only.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeGb")]
		public string SizeGb { get; set; }
	}
	
	/// <summary>
	/// The request used for `DeleteInstance`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaDeleteInstanceRequest
	{
		
		/// <summary>
		/// Required. Name of the instance to delete. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The request used for DeleteWorkerPool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaDeleteWorkerPoolRequest
	{
		
		/// <summary>
		/// Name of the worker pool to delete. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]/workerpools/[POOL_ID]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The request used for `GetInstance`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaGetInstanceRequest
	{
		
		/// <summary>
		/// Required. Name of the instance to retrieve. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The request used for GetWorkerPool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaGetWorkerPoolRequest
	{
		
		/// <summary>
		/// Name of the worker pool to retrieve. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]/workerpools/[POOL_ID]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The request used for `ListInstances`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaListInstancesRequest
	{
		
		/// <summary>
		/// Required. Resource name of the project. Format: `projects/[PROJECT_ID]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public string Parent { get; set; }
	}
	
	/// <summary>
	/// The response used for `ListInstances`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaListInstancesResponse
	{
		
		/// <summary>
		/// The list of instances in a given project.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instances")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaInstance[] Instances { get; set; }
		
		/// <summary>
		/// Unreachable regions.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="unreachable")]
		public string[] Unreachable { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaListWorkerPoolsRequest
	{
		
		/// <summary>
		/// Optional. A filter expression that filters resources listed in the response. The expression must specify the field name, a comparison operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. String values are case-insensitive. The comparison operator must be either `:`, `=`, `!=`, `>`, `>=`, `<=` or `<`. The `:` operator can be used with string fields to match substrings. For non-string fields it is equivalent to the `=` operator. The `:*` comparison can be used to test whether a key has been defined. You can also filter on nested fields. To filter on multiple expressions, you can separate expression using `AND` and `OR` operators, using parentheses to specify precedence. If neither operator is specified, `AND` is assumed. Examples: Include only pools with more than 100 reserved workers: `(worker_count > 100) (worker_config.reserved = true)` Include only pools with a certain label or machines of the e2-standard family: `worker_config.labels.key1 : * OR worker_config.machine_type: e2-standard`
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="filter")]
		public string Filter { get; set; }
		
		/// <summary>
		/// Resource name of the instance. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parent")]
		public string Parent { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaListWorkerPoolsResponse
	{
		
		/// <summary>
		/// The list of worker pools in a given instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workerPools")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerPool[] WorkerPools { get; set; }
	}
	
	/// <summary>
	/// The request used for `TestNotifyInstance`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaTestNotifyInstanceRequest
	{
	}
	
	/// <summary>
	/// The request used for `UpdateInstance`.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaUpdateInstanceRequest
	{
		
		/// <summary>
		/// Instance conceptually encapsulates all Remote Build Execution resources for remote builds. An instance consists of storage and compute resources (for example, `ContentAddressableStorage`, `ActionCache`, `WorkerPools`) used for running remote builds. All Remote Build Execution API calls are scoped to an instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="instance")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaInstance Instance { get; set; }
		
		/// <summary>
		/// Deprecated, use instance.logging_enabled instead. Whether to enable Stackdriver logging for this instance.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="loggingEnabled")]
		public System.Nullable<System.Boolean> LoggingEnabled { get; set; }
		
		/// <summary>
		/// Deprecated, use instance.Name instead. Name of the instance to update. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The update mask applies to instance. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask If an empty update_mask is provided, only the non-default valued field in the worker pool field will be updated. Note that in order to update a field to the default value (zero, false, empty string) an explicit update_mask must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateMask")]
		public string UpdateMask { get; set; }
	}
	
	/// <summary>
	/// The request used for UpdateWorkerPool.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemotebuildexecutionAdminV1alphaUpdateWorkerPoolRequest
	{
		
		/// <summary>
		/// The update mask applies to worker_pool. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask If an empty update_mask is provided, only the non-default valued field in the worker pool field will be updated. Note that in order to update a field to the default value (zero, false, empty string) an explicit update_mask must be provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateMask")]
		public string UpdateMask { get; set; }
		
		/// <summary>
		/// A worker pool resource in the Remote Build Execution API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workerPool")]
		public GoogleDevtoolsRemotebuildexecutionAdminV1alphaWorkerPool WorkerPool { get; set; }
	}
	
	/// <summary>
	/// AdminTemp is a prelimiary set of administration tasks. It's called "Temp" because we do not yet know the best way to represent admin tasks; it's possible that this will be entirely replaced in later versions of this API. If this message proves to be sufficient, it will be renamed in the alpha or beta release of this API. This message (suitably marshalled into a protobuf.Any) can be used as the inline_assignment field in a lease; the lease assignment field should simply be `"admin"` in these cases. This message is heavily based on Swarming administration tasks from the LUCI project (http://github.com/luci/luci-py/appengine/swarming).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2AdminTemp
	{
		
		/// <summary>
		/// The argument to the admin action; see `Command` for semantics.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="arg")]
		public string Arg { get; set; }
		
		/// <summary>
		/// The admin action; see `Command` for legal values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="command")]
		public System.Nullable<GoogleDevtoolsRemoteworkersV1test2AdminTempCommand> Command { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum GoogleDevtoolsRemoteworkersV1test2AdminTempCommand
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOT_UPDATE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOT_RESTART = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		BOT_TERMINATE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HOST_RESTART = 4,
	}
	
	/// <summary>
	/// Describes a blob of binary content with its digest.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2Blob
	{
		
		/// <summary>
		/// The contents of the blob.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// The CommandTask and CommandResult messages assume the existence of a service that can serve blobs of content, identified by a hash and size known as a "digest." The method by which these blobs may be retrieved is not specified here, but a model implementation is in the Remote Execution API's "ContentAddressibleStorage" interface. In the context of the RWAPI, a Digest will virtually always refer to the contents of a file or a directory. The latter is represented by the byte-encoded Directory message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public GoogleDevtoolsRemoteworkersV1test2Digest Digest { get; set; }
	}
	
	/// <summary>
	/// The CommandTask and CommandResult messages assume the existence of a service that can serve blobs of content, identified by a hash and size known as a "digest." The method by which these blobs may be retrieved is not specified here, but a model implementation is in the Remote Execution API's "ContentAddressibleStorage" interface. In the context of the RWAPI, a Digest will virtually always refer to the contents of a file or a directory. The latter is represented by the byte-encoded Directory message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2Digest
	{
		
		/// <summary>
		/// A string-encoded hash (eg "1a2b3c", not the byte array [0x1a, 0x2b, 0x3c]) using an implementation-defined hash algorithm (eg SHA-256).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hash")]
		public string Hash { get; set; }
		
		/// <summary>
		/// The size of the contents. While this is not strictly required as part of an identifier (after all, any given hash will have exactly one canonical size), it's useful in almost all cases when one might want to send or retrieve blobs of content and is included here for this reason.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sizeBytes")]
		public string SizeBytes { get; set; }
	}
	
	/// <summary>
	/// DEPRECATED - use CommandResult instead. Describes the actual outputs from the task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2CommandOutputs
	{
		
		/// <summary>
		/// exit_code is only fully reliable if the status' code is OK. If the task exceeded its deadline or was cancelled, the process may still produce an exit code as it is cancelled, and this will be populated, but a successful (zero) is unlikely to be correct unless the status code is OK.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exitCode")]
		public System.Nullable<System.Int32> ExitCode { get; set; }
		
		/// <summary>
		/// The CommandTask and CommandResult messages assume the existence of a service that can serve blobs of content, identified by a hash and size known as a "digest." The method by which these blobs may be retrieved is not specified here, but a model implementation is in the Remote Execution API's "ContentAddressibleStorage" interface. In the context of the RWAPI, a Digest will virtually always refer to the contents of a file or a directory. The latter is represented by the byte-encoded Directory message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputs")]
		public GoogleDevtoolsRemoteworkersV1test2Digest Outputs { get; set; }
	}
	
	/// <summary>
	/// DEPRECATED - use CommandResult instead. Can be used as part of CompleteRequest.metadata, or are part of a more sophisticated message.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2CommandOverhead
	{
		
		/// <summary>
		/// The elapsed time between calling Accept and Complete. The server will also have its own idea of what this should be, but this excludes the overhead of the RPCs and the bot response time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// The amount of time *not* spent executing the command (ie uploading/downloading files).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overhead")]
		public string Overhead { get; set; }
	}
	
	/// <summary>
	/// All information about the execution of a command, suitable for providing as the Bots interface's `Lease.result` field.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2CommandResult
	{
		
		/// <summary>
		/// The elapsed time between calling Accept and Complete. The server will also have its own idea of what this should be, but this excludes the overhead of the RPCs and the bot response time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duration")]
		public string Duration { get; set; }
		
		/// <summary>
		/// The exit code of the process. An exit code of "0" should only be trusted if `status` has a code of OK (otherwise it may simply be unset).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="exitCode")]
		public System.Nullable<System.Int32> ExitCode { get; set; }
		
		/// <summary>
		/// Implementation-dependent metadata about the task. Both servers and bots may define messages which can be encoded here; bots are free to provide metadata in multiple formats, and servers are free to choose one or more of the values to process and ignore others. In particular, it is *not* considered an error for the bot to provide the server with a field that it doesn't know about.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string[] Metadata { get; set; }
		
		/// <summary>
		/// The CommandTask and CommandResult messages assume the existence of a service that can serve blobs of content, identified by a hash and size known as a "digest." The method by which these blobs may be retrieved is not specified here, but a model implementation is in the Remote Execution API's "ContentAddressibleStorage" interface. In the context of the RWAPI, a Digest will virtually always refer to the contents of a file or a directory. The latter is represented by the byte-encoded Directory message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outputs")]
		public GoogleDevtoolsRemoteworkersV1test2Digest Outputs { get; set; }
		
		/// <summary>
		/// The amount of time *not* spent executing the command (ie uploading/downloading files).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overhead")]
		public string Overhead { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public GoogleRpcStatus Status { get; set; }
	}
	
	/// <summary>
	/// Describes a shell-style task to execute, suitable for providing as the Bots interface's `Lease.payload` field.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2CommandTask
	{
		
		/// <summary>
		/// Describes the expected outputs of the command.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="expectedOutputs")]
		public GoogleDevtoolsRemoteworkersV1test2CommandTaskOutputs ExpectedOutputs { get; set; }
		
		/// <summary>
		/// Describes the inputs to a shell-style task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inputs")]
		public GoogleDevtoolsRemoteworkersV1test2CommandTaskInputs Inputs { get; set; }
		
		/// <summary>
		/// Describes the timeouts associated with this task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="timeouts")]
		public GoogleDevtoolsRemoteworkersV1test2CommandTaskTimeouts Timeouts { get; set; }
	}
	
	/// <summary>
	/// Describes the expected outputs of the command.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2CommandTaskOutputs
	{
		
		/// <summary>
		/// A list of expected directories, relative to the execution root. All paths MUST be delimited by forward slashes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="directories")]
		public string[] Directories { get; set; }
		
		/// <summary>
		/// A list of expected files, relative to the execution root. All paths MUST be delimited by forward slashes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="files")]
		public string[] Files { get; set; }
		
		/// <summary>
		/// The destination to which any stderr should be sent. The method by which the bot should send the stream contents to that destination is not defined in this API. As examples, the destination could be a file referenced in the `files` field in this message, or it could be a URI that must be written via the ByteStream API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stderrDestination")]
		public string StderrDestination { get; set; }
		
		/// <summary>
		/// The destination to which any stdout should be sent. The method by which the bot should send the stream contents to that destination is not defined in this API. As examples, the destination could be a file referenced in the `files` field in this message, or it could be a URI that must be written via the ByteStream API.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stdoutDestination")]
		public string StdoutDestination { get; set; }
	}
	
	/// <summary>
	/// Describes the inputs to a shell-style task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2CommandTaskInputs
	{
		
		/// <summary>
		/// The command itself to run (e.g., argv). This field should be passed directly to the underlying operating system, and so it must be sensible to that operating system. For example, on Windows, the first argument might be "C:\Windows\System32\ping.exe" - that is, using drive letters and backslashes. A command for a *nix system, on the other hand, would use forward slashes. All other fields in the RWAPI must consistently use forward slashes, since those fields may be interpretted by both the service and the bot.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="arguments")]
		public string[] Arguments { get; set; }
		
		/// <summary>
		/// All environment variables required by the task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="environmentVariables")]
		public GoogleDevtoolsRemoteworkersV1test2CommandTaskInputsEnvironmentVariable[] EnvironmentVariables { get; set; }
		
		/// <summary>
		/// The input filesystem to be set up prior to the task beginning. The contents should be a repeated set of FileMetadata messages though other formats are allowed if better for the implementation (eg, a LUCI-style .isolated file). This field is repeated since implementations might want to cache the metadata, in which case it may be useful to break up portions of the filesystem that change frequently (eg, specific input files) from those that don't (eg, standard header files).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="files")]
		public GoogleDevtoolsRemoteworkersV1test2Digest[] Files { get; set; }
		
		/// <summary>
		/// Inline contents for blobs expected to be needed by the bot to execute the task. For example, contents of entries in `files` or blobs that are indirectly referenced by an entry there. The bot should check against this list before downloading required task inputs to reduce the number of communications between itself and the remote CAS server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inlineBlobs")]
		public GoogleDevtoolsRemoteworkersV1test2Blob[] InlineBlobs { get; set; }
		
		/// <summary>
		/// Directory from which a command is executed. It is a relative directory with respect to the bot's working directory (i.e., "./"). If it is non-empty, then it must exist under "./". Otherwise, "./" will be used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="workingDirectory")]
		public string WorkingDirectory { get; set; }
	}
	
	/// <summary>
	/// An environment variable required by this task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2CommandTaskInputsEnvironmentVariable
	{
		
		/// <summary>
		/// The envvar name.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The envvar value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="value")]
		public string Value { get; set; }
	}
	
	/// <summary>
	/// Describes the timeouts associated with this task.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2CommandTaskTimeouts
	{
		
		/// <summary>
		/// This specifies the maximum time that the task can run, excluding the time required to download inputs or upload outputs. That is, the worker will terminate the task if it runs longer than this.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="execution")]
		public string Execution { get; set; }
		
		/// <summary>
		/// This specifies the maximum amount of time the task can be idle - that is, go without generating some output in either stdout or stderr. If the process is silent for more than the specified time, the worker will terminate the task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="idle")]
		public string Idle { get; set; }
		
		/// <summary>
		/// If the execution or IO timeouts are exceeded, the worker will try to gracefully terminate the task and return any existing logs. However, tasks may be hard-frozen in which case this process will fail. This timeout specifies how long to wait for a terminated task to shut down gracefully (e.g. via SIGTERM) before we bring down the hammer (e.g. SIGKILL on *nix, CTRL_BREAK_EVENT on Windows).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="shutdown")]
		public string Shutdown { get; set; }
	}
	
	/// <summary>
	/// The contents of a directory. Similar to the equivalent message in the Remote Execution API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2Directory
	{
		
		/// <summary>
		/// Any subdirectories
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="directories")]
		public GoogleDevtoolsRemoteworkersV1test2DirectoryMetadata[] Directories { get; set; }
		
		/// <summary>
		/// The files in this directory
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="files")]
		public GoogleDevtoolsRemoteworkersV1test2FileMetadata[] Files { get; set; }
	}
	
	/// <summary>
	/// The metadata for a directory. Similar to the equivalent message in the Remote Execution API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2DirectoryMetadata
	{
		
		/// <summary>
		/// The CommandTask and CommandResult messages assume the existence of a service that can serve blobs of content, identified by a hash and size known as a "digest." The method by which these blobs may be retrieved is not specified here, but a model implementation is in the Remote Execution API's "ContentAddressibleStorage" interface. In the context of the RWAPI, a Digest will virtually always refer to the contents of a file or a directory. The latter is represented by the byte-encoded Directory message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public GoogleDevtoolsRemoteworkersV1test2Digest Digest { get; set; }
		
		/// <summary>
		/// The path of the directory, as in FileMetadata.path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// The metadata for a file. Similar to the equivalent message in the Remote Execution API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleDevtoolsRemoteworkersV1test2FileMetadata
	{
		
		/// <summary>
		/// If the file is small enough, its contents may also or alternatively be listed here.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="contents")]
		public string Contents { get; set; }
		
		/// <summary>
		/// The CommandTask and CommandResult messages assume the existence of a service that can serve blobs of content, identified by a hash and size known as a "digest." The method by which these blobs may be retrieved is not specified here, but a model implementation is in the Remote Execution API's "ContentAddressibleStorage" interface. In the context of the RWAPI, a Digest will virtually always refer to the contents of a file or a directory. The latter is represented by the byte-encoded Directory message.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="digest")]
		public GoogleDevtoolsRemoteworkersV1test2Digest Digest { get; set; }
		
		/// <summary>
		/// Properties of the file
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isExecutable")]
		public System.Nullable<System.Boolean> IsExecutable { get; set; }
		
		/// <summary>
		/// The path of this file. If this message is part of the CommandOutputs.outputs fields, the path is relative to the execution root and must correspond to an entry in CommandTask.outputs.files. If this message is part of a Directory message, then the path is relative to the root of that directory. All paths MUST be delimited by forward slashes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
	}
	
	/// <summary>
	/// This resource represents a long-running operation that is the result of a network API call.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleLongrunningOperation
	{
		
		/// <summary>
		/// If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="done")]
		public System.Nullable<System.Boolean> Done { get; set; }
		
		/// <summary>
		/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="error")]
		public GoogleRpcStatus Error { get; set; }
		
		/// <summary>
		/// Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public System.Collections.Generic.Dictionary<string, object> Metadata { get; set; }
		
		/// <summary>
		/// The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The normal, successful response of the operation. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="response")]
		public System.Collections.Generic.Dictionary<string, object> Response { get; set; }
	}
	
	/// <summary>
	/// A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GoogleProtobufEmpty
	{
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Deletes the specified worker pool. Returns a long running operation, which contains a `google.protobuf.Empty` response on completion. While the long running operation is in progress, any call to `GetWorkerPool` returns a worker pool in state `DELETING`.
		/// Remotebuildexecution_projects_instances_workerpools_delete v1alpha/{name}
		/// </summary>
		/// <param name="name">Name of the worker pool to delete. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]/workerpools/[POOL_ID]`.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleLongrunningOperation> Remotebuildexecution_projects_instances_workerpools_deleteAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleLongrunningOperation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service.
		/// Remotebuildexecution_projects_operations_get v1alpha/{name}
		/// </summary>
		/// <param name="name">The name of the operation resource.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleLongrunningOperation> Remotebuildexecution_projects_operations_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleLongrunningOperation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Updates an existing worker pool with a specified size and/or configuration. Returns a long running operation, which contains a worker pool on completion. While the long running operation is in progress, any call to `GetWorkerPool` returns a worker pool in state `UPDATING`.
		/// Remotebuildexecution_projects_instances_workerpools_patch v1alpha/{name}
		/// </summary>
		/// <param name="name">WorkerPool resource name formatted as: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]/workerpools/[POOL_ID]`. name should not be populated when creating a worker pool since it is provided in the `poolId` field.</param>
		/// <param name="loggingEnabled">Deprecated, use instance.logging_enabled instead. Whether to enable Stackdriver logging for this instance.</param>
		/// <param name="name1">Deprecated, use instance.Name instead. Name of the instance to update. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]`.</param>
		/// <param name="updateMask">The update mask applies to instance. For the `FieldMask` definition, see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask If an empty update_mask is provided, only the non-default valued field in the worker pool field will be updated. Note that in order to update a field to the default value (zero, false, empty string) an explicit update_mask must be provided.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleLongrunningOperation> Remotebuildexecution_projects_instances_workerpools_patchAsync(string name, bool loggingEnabled, string name1, string updateMask, GoogleDevtoolsRemotebuildexecutionAdminV1alphaUpdateWorkerPoolRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (name==null? "" : System.Uri.EscapeDataString(name))+"&loggingEnabled="+loggingEnabled+"&name1=" + (name1==null? "" : System.Uri.EscapeDataString(name1))+"&updateMask=" + (updateMask==null? "" : System.Uri.EscapeDataString(updateMask));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleLongrunningOperation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Sends a test notification to the specified instance. Returns a `google.protobuf.Empty` on success.
		/// Remotebuildexecution_projects_instances_testNotify v1alpha/{name}:testNotify
		/// </summary>
		/// <param name="name">Name of the instance for which to send a test notification. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]`.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleProtobufEmpty> Remotebuildexecution_projects_instances_testNotifyAsync(string name, GoogleDevtoolsRemotebuildexecutionAdminV1alphaTestNotifyInstanceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (name==null? "" : System.Uri.EscapeDataString(name))+":testNotify";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleProtobufEmpty>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists instances in a project.
		/// Remotebuildexecution_projects_instances_list v1alpha/{parent}/instances
		/// </summary>
		/// <param name="parent">Required. Resource name of the project. Format: `projects/[PROJECT_ID]`.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleDevtoolsRemotebuildexecutionAdminV1alphaListInstancesResponse> Remotebuildexecution_projects_instances_listAsync(string parent, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/instances";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleDevtoolsRemotebuildexecutionAdminV1alphaListInstancesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new instance in the specified region. Returns a long running operation which contains an instance on completion. While the long running operation is in progress, any call to `GetInstance` returns an instance in state `CREATING`.
		/// Remotebuildexecution_projects_instances_create v1alpha/{parent}/instances
		/// </summary>
		/// <param name="parent">Required. Resource name of the project containing the instance. Format: `projects/[PROJECT_ID]`.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleLongrunningOperation> Remotebuildexecution_projects_instances_createAsync(string parent, GoogleDevtoolsRemotebuildexecutionAdminV1alphaCreateInstanceRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/instances";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleLongrunningOperation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Lists worker pools in an instance.
		/// Remotebuildexecution_projects_instances_workerpools_list v1alpha/{parent}/workerpools
		/// </summary>
		/// <param name="parent">Resource name of the instance. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]`.</param>
		/// <param name="filter">Optional. A filter expression that filters resources listed in the response. The expression must specify the field name, a comparison operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. String values are case-insensitive. The comparison operator must be either `:`, `=`, `!=`, `>`, `>=`, `<=` or `<`. The `:` operator can be used with string fields to match substrings. For non-string fields it is equivalent to the `=` operator. The `:*` comparison can be used to test whether a key has been defined. You can also filter on nested fields. To filter on multiple expressions, you can separate expression using `AND` and `OR` operators, using parentheses to specify precedence. If neither operator is specified, `AND` is assumed. Examples: Include only pools with more than 100 reserved workers: `(worker_count > 100) (worker_config.reserved = true)` Include only pools with a certain label or machines of the e2-standard family: `worker_config.labels.key1 : * OR worker_config.machine_type: e2-standard`</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleDevtoolsRemotebuildexecutionAdminV1alphaListWorkerPoolsResponse> Remotebuildexecution_projects_instances_workerpools_listAsync(string parent, string filter, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/workerpools&filter=" + (filter==null? "" : System.Uri.EscapeDataString(filter));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleDevtoolsRemotebuildexecutionAdminV1alphaListWorkerPoolsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a new worker pool with a specified size and configuration. Returns a long running operation which contains a worker pool on completion. While the long running operation is in progress, any call to `GetWorkerPool` returns a worker pool in state `CREATING`.
		/// Remotebuildexecution_projects_instances_workerpools_create v1alpha/{parent}/workerpools
		/// </summary>
		/// <param name="parent">Resource name of the instance in which to create the new worker pool. Format: `projects/[PROJECT_ID]/instances/[INSTANCE_ID]`.</param>
		/// <returns>Successful response</returns>
		public async Task<GoogleLongrunningOperation> Remotebuildexecution_projects_instances_workerpools_createAsync(string parent, GoogleDevtoolsRemotebuildexecutionAdminV1alphaCreateWorkerPoolRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1alpha/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/workerpools";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GoogleLongrunningOperation>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
