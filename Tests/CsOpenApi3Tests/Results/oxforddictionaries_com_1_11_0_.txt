//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ArrayOfRelatedEntriesElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// The identifier of the word
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// IANA language code specifying the language of the word
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CategorizedTextListElement
	{
		
		/// <summary>
		/// The identifier of the word
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// A note text
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The descriptive category of the text
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// cross references of a sense
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CrossReferencesListElement
	{
		
		/// <summary>
		/// The word id of cooccurrence
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The word of cooccurrence
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// The type of relation between the two words. Possible values are 'close match', 'related', 'see also', 'variant spelling', and 'abbreviation' in case of crossreferences, or 'pre', 'post' in case of collocates.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Entry
	{
		
		[System.Runtime.Serialization.DataMember(Name="etymologies")]
		public string[] Etymologies { get; set; }
		
		/// <summary>
		/// The different forms are correlated with meanings or functions which we text as 'features'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grammaticalFeatures")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public EntryGrammaticalFeatures[] EntryGrammaticalFeatures { get; set; }
		
		/// <summary>
		/// Identifies the homograph grouping. The last two digits identify different entries of the same homograph. The first one/two digits identify the homograph number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="homographNumber")]
		public string HomographNumber { get; set; }
		
		/// <summary>
		/// various types of notes that appear
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public CategorizedTextListElement[] Notes { get; set; }
		
		/// <summary>
		/// A list of possible pronunciations of a word
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pronunciations")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public EntryPronunciations[] EntryPronunciations { get; set; }
		
		/// <summary>
		/// Complete list of senses
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="senses")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public Sense[] Senses { get; set; }
		
		/// <summary>
		/// Various words that are used interchangeably depending on the context, e.g 'aluminium' and 'aluminum'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="variantForms")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public EntryVariantForms[] EntryVariantForms { get; set; }
	}
	
	public class EntryGrammaticalFeatures
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class EntryPronunciations
	{
		
		/// <summary>
		/// The URL of the sound file
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioFile")]
		public string AudioFile { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dialects")]
		public string[] Dialects { get; set; }
		
		/// <summary>
		/// The alphabetic system used to display the phonetic spelling
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phoneticNotation")]
		public string PhoneticNotation { get; set; }
		
		/// <summary>
		/// Phonetic spelling is the representation of vocal sounds which express pronunciations of words. It is a system of spelling in which each letter represents invariably the same spoken sound
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phoneticSpelling")]
		public string PhoneticSpelling { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
	}
	
	/// <summary>
	/// A lexical sense represents the lexical meaning of a lexical entry when interpreted as referring to the corresponding ontology element
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Sense
	{
		
		[System.Runtime.Serialization.DataMember(Name="crossReferenceMarkers")]
		public string[] CrossReferenceMarkers { get; set; }
		
		/// <summary>
		/// A reference to another word that is closely related, might provide additional information about the subject, has a variant spelling or is an abbreviated form of it.
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="crossReferences")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public CrossReferencesListElement[] CrossReferences { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="definitions")]
		public string[] Definitions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// A list of written or spoken rendering of examples of use of a word or text
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="examples")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public SenseExamples[] SenseExamples { get; set; }
		
		/// <summary>
		/// The id of the sense that is required for the delete procedure
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// various types of notes that appear
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public CategorizedTextListElement[] Notes { get; set; }
		
		/// <summary>
		/// A list of possible pronunciations of a word
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pronunciations")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public SensePronunciations[] SensePronunciations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="short_definitions")]
		public string[] Short_definitions { get; set; }
		
		/// <summary>
		/// Ordered list of subsenses of a sense
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsenses")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public Sense[] Subsenses { get; set; }
		
		/// <summary>
		/// Ordered list of links to the Thesaurus Dictionary
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="thesaurusLinks")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ThesaurusLink[] ThesaurusLinks { get; set; }
		
		/// <summary>
		/// A list of written or spoken rendering of the meaning of a word or text in another language(s)
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="translations")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public SenseTranslations[] SenseTranslations { get; set; }
		
		/// <summary>
		/// Various words that are used interchangeably depending on the context, e.g 'aluminium' and 'aluminum'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="variantForms")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public SenseVariantForms[] SenseVariantForms { get; set; }
	}
	
	public class SenseExamples
	{
		
		[System.Runtime.Serialization.DataMember(Name="definitions")]
		public string[] Definitions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// various types of notes that appear
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public CategorizedTextListElement[] Notes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="senseIds")]
		public string[] SenseIds { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// A list of written or spoken rendering of the meaning of a word or text in another language(s)
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="translations")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public SenseExamplesTranslations[] SenseExamplesTranslations { get; set; }
	}
	
	public class SenseExamplesTranslations
	{
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// The different forms are correlated with meanings or functions which we text as 'features'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grammaticalFeatures")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public SenseExamplesTranslationsGrammaticalFeatures[] SenseExamplesTranslationsGrammaticalFeatures { get; set; }
		
		/// <summary>
		/// IANA language code specifying the language of the translation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// various types of notes that appear
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public CategorizedTextListElement[] Notes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class SenseExamplesTranslationsGrammaticalFeatures
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class SensePronunciations
	{
		
		/// <summary>
		/// The URL of the sound file
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioFile")]
		public string AudioFile { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dialects")]
		public string[] Dialects { get; set; }
		
		/// <summary>
		/// The alphabetic system used to display the phonetic spelling
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phoneticNotation")]
		public string PhoneticNotation { get; set; }
		
		/// <summary>
		/// Phonetic spelling is the representation of vocal sounds which express pronunciations of words. It is a system of spelling in which each letter represents invariably the same spoken sound
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phoneticSpelling")]
		public string PhoneticSpelling { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
	}
	
	/// <summary>
	/// Link to a sense of a specific entry in the thesaurus Dictionary
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ThesaurusLink
	{
		
		/// <summary>
		/// identifier of a word
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="entry_id")]
		public string Entry_id { get; set; }
		
		/// <summary>
		/// identifier of a sense
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sense_id")]
		public string Sense_id { get; set; }
	}
	
	public class SenseTranslations
	{
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// The different forms are correlated with meanings or functions which we text as 'features'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grammaticalFeatures")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public SenseTranslationsGrammaticalFeatures[] SenseTranslationsGrammaticalFeatures { get; set; }
		
		/// <summary>
		/// IANA language code specifying the language of the translation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// various types of notes that appear
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public CategorizedTextListElement[] Notes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class SenseTranslationsGrammaticalFeatures
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	public class SenseVariantForms
	{
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class EntryVariantForms
	{
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ExamplesListElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="definitions")]
		public string[] Definitions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// various types of notes that appear
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public CategorizedTextListElement[] Notes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="senseIds")]
		public string[] SenseIds { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// A list of written or spoken rendering of the meaning of a word or text in another language(s)
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="translations")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ExamplesListElementTranslations[] ExamplesListElementTranslations { get; set; }
	}
	
	public class ExamplesListElementTranslations
	{
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// The different forms are correlated with meanings or functions which we text as 'features'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grammaticalFeatures")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ExamplesListElementTranslationsGrammaticalFeatures[] ExamplesListElementTranslationsGrammaticalFeatures { get; set; }
		
		/// <summary>
		/// IANA language code specifying the language of the translation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// various types of notes that appear
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public CategorizedTextListElement[] Notes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class ExamplesListElementTranslationsGrammaticalFeatures
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Schema for the Filters endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Filters
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// A mapping of filters available per endpoints.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public FiltersResults Results { get; set; }
	}
	
	public class FiltersResults
	{
		
		[System.Runtime.Serialization.DataMember(Name="entries")]
		public string[] Entries { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="inflections")]
		public string[] Inflections { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="translations")]
		public string[] Translations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="wordlist")]
		public string[] Wordlist { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GrammaticalFeaturesListElement
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// Description of a word
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HeadwordEntry
	{
		
		/// <summary>
		/// The identifier of a word
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// IANA language code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// A grouping of various senses in a specific language, and a lexical category that relates to a word
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lexicalEntries")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public LexicalEntry[] LexicalEntries { get; set; }
		
		/// <summary>
		/// A list of possible pronunciations of a word
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pronunciations")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public HeadwordEntryPronunciations[] HeadwordEntryPronunciations { get; set; }
		
		/// <summary>
		/// The json object type. Could be 'headword', 'inflection' or 'phrase'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// A given written or spoken realisation of a an entry, lowercased.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="word")]
		public string Word { get; set; }
	}
	
	/// <summary>
	/// Description of an entry for a particular part of speech
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LexicalEntry
	{
		
		/// <summary>
		/// A list of written or spoken words
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="derivativeOf")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ArrayOfRelatedEntriesElement[] DerivativeOf { get; set; }
		
		/// <summary>
		/// A list of written or spoken words
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="derivatives")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ArrayOfRelatedEntriesElement[] Derivatives { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public Entry[] Entries { get; set; }
		
		/// <summary>
		/// The different forms are correlated with meanings or functions which we text as 'features'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grammaticalFeatures")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public GrammaticalFeaturesListElement[] GrammaticalFeatures { get; set; }
		
		/// <summary>
		/// IANA language code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// A linguistic category of words (or more precisely lexical items), generally defined by the syntactic or morphological behaviour of the lexical item in question, such as noun or verb
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lexicalCategory")]
		public string LexicalCategory { get; set; }
		
		/// <summary>
		/// various types of notes that appear
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public CategorizedTextListElement[] Notes { get; set; }
		
		/// <summary>
		/// A list of possible pronunciations of a word
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="pronunciations")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public LexicalEntryPronunciations[] LexicalEntryPronunciations { get; set; }
		
		/// <summary>
		/// A given written or spoken realisation of a an entry.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// Various words that are used interchangeably depending on the context, e.g 'aluminium' and 'aluminum'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="variantForms")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public LexicalEntryVariantForms[] LexicalEntryVariantForms { get; set; }
	}
	
	public class LexicalEntryPronunciations
	{
		
		/// <summary>
		/// The URL of the sound file
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioFile")]
		public string AudioFile { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dialects")]
		public string[] Dialects { get; set; }
		
		/// <summary>
		/// The alphabetic system used to display the phonetic spelling
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phoneticNotation")]
		public string PhoneticNotation { get; set; }
		
		/// <summary>
		/// Phonetic spelling is the representation of vocal sounds which express pronunciations of words. It is a system of spelling in which each letter represents invariably the same spoken sound
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phoneticSpelling")]
		public string PhoneticSpelling { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
	}
	
	public class LexicalEntryVariantForms
	{
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class HeadwordEntryPronunciations
	{
		
		/// <summary>
		/// The URL of the sound file
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioFile")]
		public string AudioFile { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dialects")]
		public string[] Dialects { get; set; }
		
		/// <summary>
		/// The alphabetic system used to display the phonetic spelling
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phoneticNotation")]
		public string PhoneticNotation { get; set; }
		
		/// <summary>
		/// Phonetic spelling is the representation of vocal sounds which express pronunciations of words. It is a system of spelling in which each letter represents invariably the same spoken sound
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phoneticSpelling")]
		public string PhoneticSpelling { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
	}
	
	/// <summary>
	/// Description of an inflected form of a word
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HeadwordLemmatron
	{
		
		/// <summary>
		/// The identifier of a word
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// IANA language code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// A grouping of various senses in a specific language, and a lexical category that relates to a word
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lexicalEntries")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public LemmatronLexicalEntry[] LexicalEntries { get; set; }
		
		/// <summary>
		/// The json object type. Could be 'headword', 'inflection' or 'phrase'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// A given written or spoken realisation of a an entry, lowercased.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="word")]
		public string Word { get; set; }
	}
	
	/// <summary>
	/// Description of an entry for a particular part of speech and grammatical features
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LemmatronLexicalEntry
	{
		
		/// <summary>
		/// The different forms are correlated with meanings or functions which we text as 'features'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grammaticalFeatures")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public GrammaticalFeaturesListElement[] GrammaticalFeatures { get; set; }
		
		/// <summary>
		/// A grouping of the modifications of a word to express different grammatical categories
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="inflectionOf")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public LemmatronLexicalEntryInflectionOf[] LemmatronLexicalEntryInflectionOf { get; set; }
		
		/// <summary>
		/// IANA language code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// A linguistic category of words (or more precisely lexical items), generally defined by the syntactic or morphological behaviour of the lexical item in question, such as noun or verb
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lexicalCategory")]
		public string LexicalCategory { get; set; }
		
		/// <summary>
		/// A given written or spoken realisation of a an entry.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class LemmatronLexicalEntryInflectionOf
	{
		
		/// <summary>
		/// The identifier of the word
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// description of thesaurus information of a word
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class HeadwordThesaurus
	{
		
		/// <summary>
		/// The identifier of a word
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// IANA language code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// A grouping of various senses in a specific language, and a lexical category that relates to a word
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lexicalEntries")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ThesaurusLexicalEntry[] LexicalEntries { get; set; }
		
		/// <summary>
		/// The json object type. Could be 'headword', 'inflection' or 'phrase'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// A given written or spoken realisation of a an entry, lowercased.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="word")]
		public string Word { get; set; }
	}
	
	/// <summary>
	/// Description of an entry for a particular part of speech
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ThesaurusLexicalEntry
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="entries")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ThesaurusEntry[] Entries { get; set; }
		
		/// <summary>
		/// IANA language code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// A linguistic category of words (or more precisely lexical items), generally defined by the syntactic or morphological behaviour of the lexical item in question, such as noun or verb
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lexicalCategory")]
		public string LexicalCategory { get; set; }
		
		/// <summary>
		/// A given written or spoken realisation of a an entry.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
		
		/// <summary>
		/// Various words that are used interchangeably depending on the context, e.g 'aluminium' and 'aluminum'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="variantForms")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ThesaurusLexicalEntryVariantForms[] ThesaurusLexicalEntryVariantForms { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ThesaurusEntry
	{
		
		/// <summary>
		/// Identifies the homograph grouping. The last two digits identify different entries of the same homograph. The first one/two digits identify the homograph number.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="homographNumber")]
		public string HomographNumber { get; set; }
		
		/// <summary>
		/// Complete list of senses
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="senses")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ThesaurusSense[] Senses { get; set; }
		
		/// <summary>
		/// Various words that are used interchangeably depending on the context, e.g 'aluminium' and 'aluminum'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="variantForms")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ThesaurusEntryVariantForms[] ThesaurusEntryVariantForms { get; set; }
	}
	
	/// <summary>
	/// A lexical sense represents the lexical meaning of a lexical entry when interpreted as referring to the corresponding ontology element
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ThesaurusSense
	{
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="antonyms")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ThesaurusSenseAntonyms[] ThesaurusSenseAntonyms { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// A list of written or spoken rendering of examples of use of a word or text
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="examples")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ExamplesListElement[] Examples { get; set; }
		
		/// <summary>
		/// The id of the sense that is required for the delete procedure
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		/// <summary>
		/// subsenses of word
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subsenses")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ThesaurusSense[] Subsenses { get; set; }
		
		/// <summary>
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="synonyms")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ThesaurusSenseSynonyms[] ThesaurusSenseSynonyms { get; set; }
	}
	
	public class ThesaurusSenseAntonyms
	{
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class ThesaurusSenseSynonyms
	{
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class ThesaurusEntryVariantForms
	{
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	public class ThesaurusLexicalEntryVariantForms
	{
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InflectionsListElement
	{
		
		/// <summary>
		/// The identifier of the word
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// Schema for the languages endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Languages
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// A list of languages available.
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public LanguagesResults[] LanguagesResults { get; set; }
	}
	
	public class LanguagesResults
	{
		
		/// <summary>
		/// Name of region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// Name of source dictionary.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="source")]
		public string Source { get; set; }
		
		/// <summary>
		/// Source language of the results
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceLanguage")]
		public LanguagesResultsSourceLanguage SourceLanguage { get; set; }
		
		/// <summary>
		/// Translation language of the results
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="targetLanguage")]
		public LanguagesResultsTargetLanguage TargetLanguage { get; set; }
		
		/// <summary>
		/// whether monolingual or bilingual.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public System.Nullable<LanguagesResultsType> Type { get; set; }
	}
	
	public class LanguagesResultsSourceLanguage
	{
		
		/// <summary>
		/// IANA language code
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Language label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
	}
	
	public class LanguagesResultsTargetLanguage
	{
		
		/// <summary>
		/// IANA language code
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Language label.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum LanguagesResultsType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="monolingual")]
		monolingual = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="bilingual")]
		bilingual = 1,
	}
	
	/// <summary>
	/// Schema for the inflections endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Lemmatron
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// A list of inflections matching a given word
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public HeadwordLemmatron[] Results { get; set; }
	}
	
	/// <summary>
	/// Schema for corpus ngrams.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NgramsResult
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// A list of found ngrams along with their frequencies
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public NgramsResultResults[] NgramsResultResults { get; set; }
	}
	
	public class NgramsResultResults
	{
		
		/// <summary>
		/// The number of times the ngram (a sequence of n words) appears in the corpus
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public int Frequency { get; set; }
		
		/// <summary>
		/// A list of tokens
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tokens")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public string[] Tokens { get; set; }
	}
	
	/// <summary>
	/// A grouping of pronunciation information
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PronunciationsListElement
	{
		
		/// <summary>
		/// The URL of the sound file
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="audioFile")]
		public string AudioFile { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dialects")]
		public string[] Dialects { get; set; }
		
		/// <summary>
		/// The alphabetic system used to display the phonetic spelling
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phoneticNotation")]
		public string PhoneticNotation { get; set; }
		
		/// <summary>
		/// Phonetic spelling is the representation of vocal sounds which express pronunciations of words. It is a system of spelling in which each letter represents invariably the same spoken sound
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="phoneticSpelling")]
		public string PhoneticSpelling { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
	}
	
	/// <summary>
	/// Schema for region endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Regions
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// A mapping of regions available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public System.Collections.Generic.Dictionary<string, string[]> Results { get; set; }
	}
	
	/// <summary>
	/// Schema for the 'entries' endpoints
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RetrieveEntry
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// A list of entries and all the data related to them
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public HeadwordEntry[] Results { get; set; }
	}
	
	/// <summary>
	/// Description of a word
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SentencesEntry
	{
		
		/// <summary>
		/// The identifier of a word
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// IANA language code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// A grouping of various senses in a specific language, and a lexical category that relates to a word
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lexicalEntries")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public SentencesLexicalEntry[] LexicalEntries { get; set; }
		
		/// <summary>
		/// The json object type. Could be 'headword', 'inflection' or 'phrase'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// A given written or spoken realisation of a an entry, lowercased.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="word")]
		public string Word { get; set; }
	}
	
	/// <summary>
	/// Description of an entry for a particular part of speech
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SentencesLexicalEntry
	{
		
		/// <summary>
		/// The different forms are correlated with meanings or functions which we text as 'features'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grammaticalFeatures")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public GrammaticalFeaturesListElement[] GrammaticalFeatures { get; set; }
		
		/// <summary>
		/// IANA language code
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// A linguistic category of words (or more precisely lexical items), generally defined by the syntactic or morphological behaviour of the lexical item in question, such as noun or verb
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lexicalCategory")]
		public string LexicalCategory { get; set; }
		
		/// <summary>
		/// A list of written or spoken rendering of examples of use of a word or text
		/// Required
		/// Minimum items: 1
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sentences")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public ExamplesListElement[] Sentences { get; set; }
		
		/// <summary>
		/// A given written or spoken realisation of a an entry.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// Schema for the 'sentences' endpoint
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SentencesResults
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// A list of entries and all the data related to them
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public SentencesEntry[] Results { get; set; }
	}
	
	/// <summary>
	/// Schema for lexi-stats results for a word/trueCase/lemma/lexicalCategory returned as a frequency
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatsWordResult
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// Frequency information for a given entity
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public StatsWordResultResult Result { get; set; }
	}
	
	public class StatsWordResultResult
	{
		
		/// <summary>
		/// The number of times a word appears in the entire corpus
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public int Frequency { get; set; }
		
		/// <summary>
		/// A lemma of the word (e.g., wordforms "lay", "laid" and "laying" have all lemma "lay")
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lemma")]
		public string Lemma { get; set; }
		
		/// <summary>
		/// A lexical category such as 'verb' or 'noun'
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lexicalCategory")]
		public string LexicalCategory { get; set; }
		
		/// <summary>
		/// The number of database records that matched the query params (stated frequency is the sum of the individual frequencies)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="matchCount")]
		public int MatchCount { get; set; }
		
		/// <summary>
		/// The number of times a word appears on average in 1 million words
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="normalizedFrequency")]
		public int NormalizedFrequency { get; set; }
		
		/// <summary>
		/// A given written realisation of a an entry (e.g., "lay") usually lower case
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trueCase")]
		public string TrueCase { get; set; }
		
		/// <summary>
		/// A given written realisation of a an entry (e.g., "Lay") preserving case
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="wordform")]
		public string Wordform { get; set; }
	}
	
	/// <summary>
	/// Schema for lexi-stats results for a word/trueCase/lemma/lexicalCategory returned as a list of frequencies per wordform-trueCase-lemma-lexicalCategory entry.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StatsWordResultList
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// A list of found words along with their frequencies
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public StatsWordResultListResults[] StatsWordResultListResults { get; set; }
	}
	
	public class StatsWordResultListResults
	{
		
		/// <summary>
		/// The number of times a word appears in the entire corpus
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="frequency")]
		public int Frequency { get; set; }
		
		/// <summary>
		/// A lemma of the word.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lemma")]
		public string Lemma { get; set; }
		
		/// <summary>
		/// A lexical category such as 'verb' or 'noun'
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="lexicalCategory")]
		public string LexicalCategory { get; set; }
		
		/// <summary>
		/// The number of times a word appears on average in 1 million words
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="normalizedFrequency")]
		public int NormalizedFrequency { get; set; }
		
		/// <summary>
		/// A given written realisation of a an entry (e.g., "lay") usually lower case
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="trueCase")]
		public string TrueCase { get; set; }
		
		/// <summary>
		/// A given written realisation of a an entry (e.g., "lay") preserving case
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="wordform")]
		public string Wordform { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SynonymsAntonymsElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// Schema for thesaurus endpoint
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Thesaurus
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// A list of found synonyms or antonyms
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public HeadwordThesaurus[] Results { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TranslationsListElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public string[] Domains { get; set; }
		
		/// <summary>
		/// The different forms are correlated with meanings or functions which we text as 'features'
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="grammaticalFeatures")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public GrammaticalFeaturesListElement[] GrammaticalFeatures { get; set; }
		
		/// <summary>
		/// IANA language code specifying the language of the translation
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="language")]
		public string Language { get; set; }
		
		/// <summary>
		/// various types of notes that appear
		/// Minimum items: 1
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="notes")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		public CategorizedTextListElement[] Notes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="registers")]
		public string[] Registers { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// Schema for lexicalcategories, registers utility endpoints.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UtilityLabels
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// Mapping of labels available.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		public System.Collections.Generic.Dictionary<string, UtilityLabelsResults> Results { get; set; }
	}
	
	public class UtilityLabelsResults
	{
		
		/// <summary>
		/// Label in English
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="en")]
		public string En { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VariantFormsListElement
	{
		
		[System.Runtime.Serialization.DataMember(Name="regions")]
		public string[] Regions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="text")]
		public string Text { get; set; }
	}
	
	/// <summary>
	/// Schema for wordlist endpoint.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Wordlist
	{
		
		/// <summary>
		/// Additional Information provided by OUP
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="metadata")]
		public string Metadata { get; set; }
		
		/// <summary>
		/// A list of found words
		/// Minimum items: 0
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="results")]
		[System.ComponentModel.DataAnnotations.MinLength(0)]
		public WordlistResults[] WordlistResults { get; set; }
	}
	
	public class WordlistResults
	{
		
		/// <summary>
		/// The identifier of a word
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="matchString")]
		public string MatchString { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="matchType")]
		public string MatchType { get; set; }
		
		/// <summary>
		/// Name of region.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="region")]
		public string Region { get; set; }
		
		/// <summary>
		/// A given written or spoken realisation of a an entry, lowercased.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="word")]
		public string Word { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists available domains in a bilingual dataset
		/// Returns a list of the available [domains](documentation/glossary?term=domain) for a given bilingual language dataset.
		/// 
		/// Domains_source_domains_language_target_domains_languageGet domains/{source_domains_language}/{target_domains_language}
		/// </summary>
		/// <param name="source_domains_language">IANA language code</param>
		/// <param name="target_domains_language">IANA language code</param>
		/// <returns>Successful response.</returns>
		public async Task<UtilityLabels> Domains_source_domains_language_target_domains_languageGetAsync(Domains_source_domains_language_target_domains_languageGetSource_domains_language source_domains_language, Domains_source_domains_language_target_domains_languageGetTarget_domains_language target_domains_language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/"+source_domains_language+"/"+target_domains_language;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UtilityLabels>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists available domains in a monolingual dataset
		/// Returns a list of the available [domains](documentation/glossary?term=domain) for a given monolingual language dataset.
		/// 
		/// Domains_source_languageGet domains/{source_language}
		/// </summary>
		/// <param name="source_language">IANA language code</param>
		/// <returns>Successful response.</returns>
		public async Task<UtilityLabels> Domains_source_languageGetAsync(Domains_source_languageGetSource_language source_language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "domains/"+source_language;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UtilityLabels>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve corpus sentences for a given word
		/// 
		/// Use this to retrieve sentences extracted from  corpora which show how a word is used in the language. This is available for English and Spanish. For English, the sentences are linked to the correct [sense](documentation/glossary?term=sense) of the word in the dictionary. In Spanish, they are linked at the [headword](documentation/glossary?term=headword) level.
		/// <div id="sentences"></div>
		/// 
		/// Entries_source_language_word_idSentencesGet entries/{source_language}/{word_id}/sentences
		/// </summary>
		/// <param name="source_language">IANA language code</param>
		/// <param name="word_id">An Entry identifier. Case-sensitive.</param>
		/// <returns>Successful response.</returns>
		public async Task<SentencesResults> Entries_source_language_word_idSentencesGetAsync(Entries_source_language_word_idSentencesGetSource_language source_language, string word_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "entries/"+source_language+"/"+ (word_id==null? "" : System.Uri.EscapeDataString(word_id))+"/sentences";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SentencesResults>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve dictionary information for a given word
		/// 
		/// Use this to retrieve definitions, [pronunciations](documentation/glossary?term=pronunciation), example sentences, [grammatical information](documentation/glossary?term=grammaticalfeatures) and [word origins](documentation/glossary?term=etymology). It only works for dictionary [headwords](documentation/glossary?term=headword), so you may need to use the [Lemmatron](documentation/glossary?term=lemma) first if your input is likely to be an [inflected](documentation/glossary?term=inflection) form (e.g., 'swimming'). This would return the linked [headword](documentation/glossary?term=headword) (e.g., 'swim') which you can then use in the Entries endpoint. Unless specified using a region filter, the default lookup will be the Oxford Dictionary of English (GB).
		/// <div id="dictionary_entries"></div>
		/// 
		/// Entries_source_lang_word_idGet entries/{source_lang}/{word_id}
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="word_id">An Entry identifier. Case-sensitive.</param>
		/// <returns>Successful response.</returns>
		public async Task<RetrieveEntry> Entries_source_lang_word_idGetAsync(Entries_source_lang_word_idGetSource_lang source_lang, string word_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "entries/"+source_lang+"/"+ (word_id==null? "" : System.Uri.EscapeDataString(word_id));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetrieveEntry>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve words that mean the opposite
		/// 
		/// Retrieve words that are opposite in meaning to the input word ([antonym](documentation/glossary?term=thesaurus)).
		/// 
		/// <div id="antonyms"></div>
		/// 
		/// Entries_source_lang_word_idAntonymsGet entries/{source_lang}/{word_id}/antonyms
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="word_id">An Entry identifier. Case-sensitive.</param>
		/// <returns>Successful response.</returns>
		public async Task<Thesaurus> Entries_source_lang_word_idAntonymsGetAsync(Entries_source_lang_word_idAntonymsGetSource_lang source_lang, string word_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "entries/"+source_lang+"/"+ (word_id==null? "" : System.Uri.EscapeDataString(word_id))+"/antonyms";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Thesaurus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Specify GB or US dictionary for English entry search
		/// 
		/// USe this filter to restrict the lookup to either our Oxford Dictionary of English (GB) or New Oxford American Dictionary (US).
		/// 
		/// Entries_source_lang_word_idRegions__regionGet entries/{source_lang}/{word_id}/regions={region}
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="word_id">An Entry identifier. Case-sensitive.</param>
		/// <param name="region">Region filter parameter. gb = Oxford Dictionary of English. us = New Oxford American Dictionary.</param>
		/// <returns>Successful response.</returns>
		public async Task<RetrieveEntry> Entries_source_lang_word_idRegions__regionGetAsync(Entries_source_lang_word_idAntonymsGetSource_lang source_lang, string word_id, Entries_source_lang_word_idRegions__regionGetRegion region, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "entries/"+source_lang+"/"+ (word_id==null? "" : System.Uri.EscapeDataString(word_id))+"/regions="+region;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetrieveEntry>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve words that are similar
		/// 
		/// Use this to retrieve words that are similar in meaning to the input word ([synonym](documentation/glossary?term=synonym)).
		/// 
		/// <div id="synonyms"></div>
		/// 
		/// Entries_source_lang_word_idSynonymsGet entries/{source_lang}/{word_id}/synonyms
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="word_id">An Entry identifier. Case-sensitive.</param>
		/// <returns>Successful response.</returns>
		public async Task<Thesaurus> Entries_source_lang_word_idSynonymsGetAsync(Entries_source_lang_word_idAntonymsGetSource_lang source_lang, string word_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "entries/"+source_lang+"/"+ (word_id==null? "" : System.Uri.EscapeDataString(word_id))+"/synonyms";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Thesaurus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve synonyms and antonyms for a given word
		/// 
		/// Retrieve available [synonyms](documentation/glossary?term=thesaurus) and [antonyms](documentation/glossary?term=thesaurus) for a given word and language.
		/// 
		/// <div id="synonyms_and_antonyms"></div>
		/// 
		/// Entries_source_lang_word_idSynonyms_antonymsGet entries/{source_lang}/{word_id}/synonyms;antonyms
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="word_id">An Entry identifier. Case-sensitive.</param>
		/// <returns>Successful response.</returns>
		public async Task<Thesaurus> Entries_source_lang_word_idSynonyms_antonymsGetAsync(Entries_source_lang_word_idAntonymsGetSource_lang source_lang, string word_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "entries/"+source_lang+"/"+ (word_id==null? "" : System.Uri.EscapeDataString(word_id))+"/synonyms;antonyms";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Thesaurus>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Apply filters to response
		/// 
		/// Use filters to limit the [entry](documentation/glossary?term=entry) information that is returned. For example, you may only require definitions and not everything else, or just [pronunciations](documentation/glossary?term=pronunciation). The full list of filters can be retrieved from the filters Utility endpoint. You can also specify values within the filter using '='. For example 'grammaticalFeatures=singular'. Filters can also be combined using a semicolon.
		/// 
		/// <div id="dictionary_entries_filters"></div>
		/// 
		/// Entries_source_lang_word_id_filtersGet entries/{source_lang}/{word_id}/{filters}
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="word_id">An Entry identifier. Case-sensitive.</param>
		/// <param name="filters">Separate filtering conditions using a semicolon. Conditions take values grammaticalFeatures and/or lexicalCategory and are case-sensitive. To list multiple values in single condition divide them with comma.</param>
		/// <returns>Successful response.</returns>
		public async Task<RetrieveEntry> Entries_source_lang_word_id_filtersGetAsync(Entries_source_lang_word_idGetSource_lang source_lang, string word_id, string filters, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "entries/"+source_lang+"/"+ (word_id==null? "" : System.Uri.EscapeDataString(word_id))+"/"+ (filters==null? "" : System.Uri.EscapeDataString(filters));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetrieveEntry>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve translation for a given word
		/// 
		/// Use this to return translations for a given word. In the event that a word in the dataset does not have a direct translation, the response will be a [definition](documentation/glossary?term=entry) in the target language.
		/// 
		/// <div id="translation"></div>
		/// 
		/// Entries_source_translation_language_word_idTranslations__target_translation_languageGet entries/{source_translation_language}/{word_id}/translations={target_translation_language}
		/// </summary>
		/// <param name="source_translation_language">IANA language code</param>
		/// <param name="word_id">The source word</param>
		/// <param name="target_translation_language">IANA language code</param>
		/// <returns>Successful response. In case word doesn't have a direct translation a response would be definitions.</returns>
		public async Task<RetrieveEntry> Entries_source_translation_language_word_idTranslations__target_translation_languageGetAsync(Entries_source_translation_language_word_idTranslations__target_translation_languageGetSource_translation_language source_translation_language, string word_id, Domains_source_domains_language_target_domains_languageGetTarget_domains_language target_translation_language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "entries/"+source_translation_language+"/"+ (word_id==null? "" : System.Uri.EscapeDataString(word_id))+"/translations="+target_translation_language;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RetrieveEntry>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists available filters
		/// Returns a list of all the valid filters to construct API calls.
		/// 
		/// FiltersGet filters
		/// </summary>
		/// <returns>Successful response.</returns>
		public async Task<Filters> FiltersGetAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filters";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Filters>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists available filters for specific endpoint
		/// Returns a list of all the valid filters for a given endpoint to construct API calls.
		/// 
		/// Filters_endpointGet filters/{endpoint}
		/// </summary>
		/// <param name="endpoint">Name of the endpoint.</param>
		/// <returns>Successful response.</returns>
		public async Task<Filters> Filters_endpointGetAsync(Filters_endpointGetEndpoint endpoint, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "filters/"+endpoint;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Filters>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists available grammatical features in a dataset
		/// Returns a list of the available [grammatical features](documentation/glossary?term=grammaticalfeatures) for a given language dataset.
		/// 
		/// GrammaticalFeatures_source_languageGet grammaticalFeatures/{source_language}
		/// </summary>
		/// <param name="source_language">IANA language code. If provided output will be filtered by sourceLanguage.</param>
		/// <returns>Successful response.</returns>
		public async Task<UtilityLabels> GrammaticalFeatures_source_languageGetAsync(GrammaticalFeatures_source_languageGetSource_language source_language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "grammaticalFeatures/"+source_language;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UtilityLabels>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check a word exists in the dictionary and retrieve its root form
		/// 
		/// Use this to check if a word exists in the dictionary, or what 'root' form it links to (e.g., swimming > swim). The response tells you the possible [lemmas](documentation/glossary?term=lemma) for a given [inflected](documentation/glossary?term=inflection) word. This can then be combined with other endpoints to retrieve more information.
		/// 
		/// <div id="lemmatron"></div>
		/// 
		/// Inflections_source_lang_word_id_filtersGet inflections/{source_lang}/{word_id}/{filters}
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="filters">Separate filtering conditions using a semicolon. Conditions take values grammaticalFeatures and/or lexicalCategory and are case-sensitive. To list multiple values in single condition divide them with comma.</param>
		/// <param name="word_id">The input word</param>
		/// <returns>Successful response.</returns>
		public async Task<Lemmatron> Inflections_source_lang_word_id_filtersGetAsync(Inflections_source_lang_word_id_filtersGetSource_lang source_lang, string filters, string word_id, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "inflections/"+source_lang+"/"+ (word_id==null? "" : System.Uri.EscapeDataString(word_id))+"/"+ (filters==null? "" : System.Uri.EscapeDataString(filters));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Lemmatron>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists available dictionaries
		/// Returns a list of monolingual and bilingual language datasets available in the API
		/// 
		/// LanguagesGetBySourceLanguageAndTargetLanguage languages
		/// </summary>
		/// <param name="sourceLanguage">IANA language code. If provided output will be filtered by sourceLanguage.</param>
		/// <param name="targetLanguage">IANA language code. If provided output will be filtered by sourceLanguage.</param>
		/// <returns>Successful response.</returns>
		public async Task<Languages> LanguagesGetBySourceLanguageAndTargetLanguageAsync(LanguagesGetBySourceLanguageAndTargetLanguageSourceLanguage sourceLanguage, LanguagesGetBySourceLanguageAndTargetLanguageTargetLanguage targetLanguage, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "languages?sourceLanguage=" + sourceLanguage+"&targetLanguage=" + targetLanguage;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Languages>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists available lexical categories in a dataset
		/// Returns a list of available [lexical categories](documentation/glossary?term=lexicalcategory) for a given language dataset.
		/// 
		/// Lexicalcategories_languageGet lexicalcategories/{language}
		/// </summary>
		/// <param name="language">IANA language code</param>
		/// <returns>Successful response.</returns>
		public async Task<UtilityLabels> Lexicalcategories_languageGetAsync(LanguagesGetBySourceLanguageAndTargetLanguageSourceLanguage language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "lexicalcategories/"+language;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UtilityLabels>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists available regions in a monolingual dataset
		/// Returns a list of the available [regions](documentation/glossary?term=regions) for a given monolingual language dataset.
		/// 
		/// Regions_source_languageGet regions/{source_language}
		/// </summary>
		/// <param name="source_language">IANA language code</param>
		/// <returns>Successful response.</returns>
		public async Task<Regions> Regions_source_languageGetAsync(Entries_source_lang_word_idAntonymsGetSource_lang source_language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "regions/"+source_language;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Regions>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists available registers in a  monolingual dataset
		/// Returns a list of the available [registers](documentation/glossary?term=registers) for a given monolingual language dataset.
		/// 
		/// Registers_source_languageGet registers/{source_language}
		/// </summary>
		/// <param name="source_language">IANA language code</param>
		/// <returns>Successful response.</returns>
		public async Task<UtilityLabels> Registers_source_languageGetAsync(Registers_source_languageGetSource_language source_language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registers/"+source_language;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UtilityLabels>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Lists available registers in a bilingual dataset
		/// Returns a list of the available [registers](documentation/glossary?term=registers) for a given bilingual language dataset.
		/// 
		/// Registers_source_register_language_target_register_languageGet registers/{source_register_language}/{target_register_language}
		/// </summary>
		/// <param name="source_register_language">IANA language code</param>
		/// <param name="target_register_language">IANA language code</param>
		/// <returns>Successful response.</returns>
		public async Task<UtilityLabels> Registers_source_register_language_target_register_languageGetAsync(Registers_source_register_language_target_register_languageGetSource_register_language source_register_language, Registers_source_register_language_target_register_languageGetTarget_register_language target_register_language, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "registers/"+source_register_language+"/"+target_register_language;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UtilityLabels>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve possible matches to input
		/// 
		/// Use this to retrieve possible [headword](documentation/glossary?term=headword) matches for a given string of text. The results are culculated using headword matching, fuzzy matching, and [lemmatization](documentation/glossary?term=lemma)
		/// 
		/// <div id="search"></div>
		/// 
		/// Search_source_langGetByQAndPrefixAndRegionsAndLimitAndOffset search/{source_lang}
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="q">Search string</param>
		/// <param name="prefix">Set prefix to true if you'd like to get results only starting with search string.</param>
		/// <param name="regions">If searching in English, filter words with specific region(s) either 'us' or 'gb'.</param>
		/// <param name="limit">Limit the number of results per response. Default and maximum limit is 5000.</param>
		/// <param name="offset">Offset the start number of the result.</param>
		/// <returns>Successful response.</returns>
		public async Task<Wordlist> Search_source_langGetByQAndPrefixAndRegionsAndLimitAndOffsetAsync(Search_source_langGetByQAndPrefixAndRegionsAndLimitAndOffsetSource_lang source_lang, string q, Search_source_langGetByQAndPrefixAndRegionsAndLimitAndOffsetPrefix prefix, string regions, string limit, string offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/"+source_lang+"?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&prefix="+prefix+"&regions=" + (regions==null? "" : System.Uri.EscapeDataString(regions))+"&limit=" + (limit==null? "" : System.Uri.EscapeDataString(limit))+"&offset=" + (offset==null? "" : System.Uri.EscapeDataString(offset));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Wordlist>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve possible translation matches to input
		/// 
		/// Use this to find matches in our translation dictionaries.
		/// 
		/// <div id="search_translation"></div>
		/// 
		/// Search_source_search_languageTranslations__target_search_languageGetByQAndPrefixAndRegionsAndLimitAndOffset search/{source_search_language}/translations={target_search_language}
		/// </summary>
		/// <param name="source_search_language">IANA language code</param>
		/// <param name="target_search_language">IANA language code</param>
		/// <param name="q">Search string.</param>
		/// <param name="prefix">Set prefix to true if you'd like to get results only starting with search string.</param>
		/// <param name="regions">Filter words with specific region(s) E.g., regions=us. For now gb, us are available for en language.</param>
		/// <param name="limit">Limit the number of results per response. Default and maximum limit is 5000.</param>
		/// <param name="offset">Offset the start number of the result.</param>
		/// <returns>Successful response.</returns>
		public async Task<Wordlist> Search_source_search_languageTranslations__target_search_languageGetByQAndPrefixAndRegionsAndLimitAndOffsetAsync(Entries_source_translation_language_word_idTranslations__target_translation_languageGetSource_translation_language source_search_language, Domains_source_domains_language_target_domains_languageGetTarget_domains_language target_search_language, string q, Search_source_search_languageTranslations__target_search_languageGetByQAndPrefixAndRegionsAndLimitAndOffsetPrefix prefix, string regions, string limit, string offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "search/"+source_search_language+"/translations="+target_search_language+"?q=" + (q==null? "" : System.Uri.EscapeDataString(q))+"&prefix="+prefix+"&regions=" + (regions==null? "" : System.Uri.EscapeDataString(regions))+"&limit=" + (limit==null? "" : System.Uri.EscapeDataString(limit))+"&offset=" + (offset==null? "" : System.Uri.EscapeDataString(offset));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Wordlist>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the frequency of ngrams (1-4) derived from a corpus
		/// This endpoint returns frequencies of ngrams of size 1-4. That is the number of times a word (ngram size = 1) or words (ngram size > 1) appear in the corpus. Ngrams are case sensitive ("I AM" and "I am" will have different frequency) and frequencies are calculated per word (true case) so "the book" and "the books" are two different ngrams. The results can be filtered based on query parameters. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> Example for bigrams (ngram of size 2):
		/// * PATH: /tokens=a word,another word
		/// * GET: /?tokens=a word&tokens=another word
		/// * POST (json):
		/// 
		/// ```javascript
		/// {
		/// "tokens": ["a word", "another word"]
		/// }
		/// ```
		/// 
		/// Either "tokens" or "contains" has to be provided. <br> <br> Some queries with "contains" or "sort" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as "minFrequency" and "maxFrequency". <br> <br> You can use the parameters "offset" and "limit" to paginate through large result sets. For convenience, the HTTP header "Link" is set on the response to provide links to "first", "self", "next", "prev" and "last" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter "limit" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python's `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example:
		/// ```python def get_all_results(url):
		/// while url:
		/// r = requests.get(url)
		/// r.raise_for_status()
		/// for item in r.json()['results']:
		/// yield item
		/// url = r.links.get('next', {}).get('url')
		/// ```
		/// 
		/// StatsFrequencyNgrams_source_lang_corpus_ngram_sizeGetByTokensAndContainsAndPunctuationAndFormatAndMinFrequencyAndMaxFrequencyAndMinDocumentFrequencyAndMaxDocumentFrequencyAndCollateAndSortAndOffsetAndLimit stats/frequency/ngrams/{source_lang}/{corpus}/{ngram_size}/
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="corpus">For corpora other than 'nmc' (New Monitor Corpus) please contact api@oxforddictionaries.com</param>
		/// <param name="ngram_size">the size of ngrams requested (1-4)</param>
		/// <param name="tokens">List of tokens to filter. The tokens are separated by spaces, the list items are separated by comma (e.g., for bigrams (n=2) tokens=this is,this was, this will)</param>
		/// <param name="contains">Find ngrams containing the given token(s). Use comma or space as token separators; the order of tokens is irrelevant.</param>
		/// <param name="punctuation">Flag specifying whether to lookup ngrams that include punctuation or not (possible values are "true" and "false"; default is "false")</param>
		/// <param name="format">Option specifying whether tokens should be returned as a single string (option "google") or as a list of strings (option "oup")</param>
		/// <param name="minFrequency">Restrict the query to entries with frequency of at least `minFrequency`</param>
		/// <param name="maxFrequency">Restrict the query to entries with frequency of at most `maxFrequency`</param>
		/// <param name="minDocumentFrequency">Restrict the query to entries that appear in at least `minDocumentFrequency` documents</param>
		/// <param name="maxDocumentFrequency">Restrict the query to entries that appera in at most `maxDocumentFrequency` documents</param>
		/// <param name="collate">collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate=trueCase,lemma,lexicalCategory).</param>
		/// <param name="sort">sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign ('-'). Multiple values can be separated by commas (e.g., sort=lexicalCategory,-frequency)</param>
		/// <param name="offset">pagination - results offset</param>
		/// <param name="limit">pagination - results limit</param>
		/// <returns>Successful response.</returns>
		public async Task<NgramsResult> StatsFrequencyNgrams_source_lang_corpus_ngram_sizeGetByTokensAndContainsAndPunctuationAndFormatAndMinFrequencyAndMaxFrequencyAndMinDocumentFrequencyAndMaxDocumentFrequencyAndCollateAndSortAndOffsetAndLimitAsync(
					string source_lang, 
					string corpus, 
					string ngram_size, 
					string tokens, 
					string contains, 
					string punctuation, 
					string format, 
					long minFrequency, 
					long maxFrequency, 
					long minDocumentFrequency, 
					long maxDocumentFrequency, 
					string collate, 
					string sort, 
					long offset, 
					long limit, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "stats/frequency/ngrams/"+ (source_lang==null? "" : System.Uri.EscapeDataString(source_lang))+"/"+ (corpus==null? "" : System.Uri.EscapeDataString(corpus))+"/{ngram_size}/&tokens=" + (tokens==null? "" : System.Uri.EscapeDataString(tokens))+"&contains=" + (contains==null? "" : System.Uri.EscapeDataString(contains))+"&punctuation=" + (punctuation==null? "" : System.Uri.EscapeDataString(punctuation))+"&format=" + (format==null? "" : System.Uri.EscapeDataString(format))+"&minFrequency="+minFrequency+"&maxFrequency="+maxFrequency+"&minDocumentFrequency="+minDocumentFrequency+"&maxDocumentFrequency="+maxDocumentFrequency+"&collate=" + (collate==null? "" : System.Uri.EscapeDataString(collate))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<NgramsResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve the frequency of a word derived from a corpus.
		/// This endpoint provides the frequency of a given word. When multiple database records match the query parameters, the returned frequency is the sum of the individual frequencies. For example, if the query parameters are lemma=test, the returned frequency will include the verb "test", the noun "test" and the adjective "test" in all forms (Test, tested, testing, etc.) <br> <br> If you are interested in the frequency of the word "test" but want to exclude other forms (e.g., tested) use the option trueCase=test. Normally, the word "test" will be spelt with a capital letter at the beginning of a sentence. The option trueCase will ignore this and it will count "Test" and "test" as the same token. If you are interested in frequencies of "Test" and "test", use the option wordform=test or wordform=Test. Note that trueCase is not just a lower case of the word as some words are genuinely spelt with a capital letter such as the word "press" in Oxford University Press. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overriden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). Examples:
		/// * PATH: /lemma=test;lexicalCategory=noun
		/// * GET: /?lemma=test&lexicalCategory=noun
		/// * POST (json):
		/// 
		/// ```javascript
		/// {
		/// "lemma": "test",
		/// "lexicalCategory": "noun"
		/// }
		/// ```
		/// 
		/// <br> One of the options wordform/trueCase/lemma/lexicalCategory has to be provided.
		/// 
		/// StatsFrequencyWord_source_langGetByCorpusAndWordformAndTrueCaseAndLemmaAndLexicalCategory stats/frequency/word/{source_lang}/
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="corpus">For corpora other than 'nmc' (New Monitor Corpus) please contact api@oxforddictionaries.com</param>
		/// <param name="wordform">The written form of the word to look up (preserving case e.g., Books vs books)</param>
		/// <param name="trueCase">The written form of the word to look up with normalised case (Books --> books)</param>
		/// <param name="lemma">The lemma of the word to look up (e.g., Book, booked, books all have the lemma "book")</param>
		/// <param name="lexicalCategory">The lexical category of the word(s) to look up (e.g., noun or verb)</param>
		/// <returns>Successful response.</returns>
		public async Task<StatsWordResult> StatsFrequencyWord_source_langGetByCorpusAndWordformAndTrueCaseAndLemmaAndLexicalCategoryAsync(string source_lang, string corpus, string wordform, string trueCase, string lemma, string lexicalCategory, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "stats/frequency/word/"+ (source_lang==null? "" : System.Uri.EscapeDataString(source_lang))+"/&corpus=" + (corpus==null? "" : System.Uri.EscapeDataString(corpus))+"&wordform=" + (wordform==null? "" : System.Uri.EscapeDataString(wordform))+"&trueCase=" + (trueCase==null? "" : System.Uri.EscapeDataString(trueCase))+"&lemma=" + (lemma==null? "" : System.Uri.EscapeDataString(lemma))+"&lexicalCategory=" + (lexicalCategory==null? "" : System.Uri.EscapeDataString(lexicalCategory));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StatsWordResult>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of frequencies of a word/words derived from a corpus.
		/// This endpoint provides a list of frequencies for a given word or words. Unlike the /word/ endpoint, the results are split into the smallest units. <br> <br> To exclude a specific value, prepend it with the minus sign ('-'). For example, to get frequencies of the lemma 'happy' but exclude superlative forms (i.e., happiest) you could use options 'lemma=happy;grammaticalFeatures=-degreeType:superlative'. <br> <br> Parameters can be provided in PATH, GET or POST (form or json). The parameters in PATH are overridden by parameters in GET, POST and json (in that order). In PATH, individual options are separated by semicolon and values are separated by commas (where multiple values can be used). <br> <br> The parameters wordform/trueCase/lemma/lexicalCategory also exist in a plural form, taking a lists of items. Examples:
		/// * PATH: /wordforms=happy,happier,happiest
		/// * GET: /?wordforms=happy&wordforms=happier&wordforms=happiest
		/// * POST (json):
		/// ```javascript
		/// {
		/// "wordforms": ["happy", "happier", "happiest"]
		/// }
		/// ```
		/// A mor complex example of retrieving frequencies of multiple lemmas:
		/// ```
		/// {
		/// "lemmas": ["happy", "content", "cheerful", "cheery", "merry", "joyful", "ecstatic"],
		/// "grammaticalFeatures": {
		/// "adjectiveFunctionType": "predicative"
		/// },
		/// "lexicalCategory": "adjective",
		/// "sort": ["lemma", "-frequency"]
		/// }
		/// ```
		/// Some queries with "collate" or "sort" can exceed the 30s timeout, in which case the API will return an error message with status code 503. You mitigate this by providing additional restrictions such as "minFrequency" and "maxFrequency". <br> <br> You can use the parameters "offset" and "limit" to paginate through large result sets. For convenience, the HTTP header "Link" is set on the response to provide links to "first", "self", "next", "prev" and "last" pages of results (depending on the context). For example, if the result set contains 50 results and the parameter "limit" is set to 25, the Links header will contain an URL for the first 25 results and the next 25 results. <br> <br> Some libraries such as python's `requests` can parse the header automatically and offer a convenient way of iterating through the results. For example:
		/// ```python def get_all_results(url):
		/// while url:
		/// r = requests.get(url)
		/// r.raise_for_status()
		/// for item in r.json()['results']:
		/// yield item
		/// url = r.links.get('next', {}).get('url')
		/// ```
		/// 
		/// StatsFrequencyWords_source_langGetByCorpusAndWordformAndTrueCaseAndLemmaAndLexicalCategoryAndGrammaticalFeaturesAndSortAndCollateAndMinFrequencyAndMaxFrequencyAndMinNormalizedFrequencyAndMaxNormalizedFrequencyAndOffsetAndLimit stats/frequency/words/{source_lang}/
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="corpus">For corpora other than 'nmc' (New Monitor Corpus) please contact api@oxforddictionaries.com</param>
		/// <param name="wordform">The written form of the word to look up (preserving case e.g., Book vs book)</param>
		/// <param name="trueCase">The written form of the word to look up with normalised case (Books --> books)</param>
		/// <param name="lemma">The lemma of the word to look up (e.g., Book, booked, books all have the lemma "book")</param>
		/// <param name="lexicalCategory">The lexical category of the word(s) to look up (e.g., adjective or noun)</param>
		/// <param name="grammaticalFeatures">The grammatical features of the word(s) to look up entered as a list of k:v (e.g., degree_type:comparative)</param>
		/// <param name="sort">sort the resulting list by wordform, trueCase, lemma, lexicalCategory, frequency, normalizedFrequency. Descending order is achieved by prepending the value with the minus sign ('-'). Multiple values can be separated by commas (e.g., sort=lexicalCategory,-frequency)</param>
		/// <param name="collate">collate the results by wordform, trueCase, lemma, lexicalCategory. Multiple values can be separated by commas (e.g., collate=trueCase,lemma,lexicalCategory).</param>
		/// <param name="minFrequency">Restrict the query to entries with frequency of at least `minFrequency`</param>
		/// <param name="maxFrequency">Restrict the query to entries with frequency of at most `maxFrequency`</param>
		/// <param name="minNormalizedFrequency">Restrict the query to entries with frequency of at least `minNormalizedFrequency`</param>
		/// <param name="maxNormalizedFrequency">Restrict the query to entries with frequency of at most `maxNormalizedFrequency`</param>
		/// <param name="offset">pagination - results offset</param>
		/// <param name="limit">pagination - results limit</param>
		/// <returns>Successful response.</returns>
		public async Task<StatsWordResultList> StatsFrequencyWords_source_langGetByCorpusAndWordformAndTrueCaseAndLemmaAndLexicalCategoryAndGrammaticalFeaturesAndSortAndCollateAndMinFrequencyAndMaxFrequencyAndMinNormalizedFrequencyAndMaxNormalizedFrequencyAndOffsetAndLimitAsync(
					string source_lang, 
					string corpus, 
					string wordform, 
					string trueCase, 
					string lemma, 
					string lexicalCategory, 
					string grammaticalFeatures, 
					string sort, 
					string collate, 
					long minFrequency, 
					long maxFrequency, 
					float minNormalizedFrequency, 
					float maxNormalizedFrequency, 
					long offset, 
					long limit, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "stats/frequency/words/"+ (source_lang==null? "" : System.Uri.EscapeDataString(source_lang))+"/&corpus=" + (corpus==null? "" : System.Uri.EscapeDataString(corpus))+"&wordform=" + (wordform==null? "" : System.Uri.EscapeDataString(wordform))+"&trueCase=" + (trueCase==null? "" : System.Uri.EscapeDataString(trueCase))+"&lemma=" + (lemma==null? "" : System.Uri.EscapeDataString(lemma))+"&lexicalCategory=" + (lexicalCategory==null? "" : System.Uri.EscapeDataString(lexicalCategory))+"&grammaticalFeatures=" + (grammaticalFeatures==null? "" : System.Uri.EscapeDataString(grammaticalFeatures))+"&sort=" + (sort==null? "" : System.Uri.EscapeDataString(sort))+"&collate=" + (collate==null? "" : System.Uri.EscapeDataString(collate))+"&minFrequency="+minFrequency+"&maxFrequency="+maxFrequency+"&minNormalizedFrequency="+minNormalizedFrequency+"&maxNormalizedFrequency="+maxNormalizedFrequency+"&offset="+offset+"&limit="+limit;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<StatsWordResultList>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve list of words for category with advanced options
		/// Use this to apply more complex filters to the [list of words](documentation/glossary?term=wordlist). For example, you may only want to filter out words for which all [senses](documentation/glossary?term=sense) match the filter, or only its 'prime sense'. You can also filter by word length or match by substring (prefix).
		/// 
		/// <div id="wordlist_advanced"></div>
		/// 
		/// Wordlist_source_lang_filters_advancedGetByExcludeAndExclude_sensesAndExclude_prime_sensesAndWord_lengthAndPrefixAndExactAndLimitAndOffset wordlist/{source_lang}/{filters_advanced}
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="filters_advanced">Semicolon separated list of wordlist parameters, presented as value pairs: LexicalCategory, domains, regions, registers. Parameters can take comma separated list of values. E.g., lexicalCategory=noun,adjective;domains=sport. Number of values limited to 5.</param>
		/// <param name="exclude">Semicolon separated list of parameters-value pairs (same as filters). Excludes headwords that have any senses in specified exclusion attributes (lexical categories, domains, etc.) from results.</param>
		/// <param name="exclude_senses">Semicolon separated list of parameters-value pairs (same as filters). Excludes only those senses of a particular headword that match specified exclusion attributes (lexical categories, domains, etc.) from results but includes the headword if it has other permitted senses.</param>
		/// <param name="exclude_prime_senses">Semicolon separated list of parameters-value pairs (same as filters). Excludes a headword only if the primary sense matches the specified exclusion attributes (registers, domains only).</param>
		/// <param name="word_length">Parameter to speficy the minimum (>), exact or maximum (<) length of the words required. E.g., >5 - more than 5 chars; <4 - less than 4 chars; >5<10 - from 5 to 10 chars; 3 - exactly 3 chars.</param>
		/// <param name="prefix">Filter words that start with prefix parameter</param>
		/// <param name="exact">If exact=true wordlist returns a list of entries that exactly matches the search string. Otherwise wordlist lists entries that start with prefix string.</param>
		/// <param name="limit">Limit the number of results per response. Default and maximum limit is 5000.</param>
		/// <param name="offset">Offset the start number of the result.</param>
		/// <returns>Successful response.</returns>
		public async Task<Wordlist> Wordlist_source_lang_filters_advancedGetByExcludeAndExclude_sensesAndExclude_prime_sensesAndWord_lengthAndPrefixAndExactAndLimitAndOffsetAsync(Search_source_langGetByQAndPrefixAndRegionsAndLimitAndOffsetSource_lang source_lang, string filters_advanced, string exclude, string exclude_senses, string exclude_prime_senses, string word_length, string prefix, Wordlist_source_lang_filters_advancedGetByExcludeAndExclude_sensesAndExclude_prime_sensesAndWord_lengthAndPrefixAndExactAndLimitAndOffsetExact exact, string limit, string offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "wordlist/"+source_lang+"/"+ (filters_advanced==null? "" : System.Uri.EscapeDataString(filters_advanced))+"&exclude=" + (exclude==null? "" : System.Uri.EscapeDataString(exclude))+"&exclude_senses=" + (exclude_senses==null? "" : System.Uri.EscapeDataString(exclude_senses))+"&exclude_prime_senses=" + (exclude_prime_senses==null? "" : System.Uri.EscapeDataString(exclude_prime_senses))+"&word_length=" + (word_length==null? "" : System.Uri.EscapeDataString(word_length))+"&prefix=" + (prefix==null? "" : System.Uri.EscapeDataString(prefix))+"&exact="+exact+"&limit=" + (limit==null? "" : System.Uri.EscapeDataString(limit))+"&offset=" + (offset==null? "" : System.Uri.EscapeDataString(offset));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Wordlist>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Retrieve a list of words in a category
		/// 
		/// Use this to retrieve a [list of words](documentation/glossary?term=wordlist) for particular [domain](documentation/glossary?term=domain), [lexical category](documentation/glossary?term=lexicalcategory), [register](documentation/glossary?term=registers) and/or [region](documentation/glossary?term=regions). View the full list of possible filters using the filters Utility endpoint.  The response only includes [headwords](documentation/glossary?term=headword), not all their possible [inflections](documentation/glossary?term=inflection). If you require a full [wordlist](documentation/glossary?term=wordlist) including [inflected forms](documentation/glossary?term=inflection), contact us and we can help.
		/// 
		/// <div id="wordlist"></div>
		/// 
		/// Wordlist_source_lang_filters_basicGetByLimitAndOffset wordlist/{source_lang}/{filters_basic}
		/// </summary>
		/// <param name="source_lang">IANA language code</param>
		/// <param name="filters_basic">Semicolon separated list of wordlist parameters, presented as value pairs: LexicalCategory, domains, regions, registers. Parameters can take comma separated list of values. E.g., lexicalCategory=noun,adjective;domains=sport. Number of values limited to 5.</param>
		/// <param name="limit">Limit the number of results per response. Default and maximum limit is 5000.</param>
		/// <param name="offset">Offset the start number of the result</param>
		/// <returns>Successful response.</returns>
		public async Task<Wordlist> Wordlist_source_lang_filters_basicGetByLimitAndOffsetAsync(Search_source_langGetByQAndPrefixAndRegionsAndLimitAndOffsetSource_lang source_lang, string filters_basic, string limit, string offset, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "wordlist/"+source_lang+"/"+ (filters_basic==null? "" : System.Uri.EscapeDataString(filters_basic))+"&limit=" + (limit==null? "" : System.Uri.EscapeDataString(limit))+"&offset=" + (offset==null? "" : System.Uri.EscapeDataString(offset));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Wordlist>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Domains_source_domains_language_target_domains_languageGetSource_domains_language
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="nso")]
		nso = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="zu")]
		zu = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ur")]
		ur = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="de")]
		de = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pt")]
		pt = 6,
	}
	
	public enum Domains_source_domains_language_target_domains_languageGetTarget_domains_language
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="nso")]
		nso = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="zu")]
		zu = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ms")]
		ms = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tn")]
		tn = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ro")]
		ro = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="de")]
		de = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pt")]
		pt = 8,
	}
	
	public enum Domains_source_languageGetSource_language
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="nso")]
		nso = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="zu")]
		zu = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hi")]
		hi = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sw")]
		sw = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ur")]
		ur = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="de")]
		de = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pt")]
		pt = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ta")]
		ta = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="gu")]
		gu = 10,
	}
	
	public enum Entries_source_language_word_idSentencesGetSource_language
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 1,
	}
	
	public enum Entries_source_lang_word_idGetSource_lang
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="lv")]
		lv = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hi")]
		hi = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sw")]
		sw = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ta")]
		ta = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="gu")]
		gu = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="fr")]
		fr = 7,
	}
	
	public enum Entries_source_lang_word_idAntonymsGetSource_lang
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
	}
	
	public enum Entries_source_lang_word_idRegions__regionGetRegion
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="gb")]
		gb = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="us")]
		us = 1,
	}
	
	public enum Entries_source_translation_language_word_idTranslations__target_translation_languageGetSource_translation_language
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="nso")]
		nso = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="zu")]
		zu = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ms")]
		ms = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tn")]
		tn = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ur")]
		ur = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="de")]
		de = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pt")]
		pt = 9,
	}
	
	public enum Filters_endpointGetEndpoint
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="entries")]
		entries = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="inflections")]
		inflections = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="translations")]
		translations = 2,
	}
	
	public enum GrammaticalFeatures_source_languageGetSource_language
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="lv")]
		lv = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="nso")]
		nso = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="zu")]
		zu = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ms")]
		ms = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tn")]
		tn = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ur")]
		ur = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hi")]
		hi = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sw")]
		sw = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="de")]
		de = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pt")]
		pt = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ta")]
		ta = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="gu")]
		gu = 13,
	}
	
	public enum Inflections_source_lang_word_id_filtersGetSource_lang
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hi")]
		hi = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="nso")]
		nso = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tn")]
		tn = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="zu")]
		zu = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="de")]
		de = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pt")]
		pt = 7,
	}
	
	public enum LanguagesGetBySourceLanguageAndTargetLanguageSourceLanguage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="lv")]
		lv = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="nso")]
		nso = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="zu")]
		zu = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ms")]
		ms = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tn")]
		tn = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ur")]
		ur = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hi")]
		hi = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sw")]
		sw = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ro")]
		ro = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="de")]
		de = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pt")]
		pt = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ta")]
		ta = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="gu")]
		gu = 15,
	}
	
	public enum LanguagesGetBySourceLanguageAndTargetLanguageTargetLanguage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="lv")]
		lv = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="nso")]
		nso = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="zu")]
		zu = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ms")]
		ms = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tn")]
		tn = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ur")]
		ur = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hi")]
		hi = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sw")]
		sw = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ro")]
		ro = 11,
	}
	
	public enum Registers_source_languageGetSource_language
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hi")]
		hi = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="lv")]
		lv = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ms")]
		ms = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sw")]
		sw = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ur")]
		ur = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="de")]
		de = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pt")]
		pt = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ta")]
		ta = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="gu")]
		gu = 11,
	}
	
	public enum Registers_source_register_language_target_register_languageGetSource_register_language
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ms")]
		ms = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ur")]
		ur = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="de")]
		de = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pt")]
		pt = 6,
	}
	
	public enum Registers_source_register_language_target_register_languageGetTarget_register_language
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="nso")]
		nso = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="zu")]
		zu = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ms")]
		ms = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="id")]
		id = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="tn")]
		tn = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ro")]
		ro = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="de")]
		de = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="pt")]
		pt = 9,
	}
	
	public enum Search_source_langGetByQAndPrefixAndRegionsAndLimitAndOffsetSource_lang
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="en")]
		en = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="es")]
		es = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="hi")]
		hi = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="lv")]
		lv = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="sw")]
		sw = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ta")]
		ta = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="gu")]
		gu = 6,
	}
	
	public enum Search_source_langGetByQAndPrefixAndRegionsAndLimitAndOffsetPrefix
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false")]
		_false = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="true")]
		_true = 1,
	}
	
	public enum Search_source_search_languageTranslations__target_search_languageGetByQAndPrefixAndRegionsAndLimitAndOffsetPrefix
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false")]
		_false = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="true")]
		_true = 1,
	}
	
	public enum Wordlist_source_lang_filters_advancedGetByExcludeAndExclude_sensesAndExclude_prime_sensesAndWord_lengthAndPrefixAndExactAndLimitAndOffsetExact
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="false")]
		_false = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="true")]
		_true = 1,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
