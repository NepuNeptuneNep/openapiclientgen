//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Metric on a particular delivery error type.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeliveryError
	{
		
		/// <summary>
		/// The class of delivery error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorClass")]
		public System.Nullable<DeliveryErrorErrorClass> ErrorClass { get; set; }
		
		/// <summary>
		/// The ratio of messages where the error occurred vs all authenticated traffic.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorRatio")]
		public System.Nullable<System.Double> ErrorRatio { get; set; }
		
		/// <summary>
		/// The type of delivery error.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errorType")]
		public System.Nullable<DeliveryErrorErrorType> ErrorType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DeliveryErrorErrorClass
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELIVERY_ERROR_CLASS_UNSPECIFIED")]
		DELIVERY_ERROR_CLASS_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PERMANENT_ERROR")]
		PERMANENT_ERROR = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TEMPORARY_ERROR")]
		TEMPORARY_ERROR = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DeliveryErrorErrorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELIVERY_ERROR_TYPE_UNSPECIFIED")]
		DELIVERY_ERROR_TYPE_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="RATE_LIMIT_EXCEEDED")]
		RATE_LIMIT_EXCEEDED = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SUSPECTED_SPAM")]
		SUSPECTED_SPAM = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CONTENT_SPAMMY")]
		CONTENT_SPAMMY = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BAD_ATTACHMENT")]
		BAD_ATTACHMENT = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BAD_DMARC_POLICY")]
		BAD_DMARC_POLICY = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LOW_IP_REPUTATION")]
		LOW_IP_REPUTATION = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LOW_DOMAIN_REPUTATION")]
		LOW_DOMAIN_REPUTATION = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="IP_IN_RBL")]
		IP_IN_RBL = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DOMAIN_IN_RBL")]
		DOMAIN_IN_RBL = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BAD_PTR_RECORD")]
		BAD_PTR_RECORD = 10,
	}
	
	/// <summary>
	/// A registered domain resource in the Postmaster API.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Domain
	{
		
		/// <summary>
		/// Timestamp when the user registered this domain. Assigned by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="createTime")]
		public string CreateTime { get; set; }
		
		/// <summary>
		/// The resource name of the Domain. Domain names have the form `domains/{domain_name}`, where domain_name is the fully qualified domain name (i.e., mymail.mydomain.com).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Userâ€™s permission for this domain. Assigned by the server.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="permission")]
		public System.Nullable<DomainPermission> Permission { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum DomainPermission
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PERMISSION_UNSPECIFIED")]
		PERMISSION_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="OWNER")]
		OWNER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="READER")]
		READER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="NONE")]
		NONE = 3,
	}
	
	/// <summary>
	/// [Feedback loop](https://support.google.com/mail/answer/6254652) identifier information.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FeedbackLoop
	{
		
		/// <summary>
		/// Feedback loop identifier that uniquely identifies individual campaigns.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// The ratio of user marked spam messages with the identifier vs the total number of inboxed messages with that identifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spamRatio")]
		public System.Nullable<System.Double> SpamRatio { get; set; }
	}
	
	/// <summary>
	/// IP Reputation information for a set of IPs in a specific reputation category.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class IpReputation
	{
		
		/// <summary>
		/// Total number of unique IPs in this reputation category. This metric only pertains to traffic that passed [SPF](http://www.openspf.org/) or [DKIM](http://www.dkim.org/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipCount")]
		public string IpCount { get; set; }
		
		/// <summary>
		/// The reputation category this IP reputation represents.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="reputation")]
		public System.Nullable<IpReputationReputation> Reputation { get; set; }
		
		/// <summary>
		/// A sample of IPs in this reputation category.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sampleIps")]
		public string[] SampleIps { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum IpReputationReputation
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REPUTATION_CATEGORY_UNSPECIFIED")]
		REPUTATION_CATEGORY_UNSPECIFIED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HIGH")]
		HIGH = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MEDIUM")]
		MEDIUM = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LOW")]
		LOW = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BAD")]
		BAD = 4,
	}
	
	/// <summary>
	/// Response message for ListDomains.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListDomainsResponse
	{
		
		/// <summary>
		/// The list of domains.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domains")]
		public Domain[] Domains { get; set; }
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
	}
	
	/// <summary>
	/// Response message for ListTrafficStats.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTrafficStatsResponse
	{
		
		/// <summary>
		/// Token to retrieve the next page of results, or empty if there are no more results in the list.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="nextPageToken")]
		public string NextPageToken { get; set; }
		
		/// <summary>
		/// The list of TrafficStats.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="trafficStats")]
		public TrafficStats[] TrafficStats { get; set; }
	}
	
	/// <summary>
	/// Email traffic statistics pertaining to a specific date.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TrafficStats
	{
		
		/// <summary>
		/// Delivery errors for the domain. This metric only pertains to traffic that passed [SPF](http://www.openspf.org/) or [DKIM](http://www.dkim.org/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="deliveryErrors")]
		public DeliveryError[] DeliveryErrors { get; set; }
		
		/// <summary>
		/// The ratio of mail that successfully authenticated with DKIM vs. all mail that attempted to authenticate with [DKIM](http://www.dkim.org/). Spoofed mail is excluded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dkimSuccessRatio")]
		public System.Nullable<System.Double> DkimSuccessRatio { get; set; }
		
		/// <summary>
		/// The ratio of mail that passed [DMARC](https://dmarc.org/) alignment checks vs all mail received from the domain that successfully authenticated with either of [SPF](http://www.openspf.org/) or [DKIM](http://www.dkim.org/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dmarcSuccessRatio")]
		public System.Nullable<System.Double> DmarcSuccessRatio { get; set; }
		
		/// <summary>
		/// Reputation of the domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="domainReputation")]
		public IpReputationReputation DomainReputation { get; set; }
		
		/// <summary>
		/// The ratio of incoming mail (to Gmail), that passed secure transport (TLS) vs all mail received from that domain. This metric only pertains to traffic that passed [SPF](http://www.openspf.org/) or [DKIM](http://www.dkim.org/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="inboundEncryptionRatio")]
		public System.Nullable<System.Double> InboundEncryptionRatio { get; set; }
		
		/// <summary>
		/// Reputation information pertaining to the IP addresses of the email servers for the domain. There is exactly one entry for each reputation category except REPUTATION_CATEGORY_UNSPECIFIED.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ipReputations")]
		public IpReputation[] IpReputations { get; set; }
		
		/// <summary>
		/// The resource name of the traffic statistics. Traffic statistic names have the form `domains/{domain}/trafficStats/{date}`, where domain_name is the fully qualified domain name (i.e., mymail.mydomain.com) of the domain this traffic statistics pertains to and date is the date in yyyymmdd format that these statistics corresponds to. For example: domains/mymail.mydomain.com/trafficStats/20160807
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The ratio of outgoing mail (from Gmail) that was accepted over secure transport (TLS).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="outboundEncryptionRatio")]
		public System.Nullable<System.Double> OutboundEncryptionRatio { get; set; }
		
		/// <summary>
		/// Spammy [Feedback loop identifiers] (https://support.google.com/mail/answer/6254652) with their individual spam rates. This metric only pertains to traffic that is authenticated by [DKIM](http://www.dkim.org/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spammyFeedbackLoops")]
		public FeedbackLoop[] SpammyFeedbackLoops { get; set; }
		
		/// <summary>
		/// The ratio of mail that successfully authenticated with SPF vs. all mail that attempted to authenticate with [SPF](http://www.openspf.org/). Spoofed mail is excluded.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="spfSuccessRatio")]
		public System.Nullable<System.Double> SpfSuccessRatio { get; set; }
		
		/// <summary>
		/// The ratio of user-report spam vs. email that was sent to the inbox. This is potentially inexact -- users may want to refer to the description of the interval fields userReportedSpamRatioLowerBound and userReportedSpamRatioUpperBound for more explicit accuracy guarantees. This metric only pertains to emails authenticated by [DKIM](http://www.dkim.org/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userReportedSpamRatio")]
		public System.Nullable<System.Double> UserReportedSpamRatio { get; set; }
		
		/// <summary>
		/// The lower bound of the confidence interval for the user reported spam ratio. If this field is set, then the value of userReportedSpamRatio is set to the midpoint of this interval and is thus inexact. However, the true ratio is guaranteed to be in between this lower bound and the corresponding upper bound 95% of the time. This metric only pertains to emails authenticated by [DKIM](http://www.dkim.org/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userReportedSpamRatioLowerBound")]
		public System.Nullable<System.Double> UserReportedSpamRatioLowerBound { get; set; }
		
		/// <summary>
		/// The upper bound of the confidence interval for the user reported spam ratio. If this field is set, then the value of userReportedSpamRatio is set to the midpoint of this interval and is thus inexact. However, the true ratio is guaranteed to be in between this upper bound and the corresponding lower bound 95% of the time. This metric only pertains to emails authenticated by [DKIM](http://www.dkim.org/).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="userReportedSpamRatioUpperBound")]
		public System.Nullable<System.Double> UserReportedSpamRatioUpperBound { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Lists the domains that have been registered by the client. The order of domains in the response is unspecified and non-deterministic. Newly created domains will not necessarily be added to the end of this list.
		/// Gmailpostmastertools_domains_list v1/domains
		/// </summary>
		/// <param name="pageSize">Requested page size. Server may return fewer domains than requested. If unspecified, server will pick an appropriate default.</param>
		/// <param name="pageToken">The next_page_token value returned from a previous List request, if any. This is the value of ListDomainsResponse.next_page_token returned from the previous call to `ListDomains` method.</param>
		/// <returns>Successful response</returns>
		public async Task<ListDomainsResponse> Gmailpostmastertools_domains_listAsync(int pageSize, string pageToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/domains?pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListDomainsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get traffic statistics for a domain on a specific date. Returns PERMISSION_DENIED if user does not have permission to access TrafficStats for the domain.
		/// Gmailpostmastertools_domains_trafficStats_get v1/{name}
		/// </summary>
		/// <param name="name">The resource name of the traffic statistics to get. E.g., domains/mymail.mydomain.com/trafficStats/20160807.</param>
		/// <returns>Successful response</returns>
		public async Task<TrafficStats> Gmailpostmastertools_domains_trafficStats_getAsync(string name, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (name==null? "" : System.Uri.EscapeDataString(name));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<TrafficStats>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List traffic statistics for all available days. Returns PERMISSION_DENIED if user does not have permission to access TrafficStats for the domain.
		/// Gmailpostmastertools_domains_trafficStats_list v1/{parent}/trafficStats
		/// </summary>
		/// <param name="parent">The resource name of the domain whose traffic statistics we'd like to list. It should have the form `domains/{domain_name}`, where domain_name is the fully qualified domain name.</param>
		/// <param name="endDate_day">Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.</param>
		/// <param name="endDate_month">Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.</param>
		/// <param name="endDate_year">Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.</param>
		/// <param name="pageSize">Requested page size. Server may return fewer TrafficStats than requested. If unspecified, server will pick an appropriate default.</param>
		/// <param name="pageToken">The next_page_token value returned from a previous List request, if any. This is the value of ListTrafficStatsResponse.next_page_token returned from the previous call to `ListTrafficStats` method.</param>
		/// <param name="startDate_day">Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.</param>
		/// <param name="startDate_month">Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.</param>
		/// <param name="startDate_year">Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.</param>
		/// <returns>Successful response</returns>
		public async Task<ListTrafficStatsResponse> Gmailpostmastertools_domains_trafficStats_listAsync(string parent, int endDate_day, int endDate_month, int endDate_year, int pageSize, string pageToken, int startDate_day, int startDate_month, int startDate_year, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/"+ (parent==null? "" : System.Uri.EscapeDataString(parent))+"/trafficStats&endDate.day="+endDate_day+"&endDate.month="+endDate_month+"&endDate.year="+endDate_year+"&pageSize="+pageSize+"&pageToken=" + (pageToken==null? "" : System.Uri.EscapeDataString(pageToken))+"&startDate.day="+startDate_day+"&startDate.month="+startDate_month+"&startDate.year="+startDate_year;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTrafficStatsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
