//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using System.Text.Json;
	using System.Text.Json.Serialization;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// A source actor catalog with the timestamp it was mostly recently updated
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ActorCatalogWithUpdatedAt
	{
		
		[System.Runtime.Serialization.DataMember(Name="catalog")]
		public string Catalog { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.Nullable<System.Int64> UpdatedAt { get; set; }
	}
	
	/// <summary>
	/// actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ActorDefinitionResourceRequirements
	{
		
		/// <summary>
		/// optional resource requirements to run workers (blank for unbounded allocations)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="default")]
		public ResourceRequirements Default { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="jobSpecific")]
		public JobTypeResourceLimit[] JobSpecific { get; set; }
	}
	
	/// <summary>
	/// optional resource requirements to run workers (blank for unbounded allocations)
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResourceRequirements
	{
		
		[System.Runtime.Serialization.DataMember(Name="cpu_limit")]
		public string Cpu_limit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cpu_request")]
		public string Cpu_request { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="memory_limit")]
		public string Memory_limit { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="memory_request")]
		public string Memory_request { get; set; }
	}
	
	/// <summary>
	/// sets resource requirements for a specific job type for an actor definition. these values override the default, if both are set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobTypeResourceLimit
	{
		
		/// <summary>
		/// enum that describes the different types of jobs that the platform runs.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobType")]
		public JobTypeResourceLimitJobType JobType { get; set; }
		
		/// <summary>
		/// optional resource requirements to run workers (blank for unbounded allocations)
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ResourceRequirements ResourceRequirements { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum JobTypeResourceLimitJobType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		get_spec = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		check_connection = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		discover_schema = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sync = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reset_connection = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		connection_updater = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		replicate = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AdvancedAuth
	{
		
		[System.Runtime.Serialization.DataMember(Name="authFlowType")]
		public System.Nullable<AdvancedAuthAuthFlowType> AuthFlowType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="oauthConfigSpecification")]
		public OAuthConfigSpecification OauthConfigSpecification { get; set; }
		
		/// <summary>
		/// Json Path to a field in the connectorSpecification that should exist for the advanced auth to be applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="predicateKey")]
		public string[] PredicateKey { get; set; }
		
		/// <summary>
		/// Value of the predicate_key fields for the advanced auth to be applicable.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="predicateValue")]
		public string PredicateValue { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AdvancedAuthAuthFlowType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="oauth2.0")]
		oauth2_0 = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="oauth1.0")]
		oauth1_0 = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OAuthConfigSpecification
	{
		
		/// <summary>
		/// The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completeOAuthOutputSpecification")]
		public OAuthConfiguration CompleteOAuthOutputSpecification { get; set; }
		
		/// <summary>
		/// The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completeOAuthServerInputSpecification")]
		public OAuthConfiguration CompleteOAuthServerInputSpecification { get; set; }
		
		/// <summary>
		/// The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="completeOAuthServerOutputSpecification")]
		public OAuthConfiguration CompleteOAuthServerOutputSpecification { get; set; }
		
		/// <summary>
		/// The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauthUserInputFromConnectorConfigSpecification")]
		public OAuthConfiguration OauthUserInputFromConnectorConfigSpecification { get; set; }
	}
	
	/// <summary>
	/// describes the available schema (catalog).
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AirbyteCatalog
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streams")]
		public AirbyteStreamAndConfiguration[] Streams { get; set; }
	}
	
	/// <summary>
	/// each stream is split in two parts; the immutable schema from source and mutable configuration for destination
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AirbyteStreamAndConfiguration
	{
		
		/// <summary>
		/// the mutable part of the stream to configure the destination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="config")]
		public AirbyteStreamConfiguration Config { get; set; }
		
		/// <summary>
		/// the immutable schema defined by the source
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stream")]
		public AirbyteStream Stream { get; set; }
	}
	
	/// <summary>
	/// the mutable part of the stream to configure the destination
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AirbyteStreamConfiguration
	{
		
		/// <summary>
		/// Alias name to the stream to be used in the destination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="aliasName")]
		public string AliasName { get; set; }
		
		/// <summary>
		/// Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental`. Otherwise it is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="cursorField")]
		public string[] CursorField { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationSyncMode")]
		public AirbyteStreamConfigurationDestinationSyncMode DestinationSyncMode { get; set; }
		
		/// <summary>
		/// Whether field selection should be enabled. If this is true, only the properties in `selectedFields` will be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="fieldSelectionEnabled")]
		public System.Nullable<System.Boolean> FieldSelectionEnabled { get; set; }
		
		/// <summary>
		/// Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup`. Otherwise it is ignored.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="primaryKey")]
		public string[] PrimaryKey { get; set; }
		
		/// <summary>
		/// If this is true, the stream is selected with all of its properties. For new connections, this considers if the stream is suggested or not
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selected")]
		public System.Nullable<System.Boolean> Selected { get; set; }
		
		/// <summary>
		/// Paths to the fields that will be included in the configured catalog. This must be set if `fieldSelectedEnabled` is set. An empty list indicates that no properties will be included.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="selectedFields")]
		public SelectedFieldInfo[] SelectedFields { get; set; }
		
		/// <summary>
		/// Does the connector suggest that this stream be enabled by default?
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="suggested")]
		public System.Nullable<System.Boolean> Suggested { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="syncMode")]
		public AirbyteStreamConfigurationSyncMode SyncMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AirbyteStreamConfigurationDestinationSyncMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		append = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		overwrite = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		append_dedup = 2,
	}
	
	/// <summary>
	/// Path to a field/column/property in a stream to be selected. For example, if the field to be selected is a database column called "foo", this will be ["foo"]. Use multiple path elements for nested schemas.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SelectedFieldInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="fieldPath")]
		public string[] FieldPath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AirbyteStreamConfigurationSyncMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full_refresh = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		incremental = 1,
	}
	
	/// <summary>
	/// the immutable schema defined by the source
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AirbyteStream
	{
		
		/// <summary>
		/// Path to the field that will be used to determine if a record is new or modified since the last sync. If not provided by the source, the end user will have to specify the comparable themselves.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultCursorField")]
		public string[] DefaultCursorField { get; set; }
		
		/// <summary>
		/// Stream schema using Json Schema specs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="jsonSchema")]
		public StreamJsonSchema JsonSchema { get; set; }
		
		/// <summary>
		/// Stream's name.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Optional Source-defined namespace. Airbyte streams from the same sources should have the same namespace. Currently only used by JDBC destinations to determine what schema to write to.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespace")]
		public string Namespace { get; set; }
		
		/// <summary>
		/// If the source defines the cursor field, then any other cursor field inputs will be ignored. If it does not, either the user_provided one is used, or the default one is used as a backup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDefinedCursor")]
		public System.Nullable<System.Boolean> SourceDefinedCursor { get; set; }
		
		/// <summary>
		/// If the source defines the primary key, paths to the fields that will be used as a primary key. If not provided by the source, the end user will have to specify the primary key themselves.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sourceDefinedPrimaryKey")]
		public string[] SourceDefinedPrimaryKey { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="supportedSyncModes")]
		public SyncMode[] SupportedSyncModes { get; set; }
	}
	
	/// <summary>
	/// Stream schema using Json Schema specs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamJsonSchema
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SyncMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		full_refresh = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		incremental = 1,
	}
	
	/// <summary>
	/// Indicates where the error originated. If not set, the origin of error is not well known.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AttemptFailureOrigin
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		source = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		destination = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		replication = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		persistence = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		normalization = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dbt = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		airbyte_platform = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		unknown = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AttemptFailureReason
	{
		
		[System.Runtime.Serialization.DataMember(Name="externalMessage")]
		public string ExternalMessage { get; set; }
		
		/// <summary>
		/// Indicates where the error originated. If not set, the origin of error is not well known.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failureOrigin")]
		public AttemptFailureOrigin FailureOrigin { get; set; }
		
		/// <summary>
		/// Categorizes well known errors into types for programmatic handling. If not set, the type of error is not well known.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="failureType")]
		public System.Nullable<AttemptFailureReasonFailureType> FailureType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="internalMessage")]
		public string InternalMessage { get; set; }
		
		/// <summary>
		/// True if it is known that retrying may succeed, e.g. for a transient failure. False if it is known that a retry will not succeed, e.g. for a configuration issue. If not set, retryable status is not well known.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="retryable")]
		public System.Nullable<System.Boolean> Retryable { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stacktrace")]
		public string Stacktrace { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timestamp")]
		public long Timestamp { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AttemptFailureReasonFailureType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		config_error = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		system_error = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		manual_cancellation = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		refresh_schema = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AttemptFailureSummary
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="failures")]
		public AttemptFailureReason[] Failures { get; set; }
		
		/// <summary>
		/// True if the number of committed records for this attempt was greater than 0. False if 0 records were committed. If not set, the number of committed records is unknown.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="partialSuccess")]
		public System.Nullable<System.Boolean> PartialSuccess { get; set; }
	}
	
	/// <summary>
	/// Categorizes well known errors into types for programmatic handling. If not set, the type of error is not well known.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AttemptFailureType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		config_error = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		system_error = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		manual_cancellation = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		refresh_schema = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AttemptInfoRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="attempt")]
		public AttemptRead Attempt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logs")]
		public LogRead Logs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AttemptRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="bytesSynced")]
		public System.Nullable<System.Int64> BytesSynced { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public long CreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="endedAt")]
		public System.Nullable<System.Int64> EndedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="failureSummary")]
		public AttemptFailureSummary FailureSummary { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public long Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordsSynced")]
		public System.Nullable<System.Int64> RecordsSynced { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public AttemptReadStatus Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamStats")]
		public AttemptStreamStats[] StreamStats { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="totalStats")]
		public AttemptStats TotalStats { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public long UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AttemptReadStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		succeeded = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AttemptStreamStats
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stats")]
		public AttemptStats Stats { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streamName")]
		public string StreamName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamNamespace")]
		public string StreamNamespace { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AttemptStats
	{
		
		[System.Runtime.Serialization.DataMember(Name="bytesEmitted")]
		public System.Nullable<System.Int64> BytesEmitted { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="estimatedBytes")]
		public System.Nullable<System.Int64> EstimatedBytes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="estimatedRecords")]
		public System.Nullable<System.Int64> EstimatedRecords { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordsCommitted")]
		public System.Nullable<System.Int64> RecordsCommitted { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordsEmitted")]
		public System.Nullable<System.Int64> RecordsEmitted { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="stateMessagesEmitted")]
		public System.Nullable<System.Int64> StateMessagesEmitted { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LogRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logLines")]
		public string[] LogLines { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AttemptNormalizationStatusRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="attemptNumber")]
		public System.Nullable<System.Int32> AttemptNumber { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hasNormalizationFailed")]
		public System.Nullable<System.Boolean> HasNormalizationFailed { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="hasRecordsCommitted")]
		public System.Nullable<System.Boolean> HasRecordsCommitted { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="recordsCommitted")]
		public System.Nullable<System.Int64> RecordsCommitted { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AttemptNormalizationStatusReadList
	{
		
		[System.Runtime.Serialization.DataMember(Name="attemptNormalizationStatuses")]
		public AttemptNormalizationStatusRead[] AttemptNormalizationStatuses { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AttemptStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		succeeded = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AttemptSyncConfig
	{
		
		/// <summary>
		/// The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationConfiguration")]
		public DestinationConfiguration DestinationConfiguration { get; set; }
		
		/// <summary>
		/// The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceConfiguration")]
		public SourceConfiguration SourceConfiguration { get; set; }
		
		/// <summary>
		/// Contains the state for a connection. The stateType field identifies what type of state it is. Only the field corresponding to that type will be set, the rest will be null. If stateType=not_set, then none of the fields will be set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="state")]
		public ConnectionState State { get; set; }
	}
	
	/// <summary>
	/// Contains the state for a connection. The stateType field identifies what type of state it is. Only the field corresponding to that type will be set, the rest will be null. If stateType=not_set, then none of the fields will be set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConnectionState
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="globalState")]
		public GlobalState GlobalState { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="state")]
		public StateBlob State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stateType")]
		public ConnectionStateStateType StateType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamState")]
		public StreamState[] StreamState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class GlobalState
	{
		
		[System.Runtime.Serialization.DataMember(Name="shared_state")]
		public StateBlob Shared_state { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streamStates")]
		public StreamState[] StreamStates { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StateBlob
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamState
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streamDescriptor")]
		public StreamDescriptor StreamDescriptor { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamState")]
		public StateBlob StreamState1 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamDescriptor
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="namespace")]
		public string Namespace { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionStateStateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		global = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stream = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		legacy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_set = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class AuthSpecification
	{
		
		[System.Runtime.Serialization.DataMember(Name="auth_type")]
		public System.Nullable<AuthSpecificationAuth_type> Auth_type { get; set; }
		
		/// <summary>
		/// An object containing any metadata needed to describe this connector's Oauth flow
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauth2Specification")]
		public OAuth2Specification Oauth2Specification { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum AuthSpecificationAuth_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="oauth2.0")]
		oauth2_0 = 0,
	}
	
	/// <summary>
	/// An object containing any metadata needed to describe this connector's Oauth flow
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OAuth2Specification
	{
		
		/// <summary>
		/// Pointers to the fields in the rootObject needed to obtain the initial refresh/access tokens for the OAuth flow. Each inner array represents the path in the rootObject of the referenced field. For example. Assume the rootObject contains params 'app_secret', 'app_id' which are needed to get the initial refresh token. If they are not nested in the rootObject, then the array would look like this [['app_secret'], ['app_id']] If they are nested inside an object called 'auth_params' then this array would be [['auth_params', 'app_secret'], ['auth_params', 'app_id']]
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="oauthFlowInitParameters")]
		public string[] OauthFlowInitParameters { get; set; }
		
		/// <summary>
		/// Pointers to the fields in the rootObject which can be populated from successfully completing the oauth flow using the init parameters. This is typically a refresh/access token. Each inner array represents the path in the rootObject of the referenced field.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="oauthFlowOutputParameters")]
		public string[] OauthFlowOutputParameters { get; set; }
		
		/// <summary>
		/// A list of strings representing a pointer to the root object which contains any oauth parameters in the ConnectorSpecification.
		///Examples:
		///if oauth parameters were contained inside the top level, rootObject=[] If they were nested inside another object {'credentials': {'app_id' etc...}, rootObject=['credentials'] If they were inside a oneOf {'switch': {oneOf: [{client_id...}, {non_oauth_param]}},  rootObject=['switch', 0] 
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rootObject")]
		public string[] RootObject { get; set; }
	}
	
	/// <summary>
	/// Describes the difference between two Airbyte catalogs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CatalogDiff
	{
		
		/// <summary>
		/// list of stream transformations. order does not matter.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transforms")]
		public StreamTransform[] Transforms { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class StreamTransform
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="streamDescriptor")]
		public StreamDescriptor StreamDescriptor { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transformType")]
		public StreamTransformTransformType TransformType { get; set; }
		
		/// <summary>
		/// list of field transformations. order does not matter.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="updateStream")]
		public FieldTransform[] UpdateStream { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum StreamTransformTransformType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		add_stream = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		remove_stream = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		update_stream = 2,
	}
	
	/// <summary>
	/// Describes the difference between two Streams.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FieldTransform
	{
		
		[System.Runtime.Serialization.DataMember(Name="addField")]
		public FieldAdd AddField { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="breaking")]
		public bool Breaking { get; set; }
		
		/// <summary>
		/// A field name is a list of strings that form the path to the field.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fieldName")]
		public string[] FieldName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="removeField")]
		public FieldRemove RemoveField { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="transformType")]
		public FieldTransformTransformType TransformType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="updateFieldSchema")]
		public FieldSchemaUpdate UpdateFieldSchema { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FieldAdd
	{
		
		/// <summary>
		/// JSONSchema representation of the field
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public FieldSchema Schema { get; set; }
	}
	
	/// <summary>
	/// JSONSchema representation of the field
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FieldSchema
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FieldRemove
	{
		
		/// <summary>
		/// JSONSchema representation of the field
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schema")]
		public FieldSchema Schema { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum FieldTransformTransformType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		add_field = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		remove_field = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		update_field_schema = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class FieldSchemaUpdate
	{
		
		/// <summary>
		/// JSONSchema representation of the field
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="newSchema")]
		public FieldSchema NewSchema { get; set; }
		
		/// <summary>
		/// JSONSchema representation of the field
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="oldSchema")]
		public FieldSchema OldSchema { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CheckConnectionRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobInfo")]
		public SynchronousJobRead JobInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public CheckConnectionReadStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SynchronousJobRead
	{
		
		/// <summary>
		/// only present if a config id was provided.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configId")]
		public string ConfigId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configType")]
		public SynchronousJobReadConfigType ConfigType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="connectorConfigurationUpdated")]
		public System.Nullable<System.Boolean> ConnectorConfigurationUpdated { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public long CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="endedAt")]
		public long EndedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="logs")]
		public LogRead Logs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="succeeded")]
		public bool Succeeded { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SynchronousJobReadConfigType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		check_connection_source = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		check_connection_destination = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		discover_schema = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		get_spec = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sync = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reset_connection = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum CheckConnectionReadStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		succeeded = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CheckOperationRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public CheckConnectionReadStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CompleteDestinationOAuthRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		/// <summary>
		/// The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oAuthInputConfiguration")]
		public OAuthConfiguration OAuthInputConfiguration { get; set; }
		
		/// <summary>
		/// The query parameters present in the redirect URL after a user granted consent e.g auth code
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryParams")]
		public string QueryParams { get; set; }
		
		/// <summary>
		/// When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectUrl")]
		public string RedirectUrl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CompleteOAuthResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CompleteSourceOauthRequest
	{
		
		/// <summary>
		/// The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oAuthInputConfiguration")]
		public OAuthConfiguration OAuthInputConfiguration { get; set; }
		
		/// <summary>
		/// The query parameters present in the redirect URL after a user granted consent e.g auth code
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="queryParams")]
		public string QueryParams { get; set; }
		
		/// <summary>
		/// When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="redirectUrl")]
		public string RedirectUrl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConnectionCreate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="geography")]
		public System.Nullable<ConnectionCreateGeography> Geography { get; set; }
		
		/// <summary>
		/// Optional name of the connection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Method used for computing final namespace in destination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceDefinition")]
		public System.Nullable<ConnectionCreateNamespaceDefinition> NamespaceDefinition { get; set; }
		
		/// <summary>
		/// Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceFormat")]
		public string NamespaceFormat { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nonBreakingChangesPreference")]
		public System.Nullable<ConnectionCreateNonBreakingChangesPreference> NonBreakingChangesPreference { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notifySchemaChanges")]
		public System.Nullable<System.Boolean> NotifySchemaChanges { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operationIds")]
		public string[] OperationIds { get; set; }
		
		/// <summary>
		/// Prefix that will be prepended to the name of each stream when it is written to the destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// optional resource requirements to run workers (blank for unbounded allocations)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ResourceRequirements ResourceRequirements { get; set; }
		
		/// <summary>
		/// if null, then no schedule is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public ConnectionSchedule Schedule { get; set; }
		
		/// <summary>
		/// schedule for when the the connection should run, per the schedule type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleData")]
		public ConnectionScheduleData ScheduleData { get; set; }
		
		/// <summary>
		/// determine how the schedule data should be interpreted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleType")]
		public System.Nullable<ConnectionCreateScheduleType> ScheduleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceCatalogId")]
		public string SourceCatalogId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ConnectionCreateStatus Status { get; set; }
		
		/// <summary>
		/// describes the available schema (catalog).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncCatalog")]
		public AirbyteCatalog SyncCatalog { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionCreateGeography
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		auto = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		us = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eu = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionCreateNamespaceDefinition
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		source = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		destination = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		customformat = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionCreateNonBreakingChangesPreference
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disable = 1,
	}
	
	/// <summary>
	/// if null, then no schedule is set.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConnectionSchedule
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeUnit")]
		public ConnectionScheduleTimeUnit TimeUnit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="units")]
		public long Units { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionScheduleTimeUnit
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		minutes = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		hours = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		days = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		weeks = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		months = 4,
	}
	
	/// <summary>
	/// schedule for when the the connection should run, per the schedule type
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConnectionScheduleData
	{
		
		[System.Runtime.Serialization.DataMember(Name="basicSchedule")]
		public ConnectionScheduleDataBasicSchedule BasicSchedule { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="cron")]
		public ConnectionScheduleDataCron Cron { get; set; }
	}
	
	public class ConnectionScheduleDataBasicSchedule
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="timeUnit")]
		public ConnectionScheduleTimeUnit TimeUnit { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="units")]
		public long Units { get; set; }
	}
	
	public class ConnectionScheduleDataCron
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cronExpression")]
		public string CronExpression { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="cronTimeZone")]
		public string CronTimeZone { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionCreateScheduleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		manual = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		basic = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cron = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionCreateStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		inactive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deprecated = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConnectionIdRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConnectionRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="breakingChange")]
		public bool BreakingChange { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="geography")]
		public ConnectionCreateGeography Geography { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Method used for computing final namespace in destination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceDefinition")]
		public ConnectionCreateNamespaceDefinition NamespaceDefinition { get; set; }
		
		/// <summary>
		/// Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceFormat")]
		public string NamespaceFormat { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nonBreakingChangesPreference")]
		public ConnectionCreateNonBreakingChangesPreference NonBreakingChangesPreference { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notifySchemaChanges")]
		public System.Nullable<System.Boolean> NotifySchemaChanges { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operationIds")]
		public string[] OperationIds { get; set; }
		
		/// <summary>
		/// Prefix that will be prepended to the name of each stream when it is written to the destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// optional resource requirements to run workers (blank for unbounded allocations)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ResourceRequirements ResourceRequirements { get; set; }
		
		/// <summary>
		/// if null, then no schedule is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public ConnectionSchedule Schedule { get; set; }
		
		/// <summary>
		/// schedule for when the the connection should run, per the schedule type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleData")]
		public ConnectionScheduleData ScheduleData { get; set; }
		
		/// <summary>
		/// determine how the schedule data should be interpreted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleType")]
		public ConnectionCreateScheduleType ScheduleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceCatalogId")]
		public string SourceCatalogId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ConnectionCreateStatus Status { get; set; }
		
		/// <summary>
		/// describes the available schema (catalog).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="syncCatalog")]
		public AirbyteCatalog SyncCatalog { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConnectionReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connections")]
		public ConnectionRead[] Connections { get; set; }
	}
	
	/// <summary>
	/// determine how the schedule data should be interpreted
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionScheduleType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		manual = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		basic = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cron = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConnectionSearch
	{
		
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public DestinationSearch Destination { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Method used for computing final namespace in destination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceDefinition")]
		public ConnectionCreateNamespaceDefinition NamespaceDefinition { get; set; }
		
		/// <summary>
		/// Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceFormat")]
		public string NamespaceFormat { get; set; }
		
		/// <summary>
		/// Prefix that will be prepended to the name of each stream when it is written to the destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// if null, then no schedule is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public ConnectionSchedule Schedule { get; set; }
		
		/// <summary>
		/// schedule for when the the connection should run, per the schedule type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleData")]
		public ConnectionScheduleData ScheduleData { get; set; }
		
		/// <summary>
		/// determine how the schedule data should be interpreted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleType")]
		public ConnectionCreateScheduleType ScheduleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="source")]
		public SourceSearch Source { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ConnectionCreateStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationSearch
	{
		
		/// <summary>
		/// The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public DestinationConfiguration ConnectionConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destinationName")]
		public string DestinationName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceSearch
	{
		
		/// <summary>
		/// The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public SourceConfiguration ConnectionConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceName")]
		public string SourceName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConnectionStateCreateOrUpdate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		/// <summary>
		/// Contains the state for a connection. The stateType field identifies what type of state it is. Only the field corresponding to that type will be set, the rest will be null. If stateType=not_set, then none of the fields will be set.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionState")]
		public ConnectionState ConnectionState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionStateType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		global = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		stream = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		legacy = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		not_set = 3,
	}
	
	/// <summary>
	/// Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ConnectionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		active = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		inactive = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deprecated = 2,
	}
	
	/// <summary>
	/// Used to apply a patch-style update to a connection, which means that null properties remain unchanged
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ConnectionUpdate
	{
		
		[System.Runtime.Serialization.DataMember(Name="breakingChange")]
		public System.Nullable<System.Boolean> BreakingChange { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="geography")]
		public ConnectionCreateGeography Geography { get; set; }
		
		/// <summary>
		/// Name that will be set to this connection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Method used for computing final namespace in destination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceDefinition")]
		public ConnectionCreateNamespaceDefinition NamespaceDefinition { get; set; }
		
		/// <summary>
		/// Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceFormat")]
		public string NamespaceFormat { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nonBreakingChangesPreference")]
		public ConnectionCreateNonBreakingChangesPreference NonBreakingChangesPreference { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notifySchemaChanges")]
		public System.Nullable<System.Boolean> NotifySchemaChanges { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operationIds")]
		public string[] OperationIds { get; set; }
		
		/// <summary>
		/// Prefix that will be prepended to the name of each stream when it is written to the destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// optional resource requirements to run workers (blank for unbounded allocations)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ResourceRequirements ResourceRequirements { get; set; }
		
		/// <summary>
		/// if null, then no schedule is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public ConnectionSchedule Schedule { get; set; }
		
		/// <summary>
		/// schedule for when the the connection should run, per the schedule type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleData")]
		public ConnectionScheduleData ScheduleData { get; set; }
		
		/// <summary>
		/// determine how the schedule data should be interpreted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleType")]
		public ConnectionCreateScheduleType ScheduleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceCatalogId")]
		public string SourceCatalogId { get; set; }
		
		/// <summary>
		/// Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ConnectionCreateStatus Status { get; set; }
		
		/// <summary>
		/// describes the available schema (catalog).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncCatalog")]
		public AirbyteCatalog SyncCatalog { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CustomDestinationDefinitionCreate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinition")]
		public DestinationDefinitionCreate DestinationDefinition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationDefinitionCreate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dockerImageTag")]
		public string DockerImageTag { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dockerRepository")]
		public string DockerRepository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="documentationUrl")]
		public string DocumentationUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="icon")]
		public string Icon { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ActorDefinitionResourceRequirements ResourceRequirements { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CustomSourceDefinitionCreate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinition")]
		public SourceDefinitionCreate SourceDefinition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDefinitionCreate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dockerImageTag")]
		public string DockerImageTag { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dockerRepository")]
		public string DockerRepository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="documentationUrl")]
		public string DocumentationUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="icon")]
		public string Icon { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ActorDefinitionResourceRequirements ResourceRequirements { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class CustomerioNotificationConfiguration
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DataType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="string")]
		_string = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		number = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		boolean = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="object")]
		_object = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		array = 4,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DbMigrationExecutionRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="executedMigrations")]
		public DbMigrationRead[] ExecutedMigrations { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="initialVersion")]
		public string InitialVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="targetVersion")]
		public string TargetVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DbMigrationRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="migratedAt")]
		public System.Nullable<System.Int64> MigratedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="migratedBy")]
		public string MigratedBy { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="migrationDescription")]
		public string MigrationDescription { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="migrationScript")]
		public string MigrationScript { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="migrationState")]
		public System.Nullable<DbMigrationReadMigrationState> MigrationState { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="migrationType")]
		public string MigrationType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="migrationVersion")]
		public string MigrationVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DbMigrationReadMigrationState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		above_target = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		below_baseline = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		baseline = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignored = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		missing_success = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		missing_failed = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		undone = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		available = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		out_of_order = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		future_success = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		future_failed = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		outdated = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		superseded = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleted = 16,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DbMigrationReadList
	{
		
		[System.Runtime.Serialization.DataMember(Name="migrations")]
		public DbMigrationRead[] Migrations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DbMigrationRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="database")]
		public string Database { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DbMigrationState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		above_target = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		below_baseline = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		baseline = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignored = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		missing_success = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		missing_failed = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		success = 7,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		undone = 8,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		available = 9,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 10,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		out_of_order = 11,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		future_success = 12,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		future_failed = 13,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		outdated = 14,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		superseded = 15,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		deleted = 16,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationAuthSpecification
	{
		
		[System.Runtime.Serialization.DataMember(Name="auth_type")]
		public System.Nullable<DestinationAuthSpecificationAuth_type> Auth_type { get; set; }
		
		/// <summary>
		/// An object containing any metadata needed to describe this connector's Oauth flow
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauth2Specification")]
		public OAuth2Specification Oauth2Specification { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DestinationAuthSpecificationAuth_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="oauth2.0")]
		oauth2_0 = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationCloneConfiguration
	{
		
		/// <summary>
		/// The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public DestinationConfiguration ConnectionConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The values required to configure the destination. The schema for this should have an id of the existing destination along with the configuration you want to change in case.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationCloneRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationCloneId")]
		public string DestinationCloneId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destinationConfiguration")]
		public DestinationCloneConfiguration DestinationConfiguration { get; set; }
	}
	
	/// <summary>
	/// The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationConfiguration
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationCoreConfig
	{
		
		/// <summary>
		/// The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public DestinationConfiguration ConnectionConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationCreate
	{
		
		/// <summary>
		/// The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public DestinationConfiguration ConnectionConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationDefinitionIdRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationDefinitionIdWithWorkspaceId
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationDefinitionRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dockerImageTag")]
		public string DockerImageTag { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dockerRepository")]
		public string DockerRepository { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="documentationUrl")]
		public string DocumentationUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="icon")]
		public string Icon { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// describes a normalization config for destination definition
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="normalizationConfig")]
		public NormalizationDestinationDefinitionConfig NormalizationConfig { get; set; }
		
		/// <summary>
		/// The Airbyte Protocol version supported by the connector
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocolVersion")]
		public string ProtocolVersion { get; set; }
		
		/// <summary>
		/// The date when this connector was first released, in yyyy-mm-dd format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateOnly> ReleaseDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="releaseStage")]
		public System.Nullable<DestinationDefinitionReadReleaseStage> ReleaseStage { get; set; }
		
		/// <summary>
		/// actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ActorDefinitionResourceRequirements ResourceRequirements { get; set; }
		
		/// <summary>
		/// an optional flag indicating whether DBT is used in the normalization. If the flag value is NULL - DBT is not used.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="supportsDbt")]
		public bool SupportsDbt { get; set; }
	}
	
	/// <summary>
	/// describes a normalization config for destination definition
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NormalizationDestinationDefinitionConfig
	{
		
		/// <summary>
		/// a field indicating the type of integration dialect to use for normalization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="normalizationIntegrationType")]
		public string NormalizationIntegrationType { get; set; }
		
		/// <summary>
		/// a field indicating the name of the repository to be used for normalization. If the value of the flag is NULL - normalization is not used.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="normalizationRepository")]
		public string NormalizationRepository { get; set; }
		
		/// <summary>
		/// a field indicating the tag of the docker repository to be used for normalization.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="normalizationTag")]
		public string NormalizationTag { get; set; }
		
		/// <summary>
		/// whether the destination definition supports normalization.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(false)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="supported")]
		public bool Supported { get; set; } = false;
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DestinationDefinitionReadReleaseStage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		alpha = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		beta = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		generally_available = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationDefinitionReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitions")]
		public DestinationDefinitionRead[] DestinationDefinitions { get; set; }
	}
	
	/// <summary>
	/// The specification for what values are required to configure the destinationDefinition.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationDefinitionSpecification
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationDefinitionSpecificationRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="advancedAuth")]
		public AdvancedAuth AdvancedAuth { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authSpecification")]
		public AuthSpecification AuthSpecification { get; set; }
		
		/// <summary>
		/// The specification for what values are required to configure the destinationDefinition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionSpecification")]
		public DestinationDefinitionSpecification ConnectionSpecification { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="documentationUrl")]
		public string DocumentationUrl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobInfo")]
		public SynchronousJobRead JobInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="supportedDestinationSyncModes")]
		public DestinationSyncMode[] SupportedDestinationSyncModes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum DestinationSyncMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		append = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		overwrite = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		append_dedup = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationDefinitionUpdate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dockerImageTag")]
		public string DockerImageTag { get; set; }
		
		/// <summary>
		/// actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ActorDefinitionResourceRequirements ResourceRequirements { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationIdRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationOauthConsentRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		/// <summary>
		/// The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oAuthInputConfiguration")]
		public OAuthConfiguration OAuthInputConfiguration { get; set; }
		
		/// <summary>
		/// The url to redirect to after getting the user consent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="redirectUrl")]
		public string RedirectUrl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationRead
	{
		
		/// <summary>
		/// The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public DestinationConfiguration ConnectionConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationName")]
		public string DestinationName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="icon")]
		public string Icon { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinations")]
		public DestinationRead[] Destinations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationSnippetRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationName")]
		public string DestinationName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="icon")]
		public string Icon { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DestinationUpdate
	{
		
		/// <summary>
		/// The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public DestinationConfiguration ConnectionConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class DiscoverCatalogResult
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="catalogId")]
		public string CatalogId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum Geography
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		auto = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		us = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		eu = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class HealthCheckRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="available")]
		public bool Available { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="reason")]
		public string Reason { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public CheckConnectionReadStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ImportRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="resourceId")]
		public string ResourceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InternalOperationResult
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="succeeded")]
		public bool Succeeded { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InvalidInputExceptionInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="exceptionClassName")]
		public string ExceptionClassName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exceptionStack")]
		public string[] ExceptionStack { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="validationErrors")]
		public InvalidInputProperty[] ValidationErrors { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class InvalidInputProperty
	{
		
		[System.Runtime.Serialization.DataMember(Name="invalidValue")]
		public string InvalidValue { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="propertyPath")]
		public string PropertyPath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum JobConfigType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		check_connection_source = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		check_connection_destination = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		discover_schema = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		get_spec = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sync = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reset_connection = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobDebugInfoRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="attempts")]
		public AttemptInfoRead[] Attempts { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="job")]
		public JobDebugRead Job { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="workflowState")]
		public WorkflowStateRead WorkflowState { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobDebugRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="airbyteVersion")]
		public string AirbyteVersion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configId")]
		public string ConfigId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configType")]
		public SynchronousJobReadConfigType ConfigType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinition")]
		public DestinationDefinitionRead DestinationDefinition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public long Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinition")]
		public SourceDefinitionRead SourceDefinition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public JobDebugReadStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDefinitionRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dockerImageTag")]
		public string DockerImageTag { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dockerRepository")]
		public string DockerRepository { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="documentationUrl")]
		public string DocumentationUrl { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="icon")]
		public string Icon { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// The Airbyte Protocol version supported by the connector
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="protocolVersion")]
		public string ProtocolVersion { get; set; }
		
		/// <summary>
		/// The date when this connector was first released, in yyyy-mm-dd format.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="releaseDate")]
		public System.Nullable<System.DateOnly> ReleaseDate { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="releaseStage")]
		public DestinationDefinitionReadReleaseStage ReleaseStage { get; set; }
		
		/// <summary>
		/// actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ActorDefinitionResourceRequirements ResourceRequirements { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceType")]
		public System.Nullable<SourceDefinitionReadSourceType> SourceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SourceDefinitionReadSourceType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		api = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		file = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		database = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum JobDebugReadStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		incomplete = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		succeeded = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cancelled = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkflowStateRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="running")]
		public bool Running { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobIdRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public long Id { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobInfoLightRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="job")]
		public JobRead Job { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configId")]
		public string ConfigId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configType")]
		public SynchronousJobReadConfigType ConfigType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public long CreatedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public long Id { get; set; }
		
		/// <summary>
		/// contains information about how a reset was configured. only populated if the job was a reset.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resetConfig")]
		public ResetConfig ResetConfig { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.Nullable<System.Int64> StartedAt { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public JobDebugReadStatus Status { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public long UpdatedAt { get; set; }
	}
	
	/// <summary>
	/// contains information about how a reset was configured. only populated if the job was a reset.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class ResetConfig
	{
		
		[System.Runtime.Serialization.DataMember(Name="streamsToReset")]
		public StreamDescriptor[] StreamsToReset { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobInfoRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="attempts")]
		public AttemptInfoRead[] Attempts { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="job")]
		public JobRead Job { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobListRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configId")]
		public string ConfigId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configTypes")]
		public JobConfigType[] ConfigTypes { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="includingJobId")]
		public System.Nullable<System.Int64> IncludingJobId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="pagination")]
		public Pagination Pagination { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Pagination
	{
		
		[System.Runtime.Serialization.DataMember(Name="pageSize")]
		public System.Nullable<System.Int32> PageSize { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rowOffset")]
		public System.Nullable<System.Int32> RowOffset { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobOptionalRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="job")]
		public JobRead Job { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobs")]
		public JobWithAttemptsRead[] Jobs { get; set; }
		
		/// <summary>
		/// the total count of jobs for the specified connection
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="totalJobCount")]
		public long TotalJobCount { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class JobWithAttemptsRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="attempts")]
		public AttemptRead[] Attempts { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="job")]
		public JobRead Job { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum JobStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		pending = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		running = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		incomplete = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		failed = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		succeeded = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		cancelled = 5,
	}
	
	/// <summary>
	/// enum that describes the different types of jobs that the platform runs.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum JobType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		get_spec = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		check_connection = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		discover_schema = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		sync = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		reset_connection = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		connection_updater = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		replicate = 6,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class KnownExceptionInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="exceptionClassName")]
		public string ExceptionClassName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exceptionStack")]
		public string[] ExceptionStack { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rootCauseExceptionClassName")]
		public string RootCauseExceptionClassName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rootCauseExceptionStack")]
		public string[] RootCauseExceptionStack { get; set; }
	}
	
	/// <summary>
	/// type/source of logs produced
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum LogType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		server = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		scheduler = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class LogsRequestBody
	{
		
		/// <summary>
		/// type/source of logs produced
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="logType")]
		public LogType LogType { get; set; }
	}
	
	/// <summary>
	/// Method used for computing final namespace in destination
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NamespaceDefinitionType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		source = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		destination = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		customformat = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NonBreakingChangesPreference
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ignore = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		disable = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NotFoundKnownExceptionInfo
	{
		
		[System.Runtime.Serialization.DataMember(Name="exceptionClassName")]
		public string ExceptionClassName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="exceptionStack")]
		public string[] ExceptionStack { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rootCauseExceptionClassName")]
		public string RootCauseExceptionClassName { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="rootCauseExceptionStack")]
		public string[] RootCauseExceptionStack { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class Notification
	{
		
		[System.Runtime.Serialization.DataMember(Name="customerioConfiguration")]
		public CustomerioNotificationConfiguration CustomerioConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notificationType")]
		public NotificationNotificationType NotificationType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(true)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sendOnFailure")]
		public bool SendOnFailure { get; set; } = true;
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(false)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sendOnSuccess")]
		public bool SendOnSuccess { get; set; } = false;
		
		[System.Runtime.Serialization.DataMember(Name="slackConfiguration")]
		public SlackNotificationConfiguration SlackConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NotificationNotificationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		slack = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		customerio = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SlackNotificationConfiguration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="webhook")]
		public string Webhook { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class NotificationRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public CheckConnectionReadStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum NotificationType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		slack = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		customerio = 1,
	}
	
	/// <summary>
	/// The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OAuthConfiguration
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OAuthConsentRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="consentUrl")]
		public string ConsentUrl { get; set; }
	}
	
	/// <summary>
	/// The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OAuthInputConfiguration
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationCreate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operatorConfiguration")]
		public OperatorConfiguration OperatorConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperatorConfiguration
	{
		
		[System.Runtime.Serialization.DataMember(Name="dbt")]
		public OperatorDbt Dbt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="normalization")]
		public OperatorNormalization Normalization { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operatorType")]
		public OperatorConfigurationOperatorType OperatorType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="webhook")]
		public OperatorWebhook Webhook { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperatorDbt
	{
		
		[System.Runtime.Serialization.DataMember(Name="dbtArguments")]
		public string DbtArguments { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="dockerImage")]
		public string DockerImage { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="gitRepoBranch")]
		public string GitRepoBranch { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="gitRepoUrl")]
		public string GitRepoUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperatorNormalization
	{
		
		[System.Runtime.Serialization.DataMember(Name="option")]
		public System.Nullable<OperatorNormalizationOption> Option { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OperatorNormalizationOption
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		basic = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OperatorConfigurationOperatorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		normalization = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dbt = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		webhook = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperatorWebhook
	{
		
		[System.Runtime.Serialization.DataMember(Name="dbtCloud")]
		public OperatorWebhookDbtCloud DbtCloud { get; set; }
		
		/// <summary>
		/// DEPRECATED. Populate dbtCloud instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionBody")]
		public string ExecutionBody { get; set; }
		
		/// <summary>
		/// DEPRECATED. Populate dbtCloud instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="executionUrl")]
		public string ExecutionUrl { get; set; }
		
		/// <summary>
		/// The id of the webhook configs to use from the workspace.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="webhookConfigId")]
		public string WebhookConfigId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="webhookType")]
		public System.Nullable<OperatorWebhookWebhookType> WebhookType { get; set; }
	}
	
	public class OperatorWebhookDbtCloud
	{
		
		/// <summary>
		/// The account id associated with the job
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="accountId")]
		public int AccountId { get; set; }
		
		/// <summary>
		/// The job id associated with the job
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobId")]
		public int JobId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OperatorWebhookWebhookType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dbtCloud = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationIdRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operationId")]
		public string OperationId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operationId")]
		public string OperationId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operatorConfiguration")]
		public OperatorConfiguration OperatorConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public OperationRead[] Operations { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class OperationUpdate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operationId")]
		public string OperationId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operatorConfiguration")]
		public OperatorConfiguration OperatorConfiguration { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum OperatorType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		normalization = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		dbt = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		webhook = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PrivateDestinationDefinitionRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinition")]
		public DestinationDefinitionRead DestinationDefinition { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="granted")]
		public bool Granted { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PrivateDestinationDefinitionReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitions")]
		public PrivateDestinationDefinitionRead[] DestinationDefinitions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PrivateSourceDefinitionRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="granted")]
		public bool Granted { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinition")]
		public SourceDefinitionRead SourceDefinition { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class PrivateSourceDefinitionReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitions")]
		public PrivateSourceDefinitionRead[] SourceDefinitions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum ReleaseStage
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		alpha = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		beta = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		generally_available = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		custom = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SaveAttemptSyncConfigRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="attemptNumber")]
		public int AttemptNumber { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobId")]
		public long JobId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="syncConfig")]
		public AttemptSyncConfig SyncConfig { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SaveStatsRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="attemptNumber")]
		public int AttemptNumber { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobId")]
		public long JobId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="stats")]
		public AttemptStats Stats { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="streamStats")]
		public AttemptStreamStats[] StreamStats { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SchemaChange
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		no_change = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		non_breaking = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		breaking = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SetInstancewideDestinationOauthParamsRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitionId")]
		public string DestinationDefinitionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="params")]
		public string Params { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SetInstancewideSourceOauthParamsRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="params")]
		public string Params { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SetWorkflowInAttemptRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="attemptNumber")]
		public int AttemptNumber { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobId")]
		public long JobId { get; set; }
		
		[System.ComponentModel.DefaultValue("")]
		[System.Runtime.Serialization.DataMember(Name="processingTaskQueue")]
		public string ProcessingTaskQueue { get; set; } = "";
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workflowId")]
		public string WorkflowId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SlugRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceAuthSpecification
	{
		
		[System.Runtime.Serialization.DataMember(Name="auth_type")]
		public System.Nullable<SourceAuthSpecificationAuth_type> Auth_type { get; set; }
		
		/// <summary>
		/// An object containing any metadata needed to describe this connector's Oauth flow
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oauth2Specification")]
		public OAuth2Specification Oauth2Specification { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public enum SourceAuthSpecificationAuth_type
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="oauth2.0")]
		oauth2_0 = 0,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceCloneConfiguration
	{
		
		/// <summary>
		/// The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public SourceConfiguration ConnectionConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	/// <summary>
	/// The values required to configure the source. The schema for this should have an id of the existing source along with the configuration you want to change in case.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceCloneRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceCloneId")]
		public string SourceCloneId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceConfiguration")]
		public SourceCloneConfiguration SourceConfiguration { get; set; }
	}
	
	/// <summary>
	/// The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceConfiguration
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceCoreConfig
	{
		
		/// <summary>
		/// The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public SourceConfiguration ConnectionConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceCreate
	{
		
		/// <summary>
		/// The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public SourceConfiguration ConnectionConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDefinitionIdRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDefinitionIdWithWorkspaceId
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDefinitionReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitions")]
		public SourceDefinitionRead[] SourceDefinitions { get; set; }
	}
	
	/// <summary>
	/// The specification for what values are required to configure the sourceDefinition.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDefinitionSpecification
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDefinitionSpecificationRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="advancedAuth")]
		public AdvancedAuth AdvancedAuth { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="authSpecification")]
		public AuthSpecification AuthSpecification { get; set; }
		
		/// <summary>
		/// The specification for what values are required to configure the sourceDefinition.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionSpecification")]
		public SourceDefinitionSpecification ConnectionSpecification { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="documentationUrl")]
		public string DocumentationUrl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobInfo")]
		public SynchronousJobRead JobInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
	}
	
	/// <summary>
	/// Update the SourceDefinition. Currently, the only allowed attribute to update is the default docker image version.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDefinitionUpdate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dockerImageTag")]
		public string DockerImageTag { get; set; }
		
		/// <summary>
		/// actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ActorDefinitionResourceRequirements ResourceRequirements { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
	}
	
	/// <summary>
	/// Returns the results of a discover catalog job. If the job was not successful, the catalog field will not be present. jobInfo will aways be present and its status be used to determine if the job was successful or not.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDiscoverSchemaRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="breakingChange")]
		public System.Nullable<System.Boolean> BreakingChange { get; set; }
		
		/// <summary>
		/// describes the available schema (catalog).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="catalog")]
		public AirbyteCatalog Catalog { get; set; }
		
		/// <summary>
		/// Describes the difference between two Airbyte catalogs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="catalogDiff")]
		public CatalogDiff CatalogDiff { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="catalogId")]
		public string CatalogId { get; set; }
		
		/// <summary>
		/// Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="connectionStatus")]
		public ConnectionCreateStatus ConnectionStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="jobInfo")]
		public SynchronousJobRead JobInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDiscoverSchemaRequestBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="disable_cache")]
		public System.Nullable<System.Boolean> Disable_cache { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notifySchemaChange")]
		public System.Nullable<System.Boolean> NotifySchemaChange { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
	}
	
	/// <summary>
	/// to write this requested object to database.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceDiscoverSchemaWriteRequestBody
	{
		
		/// <summary>
		/// describes the available schema (catalog).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="catalog")]
		public AirbyteCatalog Catalog { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="configurationHash")]
		public string ConfigurationHash { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="connectorVersion")]
		public string ConnectorVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceIdRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceOauthConsentRequest
	{
		
		/// <summary>
		/// The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="oAuthInputConfiguration")]
		public OAuthConfiguration OAuthInputConfiguration { get; set; }
		
		/// <summary>
		/// The url to redirect to after getting the user consent
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="redirectUrl")]
		public string RedirectUrl { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceRead
	{
		
		/// <summary>
		/// The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public SourceConfiguration ConnectionConfiguration { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="icon")]
		public string Icon { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceName")]
		public string SourceName { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sources")]
		public SourceRead[] Sources { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceSnippetRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="icon")]
		public string Icon { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitionId")]
		public string SourceDefinitionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceName")]
		public string SourceName { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class SourceUpdate
	{
		
		/// <summary>
		/// The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionConfiguration")]
		public SourceConfiguration ConnectionConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class UploadRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="resourceId")]
		public string ResourceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public CheckConnectionReadStatus Status { get; set; }
	}
	
	/// <summary>
	/// Summary of source and destination definitions that could be updated
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendCheckUpdatesRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationDefinitions")]
		public int DestinationDefinitions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceDefinitions")]
		public int SourceDefinitions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendConnectionCreate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="geography")]
		public ConnectionCreateGeography Geography { get; set; }
		
		/// <summary>
		/// Optional name of the connection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Method used for computing final namespace in destination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceDefinition")]
		public ConnectionCreateNamespaceDefinition NamespaceDefinition { get; set; }
		
		/// <summary>
		/// Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceFormat")]
		public string NamespaceFormat { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nonBreakingChangesPreference")]
		public ConnectionCreateNonBreakingChangesPreference NonBreakingChangesPreference { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operationIds")]
		public string[] OperationIds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public OperationCreate[] Operations { get; set; }
		
		/// <summary>
		/// Prefix that will be prepended to the name of each stream when it is written to the destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// optional resource requirements to run workers (blank for unbounded allocations)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ResourceRequirements ResourceRequirements { get; set; }
		
		/// <summary>
		/// if null, then no schedule is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public ConnectionSchedule Schedule { get; set; }
		
		/// <summary>
		/// schedule for when the the connection should run, per the schedule type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleData")]
		public ConnectionScheduleData ScheduleData { get; set; }
		
		/// <summary>
		/// determine how the schedule data should be interpreted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleType")]
		public ConnectionCreateScheduleType ScheduleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceCatalogId")]
		public string SourceCatalogId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ConnectionCreateStatus Status { get; set; }
		
		/// <summary>
		/// describes the available schema (catalog).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncCatalog")]
		public AirbyteCatalog SyncCatalog { get; set; }
	}
	
	/// <summary>
	/// Information about a connection that shows up in the connection list view.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendConnectionListItem
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public DestinationSnippetRead Destination { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isSyncing")]
		public bool IsSyncing { get; set; }
		
		/// <summary>
		/// epoch time of the latest sync job. null if no sync job has taken place.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latestSyncJobCreatedAt")]
		public System.Nullable<System.Int64> LatestSyncJobCreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latestSyncJobStatus")]
		public JobDebugReadStatus LatestSyncJobStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// schedule for when the the connection should run, per the schedule type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleData")]
		public ConnectionScheduleData ScheduleData { get; set; }
		
		/// <summary>
		/// determine how the schedule data should be interpreted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleType")]
		public ConnectionCreateScheduleType ScheduleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schemaChange")]
		public SchemaChange SchemaChange { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public SourceSnippetRead Source { get; set; }
		
		/// <summary>
		/// Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ConnectionCreateStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendConnectionListRequestBody
	{
		
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string[] DestinationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string[] SourceId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendConnectionRead
	{
		
		/// <summary>
		/// Describes the difference between two Airbyte catalogs.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="catalogDiff")]
		public CatalogDiff CatalogDiff { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="catalogId")]
		public string CatalogId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destination")]
		public DestinationRead Destination { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="destinationId")]
		public string DestinationId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="geography")]
		public ConnectionCreateGeography Geography { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="isSyncing")]
		public bool IsSyncing { get; set; }
		
		/// <summary>
		/// epoch time of the latest sync job. null if no sync job has taken place.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="latestSyncJobCreatedAt")]
		public System.Nullable<System.Int64> LatestSyncJobCreatedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="latestSyncJobStatus")]
		public JobDebugReadStatus LatestSyncJobStatus { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Method used for computing final namespace in destination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceDefinition")]
		public ConnectionCreateNamespaceDefinition NamespaceDefinition { get; set; }
		
		/// <summary>
		/// Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceFormat")]
		public string NamespaceFormat { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="nonBreakingChangesPreference")]
		public ConnectionCreateNonBreakingChangesPreference NonBreakingChangesPreference { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="notifySchemaChanges")]
		public bool NotifySchemaChanges { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operationIds")]
		public string[] OperationIds { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public OperationRead[] Operations { get; set; }
		
		/// <summary>
		/// Prefix that will be prepended to the name of each stream when it is written to the destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// optional resource requirements to run workers (blank for unbounded allocations)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ResourceRequirements ResourceRequirements { get; set; }
		
		/// <summary>
		/// if null, then no schedule is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public ConnectionSchedule Schedule { get; set; }
		
		/// <summary>
		/// schedule for when the the connection should run, per the schedule type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleData")]
		public ConnectionScheduleData ScheduleData { get; set; }
		
		/// <summary>
		/// determine how the schedule data should be interpreted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleType")]
		public ConnectionCreateScheduleType ScheduleType { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="schemaChange")]
		public SchemaChange SchemaChange { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="source")]
		public SourceRead Source { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sourceId")]
		public string SourceId { get; set; }
		
		/// <summary>
		/// Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ConnectionCreateStatus Status { get; set; }
		
		/// <summary>
		/// describes the available schema (catalog).
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="syncCatalog")]
		public AirbyteCatalog SyncCatalog { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendConnectionReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connections")]
		public WebBackendConnectionListItem[] Connections { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendConnectionRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="withRefreshedCatalog")]
		public System.Nullable<System.Boolean> WithRefreshedCatalog { get; set; }
	}
	
	/// <summary>
	/// Used to apply a patch-style update to a connection, which means that null properties remain unchanged
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendConnectionUpdate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectionId")]
		public string ConnectionId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="geography")]
		public ConnectionCreateGeography Geography { get; set; }
		
		/// <summary>
		/// Name that will be set to the connection
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Method used for computing final namespace in destination
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceDefinition")]
		public ConnectionCreateNamespaceDefinition NamespaceDefinition { get; set; }
		
		/// <summary>
		/// Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="namespaceFormat")]
		public string NamespaceFormat { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="nonBreakingChangesPreference")]
		public ConnectionCreateNonBreakingChangesPreference NonBreakingChangesPreference { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notifySchemaChanges")]
		public System.Nullable<System.Boolean> NotifySchemaChanges { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operations")]
		public WebBackendOperationCreateOrUpdate[] Operations { get; set; }
		
		/// <summary>
		/// Prefix that will be prepended to the name of each stream when it is written to the destination.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="prefix")]
		public string Prefix { get; set; }
		
		/// <summary>
		/// optional resource requirements to run workers (blank for unbounded allocations)
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="resourceRequirements")]
		public ResourceRequirements ResourceRequirements { get; set; }
		
		/// <summary>
		/// if null, then no schedule is set.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="schedule")]
		public ConnectionSchedule Schedule { get; set; }
		
		/// <summary>
		/// schedule for when the the connection should run, per the schedule type
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleData")]
		public ConnectionScheduleData ScheduleData { get; set; }
		
		/// <summary>
		/// determine how the schedule data should be interpreted
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="scheduleType")]
		public ConnectionCreateScheduleType ScheduleType { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="skipReset")]
		public System.Nullable<System.Boolean> SkipReset { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="sourceCatalogId")]
		public string SourceCatalogId { get; set; }
		
		/// <summary>
		/// Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="status")]
		public ConnectionCreateStatus Status { get; set; }
		
		/// <summary>
		/// describes the available schema (catalog).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="syncCatalog")]
		public AirbyteCatalog SyncCatalog { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendOperationCreateOrUpdate
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="operationId")]
		public string OperationId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="operatorConfiguration")]
		public OperatorConfiguration OperatorConfiguration { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendGeographiesListResult
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="geographies")]
		public Geography[] Geographies { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendWorkspaceState
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebBackendWorkspaceStateResult
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasConnections")]
		public bool HasConnections { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasDestinations")]
		public bool HasDestinations { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasSources")]
		public bool HasSources { get; set; }
	}
	
	/// <summary>
	/// the readable info for a webhook config; omits sensitive info e.g. auth token
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebhookConfigRead
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// human-readable name e.g. for display in UI
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WebhookConfigWrite
	{
		
		/// <summary>
		/// an auth token, to be passed as the value for an HTTP Authorization header.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="authToken")]
		public string AuthToken { get; set; }
		
		/// <summary>
		/// human readable name for this webhook e.g. for UI display.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// if supplied, the webhook config will be validated by checking that this URL returns a 2xx response.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="validationUrl")]
		public string ValidationUrl { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkspaceCreate
	{
		
		[System.Runtime.Serialization.DataMember(Name="anonymousDataCollection")]
		public System.Nullable<System.Boolean> AnonymousDataCollection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="defaultGeography")]
		public ConnectionCreateGeography DefaultGeography { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="displaySetupWizard")]
		public System.Nullable<System.Boolean> DisplaySetupWizard { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="news")]
		public System.Nullable<System.Boolean> News { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notifications")]
		public Notification[] Notifications { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="securityUpdates")]
		public System.Nullable<System.Boolean> SecurityUpdates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="webhookConfigs")]
		public WebhookConfigWrite[] WebhookConfigs { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkspaceGiveFeedback
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkspaceIdRequestBody
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkspaceRead
	{
		
		[System.Runtime.Serialization.DataMember(Name="anonymousDataCollection")]
		public System.Nullable<System.Boolean> AnonymousDataCollection { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="customerId")]
		public string CustomerId { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="defaultGeography")]
		public ConnectionCreateGeography DefaultGeography { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="displaySetupWizard")]
		public System.Nullable<System.Boolean> DisplaySetupWizard { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="feedbackDone")]
		public System.Nullable<System.Boolean> FeedbackDone { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="firstCompletedSync")]
		public System.Nullable<System.Boolean> FirstCompletedSync { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="initialSetupComplete")]
		public bool InitialSetupComplete { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="news")]
		public System.Nullable<System.Boolean> News { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notifications")]
		public Notification[] Notifications { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="securityUpdates")]
		public System.Nullable<System.Boolean> SecurityUpdates { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="slug")]
		public string Slug { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="webhookConfigs")]
		public WebhookConfigRead[] WebhookConfigs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkspaceReadList
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaces")]
		public WorkspaceRead[] Workspaces { get; set; }
	}
	
	/// <summary>
	/// Used to apply a patch-style update to a workspace, which means that null properties remain unchanged
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkspaceUpdate
	{
		
		[System.Runtime.Serialization.DataMember(Name="anonymousDataCollection")]
		public System.Nullable<System.Boolean> AnonymousDataCollection { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="defaultGeography")]
		public ConnectionCreateGeography DefaultGeography { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="displaySetupWizard")]
		public System.Nullable<System.Boolean> DisplaySetupWizard { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="email")]
		public string Email { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="initialSetupComplete")]
		public System.Nullable<System.Boolean> InitialSetupComplete { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="news")]
		public System.Nullable<System.Boolean> News { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="notifications")]
		public Notification[] Notifications { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="securityUpdates")]
		public System.Nullable<System.Boolean> SecurityUpdates { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="webhookConfigs")]
		public WebhookConfigWrite[] WebhookConfigs { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="http://fonlow.com/TestOpenApi/2024/04")]
	public class WorkspaceUpdateName
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="workspaceId")]
		public string WorkspaceId { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerOptions jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerOptions jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// For worker to set sync stats of a running attempt.
		/// SaveStats v1/attempt/save_stats
		/// </summary>
		/// <returns>Successful Operation</returns>
		public async Task<InternalOperationResult> SaveStatsAsync(SaveStatsRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/attempt/save_stats";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<InternalOperationResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// For worker to save the AttemptSyncConfig for an attempt.
		/// SaveSyncConfig v1/attempt/save_sync_config
		/// </summary>
		/// <returns>Successful Operation</returns>
		public async Task<InternalOperationResult> SaveSyncConfigAsync(SaveAttemptSyncConfigRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/attempt/save_sync_config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<InternalOperationResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// For worker to register the workflow id in attempt.
		/// SetWorkflowInAttempt v1/attempt/set_workflow_in_attempt
		/// </summary>
		/// <returns>Successful Operation</returns>
		public async Task<InternalOperationResult> SetWorkflowInAttemptAsync(SetWorkflowInAttemptRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/attempt/set_workflow_in_attempt";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<InternalOperationResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a connection between a source and a destination
		/// CreateConnection v1/connections/create
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ConnectionRead> CreateConnectionAsync(ConnectionCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/connections/create";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a connection
		/// DeleteConnection v1/connections/delete
		/// </summary>
		public async Task DeleteConnectionAsync(ConnectionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/connections/delete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a connection
		/// GetConnection v1/connections/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ConnectionRead> GetConnectionAsync(ConnectionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/connections/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all connections for a workspace.
		/// List connections for workspace. Does not return deleted connections.
		/// ListConnectionsForWorkspace v1/connections/list
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ConnectionReadList> ListConnectionsForWorkspaceAsync(WorkspaceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/connections/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConnectionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all connections for a workspace, including deleted connections.
		/// List connections for workspace, including deleted connections.
		/// ListAllConnectionsForWorkspace v1/connections/list_all
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ConnectionReadList> ListAllConnectionsForWorkspaceAsync(WorkspaceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/connections/list_all";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConnectionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state.
		/// ResetConnection v1/connections/reset
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<JobInfoRead> ResetConnectionAsync(ConnectionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/connections/reset";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<JobInfoRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search connections
		/// SearchConnections v1/connections/search
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ConnectionReadList> SearchConnectionsAsync(ConnectionSearch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/connections/search";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConnectionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Trigger a manual sync of the connection
		/// SyncConnection v1/connections/sync
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<JobInfoRead> SyncConnectionAsync(ConnectionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/connections/sync";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<JobInfoRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a connection
		/// Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
		/// Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
		/// with the catalog from the request. This means that to modify a single stream, the entire new catalog
		/// containing the updated stream needs to be sent.
		/// 
		/// UpdateConnection v1/connections/update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ConnectionRead> UpdateConnectionAsync(ConnectionUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/connections/update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get specification for a destinationDefinition
		/// GetDestinationDefinitionSpecification v1/destination_definition_specifications/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationDefinitionSpecificationRead> GetDestinationDefinitionSpecificationAsync(DestinationDefinitionIdWithWorkspaceId requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definition_specifications/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationDefinitionSpecificationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a custom destinationDefinition for the given workspace
		/// CreateCustomDestinationDefinition v1/destination_definitions/create_custom
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationDefinitionRead> CreateCustomDestinationDefinitionAsync(CustomDestinationDefinitionCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/create_custom";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationDefinitionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a destination definition
		/// DeleteDestinationDefinition v1/destination_definitions/delete
		/// </summary>
		public async Task DeleteDestinationDefinitionAsync(DestinationDefinitionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/delete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get destinationDefinition
		/// GetDestinationDefinition v1/destination_definitions/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationDefinitionRead> GetDestinationDefinitionAsync(DestinationDefinitionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationDefinitionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a destinationDefinition that is configured for the given workspace
		/// GetDestinationDefinitionForWorkspace v1/destination_definitions/get_for_workspace
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationDefinitionRead> GetDestinationDefinitionForWorkspaceAsync(DestinationDefinitionIdWithWorkspaceId requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/get_for_workspace";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationDefinitionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// grant a private, non-custom destinationDefinition to a given workspace
		/// GrantDestinationDefinitionToWorkspace v1/destination_definitions/grant_definition
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<PrivateDestinationDefinitionRead> GrantDestinationDefinitionToWorkspaceAsync(DestinationDefinitionIdWithWorkspaceId requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/grant_definition";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateDestinationDefinitionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all the destinationDefinitions the current Airbyte deployment is configured to use
		/// ListDestinationDefinitions v1/destination_definitions/list
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationDefinitionReadList> ListDestinationDefinitionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationDefinitionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all the destinationDefinitions the given workspace is configured to use
		/// ListDestinationDefinitionsForWorkspace v1/destination_definitions/list_for_workspace
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationDefinitionReadList> ListDestinationDefinitionsForWorkspaceAsync(WorkspaceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/list_for_workspace";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationDefinitionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the latest destinationDefinitions Airbyte supports
		/// Guaranteed to retrieve the latest information on supported destinations.
		/// ListLatestDestinationDefinitions v1/destination_definitions/list_latest
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationDefinitionReadList> ListLatestDestinationDefinitionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/list_latest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationDefinitionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants.
		/// ListPrivateDestinationDefinitions v1/destination_definitions/list_private
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<PrivateDestinationDefinitionReadList> ListPrivateDestinationDefinitionsAsync(WorkspaceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/list_private";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateDestinationDefinitionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// revoke a grant to a private, non-custom destinationDefinition from a given workspace
		/// RevokeDestinationDefinitionFromWorkspace v1/destination_definitions/revoke_definition
		/// </summary>
		public async Task RevokeDestinationDefinitionFromWorkspaceAsync(DestinationDefinitionIdWithWorkspaceId requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/revoke_definition";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update destinationDefinition
		/// UpdateDestinationDefinition v1/destination_definitions/update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationDefinitionRead> UpdateDestinationDefinitionAsync(DestinationDefinitionUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_definitions/update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationDefinitionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Given a destination def ID generate an access/refresh token etc.
		/// CompleteDestinationOAuth v1/destination_oauths/complete_oauth
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CompleteOAuthResponse> CompleteDestinationOAuthAsync(CompleteDestinationOAuthRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_oauths/complete_oauth";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CompleteOAuthResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to.
		/// GetDestinationOAuthConsent v1/destination_oauths/get_consent_url
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<OAuthConsentRead> GetDestinationOAuthConsentAsync(DestinationOauthConsentRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_oauths/get_consent_url";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OAuthConsentRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables.
		/// 
		/// SetInstancewideDestinationOauthParams v1/destination_oauths/oauth_params/create
		/// </summary>
		/// <returns>Successful</returns>
		public async Task SetInstancewideDestinationOauthParamsAsync(SetInstancewideDestinationOauthParamsRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destination_oauths/oauth_params/create";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check connection to the destination
		/// CheckConnectionToDestination v1/destinations/check_connection
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CheckConnectionRead> CheckConnectionToDestinationAsync(DestinationIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destinations/check_connection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CheckConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check connection for a proposed update to a destination
		/// CheckConnectionToDestinationForUpdate v1/destinations/check_connection_for_update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CheckConnectionRead> CheckConnectionToDestinationForUpdateAsync(DestinationUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destinations/check_connection_for_update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CheckConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Clone destination
		/// CloneDestination v1/destinations/clone
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationRead> CloneDestinationAsync(DestinationCloneRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destinations/clone";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a destination
		/// CreateDestination v1/destinations/create
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationRead> CreateDestinationAsync(DestinationCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destinations/create";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete the destination
		/// DeleteDestination v1/destinations/delete
		/// </summary>
		public async Task DeleteDestinationAsync(DestinationIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destinations/delete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get configured destination
		/// GetDestination v1/destinations/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationRead> GetDestinationAsync(DestinationIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destinations/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List configured destinations for a workspace
		/// ListDestinationsForWorkspace v1/destinations/list
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationReadList> ListDestinationsForWorkspaceAsync(WorkspaceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destinations/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search destinations
		/// SearchDestinations v1/destinations/search
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationReadList> SearchDestinationsAsync(DestinationSearch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destinations/search";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a destination
		/// UpdateDestination v1/destinations/update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<DestinationRead> UpdateDestinationAsync(DestinationUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/destinations/update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DestinationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Health Check
		/// GetHealthCheck v1/health
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<HealthCheckRead> GetHealthCheckAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/health";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<HealthCheckRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Cancels a job
		/// CancelJob v1/jobs/cancel
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<JobInfoRead> CancelJobAsync(JobIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/jobs/cancel";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<JobInfoRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information about a job
		/// GetJobInfo v1/jobs/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<JobInfoRead> GetJobInfoAsync(JobIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/jobs/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<JobInfoRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Gets all information needed to debug this job
		/// GetJobDebugInfo v1/jobs/get_debug_info
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<JobDebugInfoRead> GetJobDebugInfoAsync(JobIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/jobs/get_debug_info";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<JobDebugInfoRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// GetLastReplicationJob v1/jobs/get_last_replication_job
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<JobOptionalRead> GetLastReplicationJobAsync(ConnectionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/jobs/get_last_replication_job";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<JobOptionalRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get information about a job excluding attempt info and logs
		/// GetJobInfoLight v1/jobs/get_light
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<JobInfoLightRead> GetJobInfoLightAsync(JobIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/jobs/get_light";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<JobInfoLightRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get normalization status to determine if we can bypass normalization phase
		/// GetAttemptNormalizationStatusesForJob v1/jobs/get_normalization_status
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<AttemptNormalizationStatusReadList> GetAttemptNormalizationStatusesForJobAsync(JobIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/jobs/get_normalization_status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<AttemptNormalizationStatusReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns recent jobs for a connection. Jobs are returned in descending order by createdAt.
		/// ListJobsFor v1/jobs/list
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<JobReadList> ListJobsForAsync(JobListRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/jobs/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<JobReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get logs
		/// GetLogs v1/logs/get
		/// </summary>
		/// <returns>Returns the log file</returns>
		public async Task<string> GetLogsAsync(LogsRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/logs/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<string>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Try sending a notifications
		/// TryNotificationConfig v1/notifications/try
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<NotificationRead> TryNotificationConfigAsync(Notification requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/notifications/try";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<NotificationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the openapi specification
		/// GetOpenApiSpec v1/openapi
		/// </summary>
		/// <returns>Returns the openapi specification file</returns>
		public async Task<string> GetOpenApiSpecAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/openapi";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<string>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check if an operation to be created is valid
		/// CheckOperation v1/operations/check
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CheckOperationRead> CheckOperationAsync(OperatorConfiguration requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/operations/check";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CheckOperationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create an operation to be applied as part of a connection pipeline
		/// CreateOperation v1/operations/create
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<OperationRead> CreateOperationAsync(OperationCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/operations/create";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OperationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete an operation
		/// DeleteOperation v1/operations/delete
		/// </summary>
		public async Task DeleteOperationAsync(OperationIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/operations/delete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns an operation
		/// GetOperation v1/operations/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<OperationRead> GetOperationAsync(OperationIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/operations/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OperationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all operations for a connection.
		/// List operations for connection.
		/// ListOperationsForConnection v1/operations/list
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<OperationReadList> ListOperationsForConnectionAsync(ConnectionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/operations/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OperationReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update an operation
		/// UpdateOperation v1/operations/update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<OperationRead> UpdateOperationAsync(OperationUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/operations/update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OperationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Run check connection for a given destination configuration
		/// ExecuteDestinationCheckConnection v1/scheduler/destinations/check_connection
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CheckConnectionRead> ExecuteDestinationCheckConnectionAsync(DestinationCoreConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/scheduler/destinations/check_connection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CheckConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Run check connection for a given source configuration
		/// ExecuteSourceCheckConnection v1/scheduler/sources/check_connection
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CheckConnectionRead> ExecuteSourceCheckConnectionAsync(SourceCoreConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/scheduler/sources/check_connection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CheckConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Run discover schema for a given source a source configuration
		/// ExecuteSourceDiscoverSchema v1/scheduler/sources/discover_schema
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceDiscoverSchemaRead> ExecuteSourceDiscoverSchemaAsync(SourceCoreConfig requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/scheduler/sources/discover_schema";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceDiscoverSchemaRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get specification for a SourceDefinition.
		/// GetSourceDefinitionSpecification v1/source_definition_specifications/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceDefinitionSpecificationRead> GetSourceDefinitionSpecificationAsync(SourceDefinitionIdWithWorkspaceId requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definition_specifications/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceDefinitionSpecificationRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a custom sourceDefinition for the given workspace
		/// CreateCustomSourceDefinition v1/source_definitions/create_custom
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceDefinitionRead> CreateCustomSourceDefinitionAsync(CustomSourceDefinitionCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/create_custom";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceDefinitionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a source definition
		/// DeleteSourceDefinition v1/source_definitions/delete
		/// </summary>
		public async Task DeleteSourceDefinitionAsync(SourceDefinitionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/delete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get source
		/// GetSourceDefinition v1/source_definitions/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceDefinitionRead> GetSourceDefinitionAsync(SourceDefinitionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceDefinitionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a sourceDefinition that is configured for the given workspace
		/// GetSourceDefinitionForWorkspace v1/source_definitions/get_for_workspace
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceDefinitionRead> GetSourceDefinitionForWorkspaceAsync(SourceDefinitionIdWithWorkspaceId requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/get_for_workspace";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceDefinitionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// grant a private, non-custom sourceDefinition to a given workspace
		/// GrantSourceDefinitionToWorkspace v1/source_definitions/grant_definition
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<PrivateSourceDefinitionRead> GrantSourceDefinitionToWorkspaceAsync(SourceDefinitionIdWithWorkspaceId requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/grant_definition";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateSourceDefinitionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all the sourceDefinitions the current Airbyte deployment is configured to use
		/// ListSourceDefinitions v1/source_definitions/list
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceDefinitionReadList> ListSourceDefinitionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceDefinitionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all the sourceDefinitions the given workspace is configured to use
		/// ListSourceDefinitionsForWorkspace v1/source_definitions/list_for_workspace
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceDefinitionReadList> ListSourceDefinitionsForWorkspaceAsync(WorkspaceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/list_for_workspace";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceDefinitionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List the latest sourceDefinitions Airbyte supports
		/// Guaranteed to retrieve the latest information on supported sources.
		/// ListLatestSourceDefinitions v1/source_definitions/list_latest
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceDefinitionReadList> ListLatestSourceDefinitionsAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/list_latest";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceDefinitionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants.
		/// ListPrivateSourceDefinitions v1/source_definitions/list_private
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<PrivateSourceDefinitionReadList> ListPrivateSourceDefinitionsAsync(WorkspaceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/list_private";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<PrivateSourceDefinitionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// revoke a grant to a private, non-custom sourceDefinition from a given workspace
		/// RevokeSourceDefinitionFromWorkspace v1/source_definitions/revoke_definition
		/// </summary>
		public async Task RevokeSourceDefinitionFromWorkspaceAsync(SourceDefinitionIdWithWorkspaceId requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/revoke_definition";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a sourceDefinition
		/// UpdateSourceDefinition v1/source_definitions/update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceDefinitionRead> UpdateSourceDefinitionAsync(SourceDefinitionUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_definitions/update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceDefinitionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Given a source def ID generate an access/refresh token etc.
		/// CompleteSourceOAuth v1/source_oauths/complete_oauth
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CompleteOAuthResponse> CompleteSourceOAuthAsync(CompleteSourceOauthRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_oauths/complete_oauth";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CompleteOAuthResponse>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Given a source connector definition ID, return the URL to the consent screen where to redirect the user to.
		/// GetSourceOAuthConsent v1/source_oauths/get_consent_url
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<OAuthConsentRead> GetSourceOAuthConsentAsync(SourceOauthConsentRequest requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_oauths/get_consent_url";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<OAuthConsentRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables.
		/// 
		/// SetInstancewideSourceOauthParams v1/source_oauths/oauth_params/create
		/// </summary>
		/// <returns>Successful</returns>
		public async Task SetInstancewideSourceOauthParamsAsync(SetInstancewideSourceOauthParamsRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/source_oauths/oauth_params/create";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check connection to the source
		/// CheckConnectionToSource v1/sources/check_connection
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CheckConnectionRead> CheckConnectionToSourceAsync(SourceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/check_connection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CheckConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Check connection for a proposed update to a source
		/// CheckConnectionToSourceForUpdate v1/sources/check_connection_for_update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<CheckConnectionRead> CheckConnectionToSourceForUpdateAsync(SourceUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/check_connection_for_update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<CheckConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Clone source
		/// CloneSource v1/sources/clone
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceRead> CloneSourceAsync(SourceCloneRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/clone";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a source
		/// CreateSource v1/sources/create
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceRead> CreateSourceAsync(SourceCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/create";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete a source
		/// DeleteSource v1/sources/delete
		/// </summary>
		public async Task DeleteSourceAsync(SourceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/delete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Discover the schema catalog of the source
		/// DiscoverSchemaForSource v1/sources/discover_schema
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceDiscoverSchemaRead> DiscoverSchemaForSourceAsync(SourceDiscoverSchemaRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/discover_schema";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceDiscoverSchemaRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get source
		/// GetSource v1/sources/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceRead> GetSourceAsync(SourceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List sources for workspace
		/// List sources for workspace. Does not return deleted sources.
		/// ListSourcesForWorkspace v1/sources/list
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceReadList> ListSourcesForWorkspaceAsync(WorkspaceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get most recent ActorCatalog for source
		/// GetMostRecentSourceActorCatalog v1/sources/most_recent_source_actor_catalog
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ActorCatalogWithUpdatedAt> GetMostRecentSourceActorCatalogAsync(SourceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/most_recent_source_actor_catalog";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ActorCatalogWithUpdatedAt>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search sources
		/// SearchSources v1/sources/search
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceReadList> SearchSourcesAsync(SourceSearch requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/search";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a source
		/// UpdateSource v1/sources/update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<SourceRead> UpdateSourceAsync(SourceUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<SourceRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Should only called from worker, to write result from discover activity back to DB.
		/// WriteDiscoverCatalogResult v1/sources/write_discover_catalog_result
		/// </summary>
		/// <returns>Successful Operation</returns>
		public async Task<DiscoverCatalogResult> WriteDiscoverCatalogResultAsync(SourceDiscoverSchemaWriteRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/sources/write_discover_catalog_result";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<DiscoverCatalogResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or update the state for a connection.
		/// CreateOrUpdateState v1/state/create_or_update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ConnectionState> CreateOrUpdateStateAsync(ConnectionStateCreateOrUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/state/create_or_update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConnectionState>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch the current state for a connection.
		/// GetState v1/state/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ConnectionState> GetStateAsync(ConnectionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/state/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConnectionState>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns a summary of source and destination definitions that could be updated.
		/// WebBackendCheckUpdates v1/web_backend/check_updates
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WebBackendCheckUpdatesRead> WebBackendCheckUpdatesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/web_backend/check_updates";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WebBackendCheckUpdatesRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create a connection
		/// WebBackendCreateConnection v1/web_backend/connections/create
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WebBackendConnectionRead> WebBackendCreateConnectionAsync(WebBackendConnectionCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/web_backend/connections/create";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WebBackendConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get a connection
		/// WebBackendGetConnection v1/web_backend/connections/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WebBackendConnectionRead> WebBackendGetConnectionAsync(WebBackendConnectionRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/web_backend/connections/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WebBackendConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns all non-deleted connections for a workspace.
		/// WebBackendListConnectionsForWorkspace v1/web_backend/connections/list
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WebBackendConnectionReadList> WebBackendListConnectionsForWorkspaceAsync(WebBackendConnectionListRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/web_backend/connections/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WebBackendConnectionReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update a connection
		/// Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
		/// Any operations that lack an ID will be created. Then, the newly created operationId will be applied to the
		/// connection along with the rest of the operationIds in the request body.
		/// Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
		/// Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
		/// with the catalog from the request. This means that to modify a single stream, the entire new catalog
		/// containing the updated stream needs to be sent.
		/// 
		/// WebBackendUpdateConnection v1/web_backend/connections/update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WebBackendConnectionRead> WebBackendUpdateConnectionAsync(WebBackendConnectionUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/web_backend/connections/update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WebBackendConnectionRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns available geographies can be selected to run data syncs in a particular geography.
		/// The 'auto' entry indicates that the sync will be automatically assigned to a geography according
		/// to the platform default behavior. Entries other than 'auto' are two-letter country codes that
		/// follow the ISO 3166-1 alpha-2 standard.
		/// 
		/// Returns all available geographies in which a data sync can run.
		/// WebBackendListGeographies v1/web_backend/geographies/list
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WebBackendGeographiesListResult> WebBackendListGeographiesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/web_backend/geographies/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WebBackendGeographiesListResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Fetch the current state type for a connection.
		/// GetStateType v1/web_backend/state/get_type
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<ConnectionStateStateType> GetStateTypeAsync(ConnectionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/web_backend/state/get_type";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<ConnectionStateStateType>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Returns the current state of a workspace
		/// WebBackendGetWorkspaceState v1/web_backend/workspace/state
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WebBackendWorkspaceStateResult> WebBackendGetWorkspaceStateAsync(WebBackendWorkspaceState requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/web_backend/workspace/state";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WebBackendWorkspaceStateResult>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Creates a workspace
		/// CreateWorkspace v1/workspaces/create
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WorkspaceRead> CreateWorkspaceAsync(WorkspaceCreate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/workspaces/create";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WorkspaceRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Deletes a workspace
		/// DeleteWorkspace v1/workspaces/delete
		/// </summary>
		public async Task DeleteWorkspaceAsync(WorkspaceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/workspaces/delete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Find workspace by ID
		/// GetWorkspace v1/workspaces/get
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WorkspaceRead> GetWorkspaceAsync(WorkspaceIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/workspaces/get";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WorkspaceRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Find workspace by connection id
		/// GetWorkspaceByConnectionId v1/workspaces/get_by_connection_id
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WorkspaceRead> GetWorkspaceByConnectionIdAsync(ConnectionIdRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/workspaces/get_by_connection_id";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WorkspaceRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Find workspace by slug
		/// GetWorkspaceBySlug v1/workspaces/get_by_slug
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WorkspaceRead> GetWorkspaceBySlugAsync(SlugRequestBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/workspaces/get_by_slug";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WorkspaceRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// List all workspaces registered in the current Airbyte deployment
		/// ListWorkspaces v1/workspaces/list
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WorkspaceReadList> ListWorkspacesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/workspaces/list";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WorkspaceReadList>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update workspace feedback state
		/// UpdateWorkspaceFeedback v1/workspaces/tag_feedback_status_as_done
		/// </summary>
		public async Task UpdateWorkspaceFeedbackAsync(WorkspaceGiveFeedback requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/workspaces/tag_feedback_status_as_done";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update workspace state
		/// UpdateWorkspace v1/workspaces/update
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WorkspaceRead> UpdateWorkspaceAsync(WorkspaceUpdate requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/workspaces/update";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WorkspaceRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update workspace name
		/// UpdateWorkspaceName v1/workspaces/update_name
		/// </summary>
		/// <returns>Successful operation</returns>
		public async Task<WorkspaceRead> UpdateWorkspaceNameAsync(WorkspaceUpdateName requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/workspaces/update_name";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			var contentJson = JsonSerializer.Serialize(requestBody, jsonSerializerSettings);
			var content = new System.Net.Http.StringContent(contentJson, System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var contentString = await responseMessage.Content.ReadAsStringAsync();
				return JsonSerializer.Deserialize<WorkspaceRead>(contentString, jsonSerializerSettings);
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public new System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
