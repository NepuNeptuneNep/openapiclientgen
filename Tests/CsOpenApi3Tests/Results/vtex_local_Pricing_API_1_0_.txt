//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Trade Policy Fixed Price Validity Period Object.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DateRange
	{
		
		/// <summary>
		/// Indicates the date and time when the fixed price will start to be valid.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// Indicates the date and time from which the fixed price will no longer be valid.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FixedPrice
	{
		
		/// <summary>
		/// Trade Policy Fixed Price Validity Period Object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dateRange")]
		public DateRange DateRange { get; set; }
		
		/// <summary>
		/// Trade Policy List Price Value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listPrice")]
		public System.Nullable<System.Double> ListPrice { get; set; }
		
		/// <summary>
		/// Trade Policy Fixed Price Minimum Item Quantity.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minQuantity")]
		public int MinQuantity { get; set; }
		
		/// <summary>
		/// Trade Policy ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tradePolicyId")]
		public string TradePolicyId { get; set; }
		
		/// <summary>
		/// Trade Policy Fixed Price Value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public double Value { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Getcomputedprice
	{
		
		/// <summary>
		/// Cost price.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costPrice")]
		public System.Nullable<System.Double> CostPrice { get; set; }
		
		/// <summary>
		/// Trade Policy List Price, also known as "from" price.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listPrice")]
		public int ListPrice { get; set; }
		
		/// <summary>
		/// Date until when the computed price will be valid, due to price scheduling. If no price scheduling applies, this will be set a year from the current time.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="priceValidUntil")]
		public string PriceValidUntil { get; set; }
		
		/// <summary>
		/// Computed Price before applying coupons, promotions and taxes. This price may change before reaching the shelf.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="sellingPrice")]
		public double SellingPrice { get; set; }
		
		/// <summary>
		/// Trade Policy ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tradePolicyId")]
		public string TradePolicyId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Getprice
	{
		
		/// <summary>
		/// SKU's reference price.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="basePrice")]
		public int BasePrice { get; set; }
		
		/// <summary>
		/// SKU's cost price.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="costPrice")]
		public int CostPrice { get; set; }
		
		/// <summary>
		/// The fixed price is a price that overlaps all other existing price configurations of a price table.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="fixedPrices")]
		public FixedPrice[] FixedPrices { get; set; }
		
		/// <summary>
		/// SKU ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="itemId")]
		public string ItemId { get; set; }
		
		/// <summary>
		/// Suggested retail price for the SKU.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listPrice")]
		public int ListPrice { get; set; }
		
		/// <summary>
		/// Desired profit margin with the SKU's sale.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="markup")]
		public int Markup { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PricingConfiguration
	{
		
		/// <summary>
		/// Defines if access to the Pricing APIs is blocked for external requests.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockAccount")]
		public System.Nullable<System.Boolean> BlockAccount { get; set; }
		
		/// <summary>
		/// Array with all blocked routes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="blockedRoutes")]
		public string[] BlockedRoutes { get; set; }
		
		/// <summary>
		/// Account default markup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="defaultMarkup")]
		public int DefaultMarkup { get; set; }
		
		/// <summary>
		/// Defines if the account has migrated to Pricing V2.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="hasMigrated")]
		public bool HasMigrated { get; set; }
		
		/// <summary>
		/// Defines if optional base price is allowed.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasOptionalBasePrice")]
		public System.Nullable<System.Boolean> HasOptionalBasePrice { get; set; }
		
		/// <summary>
		/// Deprecated. Use the `priceInheritance` field instead.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="hasPriceInheritance")]
		public System.Nullable<System.Boolean> HasPriceInheritance { get; set; }
		
		/// <summary>
		/// Pricing V2 migration status.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="migrationStatus")]
		public string MigrationStatus { get; set; }
		
		/// <summary>
		/// Account minimum markup.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minimumMarkups")]
		public System.Collections.Generic.Dictionary<string, int> MinimumMarkups { get; set; }
		
		/// <summary>
		/// Condition of price inheritance from its parent account. This field can have three possible values: `never` if the store should never inherit prices, `nonexistent` if the store should only inherit prices in case of nonexistent prices for a given product, or `always` if the store should always inherit prices, regardless of its own prices.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priceInheritance")]
		public string PriceInheritance { get; set; }
		
		/// <summary>
		/// Price Table Limit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priceTableLimit")]
		public System.Nullable<System.Int32> PriceTableLimit { get; set; }
		
		/// <summary>
		/// The strategy used to get prices when there is more than one option. Possible values: `first`, `highest`, `lowest`. Default: `first`.
		/// </summary>
		[System.ComponentModel.DefaultValue("first")]
		[System.Runtime.Serialization.DataMember(Name="priceTableSelectionStrategy")]
		public string PriceTableSelectionStrategy { get; set; } = "first";
		
		/// <summary>
		/// Price Variation object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="priceVariation")]
		public PricingConfigurationPriceVariation PriceVariation { get; set; }
		
		/// <summary>
		/// Overrides prices from sellers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="sellersToOverride")]
		public string[] SellersToOverride { get; set; }
		
		/// <summary>
		/// Trade Policy Configurations array.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tradePolicyConfigs")]
		public PricingConfigurationTradePolicyConfigs[] PricingConfigurationTradePolicyConfigs { get; set; }
	}
	
	public class PricingConfigurationPriceVariation
	{
		
		/// <summary>
		/// Lower variation limit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="lowerLimit")]
		public System.Nullable<System.Int32> LowerLimit { get; set; }
		
		/// <summary>
		/// Upper variation limit.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="upperLimit")]
		public System.Nullable<System.Int32> UpperLimit { get; set; }
	}
	
	public class PricingConfigurationTradePolicyConfigs
	{
		
		/// <summary>
		/// Trade Policy Minimum Markup.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="minimumMarkup")]
		public System.Nullable<System.Int32> MinimumMarkup { get; set; }
		
		/// <summary>
		/// Defines if the Price Rule should affect the list price too.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rulesShouldAffectListPrice")]
		public System.Nullable<System.Boolean> RulesShouldAffectListPrice { get; set; }
		
		/// <summary>
		/// Trade Policy ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tradePolicyId")]
		public string TradePolicyId { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Get Pricing Configuration
		/// Retrieves Pricing Configuration.
		/// ## Response body example
		/// 
		/// ```json
		/// {
		/// "hasMigrated": true,
		/// "migrationStatus": "Completed",
		/// "defaultMarkup": 100,
		/// "priceVariation": {
		/// "upperLimit": null,
		/// "lowerLimit": null
		/// },
		/// "minimumMarkups": {
		/// "1": 100,
		/// "2": 90
		/// },
		/// "tradePolicyConfigs": [],
		/// "sellersToOverride": [],
		/// "hasPriceInheritance": false,
		/// "priceInheritance": "never",
		/// "hasOptionalBasePrice": false,
		/// "blockAccount": false,
		/// "blockedRoutes": null,
		/// "priceTableSelectionStrategy": "first",
		/// "priceTableLimit": null
		/// }
		/// ```
		/// GetPricingConfig pricing/config
		/// </summary>
		/// <returns>OK</returns>
		public async Task GetPricingConfigAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/config";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Pricing v2 Status
		/// Retrieves Pricing v2 Status.
		/// ## Response body example
		/// 
		/// ```json
		/// {
		/// "isActive": true,
		/// "hasMigrated": true
		/// }
		/// ```
		/// GetPricingv2Status pricing/migration
		/// </summary>
		/// <returns>OK</returns>
		public async Task GetPricingv2StatusAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/migration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get all price tables and their rules
		/// This method will retrieve all price tables and their rules.
		/// 
		/// ## Response body example
		/// 
		/// ```json
		/// [
		/// {
		/// "tradePolicyId": "2",
		/// "rules": [
		/// {
		/// "id": 0,
		/// "context": {
		/// "categories": {},
		/// "brands": {},
		/// "stockStatuses": null,
		/// "internalCategories": null,
		/// "markupRange": null,
		/// "dateRange": null
		/// },
		/// "percentualModifier": 20
		/// }
		/// ]
		/// },
		/// {
		/// "tradePolicyId": "b2c",
		/// "rules": [
		/// {
		/// "id": 0,
		/// "context": {
		/// "categories": {},
		/// "brands": {
		/// "2000009": "Whiskas"
		/// },
		/// "stockStatuses": null,
		/// "internalCategories": null,
		/// "markupRange": null,
		/// "dateRange": null
		/// },
		/// "percentualModifier": 15
		/// }
		/// ]
		/// }
		/// ]
		/// ```
		/// Getallpricetablesandrules pricing/pipeline/catalog
		/// </summary>
		/// <returns>OK</returns>
		public async Task<GetallpricetablesandrulesReturn[]> GetallpricetablesandrulesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/pipeline/catalog";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetallpricetablesandrulesReturn[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get rules for a price table
		/// This method will retrieve the rules from a specific Price Table.
		/// 
		/// ## Response body example
		/// 
		/// ```json
		/// {
		/// "tradePolicyId": "b2c",
		/// "rules": [{
		/// "id": 0,
		/// "context": {
		/// "categories": {},
		/// "brands": {
		/// "2000009": "Whiskas"
		/// },
		/// "stockStatuses": null,
		/// "internalCategories": null,
		/// "markupRange": null,
		/// "dateRange": null
		/// },
		/// "percentualModifier": 15
		/// }]
		/// }
		/// ```
		/// Getrulesforapricetable pricing/pipeline/catalog/{priceTableId}
		/// </summary>
		/// <param name="priceTableId">Price Table Name.</param>
		/// <returns>OK</returns>
		public async Task<GetrulesforapricetableReturn> GetrulesforapricetableAsync(string priceTableId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/pipeline/catalog/"+ (priceTableId==null? "" : System.Uri.EscapeDataString(priceTableId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetrulesforapricetableReturn>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update rules for a price table
		/// This method will update the rules from a specific Price Table. It will delete all the rules from the requested Price Table and create new rules based on the content of the request.
		/// 
		/// ## Request body example
		/// 
		/// ```json
		/// {
		/// "rules": [
		/// {
		/// "id": 1,
		/// "context": {
		/// "categories": {
		/// "Category ID": "1",
		/// "Category Name": "Alimentação"
		/// },
		/// "brands": {
		/// "Brand ID": "2000002",
		/// "Brand Name": "Whiskas"
		/// },
		/// "markupRange": {
		/// "from": 0,
		/// "to": 200
		/// },
		/// "dateRange": {
		/// "from": "2022-01-23T19:00:00.000Z",
		/// "to": "2023-10-26T00:00:00.000Z"
		/// }
		/// },
		/// "percentualModifier": 0
		/// }
		/// ]
		/// }
		/// ```
		/// Price_TablesPutByPriceTableId pricing/pipeline/catalog/{priceTableId}
		/// </summary>
		/// <param name="priceTableId">Price Table Name.</param>
		public async Task Price_TablesPutByPriceTableIdAsync(string priceTableId, Price_TablesPutByPriceTableIdPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/pipeline/catalog/"+ (priceTableId==null? "" : System.Uri.EscapeDataString(priceTableId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Delete Price
		/// Deletes the Base Price and all available Fixed Prices for an SKU in all trade policies.
		/// DeletePrice pricing/prices/{itemId}
		/// </summary>
		/// <param name="itemId">SKU ID.</param>
		/// <returns>OK</returns>
		public async Task DeletePriceAsync(int itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/prices/"+itemId;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Price
		/// Retrieves price data given a specific SKU ID. Within the `fixedPrices` object, there might be a list of prices for specific Trade Policies and Minimium Quantities of the SKU. Fixed Prices may also be scheduled.
		/// 
		/// ## Response body example
		/// 
		/// ```json
		/// {
		/// "itemId": "1",
		/// "listPrice": 50,
		/// "costPrice": 90,
		/// "markup": 30,
		/// "basePrice": 117,
		/// "fixedPrices": [
		/// {
		/// "tradePolicyId": "1",
		/// "value": 50.5,
		/// "listPrice": 50.5,
		/// "minQuantity": 2,
		/// "dateRange": {
		/// "from": "2021-12-31T01:00:00Z",
		/// "to": "2022-12-31T01:00:00Z"
		/// }
		/// },
		/// {
		/// "tradePolicyId": "2",
		/// "value": 30,
		/// "listPrice": 50,
		/// "minQuantity": 2
		/// }
		/// ]
		/// }
		/// ```
		/// GetPrice pricing/prices/{itemId}
		/// </summary>
		/// <param name="itemId">SKU ID.</param>
		/// <returns>OK</returns>
		public async Task<Getprice> GetPriceAsync(int itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/prices/"+itemId;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Getprice>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or Update Base Price or Fixed Prices
		/// Creates or updates an SKU Base Price or Fixed Prices. The **base price** is the basic selling price of a product, it comprises the cost price and the markup wanted in the sale of the product. The **fixed price** is an optional price of the SKU for a specific trade policy with a specific minimum quantity to be activated.
		/// 
		/// <p> You may optionally set a list price. Additionally, you may set either a cost price or a markup value. By defining either one of them, the other will be calculated to conform to the formula <code>costPrice * (1 + markup) = basePrice</code>.</p> <h2>Request body example</h2>
		/// 
		/// ```json
		/// {
		/// "markup": 30,
		/// "basePrice": 100,
		/// "listPrice": 35,
		/// "fixedPrices": [
		/// {
		/// "tradePolicyId": "1",
		/// "value": 31,
		/// "listPrice": 32,
		/// "minQuantity": 1,
		/// "dateRange": {
		/// "from": "2022-05-21T22:00:00Z",
		/// "to": "2023-05-28T22:00:00Z"
		/// }
		/// },
		/// {
		/// "tradePolicyId": "1",
		/// "value": 31.5,
		/// "listPrice": 33,
		/// "minQuantity": 2
		/// }
		/// ]
		/// }
		/// ```
		/// CreateUpdatePriceOrFixedPrice pricing/prices/{itemId}
		/// </summary>
		/// <param name="itemId">SKU unique identifier number.</param>
		/// <returns>OK</returns>
		public async Task CreateUpdatePriceOrFixedPriceAsync(int itemId, CreateUpdatePriceOrFixedPricePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/prices/"+itemId;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Get Computed Price by price table or trade policy
		/// Gets the Computed Price, which is the price after all the steps in the Pricing pipeline, for an SKU in a specific price table or trade policy.
		/// 
		/// ## Response body example
		/// 
		/// ```json
		/// {
		/// "tradePolicyId": "1",
		/// "listPrice": 30,
		/// "costPrice": 76.92,
		/// "sellingPrice": 18.9,
		/// "priceValidUntil": "2018-12-20T18:12:14Z"
		/// }
		/// ```
		/// GetComputedPricebypricetable pricing/prices/{itemId}/computed/{priceTableId}
		/// </summary>
		/// <param name="categoryIds">Category ID.</param>
		/// <param name="brandId">Brand ID.</param>
		/// <param name="quantity">SKU quantity.</param>
		/// <param name="itemId">SKU ID.</param>
		/// <param name="priceTableId">SKU Price Table Name.</param>
		/// <returns>OK</returns>
		public async Task GetComputedPricebypricetableAsync(int categoryIds, int brandId, int quantity, int itemId, string priceTableId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/prices/"+itemId+"/computed/"+ (priceTableId==null? "" : System.Uri.EscapeDataString(priceTableId))+"?categoryIds="+categoryIds+"&brandId="+brandId+"&quantity="+quantity;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Fixed Prices
		/// The **fixed price** is an optional price of the SKU for a specific trade policy with a specific minimum quantity to be activated. This method retrieves an array of Fixed Prices for an SKU in a Trade Policy with Minimum Quantities.
		/// 
		/// The default value for a Minimum Quantity is `1`. This means a Fixed Price will be valid for a SKU in a Trade Policy for orders containing the specified number of Minimum Quantity or above, unless a higher Minimum Quantity is specified.
		/// 
		/// Fixed prices may, optionally, be scheduled. If so, these objects will contain the `dateRange` object with `from` and `to` properties, indicating the start and end time of the scheduled fixed price in the RFC3339 timestamp format (`YYYY-MM-DDT23:59:60Z`).
		/// 
		/// Note that the 'Z', at the end, represents the UTC time (GMT+00:00). If it was in GMT-03:00, for example, it would be (`YYYY-MM-DDT23:59:60-03:00`).
		/// 
		/// ## Response body example
		/// 
		/// ```json
		/// [
		/// {
		/// "tradePolicyId": "6",
		/// "value": 20.9,
		/// "listPrice": 22.9,
		/// "minQuantity": 1,
		/// "dateRange": {
		/// "from": "2021-12-30T22:00:00-03:00",
		/// "to": "2021-12-30T22:00:00-03:00"
		/// }
		/// },
		/// {
		/// "tradePolicyId": "1",
		/// "value": 18.9,
		/// "listPrice": null,
		/// "minQuantity": 1,
		/// "dateRange": {
		/// "from": "2021-12-30T22:00:00-03:00",
		/// "to": "2021-12-30T22:00:00-03:00"
		/// }
		/// }
		/// ]
		/// ```
		/// GetFixedPrices pricing/prices/{itemId}/fixed
		/// </summary>
		/// <param name="itemId">SKU ID.</param>
		/// <returns>OK</returns>
		public async Task GetFixedPricesAsync(int itemId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/prices/"+itemId+"/fixed";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete Fixed Prices on a price table or trade policy
		/// Deletes all Fixed Prices of an SKU in a specific Price Table or Trade Policy.
		/// Deletefixedpricesonapricetableortradepolicy pricing/prices/{itemId}/fixed/{priceTableId}
		/// </summary>
		/// <param name="itemId">SKU ID.</param>
		/// <param name="priceTableId">Price Table or Trade Policy Name.</param>
		/// <returns>OK</returns>
		public async Task DeletefixedpricesonapricetableortradepolicyAsync(int itemId, string priceTableId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/prices/"+itemId+"/fixed/"+ (priceTableId==null? "" : System.Uri.EscapeDataString(priceTableId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get Fixed Prices on a price table or trade policy
		/// Retrieves all Fixed Prices on a price table or trade policy.
		/// 
		/// ## Response body example
		/// 
		/// ```json
		/// [
		/// {
		/// "tradePolicyId": "6",
		/// "value": 20.9,
		/// "listPrice": 22.9,
		/// "minQuantity": 1,
		/// "dateRange": {
		/// "from": "2021-12-30T22:00:00-03:00",
		/// "to": "2021-12-30T22:00:00-04:00"
		/// }
		/// },
		/// {
		/// "tradePolicyId": "1",
		/// "value": 18.9,
		/// "listPrice": null,
		/// "minQuantity": 1
		/// }
		/// ]
		/// ```
		/// GetFixedPricesonapricetable pricing/prices/{itemId}/fixed/{priceTableId}
		/// </summary>
		/// <param name="itemId">SKU ID.</param>
		/// <param name="priceTableId">Price Table Name</param>
		/// <returns>OK</returns>
		public async Task GetFixedPricesonapricetableAsync(int itemId, string priceTableId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/prices/"+itemId+"/fixed/"+ (priceTableId==null? "" : System.Uri.EscapeDataString(priceTableId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create or Update Fixed Prices on a price table or trade policy
		/// Creates or updates the fixed prices of an SKU for a specific price table or trade policy. You can add one or multiple fixed prices per SKU.
		/// 
		/// ## Request body example
		/// 
		/// ```json
		/// [
		/// {
		/// "value": 50.5,
		/// "listPrice": 50.5,
		/// "minQuantity": 2,
		/// "dateRange": {
		/// "from": "2021-12-30T22:00:00-03:00",
		/// "to": "2021-12-30T22:00:00-04:00"
		/// }
		/// }
		/// ]
		/// ```
		/// Createorupdatefixedpricesonpricetableortradepolicy pricing/prices/{itemId}/fixed/{priceTableId}
		/// </summary>
		/// <param name="itemId">SKU ID.</param>
		/// <param name="priceTableId">SKU **price table** name or **trade policy** ID.</param>
		/// <returns>OK</returns>
		public async Task CreateorupdatefixedpricesonpricetableortradepolicyAsync(int itemId, string priceTableId, CreateorupdatefixedpricesonpricetableortradepolicyPostBody[] requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/prices/"+itemId+"/fixed/"+ (priceTableId==null? "" : System.Uri.EscapeDataString(priceTableId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// List price tables
		/// This method will list all price tables.
		/// 
		/// ## Response body example
		/// 
		/// ```json
		/// [
		/// "1",
		/// "2",
		/// "3",
		/// "b2c",
		/// "b2b",
		/// "gold"
		/// ]
		/// ```
		/// Listpricetables pricing/tables
		/// </summary>
		/// <returns>OK</returns>
		public async Task<string[]> ListpricetablesAsync(Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "pricing/tables";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<string[]>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public class GetallpricetablesandrulesReturn
	{
		
		/// <summary>
		/// Percentual modifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentualModifier")]
		public System.Nullable<System.Int32> PercentualModifier { get; set; }
		
		/// <summary>
		/// Array of rules for the price table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public GetallpricetablesandrulesReturnRules[] GetallpricetablesandrulesReturnRules { get; set; }
		
		/// <summary>
		/// Trade Policy ID (Price Table ID).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tradePolicyId")]
		public string TradePolicyId { get; set; }
	}
	
	public class GetallpricetablesandrulesReturnRules
	{
		
		/// <summary>
		/// Rule Context is a group of filters to be checked at an item level when applying the rule. If all those filters check out, the rule will be applied for that item, unless there is a fixed price for that item.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="context")]
		public GetallpricetablesandrulesReturnRulesContext Context { get; set; }
		
		/// <summary>
		/// Rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Double> Id { get; set; }
	}
	
	public class GetallpricetablesandrulesReturnRulesContext
	{
		
		/// <summary>
		/// Brands that an item should have to be eligible for the rule. Format: key: `brandId`, value: `brandName`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="brands")]
		public System.Collections.Generic.Dictionary<string, string> Brands { get; set; }
		
		/// <summary>
		/// Categories that an item should have to be eligible for the rule. Format: key: `categoryId`, value: `categoryName`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="categories")]
		public System.Collections.Generic.Dictionary<string, string> Categories { get; set; }
		
		/// <summary>
		/// The rule will be active during this time range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dateRange")]
		public GetallpricetablesandrulesReturnRulesContextDateRange DateRange { get; set; }
		
		/// <summary>
		/// Internal Categories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalCategories")]
		public string InternalCategories { get; set; }
		
		/// <summary>
		/// For an item to be eligible to the rule, it's markup should be in this Markup Range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="markupRange")]
		public GetallpricetablesandrulesReturnRulesContextMarkupRange MarkupRange { get; set; }
		
		/// <summary>
		/// Stock statuses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stockStatuses")]
		public string StockStatuses { get; set; }
	}
	
	public class GetallpricetablesandrulesReturnRulesContextDateRange
	{
		
		/// <summary>
		/// Date when rule will be activated. Date format: `RFC3339`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// Date when the rule will be deactivated. Date format: `RFC3339`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class GetallpricetablesandrulesReturnRulesContextMarkupRange
	{
		
		/// <summary>
		/// Item markup should be greater than or equal to this value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public System.Nullable<System.Int32> From { get; set; }
		
		/// <summary>
		/// Item markup should be less than or equal to this value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public System.Nullable<System.Int32> To { get; set; }
	}
	
	public class GetrulesforapricetableReturn
	{
		
		/// <summary>
		/// Percentual modifier.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="percentualModifier")]
		public System.Nullable<System.Int32> PercentualModifier { get; set; }
		
		/// <summary>
		/// Array of rules for the price table.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public GetrulesforapricetableReturnRules[] GetrulesforapricetableReturnRules { get; set; }
		
		/// <summary>
		/// Trade Policy ID (Price Table ID).
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tradePolicyId")]
		public string TradePolicyId { get; set; }
	}
	
	public class GetrulesforapricetableReturnRules
	{
		
		/// <summary>
		/// Rule Context is a group of filters to be checked at an item level when applying the rule. If all those filters check out, the rule will be applied for that item, unless there is a fixed price for that item.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="context")]
		public GetrulesforapricetableReturnRulesContext Context { get; set; }
		
		/// <summary>
		/// Rule ID.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="id")]
		public System.Nullable<System.Double> Id { get; set; }
	}
	
	public class GetrulesforapricetableReturnRulesContext
	{
		
		/// <summary>
		/// Brands that an item should have to be eligible for the rule. Format: key: `brandId`, value: `brandName`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="brands")]
		public System.Collections.Generic.Dictionary<string, string> Brands { get; set; }
		
		/// <summary>
		/// Categories that an item should have to be eligible for the rule. Format: key: `categoryId`, value: `categoryName`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="categories")]
		public System.Collections.Generic.Dictionary<string, string> Categories { get; set; }
		
		/// <summary>
		/// The rule will be active during this time range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dateRange")]
		public GetrulesforapricetableReturnRulesContextDateRange DateRange { get; set; }
		
		/// <summary>
		/// Internal Categories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalCategories")]
		public string InternalCategories { get; set; }
		
		/// <summary>
		/// For an item to be eligible to the rule, it's markup should be in this Markup Range.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="markupRange")]
		public GetrulesforapricetableReturnRulesContextMarkupRange MarkupRange { get; set; }
		
		/// <summary>
		/// Stock statuses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stockStatuses")]
		public string StockStatuses { get; set; }
	}
	
	public class GetrulesforapricetableReturnRulesContextDateRange
	{
		
		/// <summary>
		/// Date when rule will be activated. Date format: `RFC3339`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// Date when the rule will be deactivated. Date format: `RFC3339`.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class GetrulesforapricetableReturnRulesContextMarkupRange
	{
		
		/// <summary>
		/// Item markup should be greater than or equal to this value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="from")]
		public System.Nullable<System.Int32> From { get; set; }
		
		/// <summary>
		/// Item markup should be less than or equal to this value.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="to")]
		public System.Nullable<System.Int32> To { get; set; }
	}
	
	public class Price_TablesPutByPriceTableIdPutBody
	{
		
		/// <summary>
		/// Array of rules for the price table.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="rules")]
		public Price_TablesPutByPriceTableIdPutBodyRules[] Price_TablesPutByPriceTableIdPutBodyRules { get; set; }
	}
	
	public class Price_TablesPutByPriceTableIdPutBodyRules
	{
		
		/// <summary>
		/// Rule Context is a group of filters to be checked at an item level when applying the rule. If all those filters check out, the rule will be applied for that item, unless there is a fixed price for that item.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public Price_TablesPutByPriceTableIdPutBodyRulesContext Context { get; set; }
		
		/// <summary>
		/// Rule ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public int Id { get; set; }
		
		/// <summary>
		/// Percentual modifier.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="percentualModifier")]
		public double PercentualModifier { get; set; }
	}
	
	public class Price_TablesPutByPriceTableIdPutBodyRulesContext
	{
		
		/// <summary>
		/// Brands that an item should have to be eligible for the rule. Format: key: `brandId`, value: `brandName`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="brands")]
		public System.Collections.Generic.Dictionary<string, string> Brands { get; set; }
		
		/// <summary>
		/// Categories that an item should have to be eligible for the rule. Format: key: `categoryId`, value: `categoryName`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="categories")]
		public System.Collections.Generic.Dictionary<string, string> Categories { get; set; }
		
		/// <summary>
		/// The rule will be active during this time range.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="dateRange")]
		public Price_TablesPutByPriceTableIdPutBodyRulesContextDateRange DateRange { get; set; }
		
		/// <summary>
		/// Internal Categories.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="internalCategories")]
		public string InternalCategories { get; set; }
		
		/// <summary>
		/// For an item to be eligible to the rule, it's markup should be in this Markup Range.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="markupRange")]
		public Price_TablesPutByPriceTableIdPutBodyRulesContextMarkupRange MarkupRange { get; set; }
		
		/// <summary>
		/// Stock statuses.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="stockStatuses")]
		public string StockStatuses { get; set; }
	}
	
	public class Price_TablesPutByPriceTableIdPutBodyRulesContextDateRange
	{
		
		/// <summary>
		/// Date when rule will be activated. Date format: `RFC3339`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// Date when the rule will be deactivated. Date format: `RFC3339`.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class Price_TablesPutByPriceTableIdPutBodyRulesContextMarkupRange
	{
		
		/// <summary>
		/// Item markup should be greater than or equal to this value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public int From { get; set; }
		
		/// <summary>
		/// Item markup should be less than or equal to this value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public int To { get; set; }
	}
	
	public class CreateUpdatePriceOrFixedPricePutBody
	{
		
		/// <summary>
		/// SKU selling base price. If you decide to fill only the `basePrice` item, the `markup` and `costPrice` will be automatically generated to adapt to the number inserted in `basePrice`.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(100)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="basePrice")]
		public double BasePrice { get; set; } = 100;
		
		/// <summary>
		/// SKU selling cost price. If you decide to fill the `costPrice` item, you must also fill the `markup` and `basePrice` will be automatically generated based on both values.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="costPrice")]
		public System.Nullable<System.Double> CostPrice { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="fixedPrices")]
		public CreateUpdatePriceOrFixedPricePutBodyFixedPrices[] CreateUpdatePriceOrFixedPricePutBodyFixedPrices { get; set; }
		
		/// <summary>
		/// SKU's suggested selling price.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(50)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="listPrice")]
		public double ListPrice { get; set; } = 50;
		
		/// <summary>
		/// The profit percentage that is to be obtained from the sale of that SKU. If you decide to fill the `markup` item, you must also fill the `costPrice`. The `basePrice` will be automatically generated based on both values.
		/// Required
		/// </summary>
		[System.ComponentModel.DefaultValue(30)]
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="markup")]
		public int Markup { get; set; } = 30;
	}
	
	public class CreateUpdatePriceOrFixedPricePutBodyFixedPrices
	{
		
		/// <summary>
		/// Period of time when the fixed price will be applied to the SKU.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dateRange")]
		public CreateUpdatePriceOrFixedPricePutBodyFixedPricesDateRange DateRange { get; set; }
		
		/// <summary>
		/// SKU List Fixed Price.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listPrice")]
		public System.Nullable<System.Double> ListPrice { get; set; }
		
		/// <summary>
		/// Minimum quantity of the SKU for the fixed price to be applied.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minQuantity")]
		public int MinQuantity { get; set; }
		
		/// <summary>
		/// Trade policy name or ID that will have the fixed price configured.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tradePolicyId")]
		public string TradePolicyId { get; set; }
		
		/// <summary>
		/// Fixed price value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public double Value { get; set; }
	}
	
	public class CreateUpdatePriceOrFixedPricePutBodyFixedPricesDateRange
	{
		
		/// <summary>
		/// Start date of the price.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// End date of the price.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
	
	public class CreateorupdatefixedpricesonpricetableortradepolicyPostBody
	{
		
		/// <summary>
		/// Period of time when the fixed price will be applied to the SKU.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="dateRange")]
		public CreateorupdatefixedpricesonpricetableortradepolicyPostBodyDateRange DateRange { get; set; }
		
		/// <summary>
		/// SKU List Fixed Price.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="listPrice")]
		public System.Nullable<System.Double> ListPrice { get; set; }
		
		/// <summary>
		/// The minimum SKU quantity for the fixed price to be applied.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="minQuantity")]
		public int MinQuantity { get; set; }
		
		/// <summary>
		/// Fixed price value.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="value")]
		public double Value { get; set; }
	}
	
	public class CreateorupdatefixedpricesonpricetableortradepolicyPostBodyDateRange
	{
		
		/// <summary>
		/// Start date of the price.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="from")]
		public string From { get; set; }
		
		/// <summary>
		/// End date of the price.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="to")]
		public string To { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
