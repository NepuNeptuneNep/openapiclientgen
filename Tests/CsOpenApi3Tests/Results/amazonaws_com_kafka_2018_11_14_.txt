//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchAssociateScramSecretResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UnprocessedScramSecret[] UnprocessedScramSecrets { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Error info for scram secret associate/disassociate failure.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnprocessedScramSecret
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorMessage { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string SecretArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BadRequestException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UnauthorizedException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class InternalServerErrorException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ForbiddenException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NotFoundException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServiceUnavailableException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TooManyRequestsException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateClusterResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterState State { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The state of the Apache Kafka cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ClusterState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="HEALING")]
		HEALING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="MAINTENANCE")]
		MAINTENANCE = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REBOOTING_BROKER")]
		REBOOTING_BROKER = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="UPDATING")]
		UPDATING = 7,
	}
	
	/// <summary>
	/// 
	///            <p>The distribution of broker nodes across Availability Zones. This is an optional parameter. If you don't specify it, Amazon MSK gives it the value DEFAULT. You can also explicitly set this parameter to the value DEFAULT. No other values are currently allowed.</p>
	///         <p>Amazon MSK distributes the broker nodes evenly across the Availability Zones that correspond to the subnets you provide when you create the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum BrokerAZDistribution
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DEFAULT")]
		DEFAULT = 0,
	}
	
	/// <summary>
	/// 
	///            <p>Contains information about storage volumes attached to MSK broker nodes.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StorageInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public EBSStorageInfo EbsStorageInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Contains information about the EBS storage volumes attached to Apache Kafka broker nodes.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EBSStorageInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> VolumeSize { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Contains information about provisioned throughput for EBS storage volumes attached to kafka broker nodes.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProvisionedThroughput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> VolumeThroughput { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Information about the broker access configuration.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConnectivityInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PublicAccess PublicAccess { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectivity VpcConnectivity { get; set; }
	}
	
	/// <summary>
	/// Public access control for brokers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PublicAccess
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Type { get; set; }
	}
	
	/// <summary>
	/// VPC connectivity access control for brokers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConnectivity
	{
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectivityClientAuthentication ClientAuthentication { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Includes all client authentication information for VPC connectivity.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConnectivityClientAuthentication
	{
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectivitySasl Sasl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectivityTls Tls { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Details for SASL client authentication for VPC connectivity.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConnectivitySasl
	{
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectivityScram Scram { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectivityIam Iam { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Details for SASL/SCRAM client authentication for VPC connectivity.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConnectivityScram
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Details for IAM access control for VPC connectivity.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConnectivityIam
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Details for TLS client authentication for VPC connectivity.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConnectivityTls
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Details for client authentication using SASL.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Sasl
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Scram Scram { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Iam Iam { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Details for SASL/SCRAM client authentication.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Scram
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Details for IAM access control.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Iam
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Details for client authentication using TLS.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Tls
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string[] CertificateAuthorityArnList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Unauthenticated
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The data-volume encryption details.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EncryptionAtRest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string DataVolumeKMSKeyId { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The settings for encrypting data in transit.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EncryptionInTransit
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClientBroker ClientBroker { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> InCluster { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Client-broker encryption in transit setting.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ClientBroker
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TLS")]
		TLS = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TLS_PLAINTEXT")]
		TLS_PLAINTEXT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PLAINTEXT")]
		PLAINTEXT = 2,
	}
	
	/// <summary>
	/// 
	///            <p>Prometheus settings.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PrometheusInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public JmxExporterInfo JmxExporter { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public NodeExporterInfo NodeExporter { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JmxExporterInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EnabledInBroker { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeExporterInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EnabledInBroker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BrokerLogs
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CloudWatchLogs CloudWatchLogs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Firehose Firehose { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public S3 S3 { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CloudWatchLogs
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string LogGroup { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Firehose
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string DeliveryStream { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool Enabled { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class S3
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Bucket { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Prefix { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConflictException
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateClusterV2Response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterType ClusterType { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The type of cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ClusterType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PROVISIONED")]
		PROVISIONED = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="SERVERLESS")]
		SERVERLESS = 1,
	}
	
	/// <summary>
	/// 
	///            <p>Describes the setup to be used for Apache Kafka broker nodes in the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BrokerNodeGroupInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerAZDistribution BrokerAZDistribution { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] ClientSubnets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string InstanceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SecurityGroups { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageInfo StorageInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConnectivityInfo ConnectivityInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ZoneIds { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Includes all client authentication information.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClientAuthentication
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Sasl Sasl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tls Tls { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Unauthenticated Unauthenticated { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Specifies the configuration to use for the brokers.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigurationInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Revision { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class EncryptionInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionAtRest EncryptionAtRest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInTransit EncryptionInTransit { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum EnhancedMonitoring
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DEFAULT")]
		DEFAULT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PER_BROKER")]
		PER_BROKER = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PER_TOPIC_PER_BROKER")]
		PER_TOPIC_PER_BROKER = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="PER_TOPIC_PER_PARTITION")]
		PER_TOPIC_PER_PARTITION = 3,
	}
	
	/// <summary>
	/// 
	///            <p>JMX and Node monitoring for the MSK cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OpenMonitoringInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public PrometheusInfo Prometheus { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class LoggingInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BrokerLogs BrokerLogs { get; set; }
	}
	
	/// <summary>
	/// Controls storage mode for various supported storage tiers.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum StorageMode
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="LOCAL")]
		LOCAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="TIERED")]
		TIERED = 1,
	}
	
	/// <summary>
	/// 
	///            <p>The configuration of the Amazon VPCs for the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConfig
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] SubnetIds { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SecurityGroupIds { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Includes all client authentication information.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServerlessClientAuthentication
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ServerlessSasl Sasl { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Details for client authentication using SASL.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServerlessSasl
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Iam Iam { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationRevision LatestRevision { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationState State { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Describes a configuration revision.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ConfigurationRevision
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int Revision { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The state of a configuration.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum ConfigurationState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETE_FAILED")]
		DELETE_FAILED = 2,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVpcConnectionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcConnectionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectionState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Authentication { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ClientSubnets { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SecurityGroups { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The state of a VPC connection.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum VpcConnectionState
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="CREATING")]
		CREATING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AVAILABLE")]
		AVAILABLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="INACTIVE")]
		INACTIVE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DEACTIVATING")]
		DEACTIVATING = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DELETING")]
		DELETING = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="FAILED")]
		FAILED = 5,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REJECTED")]
		REJECTED = 6,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="REJECTING")]
		REJECTING = 7,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class @__mapOf__string
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteClusterResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteClusterPolicyResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVpcConnectionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcConnectionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectionState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeClusterResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterInfo ClusterInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about a cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ActiveOperationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerNodeGroupInfo BrokerNodeGroupInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClientAuthentication ClientAuthentication { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerSoftwareInfo CurrentBrokerSoftwareInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInfo EncryptionInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EnhancedMonitoring EnhancedMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoring OpenMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NumberOfBrokerNodes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StateInfo StateInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ZookeeperConnectString { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ZookeeperConnectStringTls { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageMode StorageMode { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Information about the current software installed on the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BrokerSoftwareInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ConfigurationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> ConfigurationRevision { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KafkaVersion { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>JMX and Node monitoring for the MSK cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class OpenMonitoring
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public Prometheus Prometheus { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Prometheus settings.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Prometheus
	{
		
		[System.Runtime.Serialization.DataMember()]
		public JmxExporter JmxExporter { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public NodeExporter NodeExporter { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Indicates whether you want to turn on or turn off the JMX Exporter.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class JmxExporter
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EnabledInBroker { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Indicates whether you want to turn on or turn off the Node Exporter.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeExporter
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public bool EnabledInBroker { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StateInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Code { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Message { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeClusterV2Response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Cluster ClusterInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about a cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Cluster
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ActiveOperationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterType ClusterType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StateInfo StateInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Provisioned Provisioned { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Serverless Serverless { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Provisioned cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Provisioned
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BrokerNodeGroupInfo BrokerNodeGroupInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerSoftwareInfo CurrentBrokerSoftwareInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClientAuthentication ClientAuthentication { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInfo EncryptionInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EnhancedMonitoring EnhancedMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoringInfo OpenMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int NumberOfBrokerNodes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ZookeeperConnectString { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ZookeeperConnectStringTls { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageMode StorageMode { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Serverless cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Serverless
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public VpcConfig[] VpcConfigs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ServerlessClientAuthentication ClientAuthentication { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeClusterOperationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationInfo ClusterOperationInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about a cluster operation.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterOperationInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientRequestId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ErrorInfo ErrorInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationStep[] OperationSteps { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MutableClusterInfo SourceClusterInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MutableClusterInfo TargetClusterInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectionInfo VpcConnectionInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about an error state of the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ErrorInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorCode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ErrorString { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Step taken during a cluster operation.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterOperationStep
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationStepInfo StepInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string StepName { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>State information about the operation step.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterOperationStepInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string StepStatus { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Information about cluster attributes that can be updated via update APIs.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class MutableClusterInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerEBSVolumeInfo[] BrokerEBSVolumeInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationInfo ConfigurationInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NumberOfBrokerNodes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EnhancedMonitoring EnhancedMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoring OpenMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KafkaVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string InstanceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClientAuthentication ClientAuthentication { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInfo EncryptionInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConnectivityInfo ConnectivityInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageMode StorageMode { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Specifies the EBS volume upgrade information. The broker identifier must be set to the keyword ALL. This means the changes apply to all the brokers in the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BrokerEBSVolumeInfo
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string KafkaBrokerNodeId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> VolumeSizeGB { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Description of the VPC connection.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConnectionInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcConnectionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserIdentity UserIdentity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Description of the requester that calls the API operation.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UserIdentity
	{
		
		[System.Runtime.Serialization.DataMember()]
		public UserIdentityType Type { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string PrincipalId { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The identity type of the requester that calls the API operation.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum UserIdentityType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSACCOUNT")]
		AWSACCOUNT = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="AWSSERVICE")]
		AWSSERVICE = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeClusterOperationV2Response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationV2 ClusterOperationInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about a cluster operation.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterOperationV2
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterType ClusterType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ErrorInfo ErrorInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationV2Provisioned Provisioned { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationV2Serverless Serverless { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about a provisioned cluster operation.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterOperationV2Provisioned
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationStep[] OperationSteps { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MutableClusterInfo SourceClusterInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public MutableClusterInfo TargetClusterInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectionInfo VpcConnectionInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about a serverless cluster operation.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterOperationV2Serverless
	{
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectionInfoServerless VpcConnectionInfo { get; set; }
	}
	
	/// <summary>
	/// Description of the VPC connection.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConnectionInfoServerless
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Owner { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UserIdentity UserIdentity { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcConnectionArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] KafkaVersions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationRevision LatestRevision { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeConfigurationRevisionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Revision { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ServerProperties { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVpcConnectionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcConnectionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string TargetClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectionState State { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Authentication { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Subnets { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SecurityGroups { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchDisassociateScramSecretResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public UnprocessedScramSecret[] UnprocessedScramSecrets { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetBootstrapBrokersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerString { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerStringTls { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerStringSaslScram { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerStringSaslIam { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerStringPublicTls { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerStringPublicSaslScram { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerStringPublicSaslIam { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerStringVpcConnectivityTls { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerStringVpcConnectivitySaslScram { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string BootstrapBrokerStringVpcConnectivitySaslIam { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetCompatibleKafkaVersionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public CompatibleKafkaVersion[] CompatibleKafkaVersions { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Contains source Apache Kafka versions and compatible target Apache Kafka versions.</p>
	///        
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CompatibleKafkaVersion
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string SourceVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] TargetVersions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetClusterPolicyResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListClusterOperationsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationInfo[] ClusterOperationInfoList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListClusterOperationsV2Response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterOperationV2Summary[] ClusterOperationInfoList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Returns information about a cluster operation.</p>
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClusterOperationV2Summary
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterType ClusterType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset StartTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset EndTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationState { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string OperationType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListClustersResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClusterInfo[] ClusterInfoList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListClustersV2Response
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Cluster[] ClusterInfoList { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListConfigurationRevisionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationRevision[] Revisions { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListConfigurationsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Configuration[] Configurations { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Represents an MSK Configuration.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Configuration
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] KafkaVersions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationRevision LatestRevision { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListKafkaVersionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public KafkaVersion[] KafkaVersions { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class KafkaVersion
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Version { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public KafkaVersionStatus Status { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum KafkaVersionStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="ACTIVE")]
		ACTIVE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="DEPRECATED")]
		DEPRECATED = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListNodesResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public NodeInfo[] NodeInfoList { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The node information object.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NodeInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AddedToClusterTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerNodeInfo BrokerNodeInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string InstanceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NodeARN { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public NodeType NodeType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ZookeeperNodeInfo ZookeeperNodeInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>BrokerNodeInfo</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BrokerNodeInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AttachedENIId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> BrokerId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientSubnet { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientVpcIpAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerSoftwareInfo CurrentBrokerSoftwareInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Endpoints { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The broker or Zookeeper node.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
	[System.SerializableAttribute()]
	public enum NodeType
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute(Value="BROKER")]
		BROKER = 0,
	}
	
	/// <summary>
	/// 
	///            <p>Zookeeper node information.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ZookeeperNodeInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string AttachedENIId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClientVpcIpAddress { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] Endpoints { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Double> ZookeeperId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ZookeeperVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListScramSecretsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SecretArnList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListClientVpcConnectionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClientVpcConnection[] ClientVpcConnections { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The client VPC connection object.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ClientVpcConnection
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Authentication { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectionState State { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string VpcConnectionArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Owner { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVpcConnectionsResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnection[] VpcConnections { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string NextToken { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>The VPC connection object.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class VpcConnection
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string VpcConnectionArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TargetClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.DateTimeOffset CreationTime { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string Authentication { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectionState State { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RejectClientVpcConnectionResponse
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutClusterPolicyResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RebootBrokerResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateBrokerCountResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateBrokerTypeResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateBrokerStorageResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationRevision LatestRevision { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateConnectivityResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateClusterConfigurationResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateClusterKafkaVersionResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateMonitoringResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateSecurityResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateStorageResponse
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterArn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string ClusterOperationArn { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Associates sasl scram secrets to cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchAssociateScramSecretRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] SecretArnList { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Provisioned cluster request.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ProvisionedRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BrokerNodeGroupInfo BrokerNodeGroupInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClientAuthentication ClientAuthentication { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationInfo ConfigurationInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInfo EncryptionInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EnhancedMonitoring EnhancedMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoringInfo OpenMonitoring { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string KafkaVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int NumberOfBrokerNodes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageMode StorageMode { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Serverless cluster request.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ServerlessRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public VpcConfig[] VpcConfigs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ServerlessClientAuthentication ClientAuthentication { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateClusterV2Request
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ClusterName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedRequest Provisioned { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ServerlessRequest Serverless { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateClusterRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BrokerNodeGroupInfo BrokerNodeGroupInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClientAuthentication ClientAuthentication { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ClusterName { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationInfo ConfigurationInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInfo EncryptionInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EnhancedMonitoring EnhancedMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoringInfo OpenMonitoring { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string KafkaVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int NumberOfBrokerNodes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageMode StorageMode { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateConfigurationRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] KafkaVersions { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Name { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerProperties { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CreateVpcConnectionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TargetClusterArn { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Authentication { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string VpcId { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] ClientSubnets { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] SecurityGroups { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteClusterRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteClusterPolicyRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteConfigurationRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DeleteVpcConnectionRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeClusterOperationRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeClusterOperationV2Request
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeClusterRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeClusterV2Request
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeConfigurationRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeConfigurationRevisionRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class DescribeVpcConnectionRequest
	{
	}
	
	/// <summary>
	/// 
	///            <p>Disassociates sasl scram secrets to cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class BatchDisassociateScramSecretRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] SecretArnList { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetBootstrapBrokersRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetCompatibleKafkaVersionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class GetClusterPolicyRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListClusterOperationsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListClusterOperationsV2Request
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListClustersRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListClustersV2Request
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListConfigurationRevisionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListConfigurationsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListKafkaVersionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListNodesRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListScramSecretsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListTagsForResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListClientVpcConnectionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ListVpcConnectionsRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RejectClientVpcConnectionRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string VpcConnectionArn { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PutClusterPolicyRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string Policy { get; set; }
	}
	
	/// <summary>
	/// Reboots a node.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class RebootBrokerRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string[] BrokerIds { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class TagResourceRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public @__mapOf__string Tags { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UntagResourceRequest
	{
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateBrokerCountRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public int TargetNumberOfBrokerNodes { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateBrokerTypeRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TargetInstanceType { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateBrokerStorageRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public BrokerEBSVolumeInfo[] TargetBrokerEBSVolumeInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateClusterConfigurationRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationInfo ConfigurationInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateClusterKafkaVersionRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationInfo ConfigurationInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string TargetKafkaVersion { get; set; }
	}
	
	/// <summary>
	/// Request body for UpdateMonitoring.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateMonitoringRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EnhancedMonitoring EnhancedMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoringInfo OpenMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateSecurityRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public ClientAuthentication ClientAuthentication { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInfo EncryptionInfo { get; set; }
	}
	
	/// <summary>
	/// 
	///            <p>Request object for UpdateStorage api. Its used to update the storage attributes for the cluster.</p>
	///         
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateStorageRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ProvisionedThroughput ProvisionedThroughput { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageMode StorageMode { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> VolumeSizeGB { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateConfigurationRequest
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Description { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string ServerProperties { get; set; }
	}
	
	/// <summary>
	/// Request body for UpdateConnectivity.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class UpdateConnectivityRequest
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public ConnectivityInfo ConnectivityInfo { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember()]
		public string CurrentVersion { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// 
		/// <p>Associates one or more Scram Secrets with an Amazon MSK cluster.</p>
		/// 
		/// BatchAssociateScramSecret v1/clusters/{clusterArn}/scram-secrets
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<BatchAssociateScramSecretResponse> BatchAssociateScramSecretAsync(string clusterArn, BatchAssociateScramSecretPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/scram-secrets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchAssociateScramSecretResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Disassociates one or more Scram Secrets from an Amazon MSK cluster.</p>
		/// 
		/// BatchDisassociateScramSecret v1/clusters/{clusterArn}/scram-secrets
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<BatchDisassociateScramSecretResponse> BatchDisassociateScramSecretAsync(string clusterArn, BatchDisassociateScramSecretPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/scram-secrets";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<BatchDisassociateScramSecretResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of the Scram Secrets associated with an Amazon MSK cluster.</p>
		/// 
		/// ListScramSecrets v1/clusters/{clusterArn}/scram-secrets
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The arn of the cluster.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maxResults of the query.</p>
		///         
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">
		///            <p>The nextToken of the query.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListScramSecretsResponse> ListScramSecretsAsync(string clusterArn, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/scram-secrets&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListScramSecretsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Creates a new MSK cluster.</p>
		/// 
		/// CreateCluster v1/clusters
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateClusterResponse> CreateClusterAsync(CreateClusterPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateClusterResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the MSK clusters in the current Region.</p>
		/// 
		/// ListClusters v1/clusters
		/// </summary>
		/// <param name="clusterNameFilter">
		///            <p>Specify a prefix of the name of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListClustersResponse> ListClustersAsync(string clusterNameFilter, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters?clusterNameFilter=" + (clusterNameFilter==null? "" : System.Uri.EscapeDataString(clusterNameFilter))+"&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListClustersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Creates a new MSK cluster.</p>
		/// 
		/// CreateClusterV2 api/v2/clusters
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateClusterV2Response> CreateClusterV2Async(CreateClusterV2PostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/clusters";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateClusterV2Response>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the MSK clusters in the current Region.</p>
		/// 
		/// ListClustersV2 api/v2/clusters
		/// </summary>
		/// <param name="clusterNameFilter">
		///            <p>Specify a prefix of the names of the clusters that you want to list. The service lists all the clusters whose names start with this prefix.</p>
		///         </param>
		/// <param name="clusterTypeFilter">
		///            <p>Specify either PROVISIONED or SERVERLESS.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListClustersV2Response> ListClustersV2Async(string clusterNameFilter, string clusterTypeFilter, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/clusters?clusterNameFilter=" + (clusterNameFilter==null? "" : System.Uri.EscapeDataString(clusterNameFilter))+"&clusterTypeFilter=" + (clusterTypeFilter==null? "" : System.Uri.EscapeDataString(clusterTypeFilter))+"&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListClustersV2Response>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Creates a new MSK configuration.</p>
		/// 
		/// CreateConfiguration v1/configurations
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateConfigurationResponse> CreateConfigurationAsync(CreateConfigurationPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/configurations";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the MSK configurations in this Region.</p>
		/// 
		/// ListConfigurations v1/configurations
		/// </summary>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListConfigurationsResponse> ListConfigurationsAsync(int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/configurations?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListConfigurationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Creates a new MSK VPC connection.</p>
		/// 
		/// CreateVpcConnection v1/vpc-connection
		/// </summary>
		/// <returns>Success</returns>
		public async Task<CreateVpcConnectionResponse> CreateVpcConnectionAsync(CreateVpcConnectionPostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/vpc-connection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CreateVpcConnectionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Deletes the MSK cluster specified by the Amazon Resource Name (ARN) in the request.</p>
		/// 
		/// DeleteCluster v1/clusters/{clusterArn}
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <param name="currentVersion">
		///            <p>The current version of the MSK cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DeleteClusterResponse> DeleteClusterAsync(string clusterArn, string currentVersion, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"&currentVersion=" + (currentVersion==null? "" : System.Uri.EscapeDataString(currentVersion));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteClusterResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of the MSK cluster whose Amazon Resource Name (ARN) is specified in the request.</p>
		/// 
		/// DescribeCluster v1/clusters/{clusterArn}
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DescribeClusterResponse> DescribeClusterAsync(string clusterArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeClusterResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Deletes the MSK cluster policy specified by the Amazon Resource Name (ARN) in the request.</p>
		/// 
		/// DeleteClusterPolicy v1/clusters/{clusterArn}/policy
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DeleteClusterPolicyResponse> DeleteClusterPolicyAsync(string clusterArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteClusterPolicyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Get the MSK cluster policy specified by the Amazon Resource Name (ARN) in the request.</p>
		/// 
		/// GetClusterPolicy v1/clusters/{clusterArn}/policy
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster.</p>
		///            </param>
		/// <returns>Success</returns>
		public async Task<GetClusterPolicyResponse> GetClusterPolicyAsync(string clusterArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetClusterPolicyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Creates or updates the MSK cluster policy specified by the cluster Amazon Resource Name (ARN) in the request.</p>
		/// 
		/// PutClusterPolicy v1/clusters/{clusterArn}/policy
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<PutClusterPolicyResponse> PutClusterPolicyAsync(string clusterArn, PutClusterPolicyPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/policy";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<PutClusterPolicyResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Deletes an MSK Configuration.</p>
		/// 
		/// DeleteConfiguration v1/configurations/{arn}
		/// </summary>
		/// <param name="arn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DeleteConfigurationResponse> DeleteConfigurationAsync(string arn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/configurations/"+ (arn==null? "" : System.Uri.EscapeDataString(arn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of this MSK configuration.</p>
		/// 
		/// DescribeConfiguration v1/configurations/{arn}
		/// </summary>
		/// <param name="arn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DescribeConfigurationResponse> DescribeConfigurationAsync(string arn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/configurations/"+ (arn==null? "" : System.Uri.EscapeDataString(arn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates an MSK configuration.</p>
		/// 
		/// UpdateConfiguration v1/configurations/{arn}
		/// </summary>
		/// <param name="arn">
		///            <p>The Amazon Resource Name (ARN) of the configuration.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateConfigurationResponse> UpdateConfigurationAsync(string arn, UpdateConfigurationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/configurations/"+ (arn==null? "" : System.Uri.EscapeDataString(arn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Deletes a MSK VPC connection.</p>
		/// 
		/// DeleteVpcConnection v1/vpc-connection/{arn}
		/// </summary>
		/// <param name="arn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK VPC connection.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DeleteVpcConnectionResponse> DeleteVpcConnectionAsync(string arn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/vpc-connection/"+ (arn==null? "" : System.Uri.EscapeDataString(arn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DeleteVpcConnectionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of this MSK VPC connection.</p>
		/// 
		/// DescribeVpcConnection v1/vpc-connection/{arn}
		/// </summary>
		/// <param name="arn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies a MSK VPC connection.</p>
		///   </param>
		/// <returns>Success</returns>
		public async Task<DescribeVpcConnectionResponse> DescribeVpcConnectionAsync(string arn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/vpc-connection/"+ (arn==null? "" : System.Uri.EscapeDataString(arn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeVpcConnectionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of the MSK cluster whose Amazon Resource Name (ARN) is specified in the request.</p>
		/// 
		/// DescribeClusterV2 api/v2/clusters/{clusterArn}
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DescribeClusterV2Response> DescribeClusterV2Async(string clusterArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeClusterV2Response>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of the cluster operation specified by the ARN.</p>
		/// 
		/// DescribeClusterOperation v1/operations/{clusterOperationArn}
		/// </summary>
		/// <param name="clusterOperationArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the MSK cluster operation.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DescribeClusterOperationResponse> DescribeClusterOperationAsync(string clusterOperationArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/operations/"+ (clusterOperationArn==null? "" : System.Uri.EscapeDataString(clusterOperationArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeClusterOperationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of the cluster operation specified by the ARN.</p>
		/// 
		/// DescribeClusterOperationV2 api/v2/operations/{clusterOperationArn}
		/// </summary>
		/// <param name="clusterOperationArn">ARN of the cluster operation to describe.</param>
		/// <returns>Success</returns>
		public async Task<DescribeClusterOperationV2Response> DescribeClusterOperationV2Async(string clusterOperationArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/operations/"+ (clusterOperationArn==null? "" : System.Uri.EscapeDataString(clusterOperationArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeClusterOperationV2Response>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a description of this revision of the configuration.</p>
		/// 
		/// DescribeConfigurationRevision v1/configurations/{arn}/revisions/{revision}
		/// </summary>
		/// <param name="arn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
		///         </param>
		/// <param name="revision">
		///            <p>A string that uniquely identifies a revision of an MSK configuration.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<DescribeConfigurationRevisionResponse> DescribeConfigurationRevisionAsync(string arn, int revision, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/configurations/"+ (arn==null? "" : System.Uri.EscapeDataString(arn))+"/revisions/"+revision;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<DescribeConfigurationRevisionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>A list of brokers that a client application can use to bootstrap.</p>
		/// 
		/// GetBootstrapBrokers v1/clusters/{clusterArn}/bootstrap-brokers
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<GetBootstrapBrokersResponse> GetBootstrapBrokersAsync(string clusterArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/bootstrap-brokers";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetBootstrapBrokersResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Gets the Apache Kafka versions to which you can update the MSK cluster.</p>
		/// 
		/// GetCompatibleKafkaVersions v1/compatible-kafka-versions
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster check.</p>
		///            </param>
		/// <returns>Success</returns>
		public async Task<GetCompatibleKafkaVersionsResponse> GetCompatibleKafkaVersionsAsync(string clusterArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/compatible-kafka-versions?clusterArn=" + (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<GetCompatibleKafkaVersionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the operations that have been performed on the specified MSK cluster.</p>
		/// 
		/// ListClusterOperations v1/clusters/{clusterArn}/operations
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListClusterOperationsResponse> ListClusterOperationsAsync(string clusterArn, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/operations&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListClusterOperationsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the operations that have been performed on the specified MSK cluster.</p>
		/// 
		/// ListClusterOperationsV2 api/v2/clusters/{clusterArn}/operations
		/// </summary>
		/// <param name="clusterArn">The arn of the cluster whose operations are being requested.</param>
		/// <param name="maxResults">The maxResults of the query.
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">The nextToken of the query.</param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListClusterOperationsV2Response> ListClusterOperationsV2Async(string clusterArn, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "api/v2/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/operations&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListClusterOperationsV2Response>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the MSK configurations in this Region.</p>
		/// 
		/// ListConfigurationRevisions v1/configurations/{arn}/revisions
		/// </summary>
		/// <param name="arn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies an MSK configuration and all of its revisions.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListConfigurationRevisionsResponse> ListConfigurationRevisionsAsync(string arn, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/configurations/"+ (arn==null? "" : System.Uri.EscapeDataString(arn))+"/revisions&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListConfigurationRevisionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of Apache Kafka versions.</p>
		/// 
		/// ListKafkaVersions v1/kafka-versions
		/// </summary>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. To get the next batch, provide this token in your next request.</p></param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListKafkaVersionsResponse> ListKafkaVersionsAsync(int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/kafka-versions?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListKafkaVersionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of the broker nodes in the cluster.</p>
		/// 
		/// ListNodes v1/clusters/{clusterArn}/nodes
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListNodesResponse> ListNodesAsync(string clusterArn, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/nodes&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListNodesResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of the tags associated with the specified resource.</p>
		/// 
		/// ListTagsForResource v1/tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<ListTagsForResourceResponse> ListTagsForResourceAsync(string resourceArn, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListTagsForResourceResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Adds tags to the specified MSK resource.</p>
		/// 
		/// TagResource v1/tags/{resourceArn}
		/// </summary>
		/// <param name="resourceArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
		///         </param>
		public async Task TagResourceAsync(string resourceArn, TagResourcePostBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the VPC connections in this Region.</p>
		/// 
		/// ListClientVpcConnections v1/clusters/{clusterArn}/client-vpc-connections
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster.</p>
		///         </param>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListClientVpcConnectionsResponse> ListClientVpcConnectionsAsync(string clusterArn, int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/client-vpc-connections&maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListClientVpcConnectionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns a list of all the VPC connections in this Region.</p>
		/// 
		/// ListVpcConnections v1/vpc-connections
		/// </summary>
		/// <param name="maxResults">
		///            <p>The maximum number of results to return in the response. If there are more results, the response includes a NextToken parameter.</p>
		///         
		/// Minimum: 1
		/// Maximum: 100
		// </param>
		/// <param name="nextToken">
		///            <p>The paginated results marker. When the result of the operation is truncated, the call returns NextToken in the response. 
		///            To get the next batch, provide this token in your next request.</p>
		///         </param>
		/// <param name="MaxResults">Pagination limit</param>
		/// <param name="NextToken">Pagination token</param>
		/// <returns>Success</returns>
		public async Task<ListVpcConnectionsResponse> ListVpcConnectionsAsync(int maxResults, string nextToken, string MaxResults, string NextToken, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/vpc-connections?maxResults="+maxResults+"&nextToken=" + (nextToken==null? "" : System.Uri.EscapeDataString(nextToken))+"&MaxResults=" + (MaxResults==null? "" : System.Uri.EscapeDataString(MaxResults))+"&NextToken=" + (NextToken==null? "" : System.Uri.EscapeDataString(NextToken));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<ListVpcConnectionsResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Returns empty response.</p>
		/// 
		/// RejectClientVpcConnection v1/clusters/{clusterArn}/client-vpc-connection
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<RejectClientVpcConnectionResponse> RejectClientVpcConnectionAsync(string clusterArn, RejectClientVpcConnectionPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/client-vpc-connection";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RejectClientVpcConnectionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Reboots brokers.
		/// RebootBroker v1/clusters/{clusterArn}/reboot-broker
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<RebootBrokerResponse> RebootBrokerAsync(string clusterArn, RebootBrokerPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/reboot-broker";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<RebootBrokerResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Removes the tags associated with the keys that are provided in the query.</p>
		/// 
		/// UntagResource v1/tags/{resourceArn}#tagKeys
		/// </summary>
		/// <param name="resourceArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the resource that's associated with the tags.</p>
		///         </param>
		/// <param name="tagKeys">
		///            <p>Tag keys must be unique for a given cluster. In addition, the following restrictions apply:</p>
		///            <ul>
		///               <li>
		///                  <p>Each tag key must be unique. If you add a tag with a key that's already in
		///                  use, your new tag overwrites the existing key-value pair. </p>
		///               </li>
		///               <li>
		///                  <p>You can't start a tag key with aws: because this prefix is reserved for use
		///                  by  AWS.  AWS creates tags that begin with this prefix on your behalf, but
		///                  you can't edit or delete them.</p>
		///               </li>
		///               <li>
		///                  <p>Tag keys must be between 1 and 128 Unicode characters in length.</p>
		///               </li>
		///               <li>
		///                  <p>Tag keys must consist of the following characters: Unicode letters, digits,
		///                  white space, and the following special characters: _ . / = + -
		///                     @.</p>
		///               </li>
		///            </ul>
		///         </param>
		public async Task UntagResourceAsync(string resourceArn, string[] tagKeys, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/tags/"+ (resourceArn==null? "" : System.Uri.EscapeDataString(resourceArn))+"#tagKeys&"+string.Join("&", tagKeys.Select(z => $"tagKeys={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the number of broker nodes in the cluster.</p>
		/// 
		/// UpdateBrokerCount v1/clusters/{clusterArn}/nodes/count
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateBrokerCountResponse> UpdateBrokerCountAsync(string clusterArn, UpdateBrokerCountPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/nodes/count";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateBrokerCountResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates EC2 instance type.</p>
		/// 
		/// UpdateBrokerType v1/clusters/{clusterArn}/nodes/type
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateBrokerTypeResponse> UpdateBrokerTypeAsync(string clusterArn, UpdateBrokerTypePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/nodes/type";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateBrokerTypeResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the EBS storage associated with MSK brokers.</p>
		/// 
		/// UpdateBrokerStorage v1/clusters/{clusterArn}/nodes/storage
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateBrokerStorageResponse> UpdateBrokerStorageAsync(string clusterArn, UpdateBrokerStoragePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/nodes/storage";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateBrokerStorageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the cluster's connectivity configuration.</p>
		/// 
		/// UpdateConnectivity v1/clusters/{clusterArn}/connectivity
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the configuration.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateConnectivityResponse> UpdateConnectivityAsync(string clusterArn, UpdateConnectivityPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/connectivity";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateConnectivityResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the cluster with the configuration that is specified in the request body.</p>
		/// 
		/// UpdateClusterConfiguration v1/clusters/{clusterArn}/configuration
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateClusterConfigurationResponse> UpdateClusterConfigurationAsync(string clusterArn, UpdateClusterConfigurationPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/configuration";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateClusterConfigurationResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the Apache Kafka version for the cluster.</p>
		/// 
		/// UpdateClusterKafkaVersion v1/clusters/{clusterArn}/version
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
		///            </param>
		/// <returns>Success</returns>
		public async Task<UpdateClusterKafkaVersionResponse> UpdateClusterKafkaVersionAsync(string clusterArn, UpdateClusterKafkaVersionPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/version";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateClusterKafkaVersionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the monitoring settings for the cluster. You can use this operation to specify which Apache Kafka metrics you want Amazon MSK to send to Amazon CloudWatch. You can also specify settings for open monitoring with Prometheus.</p>
		/// 
		/// UpdateMonitoring v1/clusters/{clusterArn}/monitoring
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateMonitoringResponse> UpdateMonitoringAsync(string clusterArn, UpdateMonitoringPutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/monitoring";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateMonitoringResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// 
		/// <p>Updates the security settings for the cluster. You can use this operation to specify encryption and authentication on existing clusters.</p>
		/// 
		/// UpdateSecurity v1/clusters/{clusterArn}/security
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateSecurityResponse> UpdateSecurityAsync(string clusterArn, UpdateSecurityPatchBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/security";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateSecurityResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Updates cluster broker volume size (or) sets cluster storage mode to TIERED.
		/// UpdateStorage v1/clusters/{clusterArn}/storage
		/// </summary>
		/// <param name="clusterArn">
		///            <p>The Amazon Resource Name (ARN) of the cluster to be updated.</p>
		///         </param>
		/// <returns>Success</returns>
		public async Task<UpdateStorageResponse> UpdateStorageAsync(string clusterArn, UpdateStoragePutBody requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "v1/clusters/"+ (clusterArn==null? "" : System.Uri.EscapeDataString(clusterArn))+"/storage";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Put, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<UpdateStorageResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
	}
	
	public class BatchAssociateScramSecretPostBody
	{
		
		/// <summary>
		/// 
		///            <p>List of AWS Secrets Manager secret ARNs.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secretArnList")]
		public string[] SecretArnList { get; set; }
	}
	
	public class BatchDisassociateScramSecretPatchBody
	{
		
		/// <summary>
		/// 
		///            <p>List of AWS Secrets Manager secret ARNs.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="secretArnList")]
		public string[] SecretArnList { get; set; }
	}
	
	public class CreateClusterPostBody
	{
		
		/// <summary>
		/// 
		///            <p>Describes the setup to be used for Apache Kafka broker nodes in the cluster.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="brokerNodeGroupInfo")]
		public CreateClusterPostBodyBrokerNodeGroupInfo BrokerNodeGroupInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Includes all client authentication information.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientAuthentication")]
		public CreateClusterPostBodyClientAuthentication ClientAuthentication { get; set; }
		
		/// <summary>
		/// 
		///            <p>The name of the cluster.</p>
		///         
		/// Required
		/// Min length: 1
		/// Max length: 64
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clusterName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string ClusterName { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies the configuration to use for the brokers.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configurationInfo")]
		public CreateClusterPostBodyConfigurationInfo ConfigurationInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionInfo")]
		public CreateClusterPostBodyEncryptionInfo EncryptionInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enhancedMonitoring")]
		public EnhancedMonitoring EnhancedMonitoring { get; set; }
		
		/// <summary>
		/// 
		///            <p>JMX and Node monitoring for the MSK cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="openMonitoring")]
		public CreateClusterPostBodyOpenMonitoring OpenMonitoring { get; set; }
		
		/// <summary>
		/// 
		///            <p>The version of Apache Kafka.</p>
		///         
		/// Required
		/// Min length: 1
		/// Max length: 128
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="kafkaVersion")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(128)]
		public string KafkaVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="loggingInfo")]
		public CreateClusterPostBodyLoggingInfo LoggingInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>The number of broker nodes in the cluster.</p>
		///         
		/// Required
		/// Minimum: 1
		/// Maximum: 15
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="numberOfBrokerNodes")]
		[System.ComponentModel.DataAnnotations.Range(1, 15)]
		public int NumberOfBrokerNodes { get; set; }
		
		/// <summary>
		/// 
		///            <p>Create tags when creating the cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// Controls storage mode for various supported storage tiers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageMode")]
		public StorageMode StorageMode { get; set; }
	}
	
	public class CreateClusterPostBodyBrokerNodeGroupInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerAZDistribution BrokerAZDistribution { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ClientSubnets { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string InstanceType { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] SecurityGroups { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageInfo StorageInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConnectivityInfo ConnectivityInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string[] ZoneIds { get; set; }
	}
	
	public class CreateClusterPostBodyClientAuthentication
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Sasl Sasl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tls Tls { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Unauthenticated Unauthenticated { get; set; }
	}
	
	public class CreateClusterPostBodyConfigurationInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Revision { get; set; }
	}
	
	public class CreateClusterPostBodyEncryptionInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionAtRest EncryptionAtRest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInTransit EncryptionInTransit { get; set; }
	}
	
	public class CreateClusterPostBodyOpenMonitoring
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PrometheusInfo Prometheus { get; set; }
	}
	
	public class CreateClusterPostBodyLoggingInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerLogs BrokerLogs { get; set; }
	}
	
	public class CreateClusterV2PostBody
	{
		
		/// <summary>
		/// 
		///            <p>The name of the cluster.</p>
		///         
		/// Required
		/// Min length: 1
		/// Max length: 64
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clusterName")]
		[System.ComponentModel.DataAnnotations.MinLength(1)]
		[System.ComponentModel.DataAnnotations.MaxLength(64)]
		public string ClusterName { get; set; }
		
		/// <summary>
		/// 
		///            <p>A map of tags that you want the cluster to have.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
		
		/// <summary>
		/// 
		///            <p>Provisioned cluster request.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisioned")]
		public CreateClusterV2PostBodyProvisioned Provisioned { get; set; }
		
		/// <summary>
		/// 
		///            <p>Serverless cluster request.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="serverless")]
		public CreateClusterV2PostBodyServerless Serverless { get; set; }
	}
	
	public class CreateClusterV2PostBodyProvisioned
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerNodeGroupInfo BrokerNodeGroupInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ClientAuthentication ClientAuthentication { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ConfigurationInfo ConfigurationInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInfo EncryptionInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EnhancedMonitoring EnhancedMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public OpenMonitoringInfo OpenMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public string KafkaVersion { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public LoggingInfo LoggingInfo { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> NumberOfBrokerNodes { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public StorageMode StorageMode { get; set; }
	}
	
	public class CreateClusterV2PostBodyServerless
	{
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConfig[] VpcConfigs { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public ServerlessClientAuthentication ClientAuthentication { get; set; }
	}
	
	public class CreateConfigurationPostBody
	{
		
		/// <summary>
		/// 
		///            <p>The description of the configuration.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// 
		///            <p>The versions of Apache Kafka with which you can use this MSK configuration.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="kafkaVersions")]
		public string[] KafkaVersions { get; set; }
		
		/// <summary>
		/// 
		///            <p>The name of the configuration.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// 
		///            <p>Contents of the <filename>server.properties</filename> file. When using the API, you must ensure that the contents of the file are base64 encoded. 
		///               When using the AWS Management Console, the SDK, or the AWS CLI, the contents of <filename>server.properties</filename> can be in plaintext.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serverProperties")]
		public string ServerProperties { get; set; }
	}
	
	public class CreateVpcConnectionPostBody
	{
		
		/// <summary>
		/// 
		///            <p>The cluster Amazon Resource Name (ARN) for the VPC connection.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetClusterArn")]
		public string TargetClusterArn { get; set; }
		
		/// <summary>
		/// 
		///            <p>The authentication type of VPC connection.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="authentication")]
		public string Authentication { get; set; }
		
		/// <summary>
		/// 
		///            <p>The VPC ID of VPC connection.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vpcId")]
		public string VpcId { get; set; }
		
		/// <summary>
		/// 
		///            <p>The list of client subnets.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="clientSubnets")]
		public string[] ClientSubnets { get; set; }
		
		/// <summary>
		/// 
		///            <p>The list of security groups.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="securityGroups")]
		public string[] SecurityGroups { get; set; }
		
		/// <summary>
		/// 
		///            <p>A map of tags for the VPC connection.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class PutClusterPolicyPutBody
	{
		
		/// <summary>
		/// 
		///            <p>The policy version.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>The policy.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="policy")]
		public string Policy { get; set; }
	}
	
	public class UpdateConfigurationPutBody
	{
		
		/// <summary>
		/// 
		///            <p>The description of the configuration revision.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="description")]
		public string Description { get; set; }
		
		/// <summary>
		/// 
		///            <p>Contents of the <filename>server.properties</filename> file. When using the API, you must ensure that the contents of the file are base64 encoded. 
		///               When using the AWS Management Console, the SDK, or the AWS CLI, the contents of <filename>server.properties</filename> can be in plaintext.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="serverProperties")]
		public string ServerProperties { get; set; }
	}
	
	public class TagResourcePostBody
	{
		
		/// <summary>
		/// 
		///            <p>The key-value pair for the resource tag.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="tags")]
		public System.Collections.Generic.Dictionary<string, string> Tags { get; set; }
	}
	
	public class RejectClientVpcConnectionPutBody
	{
		
		/// <summary>
		/// 
		///            <p>The VPC connection ARN.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="vpcConnectionArn")]
		public string VpcConnectionArn { get; set; }
	}
	
	public class RebootBrokerPutBody
	{
		
		/// <summary>
		/// 
		///            <p>The list of broker IDs to be rebooted. The reboot-broker operation supports rebooting one broker at a time.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="brokerIds")]
		public string[] BrokerIds { get; set; }
	}
	
	public class UpdateBrokerCountPutBody
	{
		
		/// <summary>
		/// 
		///            <p>The version of cluster to update from. A successful operation will then generate a new version.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>The number of broker nodes that you want the cluster to have after this operation completes successfully.</p>
		///         
		/// Required
		/// Minimum: 1
		/// Maximum: 15
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetNumberOfBrokerNodes")]
		[System.ComponentModel.DataAnnotations.Range(1, 15)]
		public int TargetNumberOfBrokerNodes { get; set; }
	}
	
	public class UpdateBrokerTypePutBody
	{
		
		/// <summary>
		/// 
		///            <p>The cluster version that you want to change. After this operation completes successfully, the cluster will have a new version.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>The Amazon MSK broker type that you want all of the brokers in this cluster to be.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetInstanceType")]
		public string TargetInstanceType { get; set; }
	}
	
	public class UpdateBrokerStoragePutBody
	{
		
		/// <summary>
		/// 
		///            <p>The version of cluster to update from. A successful operation will then generate a new version.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>Describes the target volume size and the ID of the broker to apply the update to.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetBrokerEBSVolumeInfo")]
		public BrokerEBSVolumeInfo[] TargetBrokerEBSVolumeInfo { get; set; }
	}
	
	public class UpdateConnectivityPutBody
	{
		
		/// <summary>
		/// 
		///            <p>Information about the broker access configuration.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="connectivityInfo")]
		public UpdateConnectivityPutBodyConnectivityInfo ConnectivityInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public string CurrentVersion { get; set; }
	}
	
	public class UpdateConnectivityPutBodyConnectivityInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PublicAccess PublicAccess { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public VpcConnectivity VpcConnectivity { get; set; }
	}
	
	public class UpdateClusterConfigurationPutBody
	{
		
		/// <summary>
		/// 
		///            <p>Specifies the configuration to use for the brokers.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="configurationInfo")]
		public UpdateClusterConfigurationPutBodyConfigurationInfo ConfigurationInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>The version of the cluster that needs to be updated.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public string CurrentVersion { get; set; }
	}
	
	public class UpdateClusterConfigurationPutBodyConfigurationInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Revision { get; set; }
	}
	
	public class UpdateClusterKafkaVersionPutBody
	{
		
		/// <summary>
		/// 
		///            <p>Specifies the configuration to use for the brokers.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="configurationInfo")]
		public UpdateClusterKafkaVersionPutBodyConfigurationInfo ConfigurationInfo { get; set; }
		
		/// <summary>
		/// 
		///            <p>Current cluster version.</p>
		///            
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>Target Kafka version.</p>
		///            
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="targetKafkaVersion")]
		public string TargetKafkaVersion { get; set; }
	}
	
	public class UpdateClusterKafkaVersionPutBodyConfigurationInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public string Arn { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> Revision { get; set; }
	}
	
	public class UpdateMonitoringPutBody
	{
		
		/// <summary>
		/// 
		///            <p>The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>Specifies which metrics are gathered for the MSK cluster. This property has the following possible values: DEFAULT, PER_BROKER, PER_TOPIC_PER_BROKER, and PER_TOPIC_PER_PARTITION. For a list of the metrics associated with each of these levels of monitoring, see <a href="https://docs.aws.amazon.com/msk/latest/developerguide/monitoring.html">Monitoring</a>.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="enhancedMonitoring")]
		public EnhancedMonitoring EnhancedMonitoring { get; set; }
		
		/// <summary>
		/// 
		///            <p>JMX and Node monitoring for the MSK cluster.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="openMonitoring")]
		public UpdateMonitoringPutBodyOpenMonitoring OpenMonitoring { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="loggingInfo")]
		public UpdateMonitoringPutBodyLoggingInfo LoggingInfo { get; set; }
	}
	
	public class UpdateMonitoringPutBodyOpenMonitoring
	{
		
		[System.Runtime.Serialization.DataMember()]
		public PrometheusInfo Prometheus { get; set; }
	}
	
	public class UpdateMonitoringPutBodyLoggingInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public BrokerLogs BrokerLogs { get; set; }
	}
	
	public class UpdateSecurityPatchBody
	{
		
		/// <summary>
		/// 
		///            <p>Includes all client authentication information.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="clientAuthentication")]
		public UpdateSecurityPatchBodyClientAuthentication ClientAuthentication { get; set; }
		
		/// <summary>
		/// 
		///            <p>The version of the MSK cluster to update. Cluster versions aren't simple numbers. You can describe an MSK cluster to find its version. When this update operation is successful, it generates a new cluster version.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>Includes encryption-related information, such as the AWS KMS key used for encrypting data at rest and whether you want MSK to encrypt your data in transit.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encryptionInfo")]
		public UpdateSecurityPatchBodyEncryptionInfo EncryptionInfo { get; set; }
	}
	
	public class UpdateSecurityPatchBodyClientAuthentication
	{
		
		[System.Runtime.Serialization.DataMember()]
		public Sasl Sasl { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Tls Tls { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public Unauthenticated Unauthenticated { get; set; }
	}
	
	public class UpdateSecurityPatchBodyEncryptionInfo
	{
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionAtRest EncryptionAtRest { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public EncryptionInTransit EncryptionInTransit { get; set; }
	}
	
	public class UpdateStoragePutBody
	{
		
		/// <summary>
		/// 
		///            <p>The version of cluster to update from. A successful operation will then generate a new version.</p>
		///         
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="currentVersion")]
		public string CurrentVersion { get; set; }
		
		/// <summary>
		/// 
		///            <p>Contains information about provisioned throughput for EBS storage volumes attached to kafka broker nodes.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="provisionedThroughput")]
		public UpdateStoragePutBodyProvisionedThroughput ProvisionedThroughput { get; set; }
		
		/// <summary>
		/// Controls storage mode for various supported storage tiers.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="storageMode")]
		public StorageMode StorageMode { get; set; }
		
		/// <summary>
		/// 
		///            <p>size of the EBS volume to update.</p>
		///         
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="volumeSizeGB")]
		public System.Nullable<System.Int32> VolumeSizeGB { get; set; }
	}
	
	public class UpdateStoragePutBodyProvisionedThroughput
	{
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Boolean> Enabled { get; set; }
		
		[System.Runtime.Serialization.DataMember()]
		public System.Nullable<System.Int32> VolumeThroughput { get; set; }
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
