//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace MyNS
{
	using System;
	using System.Linq;
	using System.Collections.Generic;
	using System.Threading.Tasks;
	using Newtonsoft.Json;
	using Fonlow.Net.Http;
	
	
	/// <summary>
	/// Collections of files
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CollectionResponseFile
	{
		
		[System.Runtime.Serialization.DataMember(Name="paging")]
		public Paging Paging { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public File[] Results { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Paging
	{
		
		[System.Runtime.Serialization.DataMember(Name="next")]
		public NextPage Next { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="prev")]
		public PreviousPage Prev { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class NextPage
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="after")]
		public string After { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="link")]
		public string Link { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class PreviousPage
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="before")]
		public string Before { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="link")]
		public string Link { get; set; }
	}
	
	/// <summary>
	/// File
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class File
	{
		
		/// <summary>
		/// File access. Can be PUBLIC_INDEXABLE, PUBLIC_NOT_INDEXABLE, PRIVATE.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public FileAccess Access { get; set; }
		
		/// <summary>
		/// If the file is deleted.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public bool Archived { get; set; }
		
		/// <summary>
		/// Deletion time of the file object.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archivedAt")]
		public System.Nullable<System.DateTimeOffset> ArchivedAt { get; set; }
		
		/// <summary>
		/// Creation time of the file object.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// Default hosting URL of the file. This will use one of HubSpot's provided URLs to serve the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="defaultHostingUrl")]
		public string DefaultHostingUrl { get; set; }
		
		/// <summary>
		/// Encoding of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="encoding")]
		public string Encoding { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public System.Nullable<System.Int64> ExpiresAt { get; set; }
		
		/// <summary>
		/// Extension of the file. ex: .jpg, .png, .gif, .pdf, etc.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// For image and video files, the height of the content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// File ID.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Previously "archied". Indicates if the file should be used when creating new content like web pages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isUsableInContent")]
		public System.Nullable<System.Boolean> IsUsableInContent { get; set; }
		
		/// <summary>
		/// Name of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the folder the file is in.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentFolderId")]
		public string ParentFolderId { get; set; }
		
		/// <summary>
		/// Path of the file in the file manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Size of the file in bytes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="size")]
		public System.Nullable<System.Int64> Size { get; set; }
		
		/// <summary>
		/// Type of the file. Can be IMG, DOCUMENT, AUDIO, MOVIE, or OTHER.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Timestamp of the latest update to the file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
		
		/// <summary>
		/// URL of the given file. This URL can change depending on the domain settings of the account. Will use the select file hosting domain.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// For image and video files, the width of the content.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FileAccess
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC_INDEXABLE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PUBLIC_NOT_INDEXABLE = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIDDEN_INDEXABLE = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIDDEN_NOT_INDEXABLE = 3,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		HIDDEN_PRIVATE = 4,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PRIVATE = 5,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class CollectionResponseFolder
	{
		
		[System.Runtime.Serialization.DataMember(Name="paging")]
		public Paging Paging { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="results")]
		public Folder[] Results { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Folder
	{
		
		/// <summary>
		/// Marks whether the folder is deleted or not.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="archived")]
		public bool Archived { get; set; }
		
		/// <summary>
		/// Timestamp of folder deletion.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="archivedAt")]
		public System.Nullable<System.DateTimeOffset> ArchivedAt { get; set; }
		
		/// <summary>
		/// Timestamp of folder creation.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="createdAt")]
		public System.DateTimeOffset CreatedAt { get; set; }
		
		/// <summary>
		/// ID of the folder.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Name of the folder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// ID of the parent folder.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentFolderId")]
		public string ParentFolderId { get; set; }
		
		/// <summary>
		/// Path of the folder in the file manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="path")]
		public string Path { get; set; }
		
		/// <summary>
		/// Timestamp of the latest update to the folder.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="updatedAt")]
		public System.DateTimeOffset UpdatedAt { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class Error
	{
		
		/// <summary>
		/// The error category
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// Context about the error condition
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="context")]
		public System.Collections.Generic.Dictionary<string, string[]> Context { get; set; }
		
		/// <summary>
		/// A unique identifier for the request. Include this value with any error reports or support tickets
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="correlationId")]
		public string CorrelationId { get; set; }
		
		/// <summary>
		/// further information about the error
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public ErrorDetail[] Errors { get; set; }
		
		/// <summary>
		/// A map of link names to associated URIs containing documentation about the error or recommended remediation steps
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public System.Collections.Generic.Dictionary<string, string> Links { get; set; }
		
		/// <summary>
		/// A human readable message describing the error along with remediation steps where appropriate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// A specific category that contains more specific detail about the error
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subCategory")]
		public string SubCategory { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ErrorDetail
	{
		
		/// <summary>
		/// The status code associated with the error detail
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="code")]
		public string Code { get; set; }
		
		/// <summary>
		/// Context about the error condition
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="context")]
		public System.Collections.Generic.Dictionary<string, string[]> Context { get; set; }
		
		/// <summary>
		/// The name of the field or parameter in which the error was found.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="in")]
		public string In { get; set; }
		
		/// <summary>
		/// A human readable message describing the error along with remediation steps where appropriate
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// A specific category that contains more specific detail about the error
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="subCategory")]
		public string SubCategory { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FileActionResponse
	{
		
		/// <summary>
		/// Time of completion of task.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public System.DateTimeOffset CompletedAt { get; set; }
		
		/// <summary>
		/// Descriptive error messages.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public StandardError[] Errors { get; set; }
		
		/// <summary>
		/// Link to check the status of the requested task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public System.Collections.Generic.Dictionary<string, string> Links { get; set; }
		
		/// <summary>
		/// Number of errors resulting from the task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numErrors")]
		public System.Nullable<System.Int32> NumErrors { get; set; }
		
		/// <summary>
		/// Timestamp of when the task was requested.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestedAt")]
		public System.Nullable<System.DateTimeOffset> RequestedAt { get; set; }
		
		/// <summary>
		/// File
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="result")]
		public File Result { get; set; }
		
		/// <summary>
		/// Timestamp of when the task was started.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.DateTimeOffset StartedAt { get; set; }
		
		/// <summary>
		/// Current status of the task.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public FileActionResponseStatus Status { get; set; }
		
		/// <summary>
		/// ID of the requested task.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="taskId")]
		public string TaskId { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class StandardError
	{
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="category")]
		public string Category { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="context")]
		public System.Collections.Generic.Dictionary<string, string[]> Context { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public ErrorDetail[] Errors { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="links")]
		public System.Collections.Generic.Dictionary<string, string> Links { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="message")]
		public string Message { get; set; }
		
		/// <summary>
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public string Status { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="subCategory")]
		public string SubCategory { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum FileActionResponseStatus
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PENDING = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		PROCESSING = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		CANCELED = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		COMPLETE = 3,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FileStat
	{
		
		/// <summary>
		/// File
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="file")]
		public File File { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="folder")]
		public Folder Folder { get; set; }
	}
	
	/// <summary>
	/// Object for updating files.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FileUpdateInput
	{
		
		/// <summary>
		/// NONE: Do not run any duplicate validation. REJECT: Reject the upload if a duplicate is found. RETURN_EXISTING: If a duplicate file is found, do not upload a new file and return the found duplicate instead.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="access")]
		public FileAccess Access { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public System.Nullable<System.Int64> ExpiresAt { get; set; }
		
		/// <summary>
		/// Mark whether the file should be used in new content or not.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="isUsableInContent")]
		public System.Nullable<System.Boolean> IsUsableInContent { get; set; }
		
		/// <summary>
		/// New name for the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// FolderId where the file should be moved to. folderId and folderPath parameters cannot be set at the same time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentFolderId")]
		public string ParentFolderId { get; set; }
		
		/// <summary>
		/// Folder path where the file should be moved to. folderId and folderPath parameters cannot be set at the same time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentFolderPath")]
		public string ParentFolderPath { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FolderActionResponse
	{
		
		/// <summary>
		/// When the requested changes have been completed.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="completedAt")]
		public System.DateTimeOffset CompletedAt { get; set; }
		
		/// <summary>
		/// Detailed errors resulting from the task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="errors")]
		public StandardError[] Errors { get; set; }
		
		/// <summary>
		/// Link to check the status of the task.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="links")]
		public System.Collections.Generic.Dictionary<string, string> Links { get; set; }
		
		/// <summary>
		/// Number of errors resulting from the requested changes.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="numErrors")]
		public System.Nullable<System.Int32> NumErrors { get; set; }
		
		/// <summary>
		/// Timestamp representing when the task was requested.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="requestedAt")]
		public System.Nullable<System.DateTimeOffset> RequestedAt { get; set; }
		
		[System.Runtime.Serialization.DataMember(Name="result")]
		public Folder Result { get; set; }
		
		/// <summary>
		/// Timestamp representing when the task was started at.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="startedAt")]
		public System.DateTimeOffset StartedAt { get; set; }
		
		/// <summary>
		/// Current status of the task.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="status")]
		public FileActionResponseStatus Status { get; set; }
		
		/// <summary>
		/// ID of the task.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="taskId")]
		public string TaskId { get; set; }
	}
	
	/// <summary>
	/// Object for creating a folder.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FolderInput
	{
		
		/// <summary>
		/// Desired name for the folder.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// FolderId of the parent of the created folder. If not specified, the folder will be created at the root level. parentFolderId and parentFolderPath cannot be set at the same time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentFolderId")]
		public string ParentFolderId { get; set; }
		
		/// <summary>
		/// Path of the parent of the created folder. If not specified the folder will be created at the root level. parentFolderPath and parentFolderId cannot be set at the same time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentPath")]
		public string ParentPath { get; set; }
	}
	
	/// <summary>
	/// Object for updating folders.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FolderUpdateInput
	{
		
		/// <summary>
		/// ID of the folder to change.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// New name. If specified the folder's name and fullPath will change. All children of the folder will be updated accordingly.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// New parent folderId. If changed, the folder and all it's children will be moved into the specified folder. parentFolderId and parentFolderPath cannot be specified at the same time.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="parentFolderId")]
		public System.Nullable<System.Int64> ParentFolderId { get; set; }
	}
	
	/// <summary>
	/// Information on the task that has been started, and where to check it's status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class FolderUpdateTaskLocator
	{
		
		/// <summary>
		/// ID of the task
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Links for where to check information related to the task. The `status` link gives the URL for where to check the status of the task.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="links")]
		public System.Collections.Generic.Dictionary<string, string> Links { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportFromUrlInput
	{
		
		/// <summary>
		/// PUBLIC_INDEXABLE: File is publicly accessible by anyone who has the URL. Search engines can index the file. PUBLIC_NOT_INDEXABLE: File is publicly accessible by anyone who has the URL. Search engines *can't* index the file. PRIVATE: File is NOT publicly accessible. Requires a signed URL to see content. Search engines *can't* index the file.
		///
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="access")]
		public FileAccess Access { get; set; }
		
		/// <summary>
		/// ENTIRE_PORTAL: Look for a duplicate file in the entire account. EXACT_FOLDER: Look for a duplicate file in the provided folder.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duplicateValidationScope")]
		public System.Nullable<ImportFromUrlInputDuplicateValidationScope> DuplicateValidationScope { get; set; }
		
		/// <summary>
		/// NONE: Do not run any duplicate validation. REJECT: Reject the upload if a duplicate is found. RETURN_EXISTING: If a duplicate file is found, do not upload a new file and return the found duplicate instead.
		///
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="duplicateValidationStrategy")]
		public System.Nullable<ImportFromUrlInputDuplicateValidationStrategy> DuplicateValidationStrategy { get; set; }
		
		/// <summary>
		/// One of folderId or folderPath is required. Destination folderId for the uploaded file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="folderId")]
		public string FolderId { get; set; }
		
		/// <summary>
		/// One of folderPath or folderId is required. Destination folder path for the uploaded file. If the folder path does not exist, there will be an attempt to create the folder path.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="folderPath")]
		public string FolderPath { get; set; }
		
		/// <summary>
		/// Name to give the resulting file in the file manager.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// If true, will overwrite existing file if one with the same name and extension exists in the given folder. The overwritten file will be deleted and the uploaded file will take its place with a new ID. If unset or set as false, the new file's name will be updated to prevent colliding with existing file if one exists with the same path, name, and extension
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="overwrite")]
		public System.Nullable<System.Boolean> Overwrite { get; set; }
		
		/// <summary>
		/// Time to live. If specified the file will be deleted after the given time frame. If left unset, the file will exist indefinitely
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="ttl")]
		public string Ttl { get; set; }
		
		/// <summary>
		/// URL to download the new file from.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ImportFromUrlInputDuplicateValidationScope
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		ENTIRE_PORTAL = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		EXACT_FOLDER = 1,
	}
	
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public enum ImportFromUrlInputDuplicateValidationStrategy
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		NONE = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		REJECT = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		RETURN_EXISTING = 2,
	}
	
	/// <summary>
	/// Information on the task that has been started, and where to check it's status.
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class ImportFromUrlTaskLocator
	{
		
		/// <summary>
		/// ID of the task
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="id")]
		public string Id { get; set; }
		
		/// <summary>
		/// Links for where to check information related to the task. The `status` link gives the URL for where to check the status of the task.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="links")]
		public System.Collections.Generic.Dictionary<string, string> Links { get; set; }
	}
	
	/// <summary>
	/// Signed Url object with optional ancillary metadata of requested file
	/// </summary>
	[System.Runtime.Serialization.DataContract(Namespace="")]
	[System.SerializableAttribute()]
	public class SignedUrl
	{
		
		/// <summary>
		/// Timestamp of when the URL will no longer grant access to the file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="expiresAt")]
		public System.DateTimeOffset ExpiresAt { get; set; }
		
		/// <summary>
		/// Extension of the requested file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="extension")]
		public string Extension { get; set; }
		
		/// <summary>
		/// For image and video files. The height of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="height")]
		public System.Nullable<System.Int32> Height { get; set; }
		
		/// <summary>
		/// Name of the requested file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="name")]
		public string Name { get; set; }
		
		/// <summary>
		/// Size in bytes of the requested file.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="size")]
		public int Size { get; set; }
		
		/// <summary>
		/// Type of the file. Can be IMG, DOCUMENT, AUDIO, MOVIE, or OTHER.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="type")]
		public string Type { get; set; }
		
		/// <summary>
		/// Signed URL with access to the specified file. Anyone with this URL will be able to access the file until it expires.
		/// Required
		/// </summary>
		[System.ComponentModel.DataAnnotations.Required()]
		[System.Runtime.Serialization.DataMember(Name="url")]
		public string Url { get; set; }
		
		/// <summary>
		/// For image and video files. The width of the file.
		/// </summary>
		[System.Runtime.Serialization.DataMember(Name="width")]
		public System.Nullable<System.Int32> Width { get; set; }
	}
	
	public partial class Misc
	{
		
		private System.Net.Http.HttpClient httpClient;
		
		private JsonSerializerSettings jsonSerializerSettings;
		
		public Misc(System.Net.Http.HttpClient httpClient, JsonSerializerSettings jsonSerializerSettings=null)
		{
			if (httpClient == null)
				throw new ArgumentNullException("Null HttpClient.", "httpClient");

			if (httpClient.BaseAddress == null)
				throw new ArgumentNullException("HttpClient has no BaseAddress", "httpClient");

			this.httpClient = httpClient;
			this.jsonSerializerSettings = jsonSerializerSettings;
		}
		
		/// <summary>
		/// Import a file from a URL into the file manager.
		/// Asynchronously imports the file at the given URL into the file manager.
		/// Post_SlashfilesSlashv3SlashfilesSlashimport_from_urlSlashasync_importFromUrl files/v3/files/import-from-url/async
		/// </summary>
		public async Task Post_SlashfilesSlashv3SlashfilesSlashimport_from_urlSlashasync_importFromUrlAsync(ImportFromUrlInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/files/import-from-url/async";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Check import status.
		/// Check the status of requested import.
		/// Get_SlashfilesSlashv3SlashfilesSlashimport_from_urlSlashasyncSlashtasksSlashtaskIdSlashstatus_checkImport files/v3/files/import-from-url/async/tasks/{taskId}/status
		/// </summary>
		/// <param name="taskId">Import by URL task ID</param>
		/// <returns>successful operation</returns>
		public async Task<FileActionResponse> Get_SlashfilesSlashv3SlashfilesSlashimport_from_urlSlashasyncSlashtasksSlashtaskIdSlashstatus_checkImportAsync(string taskId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/files/import-from-url/async/tasks/"+ (taskId==null? "" : System.Uri.EscapeDataString(taskId))+"/status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FileActionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Search files
		/// Search through files in the file manager. Does not display hidden or archived files.
		/// Get_SlashfilesSlashv3SlashfilesSlashsearch_doSearch files/v3/files/search
		/// </summary>
		/// <param name="properties">Desired file properties in the return object.</param>
		/// <param name="after">The maximum offset of items for a given search is 10000. Narrow your search down if you are reaching this limit.</param>
		/// <param name="limit">Number of items to return. Maximum limit is 100.</param>
		/// <param name="sort">Sort files by a given field.</param>
		/// <param name="id">Search files by given ID.</param>
		/// <param name="createdAt">Search files by time of creation.</param>
		/// <param name="updatedAt">Search files by time of latest updated.</param>
		/// <param name="name">Search for files containing the given name.</param>
		/// <param name="path">Search files by path.</param>
		/// <param name="parentFolderId">Search files within given folderId.</param>
		/// <param name="size">Query by file size.</param>
		/// <param name="height">Search files by height of image or video.</param>
		/// <param name="width">Search files by width of image or video.</param>
		/// <param name="encoding">Search files with specified encoding.</param>
		/// <param name="type">Filter by provided file type.</param>
		/// <param name="extension">Search files by given extension.</param>
		/// <param name="url">Search for given URL</param>
		/// <param name="isUsableInContent">If true shows files that have been marked to be used in new content. It false shows files that should not be used in new content.</param>
		/// <param name="allowsAnonymousAccess">If 'true' will show private files; if 'false' will show public files</param>
		/// <returns>successful operation</returns>
		public async Task<CollectionResponseFile> Get_SlashfilesSlashv3SlashfilesSlashsearch_doSearchAsync(
					string[] properties, 
					string after, 
					string before, 
					int limit, 
					string[] sort, 
					string id, 
					System.DateTimeOffset createdAt, 
					System.DateTimeOffset createdAtLte, 
					System.DateTimeOffset createdAtGte, 
					System.DateTimeOffset updatedAt, 
					System.DateTimeOffset updatedAtLte, 
					System.DateTimeOffset updatedAtGte, 
					string name, 
					string path, 
					long parentFolderId, 
					long size, 
					int height, 
					int width, 
					string encoding, 
					string type, 
					string extension, 
					string url, 
					bool isUsableInContent, 
					bool allowsAnonymousAccess, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/files/search?"+string.Join("&", properties.Select(z => $"properties={System.Uri.EscapeDataString(z.ToString())}"))+"&after=" + (after==null? "" : System.Uri.EscapeDataString(after))+"&before=" + (before==null? "" : System.Uri.EscapeDataString(before))+"&limit="+limit+"&"+string.Join("&", sort.Select(z => $"sort={System.Uri.EscapeDataString(z.ToString())}"))+"&id=" + (id==null? "" : System.Uri.EscapeDataString(id))+"&createdAt=" + createdAt.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&createdAtLte=" + createdAtLte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&createdAtGte=" + createdAtGte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&updatedAt=" + updatedAt.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&updatedAtLte=" + updatedAtLte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&updatedAtGte=" + updatedAtGte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&parentFolderId="+parentFolderId+"&size="+size+"&height="+height+"&width="+width+"&encoding=" + (encoding==null? "" : System.Uri.EscapeDataString(encoding))+"&type=" + (type==null? "" : System.Uri.EscapeDataString(type))+"&extension=" + (extension==null? "" : System.Uri.EscapeDataString(extension))+"&url=" + (url==null? "" : System.Uri.EscapeDataString(url))+"&isUsableInContent="+isUsableInContent+"&allowsAnonymousAccess="+allowsAnonymousAccess;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CollectionResponseFile>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get_SlashfilesSlashv3SlashfilesSlashstatSlashpath_getMetadata files/v3/files/stat/{path}
		/// </summary>
		/// <returns>successful operation</returns>
		public async Task<FileStat> Get_SlashfilesSlashv3SlashfilesSlashstatSlashpath_getMetadataAsync(string path, string[] properties, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/files/stat/"+ (path==null? "" : System.Uri.EscapeDataString(path))+"&"+string.Join("&", properties.Select(z => $"properties={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FileStat>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete file
		/// Delete file by ID
		/// Delete_SlashfilesSlashv3SlashfilesSlashfileId_archive files/v3/files/{fileId}
		/// </summary>
		/// <param name="fileId">FileId to delete</param>
		public async Task Delete_SlashfilesSlashv3SlashfilesSlashfileId_archiveAsync(string fileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/files/"+ (fileId==null? "" : System.Uri.EscapeDataString(fileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get file.
		/// Get file by ID.
		/// Get_SlashfilesSlashv3SlashfilesSlashfileId_getById files/v3/files/{fileId}
		/// </summary>
		/// <param name="fileId">ID of the desired file.</param>
		/// <returns>successful operation</returns>
		public async Task<File> Get_SlashfilesSlashv3SlashfilesSlashfileId_getByIdAsync(string fileId, string[] properties, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/files/"+ (fileId==null? "" : System.Uri.EscapeDataString(fileId))+"&"+string.Join("&", properties.Select(z => $"properties={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<File>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// update file properties
		/// Update properties of file by ID.
		/// Patch_SlashfilesSlashv3SlashfilesSlashfileId_updateProperties files/v3/files/{fileId}
		/// </summary>
		/// <param name="fileId">ID of file to update</param>
		/// <param name="requestBody">Options to update.</param>
		/// <returns>successful operation</returns>
		public async Task<File> Patch_SlashfilesSlashv3SlashfilesSlashfileId_updatePropertiesAsync(string fileId, FileUpdateInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/files/"+ (fileId==null? "" : System.Uri.EscapeDataString(fileId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Patch, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<File>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// GDPR delete
		/// GDRP delete file
		/// Delete_SlashfilesSlashv3SlashfilesSlashfileIdSlashgdpr_delete_archiveGDPR files/v3/files/{fileId}/gdpr-delete
		/// </summary>
		/// <param name="fileId">ID of file to GDPR delete</param>
		public async Task Delete_SlashfilesSlashv3SlashfilesSlashfileIdSlashgdpr_delete_archiveGDPRAsync(string fileId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/files/"+ (fileId==null? "" : System.Uri.EscapeDataString(fileId))+"/gdpr-delete";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get signed URL to access private file.
		/// Generates signed URL that allows temporary access to a private file.
		/// Get_SlashfilesSlashv3SlashfilesSlashfileIdSlashsigned_url_getSignedUrl files/v3/files/{fileId}/signed-url
		/// </summary>
		/// <param name="fileId">ID of file.</param>
		/// <param name="size">For image files. This will resize the image to the desired size before sharing. Does not affect the original file, just the file served by this signed URL.</param>
		/// <param name="expirationSeconds">How long in seconds the link will provide access to the file.</param>
		/// <param name="upscale">If size is provided, this will upscale the image to fit the size dimensions.</param>
		/// <returns>successful operation</returns>
		public async Task<SignedUrl> Get_SlashfilesSlashv3SlashfilesSlashfileIdSlashsigned_url_getSignedUrlAsync(string fileId, Get_SlashfilesSlashv3SlashfilesSlashfileIdSlashsigned_url_getSignedUrlSize size, long expirationSeconds, bool upscale, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/files/"+ (fileId==null? "" : System.Uri.EscapeDataString(fileId))+"/signed-url&size=" + size+"&expirationSeconds="+expirationSeconds+"&upscale="+upscale;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<SignedUrl>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Create folder.
		/// Creates a folder.
		/// Post_SlashfilesSlashv3Slashfolders_create files/v3/folders
		/// </summary>
		/// <param name="requestBody">Folder creation options</param>
		public async Task Post_SlashfilesSlashv3Slashfolders_createAsync(FolderInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/folders";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Search folders
		/// Search for folders. Does not contain hidden or archived folders.
		/// Get_SlashfilesSlashv3SlashfoldersSlashsearch_doSearch files/v3/folders/search
		/// </summary>
		/// <param name="properties">Properties that should be included in the returned folders.</param>
		/// <param name="after">The maximum offset of items for a given search is 10000. Narrow your search down if you are reaching this limit.</param>
		/// <param name="limit">Limit of results to return. Max limit is 100.</param>
		/// <param name="sort">Sort results by given property. For example -name sorts by name field descending, name sorts by name field ascending.</param>
		/// <param name="id">Search folder by given ID.</param>
		/// <param name="createdAt">Search for folders with the given creation timestamp.</param>
		/// <param name="updatedAt">Search for folder at given update timestamp.</param>
		/// <param name="name">Search for folders containing the specified name.</param>
		/// <param name="path">Search for folders by path.</param>
		/// <param name="parentFolderId">Search for folders with the given parent folderId.</param>
		/// <returns>successful operation</returns>
		public async Task<CollectionResponseFolder> Get_SlashfilesSlashv3SlashfoldersSlashsearch_doSearchAsync(
					string[] properties, 
					string after, 
					string before, 
					int limit, 
					string[] sort, 
					string id, 
					System.DateTimeOffset createdAt, 
					System.DateTimeOffset createdAtLte, 
					System.DateTimeOffset createdAtGte, 
					System.DateTimeOffset updatedAt, 
					System.DateTimeOffset updatedAtLte, 
					System.DateTimeOffset updatedAtGte, 
					string name, 
					string path, 
					long parentFolderId, 
					Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/folders/search?"+string.Join("&", properties.Select(z => $"properties={System.Uri.EscapeDataString(z.ToString())}"))+"&after=" + (after==null? "" : System.Uri.EscapeDataString(after))+"&before=" + (before==null? "" : System.Uri.EscapeDataString(before))+"&limit="+limit+"&"+string.Join("&", sort.Select(z => $"sort={System.Uri.EscapeDataString(z.ToString())}"))+"&id=" + (id==null? "" : System.Uri.EscapeDataString(id))+"&createdAt=" + createdAt.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&createdAtLte=" + createdAtLte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&createdAtGte=" + createdAtGte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&updatedAt=" + updatedAt.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&updatedAtLte=" + updatedAtLte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&updatedAtGte=" + updatedAtGte.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")+"&name=" + (name==null? "" : System.Uri.EscapeDataString(name))+"&path=" + (path==null? "" : System.Uri.EscapeDataString(path))+"&parentFolderId="+parentFolderId;
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<CollectionResponseFolder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Update folder properties
		/// Update properties of folder by given ID. This action happens asynchronously and will update all of the folder's children as well.
		/// Post_SlashfilesSlashv3SlashfoldersSlashupdateSlashasync_updateProperties files/v3/folders/update/async
		/// </summary>
		/// <param name="requestBody">Properties to change in the folder</param>
		public async Task Post_SlashfilesSlashv3SlashfoldersSlashupdateSlashasync_updatePropertiesAsync(FolderUpdateInput requestBody, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/folders/update/async";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Post, requestUri))
			{
			using (var requestWriter = new System.IO.StringWriter())
			{
			var requestSerializer = JsonSerializer.Create(jsonSerializerSettings);
			requestSerializer.Serialize(requestWriter, requestBody);
			var content = new System.Net.Http.StringContent(requestWriter.ToString(), System.Text.Encoding.UTF8, "application/json");
			httpRequestMessage.Content = content;
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
			}
		}
		
		/// <summary>
		/// Check folder update status.
		/// Check status of folder update. Folder updates happen asynchronously.
		/// Get_SlashfilesSlashv3SlashfoldersSlashupdateSlashasyncSlashtasksSlashtaskIdSlashstatus_checkUpdateStatus files/v3/folders/update/async/tasks/{taskId}/status
		/// </summary>
		/// <param name="taskId">TaskId of folder update</param>
		/// <returns>successful operation</returns>
		public async Task<FolderActionResponse> Get_SlashfilesSlashv3SlashfoldersSlashupdateSlashasyncSlashtasksSlashtaskIdSlashstatus_checkUpdateStatusAsync(string taskId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/folders/update/async/tasks/"+ (taskId==null? "" : System.Uri.EscapeDataString(taskId))+"/status";
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<FolderActionResponse>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete folder.
		/// Delete folder by ID.
		/// Delete_SlashfilesSlashv3SlashfoldersSlashfolderId_archive files/v3/folders/{folderId}
		/// </summary>
		/// <param name="folderId">ID of folder to delete.</param>
		public async Task Delete_SlashfilesSlashv3SlashfoldersSlashfolderId_archiveAsync(string folderId, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/folders/"+ (folderId==null? "" : System.Uri.EscapeDataString(folderId));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get folder
		/// Get folder by ID
		/// Get_SlashfilesSlashv3SlashfoldersSlashfolderId_getById files/v3/folders/{folderId}
		/// </summary>
		/// <param name="folderId">ID of desired folder</param>
		/// <param name="properties">Properties to set on returned folder.</param>
		/// <returns>successful operation</returns>
		public async Task<Folder> Get_SlashfilesSlashv3SlashfoldersSlashfolderId_getByIdAsync(string folderId, string[] properties, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/folders/"+ (folderId==null? "" : System.Uri.EscapeDataString(folderId))+"&"+string.Join("&", properties.Select(z => $"properties={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Delete folder.
		/// Delete folder by path.
		/// Delete_SlashfilesSlashv3SlashfoldersSlashfolderPath_archiveByPath files/v3/folders/{folderPath}
		/// </summary>
		/// <param name="folderPath">Path of folder to delete</param>
		public async Task Delete_SlashfilesSlashv3SlashfoldersSlashfolderPath_archiveByPathAsync(string folderPath, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/folders/"+ (folderPath==null? "" : System.Uri.EscapeDataString(folderPath));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Delete, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
		
		/// <summary>
		/// Get folder.
		/// Get folder by path.
		/// Get_SlashfilesSlashv3SlashfoldersSlashfolderPath_getByPath files/v3/folders/{folderPath}
		/// </summary>
		/// <param name="folderPath">Path of desired folder.</param>
		/// <param name="properties">Properties to set on returned folder.</param>
		/// <returns>successful operation</returns>
		public async Task<Folder> Get_SlashfilesSlashv3SlashfoldersSlashfolderPath_getByPathAsync(string folderPath, string[] properties, Action<System.Net.Http.Headers.HttpRequestHeaders> handleHeaders = null)
		{
			var requestUri = "files/v3/folders/"+ (folderPath==null? "" : System.Uri.EscapeDataString(folderPath))+"&"+string.Join("&", properties.Select(z => $"properties={System.Uri.EscapeDataString(z.ToString())}"));
			using (var httpRequestMessage = new System.Net.Http.HttpRequestMessage(System.Net.Http.HttpMethod.Get, requestUri))
			{
			if (handleHeaders != null)
			{
				handleHeaders(httpRequestMessage.Headers);
			}

			var responseMessage = await httpClient.SendAsync(httpRequestMessage);
			try
			{
				responseMessage.EnsureSuccessStatusCodeEx();
				var responseMessageStream = await responseMessage.Content.ReadAsStreamAsync();
				using (JsonReader jsonReader = new JsonTextReader(new System.IO.StreamReader(responseMessageStream)))
				{
				var serializer = JsonSerializer.Create(jsonSerializerSettings);
				return serializer.Deserialize<Folder>(jsonReader);
				}
			}
			finally
			{
				responseMessage.Dispose();
			}
			}
		}
	}
	
	public enum Get_SlashfilesSlashv3SlashfilesSlashfileIdSlashsigned_url_getSignedUrlSize
	{
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		thumb = 0,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		icon = 1,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		medium = 2,
		
		[System.Runtime.Serialization.EnumMemberAttribute()]
		preview = 3,
	}
}

namespace Fonlow.Net.Http
{
	using System.Net.Http;

	public class WebApiRequestException : HttpRequestException
	{
		public System.Net.HttpStatusCode StatusCode { get; private set; }

		public string Response { get; private set; }

		public System.Net.Http.Headers.HttpResponseHeaders Headers { get; private set; }

		public System.Net.Http.Headers.MediaTypeHeaderValue ContentType { get; private set; }

		public WebApiRequestException(string message, System.Net.HttpStatusCode statusCode, string response, System.Net.Http.Headers.HttpResponseHeaders headers, System.Net.Http.Headers.MediaTypeHeaderValue contentType) : base(message)
		{
			StatusCode = statusCode;
			Response = response;
			Headers = headers;
			ContentType = contentType;
		}
	}

	public static class ResponseMessageExtensions
	{
		public static void EnsureSuccessStatusCodeEx(this HttpResponseMessage responseMessage)
		{
			if (!responseMessage.IsSuccessStatusCode)
			{
				var responseText = responseMessage.Content.ReadAsStringAsync().Result;
				var contentType = responseMessage.Content.Headers.ContentType;
				throw new WebApiRequestException(responseMessage.ReasonPhrase, responseMessage.StatusCode, responseText, responseMessage.Headers, contentType);
			}
		}
	}
}
